<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mianhk&#39;s notes</title>
  
  <subtitle>这个人很懒，动不动就不想写</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-23T14:57:11.597Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mianhk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer-刷题总结</title>
    <link href="http://yoursite.com/20-%E5%88%B7%E9%A2%98/re_sword_to_offer/"/>
    <id>http://yoursite.com/20-刷题/re_sword_to_offer/</id>
    <published>2018-06-20T13:40:02.000Z</published>
    <updated>2018-06-23T14:57:11.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-二维数组中的查找"><a href="#01-二维数组中的查找" class="headerlink" title="01.二维数组中的查找"></a>01.二维数组中的查找</h2><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。  </p></blockquote><p>分析：由于每一行都有递增的特性，我们可以采用类似二分搜索的方法。将数组分成行列来进行搜索。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</div><div class="line">        if(0==array.size())</div><div class="line">            return false;</div><div class="line">        int raw=array.size();</div><div class="line">        int col=array[0].size();</div><div class="line">        for(int i=0;i&lt;raw;++i)&#123;</div><div class="line">            if(array[i][col-1]&gt;=target)&#123;</div><div class="line">                for(int j=0;j&lt;col;++j)&#123;</div><div class="line">                    if(array[i][j]==target)</div><div class="line">                        return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="02-替换空格"><a href="#02-替换空格" class="headerlink" title="02.替换空格"></a>02.替换空格</h2><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。  </p></blockquote><p>考虑到是在原字符串上操作，如果遇到一个空格就替换的话，需要把后面的都要后移两位，这个复杂度就大了，所以可以先遍历第一遍，找到空格的总数，之后就可以计算替换后的字符串长度。再经过第二遍遍历，从后往前开始替换，这样就不用移动了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">void replaceSpace(char *str,int length) &#123;</div><div class="line">         if(length&lt;=0)</div><div class="line">             return;</div><div class="line">        int origin_length=0,new_length=0,space_num=0;</div><div class="line">        for(int i=0;str[i]!=&apos;\0&apos;;++i)&#123;</div><div class="line">            origin_length++;</div><div class="line">            if(str[i]==&apos; &apos;)</div><div class="line">                space_num++;</div><div class="line">        &#125;</div><div class="line">        new_length=origin_length+2*space_num;</div><div class="line">        if(new_length&gt;length)</div><div class="line">            return;</div><div class="line">        str[new_length]=&apos;\0&apos;;</div><div class="line">        while(origin_length&gt;0)&#123;</div><div class="line">            --origin_length;</div><div class="line">            if(str[origin_length]==&apos; &apos;)&#123;</div><div class="line">                str[--new_length]=&apos;0&apos;;</div><div class="line">                str[--new_length]=&apos;2&apos;;</div><div class="line">                str[--new_length]=&apos;%&apos;;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                str[--new_length]=str[origin_length];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="03-从尾到头打印链表"><a href="#03-从尾到头打印链表" class="headerlink" title="03.从尾到头打印链表"></a>03.从尾到头打印链表</h2><blockquote><p>输入一个链表，从尾到头打印链表每个节点的值。  </p></blockquote><p>分析：由于链表我们必须从头到尾遍历才能从链表尾开始，所以直接打印的话，需要先从前往后遍历一遍找到链表尾节点，再从后往前遍历打印。能够进行的改善是，通过增加O(N)的空间复杂度，第一次遍历的时候，将数据放在一个栈中，之后再从栈中把所有的数都弹出来就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  struct ListNode &#123;</div><div class="line">*        int val;</div><div class="line">*        struct ListNode *next;</div><div class="line">*        ListNode(int x) :</div><div class="line">*              val(x), next(NULL) &#123;</div><div class="line">*        &#125;</div><div class="line">*  &#125;;</div><div class="line">*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</div><div class="line">        vector&lt;int&gt; res;</div><div class="line">        if(!head)</div><div class="line">            return res;</div><div class="line">        stack&lt;int&gt; istack;</div><div class="line">        while(head)&#123;</div><div class="line">            istack.push(head-&gt;val);</div><div class="line">            head=head-&gt;next;</div><div class="line">        &#125;</div><div class="line">        while(!istack.empty())&#123;</div><div class="line">            res.push_back(istack.top());</div><div class="line">            istack.pop();</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="04-重建二叉树"><a href="#04-重建二叉树" class="headerlink" title="04.重建二叉树"></a>04.重建二叉树</h2><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。  </p></blockquote><p>分析：首先需要知道的是前序遍历和后续遍历的特点，程序中可以维护4个子数组，当进行递归调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for binary tree</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</div><div class="line">        if(pre.empty() || pre.size()!=vin.size())</div><div class="line">            return nullptr;</div><div class="line">        vector&lt;int&gt; pre1,pre2,vin1,vin2;</div><div class="line">        TreeNode* root=new TreeNode(pre[0]);</div><div class="line">        int i=0;</div><div class="line">        for(;i&lt;vin.size();++i)&#123;</div><div class="line">            if(pre[0]==vin[i])</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        //不需要判断i ==0 或者i==vin.size()-1的情况</div><div class="line">        for(int j=0;j&lt;i;++j)&#123;</div><div class="line">            pre1.push_back(pre[1+j]);</div><div class="line">            vin1.push_back(vin[j]);</div><div class="line">        &#125;</div><div class="line">        for(int j=i+1;j&lt;pre.size();++j)&#123;</div><div class="line">            pre2.push_back(pre[j]);</div><div class="line">            vin2.push_back(vin[j]);</div><div class="line">        &#125;</div><div class="line">        root-&gt;left=reConstructBinaryTree(pre1,vin1);</div><div class="line">        root-&gt;right=reConstructBinaryTree(pre2,vin2);</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>不过上述的方法有个问题，虽然看起来比较好理解，但是增加了空间复杂度，其实这里可以多加一个递归函数就好了，所以觉得还是需要重新写一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for binary tree</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    TreeNode* recurse(vector&lt;int&gt;&amp; pre,int begin1,int end1,vector&lt;int &gt;&amp; vin,int begin2,int end2)&#123;</div><div class="line">        if(begin1&gt;end1 || begin2&gt;end2)  //退出条件</div><div class="line">            return nullptr;</div><div class="line">        TreeNode* root=new TreeNode(pre[begin1]);</div><div class="line">        for(int i=begin2;i&lt;=end2;++i)&#123;</div><div class="line">            if(pre[begin1]==vin[i])&#123;</div><div class="line">                root-&gt;left=recurse(pre,begin1+1,begin1+i-begin2,vin,begin2,i-1);  //递归的重点，这个要考虑清楚</div><div class="line">                root-&gt;right=recurse(pre,begin1+1+i-begin2,end1,vin,1+i,end2);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</div><div class="line">        if(pre.empty() || pre.size()!=vin.size())</div><div class="line">            return nullptr;</div><div class="line">        return recurse(pre,0,pre.size()-1,vin,0,vin.size()-1);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="05-用两个栈实现队列"><a href="#05-用两个栈实现队列" class="headerlink" title="05.用两个栈实现队列"></a>05.用两个栈实现队列</h2><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。  </p></blockquote><p>分析：由于栈是先进后出，队列是先进先出，于是可以想到，两个栈，必然能够实现一个队列。原理就是，当push的时候就往第一个栈push，pop的时候就从第二个栈pop，当第二个栈的数为空时，从第一个栈pop再push到第二个栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int pop() &#123;</div><div class="line">        if(stack2.empty())&#123;</div><div class="line">            while(!stack1.empty())&#123;</div><div class="line">                stack2.push(stack1.top());</div><div class="line">                stack1.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int top=stack2.top();</div><div class="line">        stack2.pop();</div><div class="line">        return top;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    stack&lt;int&gt; stack1;</div><div class="line">    stack&lt;int&gt; stack2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="06-旋转数组的最小数字"><a href="#06-旋转数组的最小数字" class="headerlink" title="06.旋转数组的最小数字"></a>06.旋转数组的最小数字</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。  </p></blockquote><p>分析：对于排序的数组，即使被旋转过，也能想到的是，采用二分查找。不过可能会存在的问题的是：当整个数组的值都是<code>1 0 0 1 1</code>之类的时候，就会失效了，只是非递减，但是不一定递增。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</div><div class="line">        if(0==rotateArray.size())&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        int begin=0,end=rotateArray.size()-1;</div><div class="line">        while(begin&lt;end-1)&#123;</div><div class="line">            int mid=begin+(end-begin)/2;</div><div class="line">            if(rotateArray[begin]&lt;rotateArray[mid])</div><div class="line">                begin=mid;</div><div class="line">            else if(rotateArray[begin]&gt;rotateArray[mid])</div><div class="line">                end=mid;</div><div class="line">            else&#123;</div><div class="line">                int res=begin;</div><div class="line">                for(size_t i=1;i&lt;rotateArray.size();++i)&#123;</div><div class="line">                    res=(res&lt;rotateArray[i]?res:rotateArray[i]);</div><div class="line">                &#125;</div><div class="line">                return res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return rotateArray[end];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="07-斐波那契数列"><a href="#07-斐波那契数列" class="headerlink" title="07.斐波那契数列"></a>07.斐波那契数列</h2><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39    </p></blockquote><p>分析：斐波拉契数列原理很简单，不过按照原理写的显然复杂度过高了，这里我们可以采用变量存下之前计算过的数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Fibonacci(int n) &#123;</div><div class="line">        if(n==0)</div><div class="line">            return 0;</div><div class="line">        if(n==1||n==2)</div><div class="line">            return 1;</div><div class="line">        int first=1,second=1,res=0;</div><div class="line">        while(--n&gt;1)&#123;</div><div class="line">            res=first+second;</div><div class="line">            first=second;</div><div class="line">            second=res;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="08-跳台阶"><a href="#08-跳台阶" class="headerlink" title="08.跳台阶"></a>08.跳台阶</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。  </p></blockquote><p>分析：原理同斐波拉契数列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int jumpFloor(int number) &#123;</div><div class="line">        if(number&lt;=2)</div><div class="line">            return number;</div><div class="line">        int first=1,second=2,res=0;</div><div class="line">        while(--number&gt;1)&#123;</div><div class="line">            res=first+second;</div><div class="line">            first=second;</div><div class="line">            second=res;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="09-变态跳台阶"><a href="#09-变态跳台阶" class="headerlink" title="09.变态跳台阶"></a>09.变态跳台阶</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。  </p></blockquote><p>分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">f(n)=f(1)+f(2)+...+f(n-1)</div><div class="line">f(n+1)=f(1)+f(2)+...+f(n-1)+f(n)=2f(n)</div><div class="line">//代码如下：</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int jumpFloorII(int number) &#123;</div><div class="line">        if(number&lt;=2)</div><div class="line">            return number;</div><div class="line">        int res=2;</div><div class="line">        while(--number&gt;=2)&#123;</div><div class="line">            res*=2;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="10-矩形覆盖-TODO"><a href="#10-矩形覆盖-TODO" class="headerlink" title="10.矩形覆盖 /TODO:"></a>10.矩形覆盖 /TODO:</h2><h2 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11.二进制中1的个数"></a>11.二进制中1的个数</h2><blockquote><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。  </p></blockquote><p>分析：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">     int  NumberOf1(int n) &#123;</div><div class="line">         int count=0;</div><div class="line">         while(n)&#123;</div><div class="line">             count++;</div><div class="line">             n=n&amp;(n-1);</div><div class="line">         &#125;</div><div class="line">         return count;</div><div class="line">     &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h2><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。  </p></blockquote><p>分析：求一个数的次方，一个就是幂数是负数的处理，另一个就是，对幂的处理，连乘必然带来复杂度，可以想到的是2^4可以表示为(2^2)^2，想到这里，考虑的开水奇偶exponent的奇偶性了，奇数的时候直接乘以base，偶数的时候自乘。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    double Power(double base, int exponent) &#123;</div><div class="line">        bool flag=true;</div><div class="line">        if(exponent&lt;0)&#123;</div><div class="line">            flag=false;</div><div class="line">            exponent*=-1;</div><div class="line">        &#125;</div><div class="line">        double res=1;</div><div class="line">        while(exponent)&#123;</div><div class="line">            if(exponent&amp;1)&#123;</div><div class="line">                res*=base;</div><div class="line">                exponent--;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                exponent=exponent/2;</div><div class="line">                res*=res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return flag?res:(1/res);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h2><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</div><div class="line">if(array.empty())</div><div class="line">return;</div><div class="line">int begin=0,end=array.size();</div><div class="line">int even=-1;</div><div class="line"></div><div class="line">while(begin&lt;end)&#123;</div><div class="line">while((array[begin]&amp;1) &amp;&amp; (begin&lt;end))&#123;</div><div class="line">begin++;</div><div class="line">&#125;</div><div class="line">even=begin;</div><div class="line">while((!(array[begin]&amp;1)))&#123;</div><div class="line">begin++;</div><div class="line">&#125;</div><div class="line">if(begin&gt;=end)</div><div class="line">return;</div><div class="line">int temp=array[begin];</div><div class="line">while(even&lt;begin)&#123;</div><div class="line">array[begin]=array[begin-1];</div><div class="line">begin--;</div><div class="line">&#125;</div><div class="line">array[even]=temp;</div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="14-链表中倒数第k个结点"><a href="#14-链表中倒数第k个结点" class="headerlink" title="14.链表中倒数第k个结点"></a>14.链表中倒数第k个结点</h2><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。  </p></blockquote><p>分析：采用两个指针一起移动是一个很好的办法，不过需要考虑是否越界。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct ListNode &#123;</div><div class="line">int val;</div><div class="line">struct ListNode *next;</div><div class="line">ListNode(int x) :</div><div class="line">val(x), next(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</div><div class="line">        ListNode* p1=pListHead;</div><div class="line">        for(int i=0;i&lt;k;++i)&#123;</div><div class="line">            if(!p1)</div><div class="line">               return nullptr;</div><div class="line">            p1=p1-&gt;next;</div><div class="line">        &#125;</div><div class="line">        while(p1)&#123;</div><div class="line">            p1=p1-&gt;next;</div><div class="line">            pListHead=pListHead-&gt;next;</div><div class="line">        &#125;</div><div class="line">        return pListHead;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h2><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。   </p></blockquote><p>分析：注意断开链表重连的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct ListNode &#123;</div><div class="line">int val;</div><div class="line">struct ListNode *next;</div><div class="line">ListNode(int x) :</div><div class="line">val(x), next(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">//最开始的一版代码，采用的是栈，看起来比较复杂。</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</div><div class="line">        if((!pHead)||(!pHead-&gt;next))</div><div class="line">            return pHead;</div><div class="line">        stack&lt;ListNode*&gt; list_stack;</div><div class="line">        while(pHead-&gt;next)&#123;</div><div class="line">            list_stack.push(pHead);</div><div class="line">            pHead=pHead-&gt;next;</div><div class="line">        &#125;</div><div class="line">        ListNode *newHead=pHead;</div><div class="line">        while(!list_stack.empty())&#123;</div><div class="line">            pHead-&gt;next=list_stack.top();</div><div class="line">            pHead=pHead-&gt;next;</div><div class="line">            list_stack.pop();</div><div class="line">        &#125;</div><div class="line">        pHead-&gt;next=nullptr;</div><div class="line">        return newHead;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//采用在链表中的穿针引线。涉及到链表的断开与重连，维护三个指针，分别为：pre,cur,next</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</div><div class="line">        ListNode* pre=nullptr;</div><div class="line">        ListNode* cur=pHead;</div><div class="line">        while(cur)&#123;</div><div class="line">            ListNode* next=cur-&gt;next;</div><div class="line">            cur-&gt;next=pre;</div><div class="line">            pre=cur;</div><div class="line">            cur=next;</div><div class="line">        &#125;</div><div class="line">        return pre;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//采用递归实现</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</div><div class="line">        if(!pHead||!pHead-&gt;next)</div><div class="line">            return pHead;</div><div class="line">        ListNode* rHead=ReverseList(pHead-&gt;next);</div><div class="line">        // head-&gt;next此刻指向head后面的链表的尾节点</div><div class="line">        // head-&gt;next-&gt;next = head把head节点放在了尾部</div><div class="line">        pHead-&gt;next-&gt;next=pHead;</div><div class="line">        pHead-&gt;next=nullptr;</div><div class="line">        </div><div class="line">        return rHead;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h2><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct ListNode &#123;</div><div class="line">int val;</div><div class="line">struct ListNode *next;</div><div class="line">ListNode(int x) :</div><div class="line">val(x), next(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</div><div class="line">    &#123;</div><div class="line">        //当一个链表为空时，直接返回另一个链表</div><div class="line">        if(!pHead1)</div><div class="line">            return pHead2;</div><div class="line">        if(!pHead2)</div><div class="line">            return pHead1;</div><div class="line">        ListNode* vHead=new ListNode(0);  //设立虚拟的头节点</div><div class="line">        ListNode* vHeadHead=vHead;</div><div class="line">        while(pHead1 &amp;&amp; pHead2)&#123;  //一旦有一个链表为空，就退出循环</div><div class="line">            if(pHead1-&gt;val&lt;=pHead2-&gt;val)&#123;</div><div class="line">                vHead-&gt;next=pHead1;</div><div class="line">                pHead1=pHead1-&gt;next;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                vHead-&gt;next=pHead2;</div><div class="line">                pHead2=pHead2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            vHead=vHead-&gt;next;</div><div class="line">        &#125;</div><div class="line">        //另一个链表不为空时，加在后面</div><div class="line">        if(!pHead1)</div><div class="line">            vHead-&gt;next=pHead2;</div><div class="line">        else</div><div class="line">            vHead-&gt;next=pHead1;</div><div class="line">        return vHeadHead-&gt;next;  //返回虚拟头节点的下一个节点</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//采用递归实现</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</div><div class="line">    &#123;</div><div class="line">        if(!pHead1)</div><div class="line">            return pHead2;</div><div class="line">        if(!pHead2)</div><div class="line">            return pHead1;</div><div class="line">        ListNode* vHead=nullptr;</div><div class="line">        if(pHead1-&gt;val&lt;=pHead2-&gt;val)&#123;</div><div class="line">            vHead=pHead1;</div><div class="line">            vHead-&gt;next=Merge(pHead1-&gt;next,pHead2);</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            vHead=pHead2;</div><div class="line">            vHead-&gt;next=Merge(pHead1,pHead2-&gt;next);</div><div class="line">        &#125;</div><div class="line">        return vHead;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h2><blockquote><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool dfs(TreeNode* pRoot1,TreeNode* pRoot2)&#123;</div><div class="line">        if(!pRoot2)    //注意不能先判断pRoot1再判断pRoot2，因为，只要pRoot2为空的时候，都是true了，而不管这时候pRoot1是不是为空。</div><div class="line">            return true;</div><div class="line">        if(!pRoot1)</div><div class="line">            return false;</div><div class="line">        if(pRoot1-&gt;val!=pRoot2-&gt;val)</div><div class="line">            return false;</div><div class="line">        return dfs(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;dfs(pRoot1-&gt;right,pRoot2-&gt;right);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</div><div class="line">    &#123;</div><div class="line">        if((!pRoot2)||(!pRoot1))</div><div class="line">            return false;</div><div class="line">        return (dfs(pRoot1,pRoot2)||HasSubtree(pRoot1-&gt;left,pRoot2)||HasSubtree(pRoot1-&gt;right,pRoot2));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h2><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。   </p></blockquote><p>分析：简单的递归解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct TreeNode &#123;</div><div class="line">int val;</div><div class="line">struct TreeNode *left;</div><div class="line">struct TreeNode *right;</div><div class="line">TreeNode(int x) :</div><div class="line">val(x), left(NULL), right(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void Mirror(TreeNode *pRoot) &#123;</div><div class="line">        if(pRoot==nullptr)</div><div class="line">            return;</div><div class="line">        Mirror(pRoot-&gt;left);</div><div class="line">        Mirror(pRoot-&gt;right);</div><div class="line">        swap(pRoot-&gt;left,pRoot-&gt;right);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h2><h2 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h2><h2 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h2><p>思路：判断是否是压入弹出序列，可以直接使用一个栈进行压入，然后在压入的过程中判断是否跟弹出序列的值相同，是的话则先弹出，最后判断栈是否为空即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</div><div class="line">        stack&lt;int&gt; istack;</div><div class="line">        int i=0,j=0;</div><div class="line">        while(i&lt;pushV.size())&#123;</div><div class="line">        istack.push(pushV[i++]);</div><div class="line">        while(j&lt;popV.size() &amp;&amp; istack.top()==popV[j])&#123;</div><div class="line">        istack.pop();</div><div class="line">        ++j;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return istack.empty();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h2><blockquote><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。  </p></blockquote><p>分析：层序遍历，需要每遍历一个节点，就将他们的左右节点保存起来，当前层遍历完后，再顺序遍历他们的孩子节点。于是很容易想到先入先出的结构，队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct TreeNode &#123;</div><div class="line">int val;</div><div class="line">struct TreeNode *left;</div><div class="line">struct TreeNode *right;</div><div class="line">TreeNode(int x) :</div><div class="line">val(x), left(NULL), right(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</div><div class="line">        vector&lt;int&gt; res;</div><div class="line">        if(root==nullptr)</div><div class="line">            return res;</div><div class="line">        queue&lt;TreeNode*&gt; ique;</div><div class="line">        ique.push(root);</div><div class="line">        while(!ique.empty())&#123;</div><div class="line">            TreeNode* temp=ique.front();</div><div class="line">            res.push_back(temp-&gt;val);</div><div class="line">            ique.pop();</div><div class="line">            </div><div class="line">            if(temp-&gt;left)</div><div class="line">                ique.push(temp-&gt;left);</div><div class="line">            if(temp-&gt;right)</div><div class="line">                ique.push(temp-&gt;right);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h2><h2 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h2><blockquote><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">    vector&lt;int&gt; temp;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</div><div class="line">        if(!root)</div><div class="line">            return res;</div><div class="line">        temp.push_back(root-&gt;val);</div><div class="line">        if(expectNumber-root-&gt;val==0 &amp;&amp; root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)</div><div class="line">            res.push_back(temp);</div><div class="line">        FindPath(root-&gt;left,expectNumber-root-&gt;val);</div><div class="line">        FindPath(root-&gt;right,expectNumber-root-&gt;val);</div><div class="line">        if(!temp.empty())</div><div class="line">            temp.pop_back();</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h2><p>代码问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">        while(pHead-&gt;next)&#123;</div><div class="line">//        cout&lt;&lt;pHead-&gt;label&lt;&lt;endl;</div><div class="line">//            RandomListNode* pTemp=pHead;   //傻了吧</div><div class="line">            RandomListNode* pTemp=new RandomListNode(pHead-&gt;label);  </div><div class="line">            pTemp-&gt;next=pHead-&gt;next;</div><div class="line">            cout&lt;&lt;pTemp-&gt;next-&gt;label&lt;&lt;endl;</div><div class="line">            pHead-&gt;next=pTemp;</div><div class="line">            pHead=pTemp-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">                //拆分</div><div class="line">        pNode=pHead;</div><div class="line">RandomListNode* newHead=pHead-&gt;next;</div><div class="line">        RandomListNode* pTemp=pNode-&gt;next;</div><div class="line">while(pNode)&#123;</div><div class="line">pNode-&gt;next=pTemp-&gt;next;</div><div class="line">pNode=pNode-&gt;next;</div><div class="line">pTemp-&gt;next=pNode?pNode-&gt;next:NULL;</div><div class="line">//pTemp-&gt;next=pNode-&gt;next;</div><div class="line">//cout&lt;&lt;&quot;pTemp: &quot;&lt;&lt;pTemp-&gt;label&lt;&lt;endl;</div><div class="line">pTemp=pTemp-&gt;next;</div><div class="line">//cout&lt;&lt;&quot;text&quot;&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    RandomListNode* Clone(RandomListNode* pHead)</div><div class="line">    &#123;</div><div class="line">    if(!pHead)</div><div class="line">    return pHead;</div><div class="line">    RandomListNode* pNode=pHead;</div><div class="line"></div><div class="line">    while(pNode)&#123;</div><div class="line">    RandomListNode* pClone=new RandomListNode(pNode-&gt;label);</div><div class="line">    pClone-&gt;next=pNode-&gt;next;</div><div class="line">    pNode-&gt;next=pClone;</div><div class="line">    pNode=pClone-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">pNode=pHead;</div><div class="line">while(pNode)&#123;</div><div class="line">RandomListNode* pClone=pNode-&gt;next;</div><div class="line">if(pNode-&gt;random)</div><div class="line">pClone-&gt;random=pNode-&gt;random-&gt;next;</div><div class="line">pNode=pClone-&gt;next;</div><div class="line">&#125;</div><div class="line">pNode=pHead;</div><div class="line">RandomListNode* newHead=pNode-&gt;next;</div><div class="line"></div><div class="line"></div><div class="line">while(pNode-&gt;next)&#123;</div><div class="line">RandomListNode* pTemp=pNode-&gt;next;</div><div class="line">pNode-&gt;next=pTemp-&gt;next;</div><div class="line">pNode=pTemp;</div><div class="line">//pNode=pNode-&gt;next;                  //这种不行，搞得我折腾了很久</div><div class="line">//pTemp-&gt;next=pNode-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return newHead;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="26二叉搜索树与双向链表"><a href="#26二叉搜索树与双向链表" class="headerlink" title="26二叉搜索树与双向链表"></a>26二叉搜索树与双向链表</h2><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br>TODO:</p></blockquote><h2 id="27字符串的排列"><a href="#27字符串的排列" class="headerlink" title="27字符串的排列"></a>27字符串的排列</h2><h2 id="28数组中出现次数超过一半的数字"><a href="#28数组中出现次数超过一半的数字" class="headerlink" title="28数组中出现次数超过一半的数字"></a>28数组中出现次数超过一半的数字</h2><p>解决一个问题，最终输出的判断，是1，还是0。如果大于1的话，万一最后只剩下了一个呢。所以还需要再判断最后剩下的结果是不是符合条件的，即是大于一般数目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</div><div class="line">        if(numbers.empty())</div><div class="line">            return 0;</div><div class="line">        int count=1;</div><div class="line">        int num=numbers[0];</div><div class="line">        for(int i=1;i&lt;numbers.size();++i)&#123;</div><div class="line">            if(numbers[i]==num)</div><div class="line">                count++;</div><div class="line">            else&#123;</div><div class="line">                if((--count)&lt;=0)&#123;</div><div class="line">                    num=numbers[i];</div><div class="line">                    count=1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //判断结果是否符合条件</div><div class="line">        count=0;</div><div class="line">        for(int i=0;i&lt;numbers.size();++i)&#123;</div><div class="line">            if(num==numbers[i])&#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return count*2&gt;numbers.size()?num:0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h2><p>存在的问题，写程序的时候越界，没有判断好边界条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</div><div class="line">        vector&lt;int&gt; min_stack;</div><div class="line">        if(input.empty()||(k&lt;=0)||(k&gt;input.size()))  //边界条件的判断</div><div class="line">            return min_stack;</div><div class="line">        for(int i=0;i&lt;input.size();++i)&#123;</div><div class="line">            sort(min_stack.begin(),min_stack.end());</div><div class="line">            if(min_stack.size()&lt;k)&#123;</div><div class="line">                min_stack.push_back(input[i]);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">            //cout&lt;&lt;&quot;min_stack[min_stack.size()-1]: &quot;&lt;&lt;min_stack[min_stack.size()-1]&lt;&lt;endl;</div><div class="line">                if(input[i]&lt;min_stack[min_stack.size()-1])&#123;</div><div class="line">                    min_stack.pop_back();</div><div class="line">                    min_stack.push_back(input[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return min_stack;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a>30.连续子数组的最大和</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</div><div class="line">    int  res=array[0];</div><div class="line">    int cur=array[0];</div><div class="line">    for(int i=1;i&lt;array.size();++i)&#123;</div><div class="line">    cur+=array[i];</div><div class="line">    if(cur&lt;array[i])</div><div class="line">    cur=array[i];</div><div class="line">    res=(res&gt;cur?res:cur);</div><div class="line">&#125;</div><div class="line">return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="31-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#31-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="31.整数中1出现的次数（从1到n整数中1出现的次数）"></a>31.整数中1出现的次数（从1到n整数中1出现的次数）</h2><h2 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32.把数组排成最小的数"></a>32.把数组排成最小的数</h2><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    static bool equal(int a,int b)&#123;</div><div class="line">        string str1=to_string(a)+to_string(b);</div><div class="line">        string str2=to_string(b)+to_string(a);</div><div class="line">        return str1&lt;str2;</div><div class="line">    &#125;</div><div class="line">    string PrintMinNumber(vector&lt;int&gt; numbers)</div><div class="line">    &#123;</div><div class="line">        string result;</div><div class="line">        sort(numbers.begin(),numbers.end(),equal);</div><div class="line">        </div><div class="line">        for(int i=0;i&lt;numbers.size();++i)&#123;</div><div class="line">            result+=to_string(numbers[i]);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h2><blockquote><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int GetUglyNumber_Solution(int index) &#123;</div><div class="line">        if(index&lt;=0)        </div><div class="line">            return 0;</div><div class="line">        vector&lt;int &gt; res(index);</div><div class="line">        res[0]=1;</div><div class="line">        int x=0,y=0,z=0;</div><div class="line">        for(int i=1;i&lt;index;++i)&#123;</div><div class="line">            res[i]=min(2*res[x],min(3*res[y],5*res[z]));</div><div class="line">            if(res[i]==2*res[x])</div><div class="line">                x++;</div><div class="line">            if(res[i]==3*res[y])</div><div class="line">                y++;</div><div class="line">            if(res[i]==5*res[z])</div><div class="line">                z++;</div><div class="line">        &#125;</div><div class="line">        return res[index-1];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="34-第一个只出现一次的字符位置"><a href="#34-第一个只出现一次的字符位置" class="headerlink" title="34.第一个只出现一次的字符位置"></a>34.第一个只出现一次的字符位置</h2><blockquote><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置  </p></blockquote><p>一般对于这种字符的处理，因为字符一般都是不超过256的，所以尤其是计数之类的，我们可以首先考虑数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    int FirstNotRepeatingChar(string str)</div><div class="line">    &#123;</div><div class="line">        if(str.size()&lt;=0)</div><div class="line">            return -1;</div><div class="line">        int array[256]=&#123;0&#125;;</div><div class="line">        for(int i=0;i&lt;str.size();++i)&#123;</div><div class="line">            array[int(str[i])]++;</div><div class="line">        &#125;</div><div class="line">        for(int i=0;i&lt;str.size();++i)&#123;</div><div class="line">            if(array[int(str[i])]==1)</div><div class="line">                return i;</div><div class="line">        &#125;</div><div class="line">        return str.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35.数组中的逆序对"></a>35.数组中的逆序对</h2><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>//TODO:</p><h2 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36.两个链表的第一个公共结点"></a>36.两个链表的第一个公共结点</h2><p>输入两个链表，找出它们的第一个公共结点。  </p></blockquote><p>需要知道的一个常识是，对于只有一个单链表，两个链表有公共节点，意味着从公共节点开始，之后两个链表都是公共的，因此他们有共同的终点。有了这个就好办了。可以将两个链表一直遍历，当遍历到链表尾的时候，就换另一个链表，当他们有公共节点时，在他们遍历到同一个节点时停止遍历，此节点即为第一个公共节点。   </p><p><strong>对于这种将两个不同的长度，通过两个结合在一起，使两个长度相等的方法，其实我们用到过很多次。例如本题中的找公共节点，原因是两个链表长度不同。还有之前的一个判断两个string的大小，可以把他们放在一起，这样他们的长度就相同了，可以直接用string的方法进行比较。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</div><div class="line">        ListNode* p1=pHead1;</div><div class="line">        ListNode* p2=pHead2;</div><div class="line">        while(p1!=p2)&#123;</div><div class="line">            p1=(p1==nullptr?pHead2:p1-&gt;next);</div><div class="line">            p2=(p2==nullptr?pHead1:p2-&gt;next);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return p1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h2><blockquote><p>统计一个数字在排序数组中出现的次数。  </p></blockquote><p>显然很容易想到的是二分法,没有用函数的话，就存在一个找到没找到的问题，在这采用了一个返回值的处理。如果没找到，(end-begin-1)<0，则可以判断是没有找到。 <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</div><div class="line">        if(data.empty())</div><div class="line">            return 0;</div><div class="line">        int begin=0,end=data.size()-1;</div><div class="line">        int count=0;</div><div class="line">        int mid;</div><div class="line">        while(begin&lt;=end)&#123;</div><div class="line">        mid=(begin+end)/2;</div><div class="line">//        cout&lt;&lt;&quot;dsdasads&quot;&lt;&lt;endl;</div><div class="line">if(data[mid]==k)</div><div class="line">break;</div><div class="line">            else if(data[mid]&lt;k)&#123;</div><div class="line">                begin=mid+1;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            else if(data[mid]&gt;k)&#123;</div><div class="line">                end=mid-1;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        begin=end=mid;</div><div class="line">        while(data[begin]==k)</div><div class="line">            --begin;</div><div class="line">        while(data[end]==k)</div><div class="line">            ++end;</div><div class="line">        count=(end-begin-1)&gt;0?(end-begin-1):0;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></0，则可以判断是没有找到。></p><h2 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h2><h2 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39.平衡二叉树"></a>39.平衡二叉树</h2><h2 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h2><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。  </p></blockquote><p>数组中只出现一次的数字，当有一个的时候，很容易利用的特性是：全部异或，最后剩下的那个就是。原因是一个数跟自身异或，结果为0.那么出现有两个的时候呢。很容易想到的还是异或，最后的结果是两个只出现一次数字异或的结果，再进行分组解决。分组的依据是：因为有两个不同的数字只出现一次，所以整个数组异或的结果必然不为0，不为0就肯定有一位为1.按该位是否为1来进行划分即可。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</div><div class="line">        if(data.empty())</div><div class="line">            return;</div><div class="line">        //第一次遍历一遍，求两个数字最后的异或</div><div class="line">        int res=data[0];</div><div class="line">        for(int i=1;i&lt;data.size();++i)&#123;</div><div class="line">            res=res^data[i];</div><div class="line">        &#125;</div><div class="line">        if(res==0)</div><div class="line">            return;</div><div class="line">        //由于存在两个只出现一次的数字，所以res的值为这两个数字的异或，因此肯定不为0，肯定不为0意味着肯定有一位是1.找出这一位是1的</div><div class="line">        int index=0;</div><div class="line">        while((res&amp;1)==0)&#123;</div><div class="line">            res=res&gt;&gt;1;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        *num1=*num2=0;        </div><div class="line">        //根据index位为不为1，将数组分为两部分。</div><div class="line">        int x;</div><div class="line">        for(int i=0;i&lt;data.size();++i)&#123;</div><div class="line">            if((x=data[i]&gt;&gt;index)&amp;1)</div><div class="line">                *num1^=data[i];</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                *num2^=data[i];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="41-和为S的连续正数序列"><a href="#41-和为S的连续正数序列" class="headerlink" title="41.和为S的连续正数序列"></a>41.和为S的连续正数序列</h2><blockquote><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">        vector&lt;int&gt; temp;</div><div class="line">        //边界条件的判断</div><div class="line">        if(sum&lt;0)</div><div class="line">            return res;</div><div class="line">            </div><div class="line">        int end=0;</div><div class="line">        int tempSum=0;</div><div class="line">        //遍历数组</div><div class="line">        while(end&lt;sum)&#123;</div><div class="line">            if(tempSum==sum)&#123;</div><div class="line">                res.push_back(temp);</div><div class="line">                end=temp[0];  //这一句其实很重要,因为要考虑将end从最开始重新开始计算，不然可能会有所遗漏,eg:9=2+3+4=4+5，其中4会重复</div><div class="line">                temp.erase(temp.begin(),temp.end());</div><div class="line">                tempSum=0;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            if(tempSum&gt;sum)&#123;</div><div class="line">                tempSum-=temp[0];</div><div class="line">                temp.erase(temp.begin());</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            temp.push_back(++end);</div><div class="line">            tempSum+=end;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="42-和为S的两个数字"><a href="#42-和为S的两个数字" class="headerlink" title="42.和为S的两个数字"></a>42.和为S的两个数字</h2><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。  </p></blockquote><p>输出乘积最小的，显然距离最大的乘积就越小，所以，可以直接前后两个指针搜索，搜到的第一个就是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum)</div><div class="line">    &#123;</div><div class="line">        vector&lt;int &gt; res;</div><div class="line">        if(array.empty())</div><div class="line">            return res;</div><div class="line">            </div><div class="line">        int i=0,j=array.size()-1;</div><div class="line">        while(i&lt;j)&#123;</div><div class="line">            int temp=array[i]+array[j];</div><div class="line">            if(temp&gt;sum)</div><div class="line">                --j;</div><div class="line">            if(temp&lt;sum)</div><div class="line">                ++i;</div><div class="line">            </div><div class="line">            if(temp==sum) </div><div class="line">            &#123;</div><div class="line">                res.push_back(array[i]);</div><div class="line">                res.push_back(array[j]);</div><div class="line">                return res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h2><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！  </p></blockquote><p>由BA=(ATBT)T计算可得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//第一次通过代码</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    string LeftRotateString(string str, int n) &#123;</div><div class="line">        int len=str.size();</div><div class="line">        if(n&gt;=len)</div><div class="line">            return str;</div><div class="line">        int i=0,j=0;</div><div class="line">        for(i=0,j=n-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</div><div class="line">        for(i=n,j=len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</div><div class="line">        for(i=0,j=len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</div><div class="line">        return str;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44.翻转单词顺序列"></a>44.翻转单词顺序列</h2><p>//TODO:</p><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//以前买的</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void ReverseSentence(string &amp;str,int begin,int end)&#123;</div><div class="line">        while(begin&lt;end)&#123;</div><div class="line">            char tmp=str[begin];</div><div class="line">            str[begin]=str[end];</div><div class="line">            str[end]=tmp;</div><div class="line">            begin++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    string ReverseSentence(string str) &#123;</div><div class="line">        if(str.size()&lt;=1)</div><div class="line">            return str;</div><div class="line">      </div><div class="line">        int begin=0;</div><div class="line">        int end=0;</div><div class="line">        </div><div class="line">        //这里需要注意，考虑只有一个单词的情况</div><div class="line">        while(end!=str.size())&#123;</div><div class="line">            if(str[end]==&apos; &apos;)&#123;</div><div class="line">                ReverseSentence(str,0,str.size()-1);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else if(end==str.size()-1)</div><div class="line">            return str;</div><div class="line">            else</div><div class="line">                ++end;</div><div class="line">        &#125;</div><div class="line">        end=0;</div><div class="line">        //开始遍历，旋转每个单词</div><div class="line">        while(begin!=str.size())&#123;</div><div class="line">            if(str[begin]==&apos; &apos;)&#123;</div><div class="line">                ++end;</div><div class="line">                ++begin;</div><div class="line">            &#125;</div><div class="line">            else if(str[end]==&apos; &apos;||end==str.size())&#123;</div><div class="line">                ReverseSentence(str,begin,--end);</div><div class="line">                begin=++end;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                ++end;</div><div class="line">        &#125;</div><div class="line">        return str;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h2><blockquote><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    bool IsContinuous(vector&lt;int&gt; numbers)</div><div class="line">    &#123;</div><div class="line">        if (numbers.empty())</div><div class="line">            return false;</div><div class="line">        sort(numbers.begin(), numbers.end());</div><div class="line">        int sum = 0, zero_num = 0;</div><div class="line">        for (int i = 0; i &lt; numbers.size() - 1; ++i)</div><div class="line">        &#123;</div><div class="line">            if (numbers[i] == 0)</div><div class="line">            &#123;</div><div class="line">                zero_num++;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            //考虑数字重复的情况</div><div class="line">            if (numbers[i + 1] == numbers[i])</div><div class="line">                return false;</div><div class="line">            sum += numbers[i + 1] - numbers[i] - 1;</div><div class="line">        &#125;</div><div class="line">        return sum &lt;= zero_num; //注意这里要大于等于就可以，不一定等于</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="46-孩子们的游戏-圆圈中最后剩下的数"><a href="#46-孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="46.孩子们的游戏(圆圈中最后剩下的数)"></a>46.孩子们的游戏(圆圈中最后剩下的数)</h2><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)   </p></blockquote><p>此约瑟夫环的问题。TODO:<a href="https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365" target="_blank" rel="external">https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int LastRemaining_Solution(int n, int m)</div><div class="line">    &#123;</div><div class="line">        if(n&lt;=0)</div><div class="line">            return -1;</div><div class="line">        int last=0;</div><div class="line">        for(int i=2;i&lt;=n;++i)&#123;</div><div class="line">            last=(last+m)%i;</div><div class="line">        &#125;</div><div class="line">        return last;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="47-求1-2-3-…-n"><a href="#47-求1-2-3-…-n" class="headerlink" title="47.求1+2+3+…+n"></a>47.求1+2+3+…+n</h2><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。  </p></blockquote><p>这个题，可以有好几种解决办法，一个容易想到的就是递归，每次都跟自己相加，直到加到0为止，判断的条件可以采用<code>&amp;&amp;</code>的短路特性：通过&amp;&amp;判断值是否为0已经到达结尾了。<br>另一种办法，可以利用类的构造函数。TODO:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Sum_Solution(int n) &#123;</div><div class="line">        int sum=n;</div><div class="line">        sum&amp;&amp;(sum+=Sum_Solution(n-1));</div><div class="line">        return sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h2><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。  </p></blockquote><p>不能用加法做加法运算，可以想到的计算机中利用的二进制的加法。通过异或两个数，也就是模2加，得到的是不考虑进位的加法的结果。通过两个数异或，左移一位得到的是进位。无进位结果加上进位，一直循环知道进位为0的时候，结果即为加法的结果。<br>计算的过程中，一定要细心。方法虽然简单，但是要写对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    int Add(int num1, int num2)</div><div class="line">    &#123;</div><div class="line">        int res = num1 ^ num2, temp = num1 &amp; num2;</div><div class="line">        while (temp != 0)</div><div class="line">        &#123;</div><div class="line">            temp = temp &lt;&lt; 1;</div><div class="line">            int t = res;  //暂存res,以避免res的值被改变</div><div class="line">            res ^= temp;</div><div class="line">            temp = temp &amp; t;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h2><blockquote><p>输入一个字符串,包括数字字母符号,可以为空.如果是合法的数值表达则返回该数字，否则返回0  </p></blockquote><p>分析：主要首先要考虑正负号，这里有一个小细节，我们把flag直接置1的话，可以直接输出flag*res得到结果，而不需要进行判断，是一种省略。另外的判断就比较简单了，按照正常的思路去判断就行。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    int StrToInt(string str)</div><div class="line">    &#123;</div><div class="line">        if (str.size() == 0)</div><div class="line">            return 0;</div><div class="line">        int flag = 1;</div><div class="line">        int size = str.size(), res = 0;</div><div class="line">        int i = 0;</div><div class="line">        if (str[0] == &apos;-&apos;)</div><div class="line">        &#123;</div><div class="line">            flag = -1;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        else if (str[0] == &apos;+&apos;)</div><div class="line">        &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        for (; i &lt; size; ++i)</div><div class="line">        &#123;</div><div class="line">            if (str[i] &lt;= &apos;0&apos; || str[i] &gt;= &apos;9&apos;)</div><div class="line">            &#123;</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                res = res * 10 + (str[i] - &apos;0&apos;);</div><div class="line">        &#125;</div><div class="line">        return flag * res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h2><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。  </p></blockquote><p>分析：由于规定了数组中的数字在范围为0–n内，所以可以利用当前数组的位置进行遍历，比如每次遍历到一个位置，就将该数字对应位置的值加n，这样，当再次遍历到该值时，发现如果该值已经大于n，说明已经重复了，返回即可。不过在遍历的时候，如果发现某一位置的值大于n，应该先减去n，得到该位置上原来的值，这里应该捋清楚。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    // Parameters:</div><div class="line">    //        numbers:     an array of integers</div><div class="line">    //        length:      the length of array numbers</div><div class="line">    //        duplication: (Output) the duplicated number in the array number</div><div class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</div><div class="line">    //                     otherwise false</div><div class="line">    bool duplicate(int numbers[], int length, int *duplication)</div><div class="line">    &#123;</div><div class="line">        for(int i=0;i&lt;length;++i)&#123;</div><div class="line">            int index=numbers[i];</div><div class="line">            if(index&gt;=length)</div><div class="line">                index=index-length;</div><div class="line">            if(numbers[index]&gt;=length)&#123;</div><div class="line">                *duplication=index;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            numbers[index]+=length;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h2><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</div><div class="line">        vector&lt;int&gt; res(A.size());</div><div class="line">        if(A.empty())</div><div class="line">            return res;</div><div class="line">        res[0]=1;</div><div class="line">        //计算下三角</div><div class="line">        for(int i=1;i&lt;A.size();++i)&#123;</div><div class="line">            res[i]=res[i-1]*A[i-1];</div><div class="line">        &#125;</div><div class="line">        int temp=1;</div><div class="line">        for(int i=A.size()-2;i&gt;=0;--i)&#123;</div><div class="line">            temp*=A[i+1];</div><div class="line">            res[i]*=temp;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="52-正则表达式匹配"><a href="#52-正则表达式匹配" class="headerlink" title="52.正则表达式匹配"></a>52.正则表达式匹配</h2><h2 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct ListNode &#123;</div><div class="line">    int val;</div><div class="line">    struct ListNode *next;</div><div class="line">    ListNode(int x) :</div><div class="line">        val(x), next(NULL) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* deleteDuplication(ListNode* pHead)</div><div class="line">    &#123;</div><div class="line">        if(pHead==nullptr)</div><div class="line">            return pHead;</div><div class="line">        ListNode* virtualHead=new ListNode(0);</div><div class="line">        virtualHead-&gt;next=pHead;</div><div class="line">        ListNode* prev=virtualHead;</div><div class="line">        </div><div class="line">        while(pHead-&gt;next)&#123;</div><div class="line">            if(pHead-&gt;val==pHead-&gt;next-&gt;val)&#123;</div><div class="line">                if(pHead-&gt;next-&gt;next)&#123;</div><div class="line">                    pHead=pHead-&gt;next-&gt;next;</div><div class="line">                    prev-&gt;next=pHead;</div><div class="line">                &#125;</div><div class="line">                else </div><div class="line">                    return virtualHead-&gt;next;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                pHead=pHead-&gt;next;</div><div class="line">                prev=prev-&gt;next;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        return virtualHead-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>测试用例:<br>{1,1,1,1,1,1,1}</p><p>对应输出应该为:</p><h2 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h2><h2 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55.链表中环的入口结点"></a>55.链表中环的入口结点</h2><h2 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56.删除链表中重复的结点"></a>56.删除链表中重复的结点</h2><h2 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57.二叉树的下一个结点"></a>57.二叉树的下一个结点</h2><h2 id="58-对称的二叉树"><a href="#58-对称的二叉树" class="headerlink" title="58.对称的二叉树"></a>58.对称的二叉树</h2><h2 id="59-按之字形顺序打印二叉树"><a href="#59-按之字形顺序打印二叉树" class="headerlink" title="59.按之字形顺序打印二叉树"></a>59.按之字形顺序打印二叉树</h2><h2 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h2><h2 id="61-序列化二叉树"><a href="#61-序列化二叉树" class="headerlink" title="61.序列化二叉树"></a>61.序列化二叉树</h2><h2 id="62-二叉搜索树的第k个结点"><a href="#62-二叉搜索树的第k个结点" class="headerlink" title="62.二叉搜索树的第k个结点"></a>62.二叉搜索树的第k个结点</h2><h2 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h2><h2 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h2><h2 id="65-矩阵中的路径"><a href="#65-矩阵中的路径" class="headerlink" title="65.矩阵中的路径"></a>65.矩阵中的路径</h2><h2 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;01-二维数组中的查找&quot;&gt;&lt;a href=&quot;#01-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;01.二维数组中的查找&quot;&gt;&lt;/a&gt;01.二维数组中的查找&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>《redis 设计与实现》--总结</title>
    <link href="http://yoursite.com/19-Linux/redis_sum/"/>
    <id>http://yoursite.com/19-Linux/redis_sum/</id>
    <published>2018-06-19T10:50:41.000Z</published>
    <updated>2018-06-22T14:05:16.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis设计与实现，以及关于Redis使用的总结  </p></blockquote><a id="more"></a><h2 id="1-数据结构与对象"><a href="#1-数据结构与对象" class="headerlink" title="1.数据结构与对象"></a>1.数据结构与对象</h2><h3 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.简单动态字符串"></a>1.简单动态字符串</h3><p>Redis自己构建了简单动态字符串(Simple Dynamic String,SDS)来作为默认的字符串表示。<br>SDS的构造如下：<br><img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180619151556.png"><br>优势是：</p><ol><li>能够在常数时间内获取字符串的长度-通过len属性   </li><li>能够杜绝缓冲区溢出：记录了缓冲区的大小，在长度不够时，能够自动扩展空间  </li><li>减少修改字符串时带来的内存重新分配次数：采用空间预分配和惰性空间释放  <h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3>Redis自己实现了链表。拥有以下特性：双端无环、带表头指针和表尾指针、带链表长度计数器、多态(使用void* 保存节点值)<h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h3>Redis字典底层采用哈希表实现。采用MurmurHash2算法，解决键冲突的方式是：链地址法。<br>哈希表的扩展与收缩：以下条件满足时：  </li><li>服务器没有执行BGSAVE或BGREWRITEAOF命令，哈希表负载因子&gt;1  </li><li>服务器在执行BGSAVE或BGREWRITEAOF命令，哈希表负载因子&gt;5  </li></ol><h3 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.跳跃表"></a>4.跳跃表</h3><p>Redis采用跳跃表作为有序集合键的底层数据结构，另：在集群节点中用作内部数据结构<br>跳跃表：一种有序数据结构，通过在一个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。支持平均O(logN),最差O(N)复杂度的查找。<br>Redis中跳跃表的实现：</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180619154918.png"> </div><br><br>其中包括表头和表尾节点，length记录节点的数量，level用于获取跳跃表中层高最大的那个节点的层数量 （表头节点的层高不计算在内）    </p><h3 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.整数集合"></a>5.整数集合</h3><p>Redis中集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合中元素的数量不多时，就会使用整数集合作为集合键的底层实现。<br>整数集合的升级策略：能够提高整数集合的灵活性，并且能够尽可能的节约内存。升级后不支持降级  </p><h3 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.压缩列表"></a>6.压缩列表</h3><p>Redis中列表键和哈希键的底层实现之一。  </p><h3 id="7-对象"><a href="#7-对象" class="headerlink" title="7.对象"></a>7.对象</h3><p>Redis使用上述的数据结构创建了一个对象系统。包括：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。其实这就是一直说的Redis五种数据结构：字符串、列表、字典、集合、有序集合。</p><h2 id="2-单机数据库的实现"><a href="#2-单机数据库的实现" class="headerlink" title="2.单机数据库的实现"></a>2.单机数据库的实现</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Redis服务器讲所有数据库保存在一个db数组中，默认创建16个数据库。<br>切换数据库:<code>select 0 #选择0号数据库</code>  </p><h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>键空间的键也是数据库的键。每个键都是一个字符串对象。<br>键空间的值也是数据库的值，每个值可以是字符串对象、列表对象、哈希对象、集合对象，有序集合对象中的任意一个Redis对象。<br>一个键空间的例子：</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180619162843.png"> </div><br></p><h4 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h4><p>原理是：过期时间是一个UNIX时间戳，当键的过期时间来临是，服务器就会自动从数据库中删除一个键。<br>命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">expire &lt;key&gt; &lt;ttl&gt;  #key的生存时间为ttl秒</div><div class="line">pexpire &lt;key&gt; &lt;ttl&gt;  #key的生存时间为ttl毫秒</div><div class="line">expireat &lt;key&gt; &lt;timestamp&gt;  #key的生存时间直到timestamp指定的时间戳s</div><div class="line">pexpireat &lt;key&gt; &lt;timestamp&gt;  #key的生存时间直到timestamp指定的时间戳ms</div><div class="line"></div><div class="line">persist &lt;key&gt;  #移除key的过期时间</div><div class="line">ttl &lt;key&gt;   #计算key的剩余生存时间</div><div class="line">```   </div><div class="line"></div><div class="line">setex命令可以设置一个字符串键的同时为键设置过期时间。</div><div class="line">一个带有过期字典的数据库例子：（实际中，键空间的键和过期字典中的键都指向同一个键对象）</div><div class="line">&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://blog-1252063226.cosbj.myqcloud.com/network/20180619163748.png&quot; /&gt; &lt;/div&gt;&lt;br&gt;</div><div class="line"></div><div class="line">#### 过期键删除策略</div><div class="line">- 定时删除： 内存最友好，CPU时间最不友好   </div><div class="line">- 惰性删除：CPU时间友好，内存不友好  </div><div class="line">- 定期删除：折中</div><div class="line">Redis实际使用：惰性删除和定期删除配合使用。</div><div class="line"></div><div class="line">#### 过期键的处理</div><div class="line">1. RDB文件：</div><div class="line">生成RDB文件：已过期的键不会保存到新创建的RDB文件中，因此对生成新的RDB文件没有影响。</div><div class="line">载入RDB文件：主服务器模式时，过期键不会被载入。从服务器模式时，都会被载入，但同步后，从服务器数据会被清空，所以也没有影响。  </div><div class="line">2. AOF文件：</div><div class="line">AOF写入：如果某个键已经过期，但没有被删除，AOF文件不会因为这个过期键产生任何影响。如果已经删除，AOF文件会追加一条DEL命令显式记录该键已被删除。  </div><div class="line">AOF重写：已过期的键不会被保存到重写的AOF文件。  </div><div class="line">3. 复制：  </div><div class="line">主服务器删除一个过期键，会显示向所有的从服务器发送DEL命令，告知删除。  </div><div class="line">从服务器遇到过期的键也不会删除。只有接收到DEL命令后才会删除过期键。  </div><div class="line"></div><div class="line">### RDB持久化</div><div class="line">通过保存数据库中的键值对来记录数据库状态不同。  </div><div class="line">功能：将Redis在内存中的数据库状态保存到磁盘中，避免数据意外丢失。RDB文件是一个经过压缩的二进制文件，保存在硬盘中，因此Redis进程退出，只要RDB文件仍在，就可以用来还原数据库的状态。  </div><div class="line">#### RDB文件的创建和载入</div><div class="line">服务器在载入RDB文件期间，会一直阻塞。  </div><div class="line">SAVE命令由服务器进程执行保存工作，因此会阻塞服务器。BGSAVE命令由子进程执行保存工作。</div><div class="line">#### 自动间隔性保存</div><div class="line">设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</div></pre></td></tr></table></figure></p><p>save 900 1  # 900s内发生了至少一次修改<br>save 300 10<br>save 60 10000<br>满足上述一个条件，BASAVE就会执行。<br>```</p><h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><table><thead><tr><th style="text-align:center">头部</th><th style="text-align:center">数据库版本</th><th style="text-align:center">数据</th><th style="text-align:center">正文结束符</th><th style="text-align:center">校验和</th></tr></thead><tbody><tr><td style="text-align:center">REDIS</td><td style="text-align:center">db_version</td><td style="text-align:center">databases</td><td style="text-align:center">EOF</td><td style="text-align:center">check_sum</td></tr></tbody></table><h3 id="AOF持久化-Append-Only-File"><a href="#AOF持久化-Append-Only-File" class="headerlink" title="AOF持久化(Append Only File)"></a>AOF持久化(Append Only File)</h3><p>通过保存Redis服务器所执行的写命令来记录数据库状态。   </p><h4 id="AOF持久化的实现过程"><a href="#AOF持久化的实现过程" class="headerlink" title="AOF持久化的实现过程"></a>AOF持久化的实现过程</h4><p>命令追加:将内容追加到aof_buf缓冲区的末尾。<br>写入与同步：服务器每次结束一个时间循环之前，都会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区中的内容写入和保存到AOF文件中。选项值为：alwals,everysec,no<br>载入与数据还原：还原过程：创建一个不带网络连接的伪客户端；从AOF文件中分析并读取一条写命令；使用伪客户端执行被读出的写命令；循环处理。  </p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>目的：解决AOF文件体积膨胀。<br>实现原理：从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。<br>后台重写：子进程AOF重写期间，服务器进程可以继续处理命令请求。<br>后台重写问题：子进程重写期间，服务器还需要处理命令请求，可能导致服务器当前数据库状态和重写后的AOF文件所保存的数据库状态不一致。解决办法：AOF重写缓冲区。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>文件事件处理器。基于Reactor模式，使用IO多路复用程序同时监听多个套接字。</p><h2 id="3-多机数据库的实现"><a href="#3-多机数据库的实现" class="headerlink" title="3.多机数据库的实现"></a>3.多机数据库的实现</h2><h2 id="4-独立功能的实现"><a href="#4-独立功能的实现" class="headerlink" title="4.独立功能的实现"></a>4.独立功能的实现</h2><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="AOF和RDB比较"><a href="#AOF和RDB比较" class="headerlink" title="AOF和RDB比较"></a>AOF和RDB比较</h3><ul><li>两者区别：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。  </li><li>优缺点：RDB：灵活设置备份频率和周期。方便灾难恢复，可以轻松的将一个单独的文件压缩再转移到其他存储介质上。性能最大化。数据集很大时，启动效率相对AOF较高。缺点：很难保证高可用，可能数据在写入磁盘之前会丢失。数据集较大时，可能导致服务器停止服务。<br>AOF：数据持久性。对日志的写入操作采用的是append模式，写入过程即使出现宕机，也不会破坏日志文件中已经存在的内容。如果日志过大，Redis可以自动启用rewrite机制。包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。缺点：RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。根据同步策略的不同，AOF在运行效率上往往会慢于RDB。  </li></ul><h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><p>使用setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。<br>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？<br>同时把setnx和expire合成一条指令来用  </p><h3 id="寻找key"><a href="#寻找key" class="headerlink" title="寻找key"></a>寻找key</h3><p>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>用keys指令可以扫出指定模式的key列表。<br>redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。  </p><h3 id="Redis同步机制"><a href="#Redis同步机制" class="headerlink" title="Redis同步机制"></a>Redis同步机制</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h3 id="redis相比memcached有哪些优势"><a href="#redis相比memcached有哪些优势" class="headerlink" title="redis相比memcached有哪些优势"></a>redis相比memcached有哪些优势</h3><ol><li>丰富的数据类型  </li><li>速度快  </li><li>可以持久化<br>区别：  </li><li>存储方式：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。  </li><li>数据类型：Memcache对数据类型支持相对简单。Redis有复杂的数据类型,Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。  </li><li>底层模型：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。  </li><li>value大小：redis最大可以达到1GB，而memcache只有1MB。  </li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ol><h3 id="Redis的LRU算法"><a href="#Redis的LRU算法" class="headerlink" title="Redis的LRU算法"></a>Redis的LRU算法</h3><p>最近最久未用算法。当内存达到限制时，Redis 具体的回收策略是通过 maxmemory-policy 配置项配置的。<br>no-eviction：不清除数据，只是返回错误，这样会导致浪费掉更多的内存，对大多数写命令（DEL 命令和其他的少数命令例外）<br>allkeys-lru：从所有的数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，以供新数据使用<br>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰，以供新数据使用<br>allkeys-random：从所有数据集（server.db[i].dict）中任意选择数据淘汰，以供新数据使用<br>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰，以供新数据使用<br>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，以供新数据使用  </p><h3 id="Redis常见的性能问题及解决"><a href="#Redis常见的性能问题及解决" class="headerlink" title="Redis常见的性能问题及解决"></a>Redis常见的性能问题及解决</h3><ol><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件. 特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。  </li><li>尽量避免在压力很大的主库上增加从库。  </li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。  </li><li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内  </li></ol><h3 id="适合Redis的场景"><a href="#适合Redis的场景" class="headerlink" title="适合Redis的场景"></a>适合Redis的场景</h3><ol><li>会话缓存 全页缓存   队列 排行榜/计数器  发布/订阅  会话  购物车 </li></ol><h3 id="Nosql和Key-Value数据库"><a href="#Nosql和Key-Value数据库" class="headerlink" title="Nosql和Key-Value数据库"></a>Nosql和Key-Value数据库</h3><p>NoSQL，泛指非关系型的数据库，全称Not Only SQL，意即“不仅仅是SQL”。<br>NoSQL数据库的四大家族：</p><ol><li>键值（Key-Value）数据库:Redis、Memcached   </li><li>面向文档（Document-Oriented）数据库:MongoDB  适用：日志、分析</li><li>列存储（Wide Column Store/Column-Family）数据库  HBase 适用:日志、博客平台</li><li>图（Graph-Oriented）数据库 适用：关系性强，推荐引擎</li></ol><h3 id="Redis最大连接数"><a href="#Redis最大连接数" class="headerlink" title="Redis最大连接数"></a>Redis最大连接数</h3><p>默认10000</p><h3 id="redis的瓶颈"><a href="#redis的瓶颈" class="headerlink" title="redis的瓶颈"></a>redis的瓶颈</h3><h3 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h3><h4 id="Redis-复制功能"><a href="#Redis-复制功能" class="headerlink" title="Redis 复制功能"></a>Redis 复制功能</h4><h3 id="Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"><a href="#Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端" class="headerlink" title="Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"></a>Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端</h3><h3 id="Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用"><a href="#Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用" class="headerlink" title="Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用"></a>Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用</h3><h3 id="Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等"><a href="#Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等" class="headerlink" title="Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等"></a>Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等</h3><h3 id="Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"><a href="#Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的" class="headerlink" title="Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"></a>Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的</h3><h3 id="Redis和memcached的区别，Redis为什么可以组集群"><a href="#Redis和memcached的区别，Redis为什么可以组集群" class="headerlink" title="Redis和memcached的区别，Redis为什么可以组集群"></a>Redis和memcached的区别，Redis为什么可以组集群</h3><h2 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h2><p><a href="https://www.bookstack.cn/read/note-of-interview/framework-redis.md" target="_blank" rel="external">https://www.bookstack.cn/read/note-of-interview/framework-redis.md</a><br><a href="http://www.techug.com/post/nosql.html" target="_blank" rel="external">http://www.techug.com/post/nosql.html</a>   </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Redis设计与实现，以及关于Redis使用的总结  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="Nosql" scheme="http://yoursite.com/tags/Nosql/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu自动push到github脚本</title>
    <link href="http://yoursite.com/24-%E5%B7%A5%E5%85%B7/shell_%E8%87%AA%E5%8A%A8push/"/>
    <id>http://yoursite.com/24-工具/shell_自动push/</id>
    <published>2018-05-24T12:20:43.000Z</published>
    <updated>2018-05-31T12:15:39.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于人比较懒，总是忘了自己提交到github上，也觉得博客好不容易写了还要打开文件夹，点一下交，这个体验有点差呀。于是就写了个Linux自动提交代码的和windows自动更新博客的。</p></blockquote><a id="more"></a><h2 id="Linux编写shell脚本"><a href="#Linux编写shell脚本" class="headerlink" title="Linux编写shell脚本"></a>Linux编写shell脚本</h2><h3 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">path=~/github/</div><div class="line"></div><div class="line">git_push()&#123;</div><div class="line">    echo &quot;开始push&quot;</div><div class="line">    modify_time=`stat -c %Y $&#123;1&#125;`</div><div class="line">    this_time=`date +%s`</div><div class="line"></div><div class="line">    cd $&#123;1&#125;</div><div class="line">    echo &quot;-------切换目录------&quot;</div><div class="line">    echo `pwd`</div><div class="line">    echo &quot;---------------------&quot;</div><div class="line">    if [ $[ $&#123;modify_time&#125;-$&#123;this_time&#125; ] -gt 86400 ];</div><div class="line">    then</div><div class="line">         echo &quot;$&#123;1&#125; 文件夹 有变化，正在准备push...&quot;</div><div class="line">        date=`date &quot;+%Y-%m-%d %H:%M:%S&quot;`</div><div class="line">        git add .    </div><div class="line">        git commit -m &quot;automatic push @$(date)&quot;</div><div class="line">        echo &quot;git fetch origin master&quot;</div><div class="line">        git fetch origin master</div><div class="line"></div><div class="line">        echo &quot;git merge origin/master&quot;</div><div class="line">        git merge origin/master</div><div class="line"></div><div class="line">        echo &quot;git push origin master:master&quot;</div><div class="line">        git push origin master:master</div><div class="line">         </div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">git_push ~/github/Linux_pro</div><div class="line">git_push ~/github/miniweb</div></pre></td></tr></table></figure><h3 id="加入定时任务"><a href="#加入定时任务" class="headerlink" title="加入定时任务"></a>加入定时任务</h3><h3 id="编辑定时任务文件"><a href="#编辑定时任务文件" class="headerlink" title="编辑定时任务文件"></a>编辑定时任务文件</h3><p>(<a href="https://blog.csdn.net/xiyuan1999/article/details/8160998" target="_blank" rel="external">https://blog.csdn.net/xiyuan1999/article/details/8160998</a>)<br><code>crontab  -e</code><br>在文件的末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30 5 * * * /home/mianhk/shell/auto_push.sh  表示在每天的 5.30执行</div></pre></td></tr></table></figure></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><code>/etc/init.d/cron start</code></p><h2 id="Windows自动提交博客"><a href="#Windows自动提交博客" class="headerlink" title="Windows自动提交博客"></a>Windows自动提交博客</h2><p>其实windows的也差不多，写一个bat的脚本，然后加到系统的定时任务里面</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">title 同步博客到远端——余国聪</div><div class="line">color 16</div><div class="line"></div><div class="line">echo;</div><div class="line">echo;</div><div class="line"></div><div class="line">echo 切换目录到blog</div><div class="line">f:</div><div class="line">cd \github\mianhk</div><div class="line">cd .\blog</div><div class="line">echo clean</div><div class="line"></div><div class="line">hexo g -d</div><div class="line"></div><div class="line">echo 切换到GitHub备份目录</div><div class="line">cd ..</div><div class="line"></div><div class="line">echo 开始提交代码到本地仓库</div><div class="line">echo 当前目录是：%cd%</div><div class="line"></div><div class="line">echo 开始添加变更</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git add -A .</div><div class="line">echo 执行结束！</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 提交变更到本地仓库</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">set declation=%date:~0,4%%date:~5,2%%date:~8,2%</div><div class="line">git commit -m &quot;%declation%同步博客&quot;</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 将变更情况提交到远程git服务器</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git push origin master</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 批处理执行完毕！</div><div class="line">echo;</div><div class="line"></div><div class="line">pause</div></pre></td></tr></table></figure><h3 id="添加到自动任务"><a href="#添加到自动任务" class="headerlink" title="添加到自动任务"></a>添加到自动任务</h3><p>计算机-&gt;管理-&gt;任务计划程序-&gt;添加任务即可  </p><p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=174pin6hqb074" target="_blank" rel="external">https://cloud.tencent.com/developer/support-plan?invite_code=174pin6hqb074</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于人比较懒，总是忘了自己提交到github上，也觉得博客好不容易写了还要打开文件夹，点一下交，这个体验有点差呀。于是就写了个Linux自动提交代码的和windows自动更新博客的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jupyter-notebook安装和问题解决</title>
    <link href="http://yoursite.com/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/"/>
    <id>http://yoursite.com/26-工具/use_of_jupyter/</id>
    <published>2018-04-26T03:36:57.000Z</published>
    <updated>2018-05-13T13:39:12.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jupyter notebook折腾日记</p></blockquote><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-采用直接pip安装"><a href="#1-采用直接pip安装" class="headerlink" title="1.采用直接pip安装"></a>1.采用直接pip安装</h2><p><code>pip install jupyter</code>不过可能由于是版本自带的pip有问题，而且用的Python版本也还是2.7的，反正就出现了各种问题。中间解决的有：  </p><ul><li>重新升级pip，但是发现直接pip还是有问题，于是找到问题原因，可能名字有点对不上，找到bin目录下还有一个pip2，在Python里面运行，发现果然是这个，有点心酸，还是换了这个。  </li><li>升级之后，会出现各种的权限问题，没事，给！  </li><li>之后运行，发现没有浏览器，于是又想起服务器上没有，又加上命令试了一下，而且每次都要复制一个长长的token吗？。。</li></ul><h2 id="2-采用Anaconda安装"><a href="#2-采用Anaconda安装" class="headerlink" title="2.采用Anaconda安装"></a>2.采用Anaconda安装</h2><p>正好晚上在床上看到一个链接，说这个更方便，反正也是折腾嘛，就试试了。过程稍微写一写哈</p><ol><li>在清华镜像站找到采用Anaconda相应版本下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br> 找到后复制链接：<code>wget 链接</code> </li><li>安装Anaconda:<br> <code>sh Anaconda3-5.1.0-Linux-x86_64.sh # 一路yes就装了</code>  </li><li>服务器管理控制台开放8888端口（当然端口可以配置，也随便换了）  </li><li>运行<code>jupyter notebook --generate-config</code> 生成默认的jupyter配置文件  </li><li><p>编辑config文件：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd .jupyter</div><div class="line">vim jupyter_notebook_config.py #编辑config文件</div><div class="line">c.NotebookApp.ip = &apos;*&apos;  #允许所有的ip登录</div><div class="line">c.NotebookApp.open_browser = False #打开浏览器：关闭，因为服务器没有浏览器</div><div class="line">c.NotebookApp.port = 8888  #开放使用的端口</div></pre></td></tr></table></figure></li><li><p>保存退出。运行jupyter notebook，会得到一个带token的访问地址。复制地址，将其中的localhost替换成服务器的公网IP，访问，应该可以正常进入jupyter。  </p></li><li>每次都tocken当然有点麻烦了。设置一个密码吧：<br> <code>jupyter-notebook password</code></li><li>之后就可以公网输入登录了。</li></ol><h2 id="3-安装主题和相关插件"><a href="#3-安装主题和相关插件" class="headerlink" title="3.安装主题和相关插件"></a>3.安装主题和相关插件</h2><p><a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="external">jupyter_contrib_nbextensions</a><br>直接使用<code>conda install -c conda-forge jupyter_contrib_nbextensions</code></p><ul><li>使用注意：<br>1.关于ubuntu的环境变量设置没有对，导致conda命令不能用的问题。当然知道应该是环境变量的问题，不过还是搞了很久。才发现是加在ubuntu的home目录下的<code>.bashrc</code>后面<code>export PATH=~/anaconda3/bin:$PATH</code><br>2.由于我的conda版本没有更新，所以出现了插件也只有几个的情况，所以需要先更新。之后再重启jupyter notebook。<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><a href="http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/" target="_blank" rel="external">http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</a><br><a href="https://zhuanlan.zhihu.com/p/34289322" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34289322</a><br><a href="https://zhuanlan.zhihu.com/p/20226040?utm_source=qq&amp;utm_medium=social&amp;utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/20226040?utm_source=qq&amp;utm_medium=social&amp;utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;jupyter notebook折腾日记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="jupyter" scheme="http://yoursite.com/tags/jupyter/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日常折腾日记</title>
    <link href="http://yoursite.com/25-%E5%B7%A5%E5%85%B7/daily_zheteng/"/>
    <id>http://yoursite.com/25-工具/daily_zheteng/</id>
    <published>2018-04-25T03:49:56.000Z</published>
    <updated>2018-05-19T13:37:08.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>俗话说，生活就是不断的折腾，恰好自己是个这样的人。可能就是这样一个虽然不是很年轻了，但是心态总是年轻的，看到一些有趣的或者有意思的，总是忍不住想看看，或者试试。但是有时候又觉得自己不再年轻了，有些东西虽然当时记着了，但是后来又忘了，或者有时候记着又找起来很耽误时间。所以就在这记录一下吧。</p></blockquote><a id="more"></a><h2 id="博客相关"><a href="#博客相关" class="headerlink" title="博客相关"></a>博客相关</h2><p><a href="https://zhuanlan.zhihu.com/p/28128674" target="_blank" rel="external">hexo博客插件</a><br><a href="http://www.yuguocong.me/10-%E5%B7%A5%E5%85%B7/%E6%88%91%E7%9A%84hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">我的博客折腾</a><br><a href="http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/" target="_blank" rel="external">自动构建博客</a></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><a href="http://www.yuguocong.me/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/" target="_blank" rel="external">jupyter</a></p><ul><li><a href="https://www.cnblogs.com/kevingrace/p/6496899.html" target="_blank" rel="external">tmux的使用</a></li><li><a href="https://github.com/kxxoling/blog/blob/master/tool/tmux.md" target="_blank" rel="external">tmux的使用2</a></li></ul><h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><p>vip视频：<br><a href="https://github.com/laidefa/Flask_Web_Vip：" target="_blank" rel="external">https://github.com/laidefa/Flask_Web_Vip：</a>  <a href="http://101.37.147.236:1518/" target="_blank" rel="external">http://101.37.147.236:1518/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;俗话说，生活就是不断的折腾，恰好自己是个这样的人。可能就是这样一个虽然不是很年轻了，但是心态总是年轻的，看到一些有趣的或者有意思的，总是忍不住想看看，或者试试。但是有时候又觉得自己不再年轻了，有些东西虽然当时记着了，但是后来又忘了，或者有时候记着又找起来很耽误时间。所以就在这记录一下吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="资源" scheme="http://yoursite.com/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="收集" scheme="http://yoursite.com/tags/%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3使用总结</title>
    <link href="http://yoursite.com/24-%E5%B7%A5%E5%85%B7/use-of-sublime/"/>
    <id>http://yoursite.com/24-工具/use-of-sublime/</id>
    <published>2018-04-24T12:43:43.000Z</published>
    <updated>2018-04-24T14:49:47.092Z</updated>
    
    <content type="html"><![CDATA[<p>update:</p><ul><li>2018-04-24 首次更新:突然发现Sublime Text3也还是挺好用的，之前切出去光标总是乱跳，就有点烦，以为是这样的就没管，用了网易云，没想到发现只有我的是这样，赶紧找找问题，解决一下。顺便把很多重新折腾一下。</li></ul><p>#用好sublime</p><h3 id="为Sublime-Text3添加插入当前时间的命令"><a href="#为Sublime-Text3添加插入当前时间的命令" class="headerlink" title="为Sublime Text3添加插入当前时间的命令"></a><a href="https://www.cnblogs.com/jiafeimao-dabai/p/7238357.html" target="_blank" rel="external">为Sublime Text3添加插入当前时间的命令</a></h3><ol><li>创建插件：</li></ol><p>Tools → New Plugin:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import datetime</div><div class="line">import sublime_plugin</div><div class="line">class AddCurrentTimeCommand(sublime_plugin.TextCommand):</div><div class="line">    def run(self, edit):</div><div class="line">        self.view.run_command(&quot;insert_snippet&quot;, </div><div class="line">            &#123;</div><div class="line">                &quot;contents&quot;: &quot;%s&quot; % datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) </div><div class="line">            &#125;</div><div class="line">        )</div></pre></td></tr></table></figure></p><p>保存为Sublime Text3\Packages\User\addCurrentTime.py</p><ol><li>创建快捷键：</li></ol><p>Preference → Key Bindings - User:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;command&quot;: &quot;add_current_time&quot;,</div><div class="line">        &quot;keys&quot;: [</div><div class="line">            &quot;ctrl+shift+.&quot;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p><h3 id="添加了一个主题https-packagecontrol-io-packages-Predawn：Predawn"><a href="#添加了一个主题https-packagecontrol-io-packages-Predawn：Predawn" class="headerlink" title="添加了一个主题https://packagecontrol.io/packages/Predawn：Predawn"></a><a href="">添加了一个主题</a><a href="https://packagecontrol.io/packages/Predawn：Predawn" target="_blank" rel="external">https://packagecontrol.io/packages/Predawn：Predawn</a></h3><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><p>小土刀博客：<a href="http://wdxtub.com/2016/03/24/sublime-guide/" target="_blank" rel="external">http://wdxtub.com/2016/03/24/sublime-guide/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;update:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2018-04-24 首次更新:突然发现Sublime Text3也还是挺好用的，之前切出去光标总是乱跳，就有点烦，以为是这样的就没管，用了网易云，没想到发现只有我的是这样，赶紧找找问题，解决一下。顺便把很多重新折腾一下。&lt;/li&gt;
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="折腾" scheme="http://yoursite.com/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>阶段性生活思考</title>
    <link href="http://yoursite.com/24-%E9%9A%8F%E7%AC%94/redo-mylife/"/>
    <id>http://yoursite.com/24-随笔/redo-mylife/</id>
    <published>2018-04-24T12:40:26.000Z</published>
    <updated>2018-05-30T12:22:38.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="why-title"><a href="#why-title" class="headerlink" title="why title"></a>why title</h2><blockquote><p>生活就是要不断的思考,不是吗?</p></blockquote><a id="more"></a><h3 id="update-2018-05-13-21-15-04-周日"><a href="#update-2018-05-13-21-15-04-周日" class="headerlink" title="update:2018-05-13 21:15:04 周日"></a>update:2018-05-13 21:15:04 周日</h3><p>突然觉得很久没思考自己的生活了。      </p><ul><li>1.做事情注意力不集中。最近虽然看起来学习态度要好一些，每天都是待在实验室，但是学习的效率却感觉没有以前高了。而且总是注意力不够集中，明明在该学习的时候，却看看这个看看那个。做这个的时候看看想起另外一件事，就去看看，结果就该做的事情没做好。看看论文就想玩玩手机，玩着又有点愧疚就去看看c++，总是三心二意的。  </li><li>2.不太爱思考。另一个问题就是，遇到问题不求甚解。这还是以前的老问题吧，对于以前的应试教育来说，可能里面的道理也不用太深究，毕竟能最后写在试卷上就行了，看起来还能有个差不多好看的分数。但是现在处于的阶段不一样了，不管是日常的工作学习，还是平时看到一些新闻的想法，这都会有一些问题。当然，这方面可能手机因素也比较大一点，有很多的观点唾手可得，找找资料就能看到很多东西，恰好这方面自己又比较擅长，于是就又陷入了找资料不思考的陷阱。这样虽然有时候找到了很多有价值的东西，平时看到了很多，说吧，都知道，但是具体的就是不清楚，更别谈再有所新的想法了。所以这是个重要的问题。  </li><li>3.做事情应该更有目的。就是可能现在感觉很忙，但是却没有个统一的目的，有时候花的时间是多了，但是却没有很好的效果。  </li></ul><h3 id="update-2018-05-30-20-21-01-周三"><a href="#update-2018-05-30-20-21-01-周三" class="headerlink" title="update:2018-05-30 20:21:01 周三"></a>update:2018-05-30 20:21:01 周三</h3><ul><li>学习方面稍微集中了一点，但是还是没有太专注。  </li><li>做事情还是要抓住重点，仍然需要注意。  </li><li>多多总结。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;why-title&quot;&gt;&lt;a href=&quot;#why-title&quot; class=&quot;headerlink&quot; title=&quot;why title&quot;&gt;&lt;/a&gt;why title&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;生活就是要不断的思考,不是吗?&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>更好的使用Linux</title>
    <link href="http://yoursite.com/19-Linux/easy_use_of_Linux/"/>
    <id>http://yoursite.com/19-Linux/easy_use_of_Linux/</id>
    <published>2018-04-19T06:57:16.000Z</published>
    <updated>2018-06-22T03:06:13.858Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>平时总是用Linux下进行一些开发，但是日常看看论文都是windows，有时候有一些有用的或者比较有意思的，可能当时知道了，后面就忘了，或者也有一些本身就是小东西，结果用的时候又是去查，就觉得很麻烦，觉得还不如自己整理一下。  </p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180622110604.png"> </div><br><br><a id="more"></a></p></blockquote><h1 id="代码统计软件-cloc"><a href="#代码统计软件-cloc" class="headerlink" title="代码统计软件-cloc"></a>代码统计软件-cloc</h1><p>安装：<code>sudo apt-get install cloc</code><br>使用：<code>cloc yourpath</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;平时总是用Linux下进行一些开发，但是日常看看论文都是windows，有时候有一些有用的或者比较有意思的，可能当时知道了，后面就忘了，或者也有一些本身就是小东西，结果用的时候又是去查，就觉得很麻烦，觉得还不如自己整理一下。  &lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://blog-1252063226.cosbj.myqcloud.com/network/20180622110604.png&quot;&gt; &lt;/div&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="日常" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>一文总结计算机网络</title>
    <link href="http://yoursite.com/10-network/network/"/>
    <id>http://yoursite.com/10-network/network/</id>
    <published>2018-04-10T12:24:59.000Z</published>
    <updated>2018-06-22T03:07:30.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近一直在看网络编程的东西，不管是看书、还是一些博客，或者是自己的一些编程，都觉得写的有点乱，有点杂。虽然这也比较符合网络方面的特点，零碎的知识点，有些人觉得重要就写上了，另一些就没有写。想到将来可能跟网络编程接触很多，也觉得最近的学习就是缺少一些总结。就在这里站在大佬的肩膀上整理一下吧。<br><a id="more"></a></p><h1 id="计算机网络体系结构（TCP-IP四层模型）"><a href="#计算机网络体系结构（TCP-IP四层模型）" class="headerlink" title="计算机网络体系结构（TCP/IP四层模型）"></a>计算机网络体系结构（TCP/IP四层模型）</h1><p>一般所说的计算机体系结构分为三种，其中TCP/IP体系结构是实际应用较多的。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/001.png" width="500"> </div><br></p><h2 id="各层的作用以及协议"><a href="#各层的作用以及协议" class="headerlink" title="各层的作用以及协议"></a>各层的作用以及协议</h2><h3 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h3><p>表示层和会话层用途如下：</p><ol><li>表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩；</li><li>会话层：不同机器上的用户之间建立及管理会话。</li></ol><h3 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h3><ol><li>应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li>网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</li><li>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。</li><li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ol><h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。<br>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/010.png" width="400"> </div><br><br>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/011.png" width="400"> </div><br></p><h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。<br>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/012.jpg" width="600"> </div><br></p><h1 id="网络接口层（TCP-IP）"><a href="#网络接口层（TCP-IP）" class="headerlink" title="网络接口层（TCP/IP）"></a>网络接口层（TCP/IP）</h1><p>对应OSI七层协议的数据链路层和物理层。在实际的编程中，一般对底层关注的更少，作为长期从事物理层和数据链路层相关工作的通信工程本来觉得可以稍微发挥一下的，咳咳。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li>传输数据的单位–比特</li><li>数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点）</li></ul><p>通道：</p><ul><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li><li>双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul><p>通道复用技术：</p><ul><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="主要信道："><a href="#主要信道：" class="headerlink" title="主要信道："></a>主要信道：</h3><ul><li>点对点信道</li><li>广播信道</li></ul><h4 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h4><ul><li>数据单元–帧</li></ul><p>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</p><h4 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h4><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/013.jpg" width="400"> </div><br></p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>透明表示一个实际存在的事物看起来好像不存在一样。<br>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符，如果出现转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/014.jpg" width="400"> </div><br></p><h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。网络层协议有：</p><ul><li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li><li>ARP（Address Resolution Protocol，地址解析协议）</li><li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li></ul><h2 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP 网际协议"></a>IP 网际协议</h2><h3 id="IP-地址分类："><a href="#IP-地址分类：" class="headerlink" title="IP 地址分类："></a>IP 地址分类：</h3><ul><li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li></ul><table><thead><tr><th>IP 地址类别</th><th>网络号</th><th>网络范围</th><th>主机号</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A 类</td><td>8bit，第一位固定为 0</td><td>0 —— 127</td><td>24bit</td><td>1.0.0.0 —— 127.255.255.255</td></tr><tr><td>B 类</td><td>16bit，前两位固定为  10</td><td>128.0 —— 191.255</td><td>16bit</td><td>128.0.0.0 —— 191.255.255.255</td></tr><tr><td>C  类</td><td>24bit，前三位固定为  110</td><td>192.0.0 —— 223.255.255</td><td>8bit</td><td>192.0.0.0 —— 223.255.255.255</td></tr><tr><td>D  类</td><td>前四位固定为 1110，后面为多播地址</td></tr><tr><td>E  类</td><td>前五位固定为 11110，后面保留为今后所用</td></tr></tbody></table><h3 id="IP-数据报格式："><a href="#IP-数据报格式：" class="headerlink" title="IP 数据报格式："></a>IP 数据报格式：</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/015.jpg" width="500"> </div><br></p><ul><li><strong>版本</strong>  : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong>  : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong>  : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong>  : 包括首部长度和数据部分长度。</li><li><strong>标识</strong>  : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong>  : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。<br><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/016.jpg" width="500"> </div><br></li><li><strong>生存时间</strong>  ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li></ul><h3 id="ARP-RARP-地址解析协议-反向地址转化协议"><a href="#ARP-RARP-地址解析协议-反向地址转化协议" class="headerlink" title="ARP/RARP 地址解析协议/反向地址转化协议"></a>ARP/RARP 地址解析协议/反向地址转化协议</h3><h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议:"></a>地址解析协议:</h4><ul><li>在数据报向下一个站点传递时，负责将IP地址转换为物理地址。</li><li>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接受返回消息，以此确定目标的物理地址；<br>接收的返回消息后将该IP地址和物理地址存入本机并保留一段时间，下次请求时直接查询ARP缓存以节约时间。<br>（地址解析协议是IPV4中广泛使用的协议；但在IPV6中不存在该协议，使用NDP（邻居发现协议））</li><li>工作流程：<br>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址解析为主机B的MAC（物理）地址。<br>ARP缓存是一个用来存储IP地址和MAC地址的一个缓冲区，其本质是一个IP地址对应一个MAC地址。当地址解析协议在查询IP时，首先在ARP缓存中查看，若存在则返回，否则发送ARP请求；<br>地址解析协议是通过报文工作的。报文包括如下字段：硬件类型，协议类型，硬件地址长度，协议长度，操作类型。</li><li>APR缓存包含一个或多个表，他们用于存储IP地址及经过地址解析的MAC地址。ARP命令用于查询本机的ARP缓存中的IP到MAC地址的对应关系、添加或删除静态对应关系等。如果再没有参数的情况下ARP命令将显示帮助信息。</li><li>ARP-a 查看缓存中的所有项目，在Linux中命令式ARP-g;</li></ul><h4 id="反向地址转化协议"><a href="#反向地址转化协议" class="headerlink" title="反向地址转化协议:"></a>反向地址转化协议:</h4><ul><li>作用于ARP相反，负责将物理层地址转换为IP地址</li><li>反向地址转化协议，作用于ARP相反，负责将物理层地址转换为IP地址；<br>允许局域网物理机器从网关服务器的ARP表或缓存上请求主机的IP地址；当设置一台新机器时，其RARP客户机程序需要向路由器上的RARP服务器请求相应的IP地址。</li><li>ARP是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议，假设知道自己的物理地址但不知道自己的IP地址，这种情况就该使用RARP协议。<br>RARP工作方式与ARP相反，RARP发出需要反向解析的MAC地址，并且希望返回其对应的IP地址，应答包括由能提供信息的RARP服务器发出的IP地址。</li><li>工作流程：<br>从网卡读取自己的MAC地址—&gt;发送RARP请求的广播数据包—&gt;RARP服务器收到请求，为其分配IP地址，并将RARP回应发送给该机器—&gt;该机器收到IP地址后，使用IP地址进行通信</li></ul><h3 id="ICMP-网际控制报文协议"><a href="#ICMP-网际控制报文协议" class="headerlink" title="ICMP 网际控制报文协议"></a>ICMP 网际控制报文协议</h3><p>由于IP协议提供的是一种不可靠的和无连接的数据报服务，为了对IP数据报的传送进行差错控制，对未能完成传送的数据报给出出错的原因，TCP/IP协议簇在网络连层提供了一个用于传递控制报文的ICMP协议，即网际控制报文协议。<br>ICMP 报文格式：</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/017.jpg" width="400"> </div><br><br>应用：</p><ul><li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性<ul><li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li></ul></li><li>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</li></ul><h3 id="IGMP-网际组管理协议"><a href="#IGMP-网际组管理协议" class="headerlink" title="IGMP 网际组管理协议"></a>IGMP 网际组管理协议</h3><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。</p><h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/018.jpg" width="500"> </div><br></p><ul><li><strong>Source Port和Destination Port</strong>:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接</li><li><strong>Sequence Number</strong>:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401；</li><li><strong>Acknowledgment Number</strong>:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。主要用来解决不丢包的问题。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701；</li><li><strong>Offset</strong>:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；</li><li><strong>TCP Flags</strong>:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：<ul><li>URG：此标志表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</li><li><strong>确认ACK</strong>：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1；</li><li>PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li><li>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li><li><strong>同步SYN</strong>：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</li><li><strong>终止FIN</strong>： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN=1标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</li></ul></li><li><strong>窗口</strong>  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/002.jpg" width="500"> </div><br></p><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li></ul><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的。那对于TCP的断开连接，就是通常说的“四次挥手”。</p><ul><li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，主机1也关闭连接。</li></ul><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接，解决网络中存在延迟的分组，防止了服务器端的一直等待而浪费资源。</p><blockquote><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”<br>失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。</p></blockquote><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。<br>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p><h4 id="TCP的十一种状态"><a href="#TCP的十一种状态" class="headerlink" title="TCP的十一种状态"></a>TCP的十一种状态</h4><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/008.png" width="500"> </div><br></p><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li><li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li><li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li><li>FIN_WAIT_1: 其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</li><li>FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li><li>CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</li><li>LAST_ACK: 被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li><li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li></ul><h4 id="TCP长连接和短连接"><a href="#TCP长连接和短连接" class="headerlink" title="TCP长连接和短连接"></a>TCP长连接和短连接</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul><li>长连接，也叫持久连接，在TCP层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息（包括心跳）交互，直至连接的任意一方（客户端OR服务端）主动断开连接，此过程称为一次完整的长连接。HTTP 1.1相对于1.0最重要的新特性就是引入了长连接。  </li><li>短连接，与长连接的区别就是，客户端收到服务端的响应后，立刻发送FIN消息，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互（发请求-收响应）之后立刻断开连接的情况都称为短连接。  </li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>1、需要频繁交互的场景使用长连接，如即时通信工具（微信/QQ，QQ也有UDP），相反则使用短连接，比如普通的web网站，只有当浏览器发起请求时才会建立连接，服务器返回响应后，连接立即断开。<br>2、维持长连接会有一定的系统开销，用户量少不容易看出系统瓶颈，一旦用户量上去了，就很有可能把服务器资源（内存/CPU/网卡）耗尽，所以使用需谨慎。  </p><h5 id="快速区分使用的是长连接还是短连接"><a href="#快速区分使用的是长连接还是短连接" class="headerlink" title="快速区分使用的是长连接还是短连接"></a>快速区分使用的是长连接还是短连接</h5><p>1、凡是在一次完整的消息交互（发请求-收响应）之后，立刻断开连接（有一方发送FIN消息）的情况都称为短连接；<br>2、长连接的一个明显特征是会有心跳消息（也有没有心跳的情况），且一般心跳间隔都在30S或者1MIN左右，用wireshark抓包可以看到有规律的心跳消息交互（可能会存在毫秒级别的误差）。  </p><h4 id="TCP实现可靠传输"><a href="#TCP实现可靠传输" class="headerlink" title="TCP实现可靠传输"></a>TCP实现可靠传输</h4><ul><li>建立连接（标志位）：通信前确认通信实体存在。</li><li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li><li>数据校验（校验和）：CRC校验全部数据。</li><li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li><li>窗口机制（窗口）：提供流量控制，避免过量发送。</li><li>拥塞控制：同上。</li></ul><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>超时重传机制：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<br>发送的数据没能到达接收端，所以对方没有响应。<br>接收端接收到数据，但是ACK报文在返回过程中丢失。<br>接收端拒绝或丢弃数据。</p><ul><li>重传间隔(RTO)：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。<ul><li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li><li>重传次数到达上限之后停止重传。</li></ul></li><li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li></ul><h5 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a><a href="https://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="external">TCP流量控制</a></h5><h6 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h6><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/007.jpg" width="500"> </div><br><br>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><h6 id="考虑传输速率"><a href="#考虑传输速率" class="headerlink" title="考虑传输速率"></a>考虑传输速率</h6><p>可以用不同的机制来控制TCP报文段的发送时机。如：</p><ol><li>TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即TCP支持的推送( push )操作。</li><li>发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</li></ol><p>Nagle算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定：当到达的数据已达到 发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p><p>糊涂窗口综合证：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><p>拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。<br>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。<br>流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。<br>拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。<br>控制办法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><h6 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h6><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。<br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。<br>慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/004.jpg" width="500"> </div><br><br>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。<br>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：<br>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p><p>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。<br>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/005.jpg" width="500"> </div><br></p><ol><li>当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</li><li>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。</li><li>假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。</li></ol><p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。<br>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/006.jpg" width="500"> </div><br><br>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。<br>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ol><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</li><li>由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ol><h5 id="区分流量控制和拥塞控制"><a href="#区分流量控制和拥塞控制" class="headerlink" title="区分流量控制和拥塞控制"></a>区分流量控制和拥塞控制</h5><ul><li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li><li>实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</li></ul><h4 id="TCP黏包问题"><a href="#TCP黏包问题" class="headerlink" title="TCP黏包问题"></a>TCP黏包问题</h4><ul><li>原因：<br>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</li><li>解决：</li></ul><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li><li>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。</li><li>使用更加复杂的应用层协议。</li></ul><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>面向无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），对于一些控制需要在应用层解决。</p><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/009.png" width="500"> </div><br></p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ol><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li><li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ol><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><h3 id="socket原理"><a href="#socket原理" class="headerlink" title="socket原理"></a>socket原理</h3><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。<br>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h3 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><ul><li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>*连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ul><h3 id="创建TCP的socket流程"><a href="#创建TCP的socket流程" class="headerlink" title="创建TCP的socket流程"></a>创建TCP的socket流程</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul><li>创建socket： <code>int socket(int domain, int type, int protocol)</code>;</li><li>将socket绑定地址和端口号：<code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</code>;</li><li>监听：<code>int listen(int sockfd, int backlog)</code>;</li><li>接受连接：<code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)</code>;</li><li>读取数据：<code>ssize_t read(int fd, void *buf, size_t count)</code>;</li><li>关闭socket:<code>int close(int fd)</code>;</li></ul><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li>创建socket： <code>int socket(int domain, int type, int protocol)</code>;</li><li>连接：<code>int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen)</code>;</li><li>输入数据: <code>ssize_t write(int fd, const void *buf, size_t count)</code>;</li><li>关闭socket:<code>int close(int fd)</code>;</li></ul><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><p>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</p><h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h2><p>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。<br>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</p><h2 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。<br>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><h2 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h2><p>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：</p><ol><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ol><h2 id="超文本传送协议-HTTP"><a href="#超文本传送协议-HTTP" class="headerlink" title="超文本传送协议 HTTP"></a>超文本传送协议 HTTP</h2><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://github.com/huihut/interview#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" target="_blank" rel="external">https://github.com/huihut/interview#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C</a><br><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82" target="_blank" rel="external">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82</a><br><a href="https://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="external">https://blog.csdn.net/yechaodechuntian/article/details/25429143</a><br><a href="http://www.cnblogs.com/maybe2030/p/4781555.html#_label3" target="_blank" rel="external">http://www.cnblogs.com/maybe2030/p/4781555.html#_label3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近一直在看网络编程的东西，不管是看书、还是一些博客，或者是自己的一些编程，都觉得写的有点乱，有点杂。虽然这也比较符合网络方面的特点，零碎的知识点，有些人觉得重要就写上了，另一些就没有写。想到将来可能跟网络编程接触很多，也觉得最近的学习就是缺少一些总结。就在这里站在大佬的肩膀上整理一下吧。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux的fork使用</title>
    <link href="http://yoursite.com/15-Linux%E7%9A%84fork%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/15-Linux的fork使用/</id>
    <published>2018-03-15T14:48:01.000Z</published>
    <updated>2018-05-22T06:43:37.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux的fork使用"><a href="#Linux的fork使用" class="headerlink" title="Linux的fork使用"></a>Linux的fork使用</h2><blockquote><p>fork函数可以算是Linux里有点不好明白的函数了，调用一次，返回两次，虽然在平时的写法中，有基本固定的写法，但是有时候看起来还是有些让人头疼的。这里就把关于fork函数好好整理一下</p></blockquote><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><p><strong>功能</strong>：fork函数是从一个已经存在的进程中创建一个新的进程，新的进程称为子进程，原来的进程称为父进程。<br><strong>参数</strong>：无<br><strong>返回值</strong>：<br>成功：子进程中返回 0，父进程中返回子进程 ID。pid_t，为无符号整型。<br>失败：返回 -1。</p><p>失败的两个主要原因是：<br>1）当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN。<br>2）系统内存不足，这时 errno 的值被设置为 ENOMEM。</p><h3 id="测试的例子"><a href="#测试的例子" class="headerlink" title="测试的例子"></a>测试的例子</h3><p>下面是一个简单的创建子进程的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    int pid=1;</div><div class="line">    pid=fork();</div><div class="line">    if(0==pid)&#123; //pid为0，表示为子进程</div><div class="line">        cout&lt;&lt;&quot;我是子进程，我的pid是：&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    else if(pid&gt;0)&#123; //pid&gt;0表示父进程，此时返回值为子进程的pid</div><div class="line">        cout&lt;&lt;&quot;我是父进程，我的pid是&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    else &#123;  //fork 失败</div><div class="line">        cout&lt;&lt;&quot;fork失败&quot;&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面的例子可以看出，fork函数会有两个返回值，一个是在子进程中返回0,一个是在父进程中返回子进程的pid。因此在编程过程中，需要判断这个值的返回值来判断当前是父进程还是子进程。</p><h3 id="fork进程的原理"><a href="#fork进程的原理" class="headerlink" title="fork进程的原理"></a>fork进程的原理</h3><p>使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用 fork()函数的代价是很大的。<br><img src="http://blog-1252063226.cosbj.myqcloud.com/Linux/003001.jpg?raw=true" alt=""></p><h3 id="日常使用fork"><a href="#日常使用fork" class="headerlink" title="日常使用fork"></a>日常使用fork</h3><p>简单来说， 一个进程调用 fork() 函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p><p>实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在<strong>需要写入的时候才会进行，在此之前，只有以只读方式共享</strong>。</p><p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。一般来说，在 fork() 之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。</p><p>因此，在实际的使用过程中，一般都需要对fork()的返回值进行判断，看我们操作的是父进程还是子进程。</p><h4 id="一般的操作：同时创建多个子进程"><a href="#一般的操作：同时创建多个子进程" class="headerlink" title="一般的操作：同时创建多个子进程"></a>一般的操作：同时创建多个子进程</h4><p>不对的例子:父进程会生成 n(n+1)/2+1个子进程，N 为循环次数，本例中共有 7 个子进程， 但实际上只有 3 个是父进程产生的，其余都为子进程 fork（）出来的。父进程fork了3个进程，第一个子进程执行完之后又fork了2个进程，第2个子进程fork了1个进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    pid_t p1,p2;</div><div class="line">    int i;</div><div class="line">    int N=100;</div><div class="line">    for(int i=0;i&lt;=N;++i)&#123;</div><div class="line">        if((p1=fork())==0)&#123;</div><div class="line">            cout&lt;&lt;&quot;子进程1：&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">            //return 0;  //很关键的地方，为什么需要返回呢</div><div class="line">        &#125;</div><div class="line">        wait(p1,NULL,0); //父进程等待p1子进程执行后才能继续fork其他子进程</div><div class="line">        cout&lt;&lt;&quot;这是父进程: &quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>正确的使用Linux中的用fork()由一个父进程创建同时多个子进程 的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    pid_t p1,p2;</div><div class="line">    int i;</div><div class="line">    int N=100;</div><div class="line">    for(int i=0;i&lt;=N;++i)&#123;</div><div class="line">        status=fork();</div><div class="line">        if(status==0||status==1) break;//每次循环时，如果发现是子进程就直接从创建子进程的循环中跳出来，不让你进入循环，这样就保证了每次只有父进程来做循环创建子进程的工作</div><div class="line">        if (status == -1)</div><div class="line">        &#123;</div><div class="line">          //error</div><div class="line">        &#125;</div><div class="line">        else if (status == 0) //每个子进程都会执行的代码</div><div class="line"></div><div class="line">        &#123;</div><div class="line">          //sub process</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">          //parent process</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="无聊的问题"><a href="#无聊的问题" class="headerlink" title="无聊的问题"></a>无聊的问题</h3><p>1.下面的程序，不算 main这个进程自身，到底创建了多少个进程啊？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">   fork();</div><div class="line">   fork() &amp;&amp; fork() || fork();</div><div class="line">   fork();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>每fork一次就翻倍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  fork(); //2个</div><div class="line">   fork() &amp;&amp; fork() || fork();</div><div class="line">//A&amp;&amp;B||C</div><div class="line">//A为假，跳过B，判断C-----------------------2</div><div class="line">//A为真，判断B，若B为真，跳过C-----------1</div><div class="line">//若B为假，判断C ------------2</div><div class="line">   fork(); //2</div></pre></td></tr></table></figure></p><p>总共有：<br>2<em>(2+1+2)</em>2=20<br>不算自己的话有20-1=19个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux的fork使用&quot;&gt;&lt;a href=&quot;#Linux的fork使用&quot; class=&quot;headerlink&quot; title=&quot;Linux的fork使用&quot;&gt;&lt;/a&gt;Linux的fork使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;fork函数可以算是Linux里有
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-60-Permutation-Sequence</title>
    <link href="http://yoursite.com/06-%E5%88%B7%E9%A2%98/LeetCode-60-Permutation-Sequence/"/>
    <id>http://yoursite.com/06-刷题/LeetCode-60-Permutation-Sequence/</id>
    <published>2018-02-06T09:32:24.000Z</published>
    <updated>2018-04-27T02:28:48.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-60-Permutation-Sequence"><a href="#LeetCode-60-Permutation-Sequence" class="headerlink" title="LeetCode-60-Permutation-Sequence"></a>LeetCode-60-Permutation-Sequence</h3><blockquote><p>The set [1,2,3,…,n] contains a total of n! unique permutations.<br>By listing and labeling all of the permutations in order,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">We get the following sequence (ie, for n = 3):</div><div class="line"></div><div class="line">&quot;123&quot;</div><div class="line">&quot;132&quot;</div><div class="line">&quot;213&quot;</div><div class="line">&quot;231&quot;</div><div class="line">&quot;312&quot;</div><div class="line">&quot;321&quot;</div><div class="line">Given n and k, return the kth permutation sequence.</div></pre></td></tr></table></figure></p></blockquote><p>同样是排列 组合的问题，这次不需要打印所有的排列了，只需要按照排列的顺序打印出第k个，很显然，思路不会是列出所有的排列，然后找第k个打印出来是吧。</p><p>观察来看，以<code>1,2,3,4</code>为例，有<code>4*3*2*1=24</code>种排列，其中根据排列的顺序，按照第一个数字可以分为以下4种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1 * * *</div><div class="line"></div><div class="line">2 * * *</div><div class="line"></div><div class="line">3 1 2 4</div><div class="line">3 1 4 2</div><div class="line">3 2 1 4</div><div class="line">3 2 4 1</div><div class="line">3 4 1 2</div><div class="line">3 4 2 1</div><div class="line"></div><div class="line">4 * * *</div><div class="line">#### 方法一</div></pre></td></tr></table></figure></p><ul><li><p>第一个数<br>可以看出，当k=14时，第一个数字为3,这个是可以通过计算的。由于是从1开始的，取k=13；<code>index=k/(n-1)!=13/3!=2</code>，于是可以知道第一个数是3。那么第二个数字呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1+permutation(2,4)</div><div class="line">2+permutation(1,4)</div><div class="line">4+permutation(1,2)</div></pre></td></tr></table></figure></li><li><p>第二个数<br>可以根据:<code>k=k-index_pre*(n-1)!=13-2*3!=1</code>;<br><code>index=k/(n-2)!=1/(4-2)!=0</code>于是第二个数为1。</p></li><li>第三个数<br>接下来就只剩下2和4了，继续:<code>k=k-index_pre*(n-2)!=1-0*(4-2)!=1</code>,  <code>index=k/(n-3)!=1/(4-3)!=1</code>在此处表示为4.之后再确定最后一个:</li><li>第四个数<br><code>k=k-index_pre*(n-4)!=1-1*(4-4)=0</code>;<br><code>index=k/(n-4)!=0/(4-4)!=0</code> 故第四个数为2</li></ul><p>到了这里，思路就比较清晰了。我们需要做的是从第一个一直到最后一个的循环，每次选出一个数，但是还需要将该数从原来的数组中剔除掉，因为前面选过的后面就不能排列了。</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>其实原理差不多，也还是根据排列的规律。只不过算的方法不一样。</p><ol><li>j=i+k/(n-i)!;</li><li>删除s[j];</li><li>k=k%(n-i);</li><li>s[i]=s[j];<br>代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    string getPermutation(int n, int k) &#123;</div><div class="line">        if(n&lt;=0)</div><div class="line">            return &quot; &quot;;</div><div class="line">        int i,j,f=1;</div><div class="line">        string s(n,&apos;0&apos;);</div><div class="line">        for(i=1;i&lt;=n;i++)&#123;</div><div class="line">            f*=i;</div><div class="line">            s[i-1]+=i;</div><div class="line">        &#125;</div><div class="line">        for(i=0,k--;i&lt;n;++i)&#123;</div><div class="line">            f/=n-i;</div><div class="line">            j=i+k/f;</div><div class="line">            char c=s[j];</div><div class="line">            for(;j&gt;i;j--)</div><div class="line">                s[j]=s[j-1];</div><div class="line">            k%=f;</div><div class="line">            s[i]=c;</div><div class="line">        &#125;</div><div class="line">        return s;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-60-Permutation-Sequence&quot;&gt;&lt;a href=&quot;#LeetCode-60-Permutation-Sequence&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-60-Permutation-Sequ
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构技术-架构模式</title>
    <link href="http://yoursite.com/03-architecture-model-of-web-architecture/"/>
    <id>http://yoursite.com/03-architecture-model-of-web-architecture/</id>
    <published>2018-02-03T08:39:27.000Z</published>
    <updated>2018-05-13T13:47:16.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大型网站架构技术-架构模式"><a href="#大型网站架构技术-架构模式" class="headerlink" title="大型网站架构技术-架构模式"></a>大型网站架构技术-架构模式</h2><p>模式的关键在于模式的可重复性。<br><a id="more"></a></p><blockquote><p>每一个模式描述了一个在我们周围不断变化重复发生的问题及该问题解决方案的核心。这样就能一次次的使用该方案而不必做重复的工作。</p></blockquote><p>这是经过很多个实践，被很多网站重复使用而逐渐形成大型网站架构模式：</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>将系统再横向维度上切成几个部分，每个部分负责一部分相对单一的职责。就好比平时一份工作比较多的时候，团队中大家各自负责自己擅长的那一部分。大型网站中一般分为三层：</p><ul><li>应用层：负责具体业务和视图展示。</li><li>服务层：为应用层提供服务支持。</li><li>数据层：提供数据存储访问服务。如数据库、缓存、文件、搜索引擎等。<br>需要注意的是：这个分层是逻辑的，并不一定要部署在不同的服务器上，可能会根据业务调整。  </li></ul><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>对业务进行横向切分。比如应用层：分为购物、论坛、搜索等。  </p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>一台服务器解决不了的时候，就采用分布式解决一下。<br>分为：分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算。  </p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>使用分布式已经将分层和分割后的模块独立部署，但是对于用户集中访问的模块，可能还需要将独立部署的服务器集群化（多台服务器部署相同的应用构成一个集群），再通过一个负载均衡服务器对外提供服务。  </p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存是改善软件性能的第一手段。</p><ul><li>CDN：讲内容部署在离用户最近的网络服务商，用户请求的时候，可以直接访问网络服务商缓存的静态资源，所以会很快。</li><li>反向代理：用户请求到网站的数据中心时，最先访问的是反向代理服务器，这里会缓存网站的静态资源。</li><li>本地缓存：应用服务器本地缓存的热点数据，可以在本机内存中直接访问，不需要访问数据库。</li><li>分布式缓存：数据量非常庞大时，需要的内存不是单机能承受的。因此还需要分布式缓存    </li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步进行协作。<br>在单一服务器内部：采用<strong>多线程共享队列</strong>的方式实现异步。在分布式系统中：多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看做内存的分布式部署。</p><p>分布式消息队列的特性：网站扩展新功能便利，提高系统可用性，加快网站响应速度，消除并发访问高峰。  </p><h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>备份嘛，较少的机器可能坏的时间不长，但是小概率时间试验的次数过多的话就基本是必然事件了。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>主要集中在运维方面，包括：发布过程自动化、自动化代码管理、自动化测试、自动化安全监测、自动化部署。对于运行中：自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降级、自动化分配资源。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>密码和手机验证码；加密；网站验证码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大型网站架构技术-架构模式&quot;&gt;&lt;a href=&quot;#大型网站架构技术-架构模式&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构技术-架构模式&quot;&gt;&lt;/a&gt;大型网站架构技术-架构模式&lt;/h2&gt;&lt;p&gt;模式的关键在于模式的可重复性。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="大型网站技术" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构技术-演化</title>
    <link href="http://yoursite.com/03-evolution-of-webArchitecture/"/>
    <id>http://yoursite.com/03-evolution-of-webArchitecture/</id>
    <published>2018-02-03T05:43:26.000Z</published>
    <updated>2018-05-13T13:53:47.793Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="大型网站架构技术-演化"><a href="#大型网站架构技术-演化" class="headerlink" title="大型网站架构技术-演化"></a>大型网站架构技术-演化</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>高并发、大流量</li><li>高可用</li><li>海量数据</li><li>用户分布广泛、网络情况复杂</li><li>安全环境恶劣：易受攻击</li><li>需求变化快、发布频繁：为了快速适应市场</li><li>渐进式发展：逐渐进步发展</li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><h3 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h3><p>应用程序、数据库、文件等所有资源都在一台服务器上。一般是在一台廉价的服务器上采用LAMP这种免费资源。</p><h3 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h3><p>采用三台服务器分别承担自己的角色。</p><h3 id="使用缓存改善网站的性能"><a href="#使用缓存改善网站的性能" class="headerlink" title="使用缓存改善网站的性能"></a>使用缓存改善网站的性能</h3><p>二八定律：80%的业务访问集中在20%的数据上，为了减少数据库的访问压力，可以将一些数据放到缓存服务器上，这样可以提高整个网站的数据访问速度。<br>一般分为两种：</p><ul><li>缓存在应用服务器上的本地缓存：访问速度快，但缓存的数据有限；</li><li>缓存在专门的分布式缓存服务器上的远程缓存：可以采用分布式缓存。<h3 id="采用应用服务器改善网站并发处理能力"><a href="#采用应用服务器改善网站并发处理能力" class="headerlink" title="采用应用服务器改善网站并发处理能力"></a>采用应用服务器改善网站并发处理能力</h3>当应用服务器处理不了较多的并发请求时，可以增加一台服务器分担原有的服务器的访问，在前面加一个负载均衡服务器。<h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3>虽然采用了缓存，但有一些<strong>读操作和一部分写操作</strong>还是会落到数据库上。一般采用主从备份的数据库，写操作可以在主数据库中进行，读操作在从数据库中读取。<h3 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h3>加速用户的访问。基本原理都是缓存，CDN是部署在网络提供商的机房，反向代理部署在网站的中心机房。对于反向代理，用户首先访问的是反向代理服务器，如果反向代理服务器中缓存着资源，就直接返回给用户。<h3 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h3>持续增长的业务，单一的服务器满足不了要求的时候，一头牛拉不动的时候，不要企图换一头更厉害的牛，而是考虑再加一头牛一起拉。<h3 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h3>网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，需要采用一些非关系数据库技术和非数据库查询技术如搜索引擎。<h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3>分而治之<h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;大型网站架构技术-演化&quot;&gt;&lt;a href=&quot;#大型网站架构技术-演化&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构技术-演化&quot;&gt;&lt;/a&gt;大型网站架构技术-演化&lt;/h1&gt;&lt;h2 id=&quot;特点&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="大型网站技术" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-56and57-Merge-Intervals</title>
    <link href="http://yoursite.com/30-%E5%88%B7%E9%A2%98/LeetCode-56-Merge-Intervals/"/>
    <id>http://yoursite.com/30-刷题/LeetCode-56-Merge-Intervals/</id>
    <published>2018-01-30T08:00:00.000Z</published>
    <updated>2018-04-27T02:28:48.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-56-Merge-Intervals"><a href="#LeetCode-56-Merge-Intervals" class="headerlink" title="LeetCode-56-Merge-Intervals"></a>LeetCode-56-Merge-Intervals</h3><blockquote><p>Given a collection of intervals, merge all overlapping intervals.<br>For example,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Given [1,3],[2,6],[8,10],[15,18],</div><div class="line">return [1,6],[8,10],[15,18].</div></pre></td></tr></table></figure></p></blockquote><p>如例子中所示，每个数组的前后分别表示开始和结束，工作是合并有重叠的数组。例如，由于[1,3]和[2,6]有重叠，故直接改为[1,6]后输出。<br>想法还是比较简单的，因为输入的并不一定是给好的按照开始，所以需要先对输入以开始的值排序。首先在结果数组中写入第一个，只有遍历进行判断，分为两种情况：</p><ol><li>如果某一interval的开始比结果数组中的结尾要大，显然不会有重叠，直接写入到结果数组中即可；</li><li>某一interval的开始比结果数组中的结尾要大，必然有重叠，此时还需要判断结束位置的大小。</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for an interval.</div><div class="line"> * struct Interval &#123;</div><div class="line"> *     int start;</div><div class="line"> *     int end;</div><div class="line"> *     Interval() : start(0), end(0) &#123;&#125;</div><div class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</div><div class="line">        vector&lt;Interval&gt; res;</div><div class="line">        if(intervals.size()&lt;=0)</div><div class="line">            return res;</div><div class="line">        sort(intervals.begin(),intervals.end(),[](Interval a,Interval b)&#123;return a.start&lt;b.start;&#125;);</div><div class="line">        res.push_back(intervals[0]);</div><div class="line">        for(int i=1;i&lt;intervals.size();++i)&#123;</div><div class="line">            if(res.back().end&lt;intervals[i].start) res.push_back(intervals[i]);</div><div class="line">            else&#123;</div><div class="line">                res.back().end=max(res.back().end,intervals[i].end);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57-Insert-Interval"></a>57-Insert-Interval</h3><blockquote><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).<br>You may assume that the intervals were initially sorted according to their start times.</p></blockquote><p>题目改为向一个已经重叠的数组中加入新加入一个。需要做的是判断所处的位置，插入进去后还要删掉，值得注意的是这个删掉值的时候，vector的迭代器会发生变化，即有些会失效，所以最好的做法是，先插入，把需要的插入都插入之后再删除。</p><p>另外还有一个值得注意的是，排序搜索的谓语，使用的是<code>a.end&lt;b.start</code>，而不是之前的<code>a.start&lt;b.start</code> ，原因是需要找到一个范围，将newINterval夹在中间的一个范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for an interval.</div><div class="line"> * struct Interval &#123;</div><div class="line"> *     int start;</div><div class="line"> *     int end;</div><div class="line"> *     Interval() : start(0), end(0) &#123;&#125;</div><div class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</div><div class="line">        if(intervals.size()&lt;=0)&#123;</div><div class="line">            intervals.push_back(newInterval);</div><div class="line">            return intervals;</div><div class="line">        &#125;</div><div class="line">        auto range=equal_range(intervals.begin(),intervals.end(),newInterval,[](Interval a,Interval b)&#123;return a.end&lt;b.start;&#125;);</div><div class="line">        auto iter1=range.first,iter2=range.second;</div><div class="line">        if(iter1==iter2)</div><div class="line">            intervals.insert(iter1,newInterval);</div><div class="line">        else&#123;</div><div class="line">            iter2--;</div><div class="line">            iter2-&gt;start=min(newInterval.start,iter1-&gt;start);</div><div class="line">            iter2-&gt;end=max(newInterval.end,iter2-&gt;end);</div><div class="line">            intervals.erase(iter1,iter2);</div><div class="line">        &#125;</div><div class="line">        return intervals;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-56-Merge-Intervals&quot;&gt;&lt;a href=&quot;#LeetCode-56-Merge-Intervals&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-56-Merge-Intervals&quot;&gt;&lt;/a&gt;LeetC
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-55-Jump-Game</title>
    <link href="http://yoursite.com/30-%E5%88%B7%E9%A2%98/LeetCode-55-Jump-Game/"/>
    <id>http://yoursite.com/30-刷题/LeetCode-55-Jump-Game/</id>
    <published>2018-01-30T07:39:55.000Z</published>
    <updated>2018-04-27T02:28:48.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-55-Jump-Game"><a href="#LeetCode-55-Jump-Game" class="headerlink" title="LeetCode-55-Jump-Game"></a>LeetCode-55-Jump-Game</h3><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.</p></blockquote><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = [2,3,1,1,4], return true.</div><div class="line"></div><div class="line">A = [3,2,1,0,4], return false.</div></pre></td></tr></table></figure></p><p>由题可知，数组的位置表示从该位置可以像前跳的步数，看最终能否跳到结尾。乍一看，这像是一个动态规划的问题，dp数组内存储每一个位置能够走的最远的位置，但是仔细一想，又是没有必要的，因为最终的目的不是为了判断哪一个位置能走的更远，而是能否到达最后一个位置。<br>能到达最后一个位置的必要条件，显然一个就是能从某一位置继续往前走，而不会断。例如：<code>[3,2,1,0,4]</code>，我们都能走到第4个位置，但是却无法继续往前走，故到不了最后一个。所以代码可以做一个判断。<br>另一个需要考虑的问题是：在从前往后遍历的过程中，维护哪一个变量？显然这个变量记录的是我们能走的最远的距离，如果这个距离走的更远就更新，直到不能继续往前走，此时判断能否到终点。</p><p>贴上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int i=0;</div><div class="line">        for(int reach=0;i&lt;nums.size()&amp;&amp;i&lt;=reach;++i)</div><div class="line">            reach=max(reach,i+nums[i]);</div><div class="line">        return i==nums.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-55-Jump-Game&quot;&gt;&lt;a href=&quot;#LeetCode-55-Jump-Game&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-55-Jump-Game&quot;&gt;&lt;/a&gt;LeetCode-55-Jump-Game&lt;/
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-53-Maximum-Subarray</title>
    <link href="http://yoursite.com/26-%E5%88%B7%E9%A2%98/LeetCode-53-Maximum-Subarray/"/>
    <id>http://yoursite.com/26-刷题/LeetCode-53-Maximum-Subarray/</id>
    <published>2018-01-26T09:57:03.000Z</published>
    <updated>2018-04-27T02:28:48.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-53-Maximum-Subarray"><a href="#LeetCode-53-Maximum-Subarray" class="headerlink" title="LeetCode-53-Maximum-Subarray"></a>LeetCode-53-Maximum-Subarray</h2><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.<br>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p></blockquote><p>最长子序列，又是一个动态规划的问题，关于动态规划，我们最主要的是要维护DP数组，这个问题以前还有点不理解，感觉主要的还是思想，只要知道这是一个动态规划的问题，解决动态规划的一般方法掌握了，其他的就都是细节了。</p><p>最近刷算法题，不得不想到的是以前的数学，数学是逻辑性可能更强的东西，尚且需要多做练习才行，何况算法了。当然现在慢慢的感觉就是，以前看到很多题完全没有头绪，现在很多大概是能分清是想考啥了，也会想着主动去选择相应的数据结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;int&gt; dp(nums.size(),0);</div><div class="line">        dp[0]=nums[0];</div><div class="line">        int res=dp[0];</div><div class="line">        for(int i=1;i&lt;nums.size();++i)&#123;</div><div class="line">            dp[i]=nums[i]+(dp[i-1]&gt;0?dp[i-1]:0);</div><div class="line">            res=max(dp[i],res);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LeetCode-53-Maximum-Subarray&quot;&gt;&lt;a href=&quot;#LeetCode-53-Maximum-Subarray&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-53-Maximum-Subarray&quot;&gt;&lt;/a&gt;Le
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-52-N-Queens-II</title>
    <link href="http://yoursite.com/26-%E5%88%B7%E9%A2%98/LeetCode-52-N-Queens-II/"/>
    <id>http://yoursite.com/26-刷题/LeetCode-52-N-Queens-II/</id>
    <published>2018-01-26T09:00:24.000Z</published>
    <updated>2018-04-27T02:28:48.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-52-N-Queens-II"><a href="#LeetCode-52-N-Queens-II" class="headerlink" title="LeetCode-52-N-Queens-II"></a>LeetCode-52-N-Queens-II</h3><blockquote><p>Follow up for N-Queens problem.<br>Now, instead outputting board configurations, return the total number of distinct solutions.</p></blockquote><p>只返回N皇后问题结果的种数。<br>因此不需要每一个字符串置位了，只需要判断一个位置的横竖，斜45度和斜135度方向的值即可。依然采用递归的方式，这里需要注意的是，由于是对列递归，所以需要考虑的是行，斜45度，斜135度，本来是要维护一个一维数组和两个二维数组，但是想到二维数组的特征，可以改为维护三个一维数组，这两个一维数组保存的是将二维数组展开的信息。甚至是一波操作改为共维护两个一维数组也可以。<br>接下来是代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int totalNQueens(int n) &#123;</div><div class="line">        vector&lt;int&gt; rows(n),d1(2*n-1),d2(2*n-1);</div><div class="line">        return find(n,n,0,rows,d1,d2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int find(int n,int left,int i,vector&lt;int&gt;&amp; rows,vector&lt;int&gt;&amp; d1,vector&lt;int&gt;&amp; d2)&#123;</div><div class="line">        if(left==0)</div><div class="line">            return 1;</div><div class="line">        int j,sum=0;</div><div class="line">        for(j=0;j&lt;n;++j)&#123;</div><div class="line">            if(rows[j]||d1[i+j]||d2[n-1+i-j])</div><div class="line">                continue;</div><div class="line">            rows[j]=d1[i+j]=d2[n-1+i-j]=1;</div><div class="line">            sum+=find(n,left-1,i+1,rows,d1,d2);</div><div class="line">            rows[j]=d1[i+j]=d2[n-1+i-j]=0;</div><div class="line">        &#125;</div><div class="line">        return sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>看了一下别人的好像确实快一点，毕竟0ms啊，也贴一下别人的代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int totalNQueens(int n) &#123;</div><div class="line">        bool flag[5*n] = &#123;false&#125;;</div><div class="line">        int num = 0;</div><div class="line">        dfs(num,flag,0,n);</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void dfs(int&amp; num, bool* flag, int row, int n)&#123;</div><div class="line">        if(row == n)&#123;</div><div class="line">            ++num;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i = 0; i&lt;n;i++)&#123;</div><div class="line">            if(!flag[i] &amp;&amp; !flag[row+i+n] &amp;&amp; !flag[4*n + row - i])&#123;</div><div class="line">                flag[i] = 1;</div><div class="line">                flag[row+i+n] = 1;</div><div class="line">                flag[4*n + row - i] = 1;</div><div class="line">                dfs(num,flag,row+1,n);</div><div class="line">                flag[i] = 0;</div><div class="line">                flag[row+i+n] = 0;</div><div class="line">                flag[4*n + row - i] = 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h4><p><a href="https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand" target="_blank" rel="external">https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-52-N-Queens-II&quot;&gt;&lt;a href=&quot;#LeetCode-52-N-Queens-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-52-N-Queens-II&quot;&gt;&lt;/a&gt;LeetCode-52-N-Que
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-51-N-Queens</title>
    <link href="http://yoursite.com/26-%E5%88%B7%E9%A2%98/LeetCode-51-N-Queens/"/>
    <id>http://yoursite.com/26-刷题/LeetCode-51-N-Queens/</id>
    <published>2018-01-26T02:12:49.000Z</published>
    <updated>2018-04-27T02:28:48.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-51-N-Queens"><a href="#LeetCode-51-N-Queens" class="headerlink" title="LeetCode-51-N-Queens"></a>LeetCode-51-N-Queens</h3><p>经典的N皇后问题，重点是全排列的问题，但是这里由于N皇后的不重复行、列、斜的要求，在排列的过程中，比如从行开始排列，只能保证同行不重复，所以需要引入isValid函数。通过判断列，左斜、右斜是否重复。</p><p>需要注意的是：关于全排列递归的写法，要更加熟练掌握才行，并且能完全理解，能够在不同的情况中灵活运用。其基本思想还是：固定前面的某个数字，不短的对后面进行交换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isValid(vector&lt;string&gt;&amp; queen, int row,int col,int n)&#123;</div><div class="line">        for(int i=0;i&lt;row;++i)&#123;</div><div class="line">            if(queen[i][col]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;--i,--j)&#123;</div><div class="line">            if(queen[i][j]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;--i,++j)&#123;</div><div class="line">            if(queen[i][j]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    void recurse(vector&lt;string&gt;&amp; queen,vector&lt;vector&lt;string&gt;&gt;&amp; res,int row,int n)&#123;</div><div class="line">        if(row==n)&#123;</div><div class="line">            res.push_back(queen);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int col=0;col!=n;++col)&#123;</div><div class="line">            if(isValid(queen,row,col,n))&#123;</div><div class="line">                queen[row][col]=&apos;Q&apos;;</div><div class="line">                recurse(queen,res,row+1,n);</div><div class="line">                queen[row][col]=&apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">        vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">        vector&lt;string&gt; queen(n,string(n,&apos;.&apos;));</div><div class="line">        recurse(queen,res,0,n);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-51-N-Queens&quot;&gt;&lt;a href=&quot;#LeetCode-51-N-Queens&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-51-N-Queens&quot;&gt;&lt;/a&gt;LeetCode-51-N-Queens&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-49-Group-Anagrams</title>
    <link href="http://yoursite.com/25-%E5%88%B7%E9%A2%98/LeetCode-49-Group-Anagrams/"/>
    <id>http://yoursite.com/25-刷题/LeetCode-49-Group-Anagrams/</id>
    <published>2018-01-25T13:44:37.000Z</published>
    <updated>2018-04-27T02:28:48.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-49-Group-Anagrams"><a href="#LeetCode-49-Group-Anagrams" class="headerlink" title="LeetCode-49-Group-Anagrams"></a>LeetCode-49-Group-Anagrams</h3><blockquote><p>Given an array of strings, group anagrams together.<br>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],</p></blockquote><p>Return:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],</div><div class="line">  [&quot;nat&quot;,&quot;tan&quot;],</div><div class="line">  [&quot;bat&quot;]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>输入一个字符串数组，输出的是：将相同字符的字符串放在一个数组的二维数组。相同字符的处理，基本就是要对字符串排序的。然后需要考虑的就是排序好的那一个字符串怎么存的问题。用的数据结构是map，string为键，对应的值是一个set或者是一个vector，存放满足要求的string，之后再用这个初始化结果数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class="line">        unordered_map&lt;string,multiset&lt;string&gt;&gt; map_str;</div><div class="line">        for(string s:strs)&#123;</div><div class="line">            string t=s;</div><div class="line">            sort(t.begin(),t.end());</div><div class="line">            map_str[t].insert(s);</div><div class="line">        &#125;</div><div class="line">        vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">        for(auto temp:map_str)&#123;</div><div class="line">            vector&lt;string&gt; vec_str_temp(temp.second.begin(),temp.second.end());</div><div class="line">            res.push_back(vec_str_temp);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>后来发现用vector其实要好一些。只是别人这么写的，时间竟然要短一点，毕竟是用vector初始化vector？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-49-Group-Anagrams&quot;&gt;&lt;a href=&quot;#LeetCode-49-Group-Anagrams&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-49-Group-Anagrams&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-48-Rotate-Image</title>
    <link href="http://yoursite.com/25-%E5%88%B7%E9%A2%98/Leetcode-48-Rotate-Image/"/>
    <id>http://yoursite.com/25-刷题/Leetcode-48-Rotate-Image/</id>
    <published>2018-01-25T12:44:32.000Z</published>
    <updated>2018-04-27T02:28:47.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Leetcode-48-Rotate-Image"><a href="#Leetcode-48-Rotate-Image" class="headerlink" title="Leetcode-48-Rotate-Image"></a>Leetcode-48-Rotate-Image</h3><blockquote><p>ou are given an n x n 2D matrix representing an image.<br>Rotate the image by 90 degrees (clockwise).<br>Note:<br>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p></blockquote><p>Example :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [4,5,6],</div><div class="line">  [7,8,9]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [7,4,1],</div><div class="line">  [8,5,2],</div><div class="line">  [9,6,3]</div><div class="line">]</div><div class="line"></div><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [ 5, 1, 9,11],</div><div class="line">  [ 2, 4, 8,10],</div><div class="line">  [13, 3, 6, 7],</div><div class="line">  [15,14,12,16]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [15,13, 2, 5],</div><div class="line">  [14, 3, 4, 1],</div><div class="line">  [12, 6, 8, 9],</div><div class="line">  [16, 7,10,11]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>这个乍一看觉得不难，但是写的时候又不知道怎么回事，其实旋转，对于我们写程序来说，其实就是不停的调换位置，但是怎么调换是个问题。</p><p>观察发现，第一个矩阵，最角上的四个1,3,7,9。转完之后，还是这四个数字，只不过是位置变了，接下来这样的四个是：2,4,6,8.最后一个5.再看一下4x4的其实也差不多。</p><p>所以想法就是直接每次四个数字进行换，换三次，就能换回来，然后进行下一次调换。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class="line">        if(matrix.size()&lt;=0)</div><div class="line">            return;</div><div class="line">        int a=0,b=matrix.size()-1;</div><div class="line">        while(a&lt;b)&#123;</div><div class="line">            for(int i=0;i&lt;b-a;++i)&#123;</div><div class="line">                swap(matrix[a][a+i],matrix[a+i][b]);</div><div class="line">                swap(matrix[a][a+i],matrix[b][b-i]);</div><div class="line">                swap(matrix[a][a+i],matrix[b-i][a]);</div><div class="line">            &#125;</div><div class="line">            ++a;</div><div class="line">            --b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Leetcode-48-Rotate-Image&quot;&gt;&lt;a href=&quot;#Leetcode-48-Rotate-Image&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-48-Rotate-Image&quot;&gt;&lt;/a&gt;Leetcode-48-Ro
      
    
    </summary>
    
    
  </entry>
  
</feed>
