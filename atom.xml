<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mianhk</title>
  
  <subtitle>这个人很懒，动不动就不想写</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yuguocong.cn/"/>
  <updated>2021-09-25T04:04:54.901Z</updated>
  <id>http://www.yuguocong.cn/</id>
  
  <author>
    <name>mianhk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kubernetes之webhook</title>
    <link href="http://www.yuguocong.cn/2021/09/25/kubernetes/1-k8s-webhook/k8s-webhook/"/>
    <id>http://www.yuguocong.cn/2021/09/25/kubernetes/1-k8s-webhook/k8s-webhook/</id>
    <published>2021-09-25T11:42:11.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>  <p><strong>Admission Webhook</strong>调用图</p><p><img src="img1-20210925120413030.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;  
&lt;p&gt;&lt;strong&gt;Admission Webhook&lt;/strong&gt;调用图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img1-20210925120413030.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="k8s" scheme="http://www.yuguocong.cn/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://www.yuguocong.cn/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>2020年总结</title>
    <link href="http://www.yuguocong.cn/2020/12/26/2020_summary/"/>
    <id>http://www.yuguocong.cn/2020/12/26/2020_summary/</id>
    <published>2020-12-26T09:30:02.000Z</published>
    <updated>2021-09-25T04:04:54.893Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020，仿佛还是刚刚开始，不过已经快要过完了。三月份一到周末就跟家人一起去爬山的日子感觉就在不久前，现在也已12月了，口罩从冬天戴到了冬天，感觉都已经记不起原来从没戴过口罩的生活是什么样的了。疫情影响着生活的大小方面，不过在此还是总结自己吧。</p></blockquote><a id="more"></a>  <h1 id="工作">工作</h1><p>首先在工作上，整体给自己打个70分吧。在整体完成方面觉得还不错了，做的事情也算是比较多了：</p><ul><li><strong>前端</strong>：由于去年用Python写了个系统，需要一些前端的展示，但是组内唯一的前端同学又排期不过来，于是就直接撸起了vue。甚至在Q2的时候，昨晚本身系统的前端后，还帮忙做了很多其他的需求。从最开始还没接触过js到后面开始已经踩了很多坑了，但是在写代码方面还不是很熟练，后续如果有时间希望还是能整体补一补。</li><li><strong>日常项目</strong>：主要是围绕MySQL数据库的一些项目，来保证备份的数据、系统的高可用、数据传输等方面，技术栈用的go，不过因为项目数量比较多，虽然能够完成项目的任务，但是在项目的深层理解上还不够。在数据传输项目中，基本是由自己一个人主导，目前进展也相对比较顺利。</li><li><strong>MySQL运维</strong>： 从年初接了100个实例的MySQL运维，到年底前又因为开发任务比较重把MySQL集群交接给新人。从开始接触时候的啥都不会，到把90%实例完成版本升级，交接后带着新人处理日常问题。这一点还是想给自己点个赞的，毕竟虽然这一年时间都有运维工作，但是在其他方面也都没落下过。</li><li><strong>TiDB</strong>：由于很多业务量的增长，对TiDB的需求也有增加，下半年开始也有一部分工作重心在TiDB。目前主要工作是接入到内部系统中，在这一部分也基本是自己主导。也一直在学习TiDB相关的内容，中间还参加了一个TiDB的性能竞赛，拿了第三名。</li></ul><p>回头看这些，工作量还是很饱满，以及在日常的工作中，也发现了自己的一些问题：</p><ul><li><p><strong>专注</strong>：工作量比较饱满，但是工作深度不够。不管是作为工具写了一两个月的前端，还是搭着做了一年的MySQL运维，在深度方面都有些欠缺，对于前端来说，可能后面也不一定会用到，但是基础是可以看看的。而对于MySQL，是很多工作的基础，需要随时补。另外后面也应该在多项工作中，找到专注的点，把这些点优先做好。</p></li><li><p><strong>沟通表达能力</strong>： 其实以前并没有觉得自己表达的不好，可能是以前上学的时候也没往这上面说。现在工作期间，沟通交流基本上是每天都有，如何能够更好的表达自己，更有效的沟通来提高工作效率，是重要的技能。</p></li></ul><h1 id="学习">学习</h1><p>学习方面，今年真的是有点惭愧了。</p><ul><li><strong>读书</strong>：真的是一本都没有完整的读完，一本《经济学原理》教材看了一半，觉得讲的很好，但就是没看完。</li><li><strong>编程方面</strong>： 主要还是在学在用Go，前端方面也没有系统的去学习，其实是学习了一点吧，但是又因为其他事情落下了。</li></ul><h1 id="生活">生活</h1><h2 id="重要事件"><strong>重要事件</strong></h2><p>今年最重要的事情就是新冠疫情了，而且已经持续了一年，现在到了年底，又开始蠢蠢欲动了。不知道什么时候能开始成为大家的回忆了。</p><p>买房。从毕业开始就在酝酿，今年来上班已经是五月了，来之后开始关注，到7月底买，算是一件大事了。</p><ul><li><strong>娱乐</strong>：能算是娱乐的比较多了。</li><li><strong>旅游</strong>：除了年初去北京出差学习回来后，都没出过省了</li><li><strong>体重</strong>： 继续保重中</li></ul><h1 id="hello-2021">Hello，2021</h1><h2 id="工作-v2">工作</h2><p><strong>专注、增加深度</strong>：在把事情做好的同时，能够更多的思考，而不是停留在表面。</p><p><strong>提高沟通表达能力</strong>： 说话慢一点；说话是为了让别人听明白，而不是自己明白；时常注重梳理好逻辑，不至于在讨论问题时被带偏</p><h2 id="学习-v2">学习</h2><p><strong>技术能力</strong>： 没啥可说的，一直都是最重要的。但是毕竟时间有限，优先做好什么。</p><p><strong>看书</strong>：每年都给自己一点目标，但是好像都没有完成，今年还是继续定一下，继续看自己的脸皮：12本吧，一个月一本了。</p><p><strong>博客</strong>：坚持，每月一篇；重在输出，而不是记录。学习过的内容，能够按照自己的想法写出来，这样才是更好的掌握。</p><h2 id="生活-v2">生活</h2><p><strong>慢一点</strong>：关注身边有趣有意义的事情，记录一些重要的事情和节点。</p><p><strong>体重</strong>：减重10%？</p><p><strong>旅游</strong>：疫情如果允许就出去玩一次。</p><p><strong>娱乐</strong>：注重半衰期更长的娱乐（运动、电影、纪录片之类），杜绝无营养的短视频和无聊的游戏（浪费时间又无法从中体验到该有的愉悦感，比如最近开始捡起来玩的dota2。。）</p><p><strong>其他折腾</strong>： 功利的对待自己的时间。</p><p>最后，2021年，继续加油，最后附上一张小豆的照片吧。</p><p><img src="https://blog-1252063226.cos.ap-beijing.myqcloud.com/img/image-20201228003035033.png" alt="image-20201228003035033"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2020，仿佛还是刚刚开始，不过已经快要过完了。三月份一到周末就跟家人一起去爬山的日子感觉就在不久前，现在也已12月了，口罩从冬天戴到了冬天，感觉都已经记不起原来从没戴过口罩的生活是什么样的了。疫情影响着生活的大小方面，不过在此还是总结自己吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活" scheme="http://www.yuguocong.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://www.yuguocong.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="日常总结" scheme="http://www.yuguocong.cn/tags/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】Binlog详解</title>
    <link href="http://www.yuguocong.cn/2020/11/05/binlog/"/>
    <id>http://www.yuguocong.cn/2020/11/05/binlog/</id>
    <published>2020-11-05T12:04:46.000Z</published>
    <updated>2021-09-25T04:04:54.897Z</updated>
    
    <content type="html"><![CDATA[<p>Binlog作为MySQL重要的灵魂之一，在MySQL的主从同步、问题定位、数据恢复、增量备份等都发挥着重要的作用。也是MySQL多年来被大家信任的原因之一，同时Binlog也随着MySQL的流行被大家熟知，不过对于很多人来说，只是知道Binlog记录MySQL操作的功能，以及做过简单的解析查看操作SQL，却并没有深入。最近与Binlog交流比较多，就正好梳理下。</p><a id="more"></a>  <h1 id="什么是binlog">什么是Binlog</h1><p>Binlog是MySQL server层的日志，记录MySQL的数据更新或潜在更新的SQL语句。Binlog是与innodb引擎中的undo log和redo log不一样的</p><h2 id="binlog作用">Binlog作用</h2><p>binlog的作用主要包括：</p><ul><li>主从同步：在一个MySQL集群中，从库通过拉取主库的Binlog，在本地进行回放执行，从而同步主库的数据更新，达到主从同步的目的。主从同步也是一般生产环境MySQL服务高可用的必要保障。</li><li>数据恢复：作为一个数据存储工具，可能存在写错数据的情况，需要回滚到某一时间点，可以通过解析Binlog，通过binlog2sql等工具，来闪回到指定的时间点。</li><li>增量备份：一般生产环境都会对MySQL数据进行定期的备份，以应对MySQL集群的快速扩容、版本升级等需求，全量备份耗时较长，且占用空间较多，因此一般采用全量备份+增量备份的方式对集群数据进行备份，其中增量备份备份的就是Binlog。</li><li>问题定位：由于所有的数据更新都会记录在Binlog中，所以Binlog也是解决问题的一把好手，通过分析Binlog，有时是快速解决问题的途径。</li></ul><h2 id="binlog格式">Binlog格式</h2><p>Binlog格式分为三种：statement、row、mixed</p><ul><li>statement：记录数据更新的SQL。意思是binlog记录数据更新的语句，优点是节省binlog日志量，减少磁盘占用（只是在部分时候）。这种方式很简单，但是会存在问题，比如SQL中出现了now()等函数，还需要保存语句执行时候的一些信息，才能使语句在回放的时候不至于数据不一致。但是仍然有一些函数无法被复制。</li><li>row：记录数据变更的行记录。记录每一行被更改的记录，这样就能保证函数的执行也能被完全的记录，问题是，如果某条语句更新的行数较多（如变更表结构），会产生较多的Binlog，日志量增长很大。</li><li>mixed：是statement和row格式的一种折中，结合了两者的优点。会自动切换采用row还是statement格式，但是还是会存在数据不一致的问题。级联复制在特殊情况下会binlog丢失。</li></ul><p>在实际生产环境中，为了保证数据完全一致，还是会采用row格式的binlog，毕竟作为底层软件，首先应该保证正确，其次才是节省。</p><h2 id="binlog何时写入">Binlog何时写入</h2><p>Binlog在事务commit前才会写入（由于innodb的两阶段提交，会先写Binlog再写redo log）。</p><p>同时binlog的写入会通过参数<code>sync_binlog</code> 控制，如果设置为0，则表示不会主动控制Binlog的刷新，由文件系统控制缓存的刷新，设为0安全，当MySQL异常重启会丢失缓存中的事务。一般生产环境主库会设置为1，保证每次事务都能被写到磁盘。</p><h2 id="与其他日志的区别">与其他日志的区别</h2><h1 id="使用binlog">使用Binlog</h1><h2 id="mysql配置">MySQL配置</h2><p>Binlog的配置有一下几个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log_bin &#x3D; on   # 开启binlog</span><br><span class="line">binlog_format &#x3D; row  # binlog格式为row </span><br><span class="line">log_bin &#x3D; &#x2F;home&#x2F;work&#x2F;mysql&#x2F;log&#x2F;mysql-bin.log # binlog 位置</span><br><span class="line">expire_logs_days &#x3D; 7  # binlog清理周期7天</span><br><span class="line">max_binlog_size &#x3D; 1G  # binlog文件大小</span><br><span class="line">sync_binlog &#x3D; 1   # binlog刷盘控制，为1表示每次事务都会刷盘</span><br><span class="line">max_binlog_cache_size &#x3D; 2147483648  # 最大binlog缓存大小，如果一个事务的binlog超过此大小，会报错</span><br><span class="line">binlog_rows_query_log_events &#x3D; on  # 展示SQL</span><br></pre></td></tr></table></figure><h2 id="查看binlog">查看Binlog</h2><h3 id="查看binlog信息">查看Binlog信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 查看现有的binlog文件</span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 | 142554153 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line"></span><br><span class="line"># 查看当前binlog位点</span><br><span class="line">mysql&gt; show master status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             File: mysql-bin.000001</span><br><span class="line">         Position: 142556517</span><br><span class="line">     Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line">Executed_Gtid_Set: 727332c9-1a67-11eb-8021-fa163e7d3507:1-841889,</span><br><span class="line">73841e3c-ec47-11ea-9d43-fa163e263d6f:1-150</span><br><span class="line"></span><br><span class="line"># 清理binlog</span><br><span class="line">PURGE BINARY LOGS TO &#39;mysql-bin.000001&#39;; # 清理到</span><br><span class="line">PURGE BINARY LOGS BEFORE &#39;2014-04-28 23:59:59&#39;;</span><br><span class="line"></span><br><span class="line"># 查看binlog事件</span><br><span class="line">show binlog events in &#39;mysql-bin.000001&#39;;</span><br></pre></td></tr></table></figure><h3 id="远程查看">远程查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -R -hhostname -uroot -p123456 mysql-bin.000001 &gt; binlog.sql</span><br></pre></td></tr></table></figure><h3 id="本地查看">本地查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --base64-output&#x3D;DECODE-ROWS --start-position&#x3D;start_position --end-position&#x3D;end_position --start-time&#x3D;start_time --end-time&#x3D;end_time -v -v mysql-bin.000776 | less</span><br></pre></td></tr></table></figure><h1 id="binlog内容">Binlog内容</h1><h2 id="binlog基本格式">Binlog基本格式</h2><p>如官方文档所说:</p><ul><li>binlog文件以一个值为0Xfe62696e的魔数开头，这个魔数对应0xfe ‘b’‘i’‘n’。</li><li>binlog由一系列的binlog event构成。每个binlog event包含header和data两部分。</li></ul><p>​          <code>header</code>部分提供的是event的公共的类型信息，包括event的创建时间，服务器等</p><p>​          <code>data</code>部分提供的是针对该event的具体信息，如具体数据的修改</p><ul><li>最后一个<code>rotate event</code>用于说明下一个binlog文件</li><li>binlog索引文件是一个文本文件，其中内容为当前的binlog文件列表。比如下面就是一个mysql-bin.index文件的内容</li></ul><p>以执行一个insert语句为例，会产生如下几个binlog event。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="binlog事件解析">Binlog事件解析</h2><h1 id="注意">注意</h1><h2 id="事务的写入顺序">事务的写入顺序</h2><p>Reference：</p><p><a href="https://dev.mysql.com/doc/internals/en/binary-log.html" target="_blank" rel="noopener">官方Binlog解析</a></p><p>https://www.cnblogs.com/igoodful/p/11920740.html</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binlog作为MySQL重要的灵魂之一，在MySQL的主从同步、问题定位、数据恢复、增量备份等都发挥着重要的作用。也是MySQL多年来被大家信任的原因之一，同时Binlog也随着MySQL的流行被大家熟知，不过对于很多人来说，只是知道Binlog记录MySQL操作的功能，以及做过简单的解析查看操作SQL，却并没有深入。最近与Binlog交流比较多，就正好梳理下。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL45讲总结</title>
    <link href="http://www.yuguocong.cn/2020/06/23/yuque/MySQL45%E8%AE%B2%E6%80%BB%E7%BB%93/"/>
    <id>http://www.yuguocong.cn/2020/06/23/yuque/MySQL45讲总结/</id>
    <published>2020-06-23T02:45:04.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-基础架构：一条-sql-查询语句是如何执行的？">01 | 基础架构：一条 SQL 查询语句是如何执行的？</h1><p>配置：wait_timeout：控制 Sleep 连接保持时间。线上未配置，默认 8 小时，</p><h4 id="sql-执行步骤">SQL 执行步骤</h4><p>客户端-连接器（管理连接、权限验证）-查询缓存（命中则直接返回，基本没啥用）-分析器（词法分析、语法分析，语法错误在这就能看到了）-优化器（执行计划生成、索引选择）-存储引擎（存储数据、提供读写接口）</p><h4 id="server-层">server 层</h4><p>连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h4 id="存储引擎">存储引擎</h4><p>负责数据的存储和提取。</p><h3 id="连接器">连接器</h3><p>Sleep：表示是空闲连接。</p><p>数据库长连接和短连接：长连接是连接成功后，如果客户端持续有请求，则一直使用同一个连接。优点：减少建立连接的动作，尽量使用短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>全部使用长连接问题：可能 MySQL 占用内存会涨的很快，因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的，会在连接断开才释放，如果长连接积累，会导致内存占用较大。解决办法：定期断开长连接；5.7 版本，执行比较大的操作的后，mysql_reset_connection 来重新初始化连接资源，恢复连接到刚刚创建时的状态。miproxy 连接数太多会自己断开</p><p>内存：操作系统 10G，应用 8G，线程级别的内存占用，一个连接占多大，tcp 占 1M，文件系统描述符。</p><p>为啥会用 swap 内存，操作系统配置：是否使用 swap    cpu 结构有关 对称一致访问：每个核心访问最近的 32G 内存最快，开了的话，cpu0 访问 32G，这个进程用了 32G 就会用 swap 分区。 smp  numa</p><h3 id="查询缓存">查询缓存</h3><p>基本没用了</p><h3 id="分析器">分析器</h3><p>词法分析：识别关键字，以及表名之类。语法分析：根据语法规则判断语法是否错误。</p><h3 id="优化器">优化器</h3><p>索引顺序选择，多表 join 顺序等。</p><h3 id="执行器">执行器</h3><p>执行前判断对表有没有相应权限。（没分析完词法，不知道是哪张表）</p><p>问题：1.Sleep 连接是不是杀了一直没影响2.miproxy 对连接的管理：长短连接，长连接的维护。<em>功能怎么实现的，</em>3.MySQL 内存的使用。（innodb_buffer_size_pool 之外的内存）。 4.数据库权限和表权限验证时间不一样</p><h1 id="02-日志系统：一条-sql-更新语句是如何执行的？">02 | 日志系统：一条 SQL 更新语句是如何执行的？</h1><p>线上配置：innodb_flush_log_at_trx_commit：为 1 时保证每次事务的 redo log 都会持久化到磁盘。sync_binlog：为 1 时保证每次事务的 binlog 都持久化到磁盘。</p><p>更新流程：两阶段提交，涉及和 binlog</p><p>||||||</p><table><thead><tr><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">redo log</td></tr><tr><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td></tr><tr><td style="text-align:left">binlog</td></tr><tr><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td></tr></tbody></table><p>redo log：保证了 MySQL crash-safe 能力。记录更新时，先把记录写到 redo log 并更新内存。binlog：。。，crash-safe：有了 redo-log，可以保证数据库异常重启时，从 redo log 读取后写入内存再写入磁盘，保证数据部丢失。</p><p>两阶段提交：更新写入到内存后，redolog 处于 prapare 阶段，然后写 binlog，再调用引擎的提交事务接口，将 redolog 改成提交状态。server 是作为一个协调者。innodb 只知道干啥。发起 commit 时候，innodb redo  write innodb 没完成不能马上写磁盘。</p><p>MySQL 磁盘满，会休眠，磁盘满。innodb 队列变长了，可能都建立连接不成功：gdbc 建立连接会 show 变量，要不建立连接不成功，要不就连接数暴涨。原因：如果在写完 binlog 到提交事务之间 MySQL crash 的问题。或者从备份恢复的时候。</p><p>问题：备份恢复 apply log 是在：将 redo log 的数据写入磁盘吗？</p><h1 id="03-事务隔离：为什么你改了我还看不见？">03 | 事务隔离：为什么你改了我还看不见？</h1><p>线上配置：</p><p>事务 ACID：Atomicity、Consistency、Isolation、Durability（原子性、一致性、隔离性、持久性）</p><p>多个事务同时执行会出现的问题：脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）隔离级别：读未提交：可以看到未提交的事务读提交：只有提交的事务才会被看到可重复读：一个事务执行过程中看到的数据，总是和启动时看到的一样。不管其他的事务有没有启动。串行化：顾名思义</p><p>|</p><table><thead><tr><th style="text-align:left">脏读</th><th style="text-align:left">不可重复读</th><th style="text-align:left">幻读</th><th style="text-align:left">视图开启时间（对于一个查询）</th></tr></thead><tbody><tr><td style="text-align:left">读未提交</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">读提交</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">可重复读</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">串行化</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr></tbody></table><p>幻读的原因：update 等操作的当前读，需要读取当前的数据，这个时候就会读到最新的更新数据了。表现为：单独 select 没有值，然后 insert 或者 update，发现值已经有了。</p><p>MVCC：undo log 实现</p><h1 id="04-深入浅出索引-上">04 | 深入浅出索引（上）</h1><p>innodb 索引类型：主键索引和：根据叶子节点的内容主键索引：叶子节点内容是整行数据非主键索引：叶子节点内容是主键的值。也叫二级索引。使用二级索引，如果想获得整列的值，需要先从索引找到主键值，然后再根据主键查，需要回表。</p><p>索引维护：分裂：某个数据页满了，新插入数据的时候。合并：相邻两个页删除了数据，利用率很低的时候。ps：自增主键是不会分裂的，因为一直是增长的。</p><p>问题： 1.同时插入较多数据时，索引维护是不是比较占资源。 2.业务字段做主键：只有一个索引；该索引必须是唯一索引？</p><h1 id="05-深入浅出索引-下">05 | 深入浅出索引（下）</h1><p>避免回表的方式：覆盖索引（组合索引）：索引使用注意： 1.最左前缀原则：不管是对于组合索引，还是对于 2.索引下推：MySQL5.6 优化，多个 and 条件的时候，对索引中的字段先过滤，减少回表次数。 2.索引列使用函数会导致索引失效</p><h1 id="06-全局锁和表锁-：给表加个字段怎么有这么多阻碍？">06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h1><p>加锁范围分类：全局锁、表级锁和行锁。全局锁加全局锁方法：Flush tables with read lock (FTWRL)。使用场景：全库逻辑备份（innodb 已经不需要了，可以使用–single-transaction）表级锁分为表锁和元数据锁（MDL）表锁：lock tables … read/write。元数据锁：当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。所以给小表加字段，如果读取较多的话，也会阻塞，会阻塞所有的查询和更新，如果客户端有重试机制，会导致该库线程打满。</p><p>尽量使用 FTWRL 而不是 set global read_only=1：1.read_only 可能会用来判断是主库还是备库。2.FTWRL 命令时，如果客户端异常断开，MySQL 会自动释放，set global read_only 会导致 MySQL 一直只读。</p><h1 id="07-行锁功过：怎么减少行锁对性能的影响？">07 | 行锁功过：怎么减少行锁对性能的影响？</h1><p>线上配置：innodb_lock_wait_timeout：10innodb_deadlock_detect：on两阶段锁协议：行锁在需要的时候才加上，但是在事务结束后才释放。所以要把可能影响并发的锁放在后面。死锁和死锁检测策略：一直等待到超时：innodb_lock_wait_timeout：一直等待锁，直到超时。值不能太大，也不能太小。死锁检测：发现死锁后，主动回滚死锁链条中的某偶一个事务，让其他事务执行。</p><p>问题：死锁检测成本：每个新来的线程，都要要判断会不会由于自己的加入导致死锁，如果同时更新同一行的线程很多的时候。CPU 消耗。原理怎么做的。</p><h1 id="08-事务到底是隔离的还是不隔离的？">08 | 事务到底是隔离的还是不隔离的？</h1><p>undolog：实现了 MVCC数据可见性，锁是实现隔离级别。查询和更新是当前读还是一致性读。一致性读：可重复读隔离级别下，读取数据时，会根据 row trx_id 找到是否能读到当前值，不在的话会根据 redo log 往前找。当前读：操作数据都是要读当前。可重复读隔离级别下，如果需要更新数据，只能拿最新的数据更新，这个时候虽然别的事务还没有提交，但还是能看到的。undolog 大小。共享表空间</p><h1 id="09-普通索引和唯一索引-应该怎么选择？">09 | 普通索引和唯一索引，应该怎么选择？</h1><h1 id="12-为什么我的-mysql-会-抖-一下？">12 | 为什么我的 MySQL 会“抖”一下？</h1><p>线上配置：innodb_flush_neighbors：1innodb_io_capacity：5000innodb_max_dirty_pages_pct：75</p><p>为什么会抖一下：1.redo log 满了。redo log 中的 checkpoint 前移动，需要刷脏页。（应该避免，因为此时数据库服务已经阻塞，需要控制刷脏页频率）  一般不会设置，不同百分比的时候不一样。 2.内存不足，需要淘汰脏页。buffer_pool     3.日常刷脏页。对应 MySQL 的配置。4.MySQL 正常关闭。</p><p>正常使用的数据库，buffer 一般未被使用的情况比较少，如果一个查询，需要的内存比较大，查询需要从磁盘读取很多页的时候，也要将脏页刷到磁盘中。可用的页，刷脏页，写到磁盘，redolog checkpoint 往前走，free list flush list lru list</p><p>脏页刷盘参考：一个是脏页比例，一个是 redo log 写盘速度。</p><p>如果高配机器 redo log 设置比较小的话：redo log 很容易被写满，就会导致经常要因为 redo log 满了而刷盘。表现为：磁盘压力很小，但是数据库出现间歇性的性能下跌</p><h1 id="13-为什么表数据删掉一半-表文件大小不变？">13 | 为什么表数据删掉一半，表文件大小不变？</h1><p>：怎么正确的回收表空间innodb_file_per_table：1 默认值删除整个表数据会删除，但是删除表中的部分数据，空间是怎么回收的。</p><p>delete 删除一条记录：将记录标记为已删除，之后可以复用。delete 删除多条记录：如果整个页被删除，则整页都被标记为可复用。相邻的两页使用率低，会合并。但空间均不会被释放。同理：插入数据，如果当前页已满，肯定会开启新页，也会造成数据空洞。</p><p>压缩空间：alter table A engine=InnoDB。5.5 之前不要用，会阻塞 DML。5.6 版本之后：Online DDL（先建新表，并将旧表的更新写在一个文件中，新表搞好之后，再读取文件中的更新。<strong>会有很短时间的 MDL 写锁</strong>）</p><p>DDL 过程如果是 Online 的，就一定是 inplace 的？</p><h1 id="14-count-这么慢-我该怎么办？">14 | count(*)这么慢，我该怎么办？</h1><p>不加 where 条件：MyISAM 引擎：把一个表的总行数存在了磁盘上，因此执行 count(*)的时候会直接返回这个数，效率很高；InnoDB 引擎：数据一行一行地从引擎里面读出来，然后累积计数。show table status：不准确。</p><p>加 where 条件：InnoDB 引擎：选择从引擎读</p><p>效率排序：count(字段)&lt;count(主键 id)&lt;count(1)≈count(<em>)count(</em>)：特殊处理过，因为不会为 null，server 会按行累计。</p><p>count(1)：InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。count(主键 id)：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。count(字段)：根据是否为 not null 进行判断。</p><h1 id="15-答疑文章-一-：日志和索引相关问题">15 | 答疑文章（一）：日志和索引相关问题</h1><p>日志相关： 1.两阶段提交不同瞬间 MySQL 异常重启怎么保证数据完整性：测试</p><h1 id="16-order-by-是怎么工作的？">16 | “order by”是怎么工作的？</h1><h2 id="全字段排序">全字段排序</h2><p>排序过程对字符串做了“紧凑”处理。即使 name 字段的定义是 varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</p><p>max_length_for_sort_data</p><h2 id="rowid-排序">rowid 排序</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;01-基础架构：一条-sql-查询语句是如何执行的？&quot;&gt;01 | 基础架构：一条 SQL 查询语句是如何执行的？&lt;/h1&gt;
&lt;p&gt;配置：
wait_timeout：控制 Sleep 连接保持时间。线上未配置，默认 8 小时，&lt;/p&gt;
&lt;h4 id=&quot;sql-执行步
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/tags/MySQL/"/>
    
      <category term="学习" scheme="http://www.yuguocong.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>go语言基础学习(3)</title>
    <link href="http://www.yuguocong.cn/2019/09/12/yuque/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(3)/"/>
    <id>http://www.yuguocong.cn/2019/09/12/yuque/go语言基础学习(3)/</id>
    <published>2019-09-12T12:45:04.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<p>配置了 Ubuntu 相关编程环境，学习 Go 语言基础内容，主要是跟着官方教程走一遍，对比 C++的一些不同点学习。</p><h1 id="一-go-语言变量-函数">一.Go 语言变量、函数</h1><h2 id="1-变量的初始化">1.变量的初始化</h2><ul><li>可以通过 <code>var a int</code>  或者采用 <code>a:=3</code>  省略变量的类型，Go 语言会自动推导变量的类型。</li></ul><h2 id="2-go-语言的基本类型">2.Go 语言的基本类型</h2><ul><li>多了一个 rune 类型，教程里没有仔细介绍，也很少使用，之后再注意。</li></ul><h2 id="3-类型转换">3.类型转换</h2><ul><li>Go 语言中不同类型的项之间需要显示转换，没有隐式类型转换。</li></ul><h2 id="4-函数有多返回值">4.函数有多返回值</h2><h1 id="二-go-语言中的流程控制">二.Go 语言中的流程控制</h1><h2 id="1-go-语言中的循环只有-for">1.Go 语言中的循环只有 for</h2><ul><li>所有的循环都采用 for 来实现，for 的使用与 C++类似，但是 for 后面不需要小括号，一定需要大括号。</li><li>可以在 for 循环中定义变量，但作用于只在 for 循环中。</li><li>需要注意的是，Go 语言只有后置++，没有前置++。</li><li>另外，for 语句中可以有空项，但是分号要写上。</li><li>当 for 用来写 while 循环时，可以直接采用 <code>for i&lt;100{}</code> ，不需要写上全部分号。</li></ul><h2 id="2-if-语句">2.if 语句</h2><ul><li>if 语句表达式外不需要小括号，但是一定需要大括号，这点与 for 语句的使用是类似的。</li><li>可以在 if 语句中执行一个简单的语句，分号隔开后再加判断语句。</li><li>同样，else 后面也需要大括号</li></ul><h2 id="3-switch-语句">3.switch 语句</h2><ul><li>Go 语言的 switch 中的 case 可以不是常量，也可以不是整数。</li><li>Switch 中的 case 语句，自带 break，不需要再写 break。</li></ul><h2 id="4-defer-语句">4.defer 语句</h2><ul><li>defer 语句会推迟到外层函数执行结束后执行。</li><li>defer 语句会压栈，当有多个 defer 语句时，后面的 defer 语句会先执行。</li></ul><h1 id="三-slice">三.slice</h1><ul><li>切片就像数组的引用，改变切片会改变底层的值</li><li>切片的默认行为，可以不写完整的上下限，切片默认有上下限</li><li>只是截取切片是不会改变切片大小的</li><li>切片的长度就是它所包含的元素个数，容量是从它的第一个元素开始数，到其底层数组元素末尾的个数</li><li>切片的零值是  <code>nil</code></li></ul><h1 id="四-主要问题记录">四.主要问题记录</h1><h2 id="1-fmt-println-函数中的执行顺序问题">1. fmt.Println()函数中的执行顺序问题</h2><p>当 Println()中打印多个函数的执行结果时，Println()会先顺序调用每个函数，将其结果保存，之后再顺序打印。例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">sum:=x+y</span><br><span class="line">fmt.Println(sum)</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>,<span class="number">2</span>),add(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="2-切片的容量扩展问题">2.切片的容量扩展问题</h2><p>类似于 C++中的 vector，切片的容量扩展，大部分时候也是采用 2 倍扩展，但是也有稍许的差别，在学习过程中无意发现，查看源码可以看到 append 的实现。就 int 而言，当元素个数小于 20 时，当 slice 的容量不够时，继续 append 会将 cap+1，超过 20 后才会 cap*2。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;配置了 Ubuntu 相关编程环境，学习 Go 语言基础内容，主要是跟着官方教程走一遍，对比 C++的一些不同点学习。&lt;/p&gt;
&lt;h1 id=&quot;一-go-语言变量-函数&quot;&gt;一.Go 语言变量、函数&lt;/h1&gt;
&lt;h2 id=&quot;1-变量的初始化&quot;&gt;1.变量的初始化&lt;/h2&gt;
&lt;
      
    
    </summary>
    
      <category term="golang" scheme="http://www.yuguocong.cn/categories/golang/"/>
    
    
      <category term="学习" scheme="http://www.yuguocong.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="golang" scheme="http://www.yuguocong.cn/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Hexo折腾笔记</title>
    <link href="http://www.yuguocong.cn/2019/08/13/yuque/Hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.yuguocong.cn/2019/08/13/yuque/Hexo折腾笔记/</id>
    <published>2019-08-13T12:45:04.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客基本架构">博客基本架构</h2><p>如下图所示，博客更新只需要在语雀上发布对应的文章即可，剩下的工作都会自动化进行。</p><h2 id="对应工具">对应工具</h2><p>语雀：编写博客腾讯云云函数: webhook 解析更新文档推送至 github 私有仓库travis-ci：当私有仓库有更新时，通过 hexo 生成静态页面，并推送至 mianhk.github.io 仓库cloud-flare：网页 CDN</p><h2 id="2019-5-12">2019-5-12</h2><blockquote><p>没错，这几天又开始折腾一下博客了，最近的节奏天天白天待在实验室怼论文，晚上看 C++，时间安排比较紧凑，就觉得更需要阶段性的总结吧，所以又来写博客了，github 始终是一个好的选择，于是入了 Hexo 的坑。。折腾的过程心情总是有些复杂，在激动和 mmp 之间徘徊，虽然很多问题在 wiki 和 issue 里都有，但还是想总结一下自己亲自踩的坑。</p></blockquote><p>修改语雀自动同步，不用再本地编辑和推送了，见：<a href="https://www.yuguocong.cn/yuque/mwklk2.html">https://www.yuguocong.cn/yuque/mwklk2.html</a></p><p>更换了主题：<a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">Aircloud</a></p><h2 id="2018-12-24">2018-12-24</h2><h3 id="hexo-添加分类">Hexo 添加分类</h3><p>在文件中使用<code>categories</code>，然后配置<code>themes/_config.yml</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;</span><br><span class="line">  #categories: &#x2F;categories&#x2F;</span><br><span class="line">  archives: &#x2F;archives&#x2F;</span><br><span class="line">  tags: &#x2F;tags&#x2F;</span><br><span class="line">  books: &#x2F;books</span><br><span class="line">  movies: &#x2F;movies</span><br><span class="line">  friends: &#x2F;categories&#x2F;friends</span><br><span class="line">  about: &#x2F;categories&#x2F;about</span><br></pre></td></tr></table></figure><h3 id="添加背景图片">添加背景图片</h3><p>使用插件 jquery-backstretch，编辑文件<code>/themes/next/layout/_layout.swig</code>,将下面的代码添加到最后面 body 的前面:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;jquery-backstretch&#x2F;2.0.4&#x2F;jquery.backstretch.min.js&quot;&gt;&lt;&#x2F;script&gt;;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  $(&quot;body&quot;).backstretch(&quot;http:&#x2F;&#x2F;blog-1252063226.cosbj.myqcloud.com&#x2F;network&#x2F;20181224194730.png&quot;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>但是好像没有效果，于是在文件<code>themes\next\source\css_custom\custom.styl</code>中添加了如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(https:&#x2F;&#x2F;source.unsplash.com&#x2F;random&#x2F;1600x900);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改背景的不透明度</span><br><span class="line">.main-inner &#123;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    padding: 60px 60px 60px 60px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-hexo-neat-进行压缩以增加页面速度">使用 hexo-neat 进行压缩以增加页面速度</h3><p>采用<code>hexo-neat</code>进行压缩，插件地址为：https://github.com/rozbo/hexo-neat，使用步骤为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装hexo-neat</span><br><span class="line">$ npm install hexo-neat --save</span><br></pre></td></tr></table></figure><p>添加配置到根目录下的<code>_config.yml</code>，在最后加上(这里跟别人的有一些改动，因为有一些配置出了问题，找了很久，但是还是没有解决，干脆就不折腾了):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.html&#39;</span><br><span class="line"># 压缩css</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.css&#39;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.js&#39;</span><br><span class="line">    - &#39;**&#x2F;jquery.fancybox.pack.js&#39;</span><br><span class="line">    - &#39;**&#x2F;index.js&#39;</span><br></pre></td></tr></table></figure><p>不用再做其他的改动，压缩前后的对比为：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557751534763-6f377175-946d-4f32-bc8e-1cbaf76c4355.png#align=left&amp;display=inline&amp;height=179&amp;margin=%5Bobject%20Object%5D&amp;originHeight=179&amp;originWidth=717&amp;size=0&amp;status=done&amp;style=none&amp;width=717" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/187932/1557751534766-e8651cdc-63b9-40d7-979c-f796aabb328a.jpeg#align=left&amp;display=inline&amp;height=407&amp;margin=%5Bobject%20Object%5D&amp;originHeight=407&amp;originWidth=1117&amp;size=0&amp;status=done&amp;style=none&amp;width=1117" alt=""></p><h5 id="主页文章添加阴影效果">主页文章添加阴影效果</h5><h5 id="在网站底部加上访问量">在网站底部加上访问量</h5><h5 id="添加热度">添加热度</h5><h5 id="网站底部字数统计">网站底部字数统计</h5><h5 id="修改-代码块自定义样式">修改``代码块自定义样式</h5><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：(颜色可以自己定义):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加访问量">添加访问量</h5><p>打开<code>\themes\next\layout\_partials\footer.swig</code>文件,搜索<code>&lt;div class=&quot;copyright&quot;&gt;</code>，在这个<code>div</code>标签前边加上如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;dn-lbstatics.qbox.me&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>然后再在合适的位置添加如下代码，放在 footer.swig 文件的末尾:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;powered-by&quot;&gt;</span><br><span class="line">&lt;i class&#x3D;&quot;fa fa-user-md&quot;&gt;&lt;&#x2F;i&gt;&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">  本站访客数:&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h5 id="设置博文内链接为蓝色">设置博文内链接为蓝色</h5><p>通过路径：<code>themes\next\source\css\_common\components\post\</code>,打开<code>post.styl</code>文件，在文件中添加，如下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">      color: #0593d3;</span><br><span class="line">      border-bottom: none;</span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        color: #0477ab;</span><br><span class="line">        text-decoration: underline;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="设置文章末尾-本文结束-标记">设置文章末尾”本文结束”标记</h5><h5 id="显示每篇文章字数">显示每篇文章字数</h5><h5 id="文章末尾添加版权说明">文章末尾添加版权说明</h5><p>直接修改<code>主题配置文件</code>，定位到<code>post_copyright</code>，将<code>enable</code>由<code>false</code>改为<code>true</code>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;3.0&#x2F;</span><br></pre></td></tr></table></figure><h5 id="实现-fork-me-on-github">实现 fork me on github</h5><p>在右上角或者左上角实现 fork me on github。点击<a href="https://blog.github.com/2008-12-19-github-ribbons/" target="_blank" rel="noopener">这里</a>挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;you&quot;&gt;&lt;img style&#x3D;&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src&#x3D;&quot;https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;github&#x2F;ribbons&#x2F;forkme_left_darkblue_121621.png&quot; alt&#x3D;&quot;Fork me on GitHub&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>粘贴刚才复制的代码到<code>themes/next/layout/_layout.swig</code>文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面)，并把<code>href</code>标签改为 github 地址：</p><h5 id="修改文章底部的-号标签">修改文章底部的#号标签</h5><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将其中的 <code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h5 id="添加搜索功能">添加搜索功能</h5><p>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>编辑 <code>站点配置文件</code> （站点根目录下），新增以下内容到任意位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>编辑 <code>主题配置文件</code> （主题目录下），启用本地搜索功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h5 id="图床修改">图床修改</h5><p>由于以前都是直接使用的 github 私人仓库做的图床，但是有时候就是访问不到，因为博客是采用双部署的，可能 coding 上的已经是外链了被屏蔽了，所以还是得想点别的办法了。看到网上说的各种，其实都还是有点问题，最终发现最近的腾讯对象存储，发现还真的可以。软件名：picgo链接：<a href="https://sspai.com/post/42310" target="_blank" rel="noopener">https://sspai.com/post/42310</a>使用方法：<a href="https://github.com/Molunerfinn/PicGo/wiki/%E8%AF%A6%E7%BB%86%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8#v5%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/wiki/详细窗口的使用#v5 版本说明</a></p><h5 id="next-主题个性化之自动更换背景图片">Next 主题个性化之自动更换背景图片</h5><p><a href="https://blog.csdn.net/mango_haoming/article/details/78473243" target="_blank" rel="noopener">https://blog.csdn.net/mango_haoming/article/details/78473243</a></p><h5 id="修改主题：yilia-已取消">修改主题：yilia（已取消）</h5><p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></p><h5 id="2018-4-22-加入畅言评论-已取消">2018-4-22 加入畅言评论（已取消）</h5><p>详见：<a href="https://blog.csdn.net/lcyaiym/article/details/76762074" target="_blank" rel="noopener">https://blog.csdn.net/lcyaiym/article/details/76762074</a></p><h5 id="2018-4-10-加入豆瓣读书和电影">2018-4-10 加入豆瓣读书和电影</h5><p>详细见：<a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener">https://github.com/mythsman/hexo-douban</a></p><h5 id="页面中文无法显示的问题">页面中文无法显示的问题</h5><p>这种中文问题，基本上都是编码的问题，但是开始各种都没找到原因，改了 language 里面的配置文件，最后发现是文件的编码，需要改成’无 bom 的 utf-8 的编码格式 ’</p><h5 id="主界面无法显示-categories-和-tags-的问题">主界面无法显示 categories 和 tags 的问题</h5><p>这个问题真的是搞的有点久，因为基本上都被人忽略了，也可能很多人都没遇到而我恰好遇到了吧，不懂前端的我只能对于这种玄学问题强行百度了。解决办法：将 categories 和 tags 目录下的 index 文件分别改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">tags:</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>折腾完又不早了，希望以后好好看书，好好编程吧，最近没有什么特别大的梦想，只想安静的学习。。。</p><h5 id="绑定-gitpages-到自己的域名">绑定 gitpages 到自己的域名</h5><p>打开<a href="https://education.github.com/" target="_blank" rel="noopener">学生包</a>，通过教育邮箱申请之后，可以在 package 中找到那么 namecheap，注册通过 GitHub 进入，可以直接申请域名，会自动绑定到我们的 gitpage，不过还需要一点点修改，就是把 cname 的 www 改成我们的 gitpage 页面，就可以了。。</p><h5 id="采用-coding-和-gitpages-双部署">采用 coding 和 gitpages 双部署</h5><p>采用双部署的原因是国内访问 github 的速度有时候太感人了，有些人直接打不开，搞得有点尴尬，于是看到了网上所说的双部署，将默认的国内地址解析到 coding 的 pages 服务上，其他的绑定到 gitpage 上，这样国内的访问速度就快了。具体的 coding pages 的搭建就不写了，在 coding 网站中建好仓库后，在我们本地的 config 文件后面的 push repository 加上 coding page 仓库的地址就可以了。具体的 cname 记录和 A 记录如下图：</p><p>** Reference: **<a href="https://tding.top/archives/12c6c559.html" target="_blank" rel="noopener">域名操作</a><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 文档</a><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next 主题文档</a><a href="http://blog.csdn.net/dengnanyi/article/details/53969684" target="_blank" rel="noopener">绑定到 coding</a><a href="https://zhuanlan.zhihu.com/p/33616481" target="_blank" rel="noopener">Hexo 搭建的 GitHub 博客之优化大全</a><a href="https://wafer.li/Hexo/%E8%A7%A3%E5%86%B3%20Travis%20CI%20%E6%80%BB%E6%98%AF%E6%9B%B4%E6%96%B0%E6%97%A7%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决 Travis CI 总是更新旧博客的问题</a><a href="http://www.tianguolangzi.com/2018/01/17/hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">修改背景图片</a><a href="https://xyzardq.github.io/2016/11/02/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">Hexo 添加分类</a><a href="https://segmentfault.com/a/1190000017797561" target="_blank" rel="noopener">云端写作，自动部署</a><a href="https://luan.ma/post/yuque2blog/" target="_blank" rel="noopener">静态博客使用语雀编辑器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;博客基本架构&quot;&gt;博客基本架构&lt;/h2&gt;
&lt;p&gt;如下图所示，博客更新只需要在语雀上发布对应的文章即可，剩下的工作都会自动化进行。&lt;/p&gt;
&lt;h2 id=&quot;对应工具&quot;&gt;对应工具&lt;/h2&gt;
&lt;p&gt;语雀：编写博客
腾讯云云函数: webhook 解析更新文档推送至 git
      
    
    </summary>
    
      <category term="工具" scheme="http://www.yuguocong.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="博客" scheme="http://www.yuguocong.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="http://www.yuguocong.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>go语言基础学习(4)</title>
    <link href="http://www.yuguocong.cn/2019/07/04/yuque/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(4)/"/>
    <id>http://www.yuguocong.cn/2019/07/04/yuque/go语言基础学习(4)/</id>
    <published>2019-07-04T03:47:16.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<ol><li>类型别名type S string 与type S = string 区别？</li></ol><p>type S string 是类型声明，S 是一种新的类型，给 S 定义的方法，接口等和 string 没有关系。而 type S = string 只是一种别名，可以理解为，S 和 String 是完全一样的，只是换了一种叫法而已。类型别名和原类型方法是一样的。也不能在 Switch 中使用两者同时作为分支。</p><ol start="2"><li>go 语言中没有按地址传递，可以深究一下如何传递 slice，再回复到邮件中</li></ol><p>Go 语言中只有按值传递，通过源码可以看到，slice 是一个结构体。结构体中包括真正的数组和长度以及容量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line">len   int</span><br><span class="line">cap   int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数传递 slice 时，其实传递的 slice 结构体，其中包括 array 的首地址、len 和 cap。通过下面的代码可以有以下的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func add_slice(a []int)&#123;</span><br><span class="line">a[0]&#x3D;2</span><br><span class="line">a[1]&#x3D;3</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func append_slice(a []int)&#123;</span><br><span class="line">a&#x3D;append(a,5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func modify_slice(a *[]int)&#123;</span><br><span class="line">*a&#x3D;append(*a,6)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">a:&#x3D;[]int&#123;1,2,3&#125;</span><br><span class="line"></span><br><span class="line">add_slice(a)</span><br><span class="line">fmt.Println(a)  &#x2F;&#x2F;输出[2 3 3]</span><br><span class="line"></span><br><span class="line">append_slice(a)</span><br><span class="line">fmt.Println(a)  &#x2F;&#x2F;输出[2 3 3]</span><br><span class="line"></span><br><span class="line">modify_slice(&amp;a)</span><br><span class="line">fmt.Println(a)   &#x2F;&#x2F;输出[2 3 3 6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是改变 slice 内部的值时，看起来像是按引用传递，因为可以改变 slice 内的值，但是实际上是在参数传递的过程中，传递了 array 的首地址，而 slice 在内存中是一连串的地址，所以知道首地址就可以修改整个数组内部的值。    但是由于是按值传递，所以不能在函数内对 slice 进行 append。如果需要改变 slice 的长度，可以通过传入 slice 的指针。    由于 slice 传递的形式，需要在编程中多多注意，避免进坑。另外看到一个关于传递 slice 的操作，加深了一下对 slice 传参的理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; []int&#123;7,8,9&#125;</span><br><span class="line">b:&#x3D;[]int&#123;&#125;</span><br><span class="line">b&#x3D;append(b,1,2,3)  &#x2F;&#x2F;a,b初始化的方式不一样，导致两者的cap不一样</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;a len: %d cap:%d data:%+v\n&quot;, len(a), cap(a), a)  &#x2F;&#x2F;a len: 3 cap:3 data:[7 8 9]</span><br><span class="line">fmt.Printf(&quot;b len: %d cap:%d data:%+v\n&quot;, len(b), cap(b), b)  &#x2F;&#x2F;b len: 3 cap:4 data:[1 2 3]</span><br><span class="line"></span><br><span class="line">append_slice(a)    &#x2F;&#x2F;显然append是没有效果的</span><br><span class="line">fmt.Printf(&quot;a len: %d cap:%d data:%+v\n&quot;, len(a), cap(a), a)</span><br><span class="line">p :&#x3D; unsafe.Pointer(&amp;a[2])  &#x2F;&#x2F;根据slice在内存的连续性，拿到最后一位的指针地址</span><br><span class="line">q :&#x3D; uintptr(p)+8           &#x2F;&#x2F;将指针往后移一位，因为是int，所以是8</span><br><span class="line">t :&#x3D; (*int)(unsafe.Pointer(q))</span><br><span class="line">fmt.Println(*t)             &#x2F;&#x2F;输出0</span><br><span class="line"></span><br><span class="line">append_slice(b)</span><br><span class="line">fmt.Printf(&quot;b len: %d cap:%d data:%+v\n&quot;, len(b), cap(b), b)</span><br><span class="line">p1 :&#x3D; unsafe.Pointer(&amp;b[2])</span><br><span class="line">q1 :&#x3D; uintptr(p1)+8</span><br><span class="line">t1 :&#x3D; (*int)(unsafe.Pointer(q1))</span><br><span class="line">fmt.Println(*t1)    &#x2F;&#x2F;输出10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func append_slice(a []int) &#123;</span><br><span class="line">a &#x3D; append(a, 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，直接 append 到 slice 的值，如果 cap 够的话，是会 append 上的，但是由于 len 的值没有改变，所以看不到，可以通过 unsafe 指针观察到结果。但是如果 cap 不够，继续 append，会导致重新分配内存空间，append 在新的位置上，此时通过 unsafe 指针也拿不到 append 的值。</p><ol start="3"><li>关于函数的执行顺序：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func add1(x,y int) int&#123;</span><br><span class="line">fmt.Println(&quot;in add1. sum1&#x3D; &quot;,x,y)</span><br><span class="line">return x+y</span><br><span class="line">&#125;</span><br><span class="line">func add(x,y,z,t int) int&#123;</span><br><span class="line">sum:&#x3D;0</span><br><span class="line">sum&#x3D;add1(x,y)+add1(z,t)</span><br><span class="line">fmt.Println(&quot;in add. sum&#x3D;&quot;,sum)</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">fmt.Println(add(1,2,3,4),add(2,3,4,5))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">in add1. sum1&#x3D;  1 2</span><br><span class="line">in add1. sum1&#x3D;  3 4</span><br><span class="line">in add. sum&#x3D; 10</span><br><span class="line">in add1. sum1&#x3D;  2 3</span><br><span class="line">in add1. sum1&#x3D;  4 5</span><br><span class="line">in add. sum&#x3D; 14</span><br><span class="line">10 14</span><br></pre></td></tr></table></figure><p>可以看到，add1 的结果是最先执行的，再执行 add，最后才执行 fmt.Println（）.是按后序遍历的顺序。</p><h1 id="go-语言学习">go 语言学习</h1><ul><li>命名返回值:没有参数的  return  语句返回已命名的返回值</li><li>println 的执行顺序。会先把函数计算结束之后，再按照顺序输出</li><li>没有条件的 switch 同  <code>switch true</code>  一样。</li><li>defer 函数调用会被压入一个栈中，所以后 defer 的值会先输出</li><li>结构体指针的使用：修改结构体指针的值时，不需要带*号。</li><li>数组定义的几种方式</li></ul><h1 id="关于切片">关于切片</h1><ul><li><p>切片就像数组的引用，改变切片会改变底层的值</p></li><li><p>切片的默认行为，可以不写完全部的上下限，因为切片默认有上下限</p></li><li><p>只是截取切片是不会改变切片大小的</p></li><li><p>切片的长度就是它所包含的元素个数。</p></li><li><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数</p></li><li><p>切片的零值是  <code>nil</code></p></li><li><p>函数的闭包</p></li><li><p>接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法，可以定义别名，<code>**type **MyFloat float64</code></p></li></ul><h1 id="关于方法和接口">关于方法和接口</h1><ul><li><p>指针参数的函数必须接受一个指针,而以指针为接收者的方法被调用时，接收者既能为值又能为指针</p></li><li><p>跟 C++中一样，使用指针接收者可以修改接收者指向的值；另外，可以避免每次在调用方法时复制该值。</p><p>1.函数执行顺序是否是后序遍历的方式，可以再嵌套一层方法试试？ 画个调用树出来看看？我在网上没有找到相关的解释，就自己查看了 fmt.Println()函数的源码，会先调用 Fprintln 函数，而 Fprintln 会先执行传入的函数，存在 p 的 buf 中，之后转换成 string 再打印。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func Println(a ...interface&#123;&#125;) (n int, err error) &#123;</span><br><span class="line">return Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br><span class="line">func Sprintln(a ...interface&#123;&#125;) string &#123;</span><br><span class="line">p :&#x3D; newPrinter()</span><br><span class="line">p.doPrintln(a)</span><br><span class="line">s :&#x3D; string(p.buf)</span><br><span class="line">p.free()</span><br><span class="line">return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时也重新把打印语句加复杂了一下，结果与预期相符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func add(x,y int) int&#123;</span><br><span class="line">sum:&#x3D;x+y</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line">func main()&#123;</span><br><span class="line">fmt.Println(add(1,2),add(add(1,1),add(3,7)),add(4,5))</span><br><span class="line">&#125;</span><br><span class="line">运行结果为：</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">9</span><br><span class="line">3 12 9</span><br></pre></td></tr></table></figure><ol start="2"><li>切片的增长为什么是 20，是否在大于 1024 或某个值时，有其他的增长方法？ 比如 增加 1.2 倍？ 可以贴源码作为论据查看了一下 slice 中的 growslice 函数，可以看到当容量小于 1024 时，是按照 2 倍进行增长的，当超过 1024 时，按照 1.25 倍进行增长，应该是从节省空间的角度考虑，毕竟对一个很长的数组，再插入同样长度的数的概率很小。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap :&#x3D; old.cap</span><br><span class="line">doublecap :&#x3D; newcap + newcap</span><br><span class="line">if cap &gt; doublecap &#123;</span><br><span class="line">newcap &#x3D; cap</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if old.len &lt; 1024 &#123;</span><br><span class="line">newcap &#x3D; doublecap</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; Check 0 &lt; newcap to detect overflow</span><br><span class="line">&#x2F;&#x2F; and prevent an infinite loop.</span><br><span class="line">for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;</span><br><span class="line">newcap +&#x3D; newcap &#x2F; 4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Set newcap to the requested cap when</span><br><span class="line">&#x2F;&#x2F; the newcap calculation overflowed.</span><br><span class="line">if newcap &lt;&#x3D; 0 &#123;</span><br><span class="line">newcap &#x3D; cap</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码测试上述结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">var a []int</span><br><span class="line">for i:&#x3D;0;i&lt;1500;i++&#123;</span><br><span class="line">a&#x3D;append(a,i)</span><br><span class="line">if i%100&#x3D;&#x3D;0&#123;</span><br><span class="line">fmt.Printf(&quot;len: %d , cap; %d\n&quot;,len(a),cap(a))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line">len: 1 , cap; 1</span><br><span class="line">len: 101 , cap; 128</span><br><span class="line">len: 201 , cap; 256</span><br><span class="line">len: 301 , cap; 512</span><br><span class="line">len: 401 , cap; 512</span><br><span class="line">len: 501 , cap; 512</span><br><span class="line">len: 601 , cap; 1024</span><br><span class="line">len: 701 , cap; 1024</span><br><span class="line">len: 801 , cap; 1024</span><br><span class="line">len: 901 , cap; 1024</span><br><span class="line">len: 1001 , cap; 1024</span><br><span class="line">len: 1101 , cap; 1280</span><br><span class="line">len: 1201 , cap; 1280</span><br><span class="line">len: 1301 , cap; 1696</span><br><span class="line">len: 1401 , cap; 1696</span><br></pre></td></tr></table></figure><p>如上符合源码结果，所以之前的分析有些问题，但是 append 多个值的时候，与之前的结果相同。再次查看源码，发现实际上还有内存对齐的考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capmem &#x3D; roundupsize(uintptr(newcap) * sys.PtrSize)</span><br></pre></td></tr></table></figure><p>其中 capmem 会根据 roundupsize 函数进行内存对齐。其中 uintptr(newcap)表示新容量的大小，sys.PtrSize 表示一个元素的大小，int 时为 8。roundupsize 函数的实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func roundupsize(size uintptr) uintptr &#123;</span><br><span class="line">if size &lt; _MaxSmallSize &#123;</span><br><span class="line">if size &lt;&#x3D; smallSizeMax-8 &#123;</span><br><span class="line">return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)&#x2F;smallSizeDiv]])</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)&#x2F;largeSizeDiv]])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if size+_PageSize &lt; size &#123;</span><br><span class="line">return size</span><br><span class="line">&#125;</span><br><span class="line">return round(size, _PageSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：_MaxSmallSize=32768,2 的 15 次方，是 32K。当需要分配的 size 大于 32K 时，需要 mchche 向 mcentral 申请；当 size 小于 32K 时，计算应该分配的 sizeclass，直接去 mchche 申请。（关于具体的内存申请方面，在后面的开发需要的时候再仔细研究）当 size 小于 smallSizeMax-8=1024-8=1016 时，采用 size_to_class8 的分配方式，大于 1016 时采用 size_to_class128 的分配方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_to_class8 &#x3D; [smallSizeMax&#x2F;smallSizeDiv + 1]uint8&#123;0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31&#125;</span><br><span class="line">size_to_class128 &#x3D; [(_MaxSmallSize-smallSizeMax)&#x2F;largeSizeDiv + 1]uint8&#123;31, 32, 33, 34, 35, 36, 36, 37, 37, 38, 38, 39, 39, 39, 40, 40, 40, 41, 42, 42, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 47, 47, 47, 48, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66&#125;</span><br><span class="line">class_to_size &#x3D; [_NumSizeClasses]uint16&#123;0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个数组值的不同，并且间隔的粒度也不同，当 size 较小时，间隔为 8，当 size 较大时，间隔为 128.而为了内存优化考虑，class_to_size 会控制分配大小，间隔从 8-4096以 int 为例</p><table><thead><tr><th style="text-align:left">个数</th><th style="text-align:left">1</th><th style="text-align:left">2</th><th style="text-align:left">3</th><th style="text-align:left">4</th><th style="text-align:left">5</th><th style="text-align:left">6</th><th style="text-align:left">7</th><th style="text-align:left">8</th><th style="text-align:left">9</th></tr></thead><tbody><tr><td style="text-align:left">字节数</td><td style="text-align:left">8</td><td style="text-align:left">16</td><td style="text-align:left">24</td><td style="text-align:left">32</td><td style="text-align:left">40</td><td style="text-align:left">48</td><td style="text-align:left">56</td><td style="text-align:left">64</td><td style="text-align:left">72</td></tr><tr><td style="text-align:left">所占空间</td><td style="text-align:left">8</td><td style="text-align:left">16</td><td style="text-align:left">32</td><td style="text-align:left">32</td><td style="text-align:left">48</td><td style="text-align:left">48</td><td style="text-align:left">64</td><td style="text-align:left">64</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left">size_to_class8</td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">3</td><td style="text-align:left">4</td><td style="text-align:left">4</td><td style="text-align:left">5</td><td style="text-align:left">5</td><td style="text-align:left">6</td></tr></tbody></table><h2 id="tips">Tips</h2><p>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var rmdirs []func()</span><br><span class="line">for _, d :&#x3D; range tempDirs() &#123;</span><br><span class="line">  dir :&#x3D; d &#x2F;&#x2F; NOTE: necessary!如果没有这一行会导致传入同样的dir</span><br><span class="line">  os.MkdirAll(dir, 0755) &#x2F;&#x2F; creates parent directories too</span><br><span class="line">  rmdirs &#x3D; append(rmdirs, func() &#123;</span><br><span class="line">  os.RemoveAll(dir)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ...do some work…</span><br><span class="line">for _, rmdir :&#x3D; range rmdirs &#123;</span><br><span class="line">rmdir() &#x2F;&#x2F; clean up</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;类型别名
type S string 与
type S = string 区别？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;type S string 是类型声明，S 是一种新的类型，给 S 定义的方法，接口等和 string 没有关系。
而 type S = string 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【Golang】go语言学习(1)-初识切片</title>
    <link href="http://www.yuguocong.cn/2019/07/02/yuque/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0(1)/"/>
    <id>http://www.yuguocong.cn/2019/07/02/yuque/go语言学习(1)/</id>
    <published>2019-07-02T02:00:25.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础记录">基础记录</h1><ul><li>命名返回值:没有参数的  return  语句返回已命名的返回值</li><li>println 的执行顺序。会先把函数计算结束之后，再按照顺序输出</li><li>没有条件的 switch 同  <code>switch true</code>  一样。</li><li>defer 函数调用会被压入一个栈中，所以后 defer 的值会先输出</li><li>结构体指针的使用：修改结构体指针的值时，不需要带*号。</li><li>数组定义的几种方式</li></ul><h1 id="关于切片">关于切片</h1><ul><li><p>切片就像数组的引用，改变切片会改变底层的值</p></li><li><p>切片的默认行为，可以不写完全部的上下限，因为切片默认有上下限</p></li><li><p>只是截取切片是不会改变切片大小的</p></li><li><p>切片的长度就是它所包含的元素个数。</p></li><li><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数</p></li><li><p>切片的零值是  <code>nil</code></p></li><li><p>函数的闭包</p></li><li><p>接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法，可以定义别名，<code>**type **MyFloat float64</code></p></li></ul><h1 id="关于方法和接口">关于方法和接口</h1><ul><li><p>指针参数的函数必须接受一个指针,而以指针为接收者的方法被调用时，接收者既能为值又能为指针</p></li><li><p>跟 C++中一样，使用指针接收者可以修改接收者指向的值；另外，可以避免每次在调用方法时复制该值。</p><p>1.函数执行顺序是否是后序遍历的方式，可以再嵌套一层方法试试？ 画个调用树出来看看？我在网上没有找到相关的解释，就自己查看了 fmt.Println()函数的源码，会先调用 Fprintln 函数，而 Fprintln 会先执行传入的函数，存在 p 的 buf 中，之后转换成 string 再打印。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.doPrintln(a)</span><br><span class="line">s := <span class="keyword">string</span>(p.buf)</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时也重新把打印语句加复杂了一下，结果与预期相符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">sum:=x+y</span><br><span class="line">fmt.Println(sum)</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>,<span class="number">2</span>),add(add(<span class="number">1</span>,<span class="number">1</span>),add(<span class="number">3</span>,<span class="number">7</span>)),add(<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line">运行结果为：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">12</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ol start="2"><li>切片的增长为什么是 20，是否在大于 1024 或某个值时，有其他的增长方法？ 比如 增加 1.2 倍？ 可以贴源码作为论据查看了一下 slice 中的 growslice 函数，可以看到当容量小于 1024 时，是按照 2 倍进行增长的，当超过 1024 时，按照 1.25 倍进行增长，应该是从节省空间的角度考虑，毕竟对一个很长的数组，再插入同样长度的数的概率很小。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码测试上述结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">1500</span>;i++&#123;</span><br><span class="line">a=<span class="built_in">append</span>(a,i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">100</span>==<span class="number">0</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"len: %d , cap; %d\n"</span>,<span class="built_in">len</span>(a),<span class="built_in">cap</span>(a))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"><span class="built_in">len</span>: <span class="number">1</span> , <span class="built_in">cap</span>; <span class="number">1</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">101</span> , <span class="built_in">cap</span>; <span class="number">128</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">201</span> , <span class="built_in">cap</span>; <span class="number">256</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">301</span> , <span class="built_in">cap</span>; <span class="number">512</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">401</span> , <span class="built_in">cap</span>; <span class="number">512</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">501</span> , <span class="built_in">cap</span>; <span class="number">512</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">601</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">701</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">801</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">901</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1001</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1101</span> , <span class="built_in">cap</span>; <span class="number">1280</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1201</span> , <span class="built_in">cap</span>; <span class="number">1280</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1301</span> , <span class="built_in">cap</span>; <span class="number">1696</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1401</span> , <span class="built_in">cap</span>; <span class="number">1696</span></span><br></pre></td></tr></table></figure><p>如上符合源码结果，所以之前的分析有些问题，但是 append 多个值的时候，与之前的结果相同。再次查看源码，发现实际上还有内存对齐的考虑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br></pre></td></tr></table></figure><p>其中 capmem 会根据 roundupsize 函数进行内存对齐。其中 uintptr(newcap)表示新容量的大小，sys.PtrSize 表示一个元素的大小，int 时为 8。roundupsize 函数的实现如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">roundupsize</span><span class="params">(size <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> size &lt; _MaxSmallSize &#123;</span><br><span class="line"><span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uintptr</span>(class_to_size[size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uintptr</span>(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line"><span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> round(size, _PageSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：_MaxSmallSize=32768,2 的 15 次方，是 32K。当需要分配的 size 大于 32K 时，需要 mchche 向 mcentral 申请；当 size 小于 32K 时，计算应该分配的 sizeclass，直接去 mchche 申请。（关于具体的内存申请方面，在后面的开发需要的时候再仔细研究）当 size 小于 smallSizeMax-8=1024-8=1016 时，采用 size_to_class8 的分配方式，大于 1016 时采用 size_to_class128 的分配方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_to_class8 &#x3D; [smallSizeMax&#x2F;smallSizeDiv + 1]uint8&#123;0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31&#125;</span><br><span class="line">size_to_class128 &#x3D; [(_MaxSmallSize-smallSizeMax)&#x2F;largeSizeDiv + 1]uint8&#123;31, 32, 33, 34, 35, 36, 36, 37, 37, 38, 38, 39, 39, 39, 40, 40, 40, 41, 42, 42, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 47, 47, 47, 48, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66&#125;</span><br><span class="line"></span><br><span class="line">class_to_size &#x3D; [_NumSizeClasses]uint16&#123;0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个数组值的不同，并且间隔的粒度也不同，当 size 较小时，间隔为 8，当 size 较大时，间隔为 128.而为了内存优化考虑，class_to_size 会控制分配大小，间隔从 8-4096以 int 为例</p><table><thead><tr><th>个数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>字节数</td><td>8</td><td>16</td><td>24</td><td>32</td><td>40</td><td>48</td><td>56</td><td>64</td><td>72</td></tr><tr><td>所占空间</td><td>8</td><td>16</td><td>32</td><td>32</td><td>48</td><td>48</td><td>64</td><td>64</td><td>80</td></tr><tr><td>size_to_class8</td><td>1</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>5</td><td>5</td><td>6</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础记录&quot;&gt;基础记录&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;命名返回值:没有参数的  return  语句返回已命名的返回值&lt;/li&gt;
&lt;li&gt;println 的执行顺序。会先把函数计算结束之后，再按照顺序输出&lt;/li&gt;
&lt;li&gt;没有条件的 switch 同  &lt;code&gt;
      
    
    </summary>
    
    
      <category term="golang" scheme="http://www.yuguocong.cn/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>【Git】Git使用总结</title>
    <link href="http://www.yuguocong.cn/2019/05/26/yuque/Git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://www.yuguocong.cn/2019/05/26/yuque/Git使用总结/</id>
    <published>2019-05-26T02:24:53.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置-user-信息">配置 user 信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &#39;your_name&#39;</span><br><span class="line">git config --global user.email &#39;your_email&#39;</span><br><span class="line"></span><br><span class="line">git config --local  #local只对某个仓库有效</span><br><span class="line">git config --global  #global对当前用户的所有仓库有效</span><br><span class="line">git config --system  #对系统所有登录用户有效，一般不用没什么意义</span><br><span class="line"></span><br><span class="line">git config --global --list #显示配置项</span><br></pre></td></tr></table></figure><p>local 比 global 优先级要高</p><h1 id="给文件重命名">给文件重命名</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#原来的使用：</span><br><span class="line">mv readme readme.md</span><br><span class="line">git add readme.md</span><br><span class="line">git rm readme</span><br><span class="line">#直接使用</span><br><span class="line">git mv readme readme.md</span><br></pre></td></tr></table></figure><h1 id="查看-gitlog">查看 gitlog</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log #只显示当前分支</span><br><span class="line">git log --all --graph #可以看所有的分支</span><br><span class="line">git log --oneline --all -n4 #一行显示所有分支最近的4个</span><br></pre></td></tr></table></figure><h1 id="git-目录">.git 目录</h1><p>HEAD：整个仓库正在工作的分支config：存放仓库本地的配置信息，记录 user 等信息refs：objects：包括文件夹和 pack</p><h1 id="commit-tree-和-blob-之间的关系">commit、tree 和 blob 之间的关系</h1><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1558841650988-46fcccb5-6359-4112-8808-e60284941018.png#align=left&amp;display=inline&amp;height=681&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=681&amp;originWidth=1132&amp;size=170368&amp;status=done&amp;style=none&amp;width=1132" alt="image.png">一个 commit 对应一棵 tree，每个文件夹对应一个 tree</p><h1 id="分离头指针">分离头指针</h1><p>表示某个变更没有基于某个 branch，在切换分支的时候，这些变更很有可能会被 git 当做垃圾清理，所以如果认为这些变更有用的话，一定要与某个 branch 绑定才能得到保留。</p><h1 id="head-和-branch">HEAD 和 branch</h1><p>切换分支时，HEAD 指向会发生变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD HEAD^  #与上一次HEAD比较</span><br><span class="line">git diff HEAD HEAD^^ #与上上次进行比较</span><br><span class="line">git diff HEAD HEAD^3 #与上上上次进行比较</span><br></pre></td></tr></table></figure><h1 id="常用场景">常用场景</h1><h2 id="删除分支">删除分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &#39;分支名&#39;  #清除分支的命令</span><br><span class="line">git branch -D &#39;分支名&#39;  #确信清除没有影响，采用D清除</span><br></pre></td></tr></table></figure><h2 id="修改-commit-的-message">修改 commit 的 message</h2><p>在维护自己的分支的时候，还没有提交的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend   #修改最新的commit的message</span><br><span class="line">git rebase -i &#39;commit id&#39;  #修改更久的commit的message</span><br><span class="line">  然后按照提示进行修改</span><br></pre></td></tr></table></figure><h2 id="整理多个-commit-为-1-个">整理多个 commit 为 1 个</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &#39;commit-id&#39;  # commit-id为最久的想合并的</span><br></pre></td></tr></table></figure><h2 id="比较暂存区和-head-所含文件的差异">比较暂存区和 HEAD 所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached  #表示暂存区和HEAD的区别</span><br></pre></td></tr></table></figure><h2 id="比较工作区和暂存区的区别">比较工作区和暂存区的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff #默认比较的是工作区和暂存区的区别</span><br><span class="line">git diff --文件名 #比较文件</span><br></pre></td></tr></table></figure><h2 id="让暂存区恢复成和-head-一样">让暂存区恢复成和 HEAD 一样</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD #将暂存区所有的变更恢复成HEAD</span><br></pre></td></tr></table></figure><h2 id="工作区的文件恢复成暂存区一样">工作区的文件恢复成暂存区一样</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &#39;文件名&#39;</span><br></pre></td></tr></table></figure><h2 id="取消暂存区部分文件的修改">取消暂存区部分文件的修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD --&#39;文件名&#39;  # 将暂存区某一文件恢复成HEAD</span><br></pre></td></tr></table></figure><h2 id="消除最近的几次提交">消除最近的几次提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &#39;commit-id&#39; #慎用</span><br></pre></td></tr></table></figure><h2 id="看不同提交的指定文件的差异">看不同提交的指定文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff &#39;branch1&#39; &#39;branch2&#39; -- &#39;文件名&#39;</span><br><span class="line">git diff &#39;commit-id1&#39; &#39;commit-id2&#39; -- &#39;文件名&#39;</span><br></pre></td></tr></table></figure><h2 id="正确删除文件的方法">正确删除文件的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &#39;文件名&#39;</span><br></pre></td></tr></table></figure><h2 id="开发临时加塞紧急任务处理方式">开发临时加塞紧急任务处理方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash apply</span><br><span class="line">或者 git stach pop  #两者区别是会丢掉</span><br></pre></td></tr></table></figure><h2 id="git-的备份">Git 的备份</h2><ul><li>哑协议：不显示进度条</li><li>智能协议：</li></ul><h1 id="tips">Tips</h1><h2 id="同步含有git的文件夹及问题解决">同步含有git的文件夹及问题解决</h2><p>同步含有 git 的文件夹真的有点烦，由于没有注意同步结果，只是一直在看 travis 构建结果，结果半天没有发现问题，后来发现了也不知道怎么解决，看远程仓库的代码是一个关联的文件夹形式，表示这是一个 git 的文件夹，但是点不开，本地的也没有上传。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置-user-信息&quot;&gt;配置 user 信息&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go语言学习(2)-极客时间</title>
    <link href="http://www.yuguocong.cn/2019/04/28/yuque/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0(2)-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    <id>http://www.yuguocong.cn/2019/04/28/yuque/go语言学习(2)-极客时间/</id>
    <published>2019-04-28T13:34:33.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个-go-程序">第一个 go 程序</h1><ul><li>go 语言主函数没有返回值，需要使用 os 包， <code>os.exit()</code> ，也不能直接函数传参。</li></ul><h1 id="变量-常量和其他语言的区别">变量、常量和其他语言的区别</h1><ul><li>赋值可以自动类型推断： <code>a:=1</code> ，怎么方便怎么来就行</li><li>快速连续赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">Monday&#x3D;itoa+1</span><br><span class="line">  Tuesday</span><br><span class="line">  Wednesday</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const(</span><br><span class="line">Open&#x3D;1&lt;&lt;itoa</span><br><span class="line">  Close</span><br><span class="line">  Pending</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="运算符">运算符</h1><ul><li>算数运算符：没有前置的++、–</li><li>比较运算符：用 <code>==</code>  比较时，相同维数的数组可以比较</li><li>逻辑运算符</li><li>位运算符： <code>&amp;^</code> ：按位清零</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &amp;^ 0 --1</span><br><span class="line">1&amp;^ 1 --0</span><br><span class="line">0&amp;^1 --0</span><br><span class="line">0&amp;^0 --0</span><br></pre></td></tr></table></figure><h1 id="条件和循环">条件和循环</h1><ul><li>循环：只支持 <code>for</code> ，并且没有括号，while 条件的写法为</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n&lt;<span class="number">5</span>&#123;</span><br><span class="line">n++</span><br><span class="line">  fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>条件：条件一定要是个布尔值或表达式。支持在 if 语句中对变量赋值</li><li>switch 条件：条件表达式不限制为常量或者整数；单个 case 中，可以出现多个结果选项，使用逗号分隔；不需要 break；可以不设定 switch 之后的条件表达式</li></ul><h1 id="数组和切片">数组和切片</h1><h2 id="数组">数组</h2><ul><li>数组的声明：声明同时初始化：<code>arr3:=[...]int{1,3,4,5}</code></li><li>数组的遍历</li><li>数组截取：a[index_begin(包含),index_end(不包含)]</li></ul><h2 id="切片">切片</h2><ul><li>切片的声明方式：与数组的声明有点相似</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s0 []<span class="keyword">int</span></span><br><span class="line">s1:=[]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">s2:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">4</span>)  <span class="comment">//([]type,len,cap)  len个元素会被初始化为零值，</span></span><br><span class="line">                       <span class="built_in">cap</span>中其它未初始化的元素不能访问</span><br></pre></td></tr></table></figure><ul><li>切片的增长方式：类似于 c++的 vector。</li><li>切片共享存储结构：切片截取后，计算 cap 得到的结果。其实切片截取，指向的是内部共享的切片存储空间。所以修改截取的切片的数据，其他截取的相同区域也会发生改变。这是一个容易出错的问题。</li></ul><h2 id="切片和数组的区别">切片和数组的区别</h2><ul><li>容量是否可伸缩</li><li>是否可以进行比较</li></ul><h1 id="map-基础">Map 基础</h1><ul><li>Map 声明方式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>:<span class="number">1</span>,<span class="string">"two"</span>:<span class="number">2</span>,<span class="string">"three"</span>:<span class="number">3</span>&#125;</span><br><span class="line">m1:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">m1[<span class="string">"one"</span>]=<span class="number">1</span></span><br><span class="line">m2:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>,<span class="number">10</span>)  <span class="comment">//10表示初始化的cap,不需要初始化len</span></span><br></pre></td></tr></table></figure><ul><li>元素访问：当访问的 key 不存在时，仍然会返回零值，编程时需要根据 nil 来判断元素是否存在</li></ul><h1 id="map-与工厂模式">Map 与工厂模式</h1><ul><li>Map 的 value 可以是一个方法</li><li>与 Go 的 Dock type 接口方式一起，可以方便的实现单一方法对象的工厂模式</li><li>Go 内置集合中没有 Set，可以通过 map 实现<code>mySet:=**map**[int]bool{}</code></li></ul><h1 id="字符串">字符串</h1><ul><li>string 是数据类型，不是引用或指针类型。零值不是空，而是空字符串。</li><li>string 是只读的 byte slice，不能重复赋值。len 函数可以表示它所包含的 byte 数</li><li>string 的 byte 数组可以存放任何数据</li></ul><h2 id="unicode-和-utf-8">Unicode 和 UTF-8</h2><ul><li>Unicode 是一种字符集（code point）</li><li>UTF-8 是 Unicode 的存储实现（转换为）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556503870325-262231e2-8b69-42ab-8711-83d68d74069e.png#align=left&amp;display=inline&amp;height=270&amp;name=image.png&amp;originHeight=398&amp;originWidth=671&amp;size=46907&amp;status=done&amp;width=456" alt="image.png"></p><h1 id="go-语言的函数">Go 语言的函数</h1><ul><li>函数可以返回多个值</li><li>所有参数都是值传递：slice，map，channel 会有传引用的错觉</li><li>函数可以作为变量的值</li><li>函数可以作为参数和返回值</li></ul><h1 id="可变参数及-defer">可变参数及 defer</h1><ul><li>延迟执行函数：defer。类似于其他语言中的 finally，主要作用是最后关闭一些资源或者关闭一些锁</li></ul><h1 id="行为的定义和实现">行为的定义和实现</h1><h2 id="封装数据和行为">封装数据和行为</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span>&#123;</span><br><span class="line">Id <span class="keyword">string</span></span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">实例的创建和初始化</span><br><span class="line">e:=Employee&#123;<span class="string">"0"</span>,<span class="string">"Bob"</span>,<span class="number">20</span>&#125;</span><br><span class="line">e1:=Employee&#123;Name:<span class="string">"Mike"</span>,Age:<span class="number">30</span>&#125;</span><br><span class="line">e2:=<span class="built_in">new</span>(Employee)  <span class="comment">//这里返回的是实例的指针</span></span><br><span class="line">e2.Id=<span class="string">"2"</span>  <span class="comment">//通过实例的指针访问指针不需要“-&gt;”</span></span><br></pre></td></tr></table></figure><h2 id="行为-方法-定义">行为（方法）定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span><span class="title">String1</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"ID:%s-Name:%s-Age:%d"</span>,e.Id,e.Name,e.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐使用的方式，类似于c++的引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span><span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"ID:%s-Name:%s-Age:%d"</span>,e.Id,e.Name,e.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="go-语言的相关接口">Go 语言的相关接口</h1><h2 id="duck-type">Duck Type</h2><p>方法签名是一样的，就认为是这样的</p><ul><li>接口是非入侵性的，实现不依赖于接口定义</li><li>接口的定义可以包含在接口使用者包内</li></ul><h2 id="接口变量">接口变量</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556508509894-85f1967f-80e0-4a9e-9db7-a2b01ba96f30.png#align=left&amp;display=inline&amp;height=338&amp;name=image.png&amp;originHeight=338&amp;originWidth=701&amp;size=40266&amp;status=done&amp;width=701" alt="image.png"></p><h2 id="自定义类型">自定义类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntConv <span class="function"><span class="keyword">func</span> <span class="params">(op <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><h1 id="扩展与复用">扩展与复用</h1><h1 id="不一样的接口类型-一样的多态">不一样的接口类型，一样的多态</h1><h2 id="空接口与断言">空接口与断言</h2><ul><li>空接口可以表示任何类型</li><li>通过断言来将空接口转换为制定类型 <code>v,ok:=p.(int) //ok=true时为转换成功</code></li></ul><h2 id="go-接口最佳实践">Go 接口最佳实践</h2><ul><li>倾向于使用小的接口定义，很多接口只包含一个方法。实现的负担较小。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type Reader <span class="keyword">interface</span>&#123;</span><br><span class="line">Read(p []<span class="keyword">byte</span>)(n <span class="keyword">int</span>,err error)</span><br><span class="line">&#125;</span><br><span class="line">Type Writer <span class="keyword">interface</span>&#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>)(n <span class="keyword">int</span>,err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>较大的接口定义，可以由多个小接口定义组合而成。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type ReadWrite <span class="keyword">interface</span>&#123;</span><br><span class="line">Reader</span><br><span class="line">  Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只依赖于必要功能的最小接口，方法才能更多的被复用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreData</span><span class="params">(reader Reader)</span> <span class="title">error</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="编写好的错误处理">编写好的错误处理</h1><ul><li>没有异常机制</li><li>error 类型实现了 error 接口</li><li>可以通过 errors.New 来快速创建错误实例</li></ul><h1 id="panic-和-recover">panic 和 recover</h1><h2 id="panic">panic</h2><ul><li>panic 用于不可恢复的错误</li><li>panic 退出前会执行 defer 指定的内容</li></ul><h2 id="panic-vs-os-exit">panic vs os.Exit</h2><ul><li>os.Exit 退出时不会调用 defer 指定的函数</li><li>os.Exit 退出时不会输出当前调用栈信息</li></ul><h2 id="recover">recover</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer func()&#123;</span><br><span class="line">if err:&#x3D;recover();err!&#x3D;nil&#123;</span><br><span class="line">  &#x2F;&#x2F;恢复错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><ul><li>不要强制恢复错误，有的时候“Let it crash”可能更好，让程序重启来恢复。</li></ul><h1 id="构建可复用的模块-包">构建可复用的模块（包）</h1><h2 id="package">package</h2><ul><li>基本复用模块单元：以<strong>首字母大写</strong>来表名可被包外代码访问</li><li>代码在 package 可以和所在的目录了不一致（相对于 Java 而言）</li><li>同一目录里的 Go 代码的 package 要保持一致</li></ul><h2 id="init-方法">init 方法</h2><ul><li>在 main 被执行前，所有依赖的 package 的 init 方法都会被执行</li><li>不同包的 init 函数按照包导入的依赖关系决定执行顺序</li><li>每个包可以有多个 init 函数</li><li>包的每个源文件也可以有多个 init 函数，比较特殊</li></ul><h2 id="go-get">go get</h2><ul><li>通过 go get 来获取远程依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u 强制从网络更新远程依赖</span><br></pre></td></tr></table></figure><ul><li>注意代码在 Github 上的组织形式，以适应 go get：直接以代码路径开始，不要有 src</li></ul><h1 id="依赖管理">依赖管理</h1><h2 id="go-未解决的依赖问题">Go 未解决的依赖问题</h2><ul><li>同一环境下，不同项目使用同一包的不同版本</li><li>无法管理对包的特定版本的依赖</li></ul><h2 id="vendor-路径">vendor 路径</h2><p>Go1.5 release 版本，vendor 目录被添加到除了 GOPATH 和 GOROOT 以外的依赖目录查找方案。查找依赖包路径的解决方案：</p><ol><li>当前包下的 vendor 目录</li><li>向上级目录查找，直到找到 src 下的 vendor 目录</li><li>在 GOPATH 下面查找依赖包</li><li>在 GOROOT 目录下查找</li></ol><p>其他第三方依赖管理工具：godep，glide，<strong>dep</strong>**</p><h1 id="协程机制">协程机制</h1><h2 id="线程-vs-协程">线程 vs 协程</h2><ul><li>创建时默认的 stack 大小：JAVA 1M vs Goroutine 2K</li><li>和 KSE（Kernel Space Entity）：java Thread 是 1:1；GO M:N</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556704202218-7913c997-6b91-48e2-9dc6-49b057a39342.png#align=left&amp;display=inline&amp;height=432&amp;name=image.png&amp;originHeight=432&amp;originWidth=618&amp;size=110172&amp;status=done&amp;width=618" alt="image.png"></p><h1 id="共享内存并发机制">共享内存并发机制</h1><h2 id="lock">Lock</h2><h2 id="waitgroup">WaitGroup</h2><p>相当于 Java 的 join</p><h1 id="csp-并发机制">CSP 并发机制</h1><h2 id="csp-vs-actor">CSP vs Actor</h2><ul><li>和 Actor 的直接通讯不同，CSP 模式是通过 Channel 进行通讯的，更松耦合一些</li><li>Go 中 Channel 是有容量限制并且独立于处理 Goroutine，而如 Erlang，Actor 模式中的 mailbox 容量是无限的，接收进程也总是被动地处理消息。</li></ul><h2 id="channel">Channel</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556705599268-5d3769a6-8c93-4827-a9c2-525810d0cc3a.png#align=left&amp;display=inline&amp;height=910&amp;name=image.png&amp;originHeight=910&amp;originWidth=1703&amp;size=565338&amp;status=done&amp;width=1703" alt="image.png">两种情况：一种是一直等待，一种 Buffered Channel ，更松耦合的 Channel，消息发送方可以在容量没满的时候一直放，满了之后需要等待。对于接收方来说，只要 Channel 内有消息就可以一直接收。</p><h1 id="多路选择和超时">多路选择和超时</h1><h2 id="select">select</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556712290363-e32d5fa7-eb01-4d32-8fed-14ae04a0042d.png#align=left&amp;display=inline&amp;height=301&amp;name=image.png&amp;originHeight=301&amp;originWidth=861&amp;size=79632&amp;status=done&amp;width=861" alt="image.png">运行到 select 时，当任一个事件准备好了，就可以对应响应。当不想一直等待某事件时，可以进行超时控制。</p><h1 id="channel-的关闭和广播">channel 的关闭和广播</h1><p>解决怎么知道 channel 数据完了的问题</p><h2 id="channel-的关闭">channel 的关闭</h2><ul><li>向关闭的 channel 发送数据，会导致 panic</li><li>v,ok&lt;-ch；ok 为 bool 值，true 表示正常接收，false 表示通道关闭</li><li>所有的 channel 接收者都会在 channel 关闭时，立即从阻塞等待中返回且上述 ok 值为 false。这个广播机制常被利用，进行向多个订阅者发送信号，如：退出信号。</li></ul><h1 id="任务的取消">任务的取消</h1><h1 id="context-与任务取消">Context 与任务取消</h1><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557062963366-c9338325-f390-4dce-ae1d-f0874f9612ba.png#align=left&amp;display=inline&amp;height=372&amp;name=image.png&amp;originHeight=298&amp;originWidth=786&amp;size=58395&amp;status=done&amp;width=982.4999853596094" alt="image.png"></p><h2 id="context">Context</h2><ul><li>根 Context：通过 context.Background()创建</li><li>子 Context：context.WithCancel(parentContext)创建</li><li>ctx,cancel：context.WithCancel(context.Background())</li><li>当前 Context 被取消时，基于他的子 context 也会被取消</li><li>接收取消通知&lt;-ctx.Done()</li></ul><p>还有一些其他的方法</p><h1 id="典型并发任务">典型并发任务</h1><h2 id="只运行一次-常见的并发任务">只运行一次（常见的并发任务）</h2><p>在常见的多任务环境下，只执行一次。单例模式（懒汉式，线程安全）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleInstance *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSingletonObj</span><span class="params">()</span> *<span class="title">Singleton</span></span>&#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;    <span class="comment">//传入创建方法</span></span><br><span class="line">fmt.Println(<span class="string">"Create Obj"</span>)</span><br><span class="line">singleInstance=<span class="built_in">new</span>(Singleton)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> singleInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所需任意任务完成">所需任意任务完成</h2><h2 id="所有任务完成">所有任务完成</h2><h2 id="对象池">对象池</h2><p>数据库连接，网络连接，经常将这些对象池化，避免重复创建。</p><h2 id="sync-pool-对象缓存">sync.pool 对象缓存</h2><p>从名字来看，像是 go 语言提供的池。其实是对象的缓存<img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557066107461-3144bf63-f63c-4522-b25d-af4bd721daab.png#align=left&amp;display=inline&amp;height=517&amp;name=image.png&amp;originHeight=414&amp;originWidth=846&amp;size=118933&amp;status=done&amp;width=1057.4999842420223" alt="image.png"></p><ul><li>如果私有对象不存在则保存为私有对象</li><li>如果私有对象存在，就放入当前 Processor 子池的共享池中</li></ul><p>使用：<img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557066277648-e57411da-71d5-4673-93bc-a82e0315284b.png#align=left&amp;display=inline&amp;height=341&amp;name=image.png&amp;originHeight=273&amp;originWidth=497&amp;size=37422&amp;status=done&amp;width=621.2499907426537" alt="image.png"></p><p>**sync.pool 对象的生命周期—**sync.pool 不能作为对象池的原因</p><ul><li>GC 会清除 sync.pool 缓存的对象</li><li>sync.pool 对象的缓存有效期为下一次 GC 之前</li></ul><p>总结：</p><ul><li>适合于通过复用，降低复杂对象的创建和 GC 代价</li><li>协程安全，会有锁的开销</li><li>声明周期受 GC 影响，不适合于做连接池等，需自己管理生命周期资源的池化</li><li>所以具体要看锁的开销大，还是初始化的开销大</li></ul><h1 id="测试">测试</h1><h2 id="单元测试">单元测试</h2><p>表格测试</p><h3 id="内置单元测试框架">内置单元测试框架</h3><ul><li>Fail，Error：该测试失败，该测试继续，其他测试继续执行</li><li>FailNow，Fatal：该测试失败，该测试中止，其他测试继续执行</li></ul><p>代码覆盖率</p><h2 id="benchmark">Benchmark</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557067837101-3bdadb6b-821f-4dbd-9b3a-c9efe304bc7a.png#align=left&amp;display=inline&amp;height=491&amp;name=image.png&amp;originHeight=393&amp;originWidth=679&amp;size=77590&amp;status=done&amp;width=848.7499873526397" alt="image.png">以 Benchmark 开头，参数类型稍有不同。通过 ResetTimer 和 StopTimer 将测试代码隔开</p><p>命令行下运行：</p><h2 id="bbd">BBD</h2><p>Behavior Driven Development常用框架：goconvey</p><h2 id="反射编程">反射编程</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557107233067-f50d5086-e384-46cc-bd5e-0a2446ec3d8f.png#align=left&amp;display=inline&amp;height=390&amp;name=image.png&amp;originHeight=312&amp;originWidth=820&amp;size=64732&amp;status=done&amp;width=1024.99998472631" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557107389241-fb6b5237-7e73-48e9-83a9-e6c6ae45f6aa.png#align=left&amp;display=inline&amp;height=356&amp;name=image.png&amp;originHeight=285&amp;originWidth=755&amp;size=35453&amp;status=done&amp;width=943.7499859370294" alt="image.png"></p><h2 id="万能程序">万能程序</h2><p>DeepEqual比较切片和 map与配置相关的，要求灵活性和复用性时，可以反射的</p><h2 id="不安全编程">不安全编程</h2><p>unsafe，一般涉及到库的交互，与 c 语言交互。“不安全”行为危险性：Go 语言中不支持强制类型转换。下列操作看似可以，实际不能转换，而且实际使用起来很危险。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i:&#x3D;10</span><br><span class="line">f:&#x3D;*(*floa64)(unsafe.Pointer(&amp;i))</span><br></pre></td></tr></table></figure><p>场景 2：用到内置的 Atomic 操作，指针原子操作，并发读写</p><h1 id="架构模式">架构模式</h1><h2 id="pipe-filter-架构">Pipe-Filter 架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557108759332-46d3b8e2-5573-419b-80b6-63cfbf5feaa1.png#align=left&amp;display=inline&amp;height=510&amp;name=image.png&amp;originHeight=408&amp;originWidth=782&amp;size=86362&amp;status=done&amp;width=977.4999854341152" alt="image.png"></p><ul><li>非常适合与数据处理及数据分析系统<img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557108843135-278143cd-9e6a-4b4f-ae49-b800e98a261c.png#align=left&amp;display=inline&amp;height=474&amp;name=image.png&amp;originHeight=379&amp;originWidth=690&amp;size=86777&amp;status=done&amp;width=862.4999871477487" alt="image.png"></li></ul><h2 id="micro-kernel">micro kernel</h2><p>特点：易于拓展，错误隔离，保持架构一致性要点：</p><ul><li>内核包含公共流程或通用逻辑</li><li>将可变成或可扩展部分规划为扩展点</li><li>抽象扩展点行为，定义接口</li><li>利用插件进行扩展</li></ul><p>生产过程任务的开发</p><h2 id="内置-json-解析">内置 json 解析</h2><p>远程过程调用等过程中，会用 json，以及在配置文件中，很多使用 json</p><h2 id="easyjson">easyjson</h2><p>go 内置的，一般适用于配置文件解析，对于 qps 较高，运用了反射，效率较低。尽量使用高性能的 json 解析</p><h2 id="http-服务">HTTP 服务</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557111353880-2f261975-45c5-4dcd-9281-44ac48f2fbcb.png#align=left&amp;display=inline&amp;height=442&amp;name=image.png&amp;originHeight=354&amp;originWidth=862&amp;size=103367&amp;status=done&amp;width=1077.499983943999" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557111366213-f5138ca3-fd5f-4da1-992a-f68e1681d3ff.png#align=left&amp;display=inline&amp;height=445&amp;name=image.png&amp;originHeight=356&amp;originWidth=771&amp;size=101595&amp;status=done&amp;width=963.7499856390061" alt="image.png"></p><h2 id="构建-restful-服务">构建 Restful 服务</h2><p>更好的 router，httprouter面向资源的架构（Resource Oriented Architecture）</p><h2 id="性能分析工具">性能分析工具</h2><p>学习函数式编程：《计算机程序的构造和解释》functional programming《Restful Web Service》《Go 程序设计语言》《面向模式的软件架构》1,2,3 本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一个-go-程序&quot;&gt;第一个 go 程序&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;go 语言主函数没有返回值，需要使用 os 包， &lt;code&gt;os.exit()&lt;/code&gt; ，也不能直接函数传参。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;变量-常量和其他语言的区别&quot;&gt;变量、
      
    
    </summary>
    
      <category term="Golang" scheme="http://www.yuguocong.cn/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://www.yuguocong.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习基础(3)</title>
    <link href="http://www.yuguocong.cn/2019/01/25/yuque/MySQL%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80(3)/"/>
    <id>http://www.yuguocong.cn/2019/01/25/yuque/MySQL学习基础(3)/</id>
    <published>2019-01-25T01:56:46.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三大范式">三大范式</h1><p>**第一范式（1NF）：**无重复的列。要求：表所有的属性不可再分。如果不符合第一范式，则不符合关系模型的定义。**第二范式（2NF）：**属性完全依赖于主键 [ 消除部分子函数依赖 ]。要求：在满足 1NF 前提，每一行能够唯一标识，不存在非主键字段。常用方法可以增加一个单字段的主键。<strong>第三范式（3NF）</strong>：属性不依赖于其它非主属性 [ 消除传递依赖 ]。要求：在满足 2NF 前提，不出现类似于 A-&gt;B-&gt;C 的情况，这样的传递依赖可以分为两个表，分别保存。</p><p>通用的原则：</p><ul><li>每个实体都有一个表。</li><li>为每一个关系（二维表）增加一个逻辑主键作为标识。</li><li>出现二维表对应的关系，采用 1:1, 1:N, M:n 的形式将关联关系设计。</li></ul><h1 id="mysql-日志类型">MySQL 日志类型</h1><p><strong>错误日志</strong>：记录启动、运行或停止 mysqld 时出现的问题<strong>查询日志</strong>：记录建立的客户端连接和执行的所有语句（包括错误的）<strong>二进制日志</strong>：记录所有更改数据的语句、还用于主从复制<strong>慢日志</strong>：记录所有执行时间超过 long_query_time 秒的所有查询</p><h1 id="索引">索引</h1><p>索引：对数据库表中一或多个列的值进行排序的结构，是帮助 MySQL 高效获取数据的数据结构，可以 加快检索表中的数据，而不必扫描整个数据库。缺点是：需要占用额外的空间，并且需要定期维护，每条记录的 INSERT,DELETE,UPDATE 操作可能付出更多的磁盘 IO。同时不必要的索引反而会使查询速度变慢。索引查询的适用的情况：基于一个范围的检索，一般查询返回结果集小于表中记录数的 30%。基于非唯一性索引的检索。数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</p><h1 id="事务">事务</h1><p>事务：并发控制的基本单位，是一个操作序列，这些操作要么都执行，要么都不执行，是一个不可分割的工作单位。</p><h2 id="事务的隔离级别">事务的隔离级别</h2><p>分为四个级别：<br>未提交读:允许脏读，可能读到其他会话没有提交的数据。已提交读:只能读到已经提交的数据。ORACAL 等多数数据库的默认隔离级别。<br>可重复读:可重复读，同一事务内的查询都是和事务开始时一致的，Innodb 的默认隔离级别。<br>串行读：完全串行化的读，每次读都需要获得表级共享锁，读写相互会阻塞。</p><p>对应：脏读、不可重复读、幻读情况为：脏读：当一个事务正在访问数据，并且对数据进行了修改，这个修改还没提交到数据库。另一个事务也访问这个数据，使用了这个数据。  不可重复读：一个事务内，多次读同一数据。这个事务还没结束时，另一个事务也访问这个数据，导致第一个事务两次访问的数据不一样。  幻读：第一个事务对表中的每一行数据进行了修改，同时第二个事务也访问这个表中的数据，这种修改是向表中插入而来一行数据，那么以后就会发生操作第一个事物的用户表中发现表中还有没修改的数据行，像是产生了幻觉。<a href="https://www.cnblogs.com/zhoujinyi/p/3437475.html" target="_blank" rel="noopener">MySQL 四种事务隔离级的说明</a></p><h1 id="drop-delete-与-truncate">DROP、DELETE 与 TRUNCATE</h1><p>DROP：不仅删除表的数据，还删除表的结构。DELETE 和 TRUNCATE 只删除表的数据不删除表的结构。删除速度：DROP&gt; DELETE&gt;TRUNCATE适用场景：当不需要一张表的时候，适用 DROP；删除部分数据行的时候，用 DELETE，并且使用 where 子句；保留表而删除所有数据的时候用 TRUNCATE。</p><h1 id="存储引擎">存储引擎</h1><p>MySQL 目前用的比较多的两种，是 Innodb 和 Myisam</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三大范式&quot;&gt;三大范式&lt;/h1&gt;
&lt;p&gt;**第一范式（1NF）：**无重复的列。
要求：表所有的属性不可再分。
如果不符合第一范式，则不符合关系模型的定义。
**第二范式（2NF）：**属性完全依赖于主键 [ 消除部分子函数依赖 ]。
要求：在满足 1NF 前提，每
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习总结(2)</title>
    <link href="http://www.yuguocong.cn/2019/01/23/yuque/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/"/>
    <id>http://www.yuguocong.cn/2019/01/23/yuque/MySQL学习总结2/</id>
    <published>2019-01-23T12:23:55.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在关系型数据库里面，每个实体有自己的一张表，所有属性都是这张表的字段，表与表之间根据关联字段&quot;连接&quot;在一起。</p></blockquote><h1 id="什么是连接">什么是连接</h1><p><strong>两张表根据关联字段，组合成一个数据集。当两张表的关联字段不匹配时，例如表 A 和表 B，处理方式为：</strong></p><ul><li>只返回两张表匹配的记录，内连接（inner join）。</li><li>返回匹配的记录，以及表 A 多余的记录，左连接（left join）。</li><li>返回匹配的记录，以及表 B 多余的记录，右连接（right join）。</li><li>返回匹配的记录，以及表 A 和表 B 各自的多余记录，全连接（full join）。</li></ul><p>这里看到了阮一峰老师的一个总结，引用了图片：             <img src="https://cdn.nlark.com/yuque/0/2019/jpeg/187932/1548247519305-bff75e42-9992-499e-9c1b-d75b9e56fe13.jpeg#align=left&amp;display=inline&amp;height=295&amp;originHeight=295&amp;originWidth=602&amp;size=0&amp;status=done&amp;width=602" alt=""></p><h1 id="内连接-inner-join">内连接（inner join）</h1><ul><li>MySQL 默认的连接就是内连接，可以省略 inner。</li><li>有条件的内连接：</li></ul><p>where：数据过滤，理解上，数据交叉连接完成后再进行过滤。on：在连接时，就对数据进行判断。using：要求负责连接的两个实体之间的字段名称一致。      在有同名字段时，使用 using，通用条件时，使用 on，在数据过滤时（不是连接的过滤）时，使用 where。</p><h1 id="外连接-outer-join">外连接（outer join）</h1><p>连接的数据不真实存在。意思是外连接的两个表，存在单个表中没有的数据。</p><h2 id="左连接-left-join">左连接（left join）</h2><p>在连接时，出现了左边表连接不到右边表的情况，则左边表的数据会被保留，而右边表的数据连接不到左表的情况，会被抛弃。</p><h2 id="右连接-right-join">右连接（right join）</h2><p>在连接时，出现了左边表连接不到右边表的情况，则数据会被抛弃，而右边表的数据连接不到左表的情况，会被保留。</p><h2 id="全连接-full-join">全连接（full join）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在关系型数据库里面，每个实体有自己的一张表，所有属性都是这张表的字段，表与表之间根据关联字段&amp;quot;连接&amp;quot;在一起。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;什么是连接&quot;&gt;什么是连接&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;两张表根
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】MySQL学习基础(1)</title>
    <link href="http://www.yuguocong.cn/2019/01/14/yuque/MySQL%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80(1)/"/>
    <id>http://www.yuguocong.cn/2019/01/14/yuque/MySQL学习基础(1)/</id>
    <published>2019-01-14T13:18:27.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库和-sql">数据库和 SQL</h1><p>SQL(StructuredQuery Language)：结构化查询语言。包括 DDL（Data Definition Language 数据定义语言）、DML（Data Management Language 数据管理语言）、DCL（Data Control Language 数据库控制语言）。其中 DML 包括：DQL（Data Query Language 数据查询语言）和 DML（Data Management Language 数据管理语言），一般来说，数据查询和管理都称为数据管理语言。</p><h1 id="安装"><a href="">安装</a></h1><h1 id="基础">基础</h1><h2 id="dml">DML</h2><h3 id="数据库操作">数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">database</span> db_name;   <span class="comment"># 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">database</span> db_name <span class="keyword">if</span> <span class="keyword">not</span> exits;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库查询</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">databases</span>;   <span class="comment"># 查看当前存在的数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name;  <span class="comment"># 查看数据库创建的语言，显示结果为</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择数据库</span></span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">database</span>;  <span class="comment"># 操作表时会使用默认的数据库，所以需要先使用USE表示使用的是哪一个数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据库中表</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span> [<span class="keyword">like</span> <span class="string">'pattern_%'</span>]; <span class="comment"># 可以使用通配符匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">database</span> db_name;   <span class="comment">#还有其他的两种，记得区分结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">database</span> db_name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库权限修改</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.* <span class="keyword">TO</span> <span class="string">'your_mysql_name'</span>@<span class="string">'your_client_host'</span>; <span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="表操作">表操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_name (列结构)[表选项]</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet (<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>), owner <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">                   species <span class="built_in">VARCHAR</span>(<span class="number">20</span>), sex <span class="built_in">CHAR</span>(<span class="number">1</span>), birth <span class="built_in">DATE</span>, death <span class="built_in">DATE</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从外部导入数据到表</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'/path/pet.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> pet</span><br><span class="line">       <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\r\n'</span>;  <span class="comment"># 从本地导入，分隔符为"\r\n"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据到表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> pet</span><br><span class="line">       <span class="keyword">VALUES</span> (<span class="string">'Puffball'</span>,<span class="string">'Diane'</span>,<span class="string">'hamster'</span>,<span class="string">'f'</span>,<span class="string">'1999-03-30'</span>,<span class="literal">NULL</span>); <span class="comment"># 如果设置了NOT NULL，则需要</span></span><br><span class="line">       在插入数据的时候该项有值</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 修改列定义</span></span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name[<span class="keyword">ADD</span>|<span class="keyword">DROP</span>|<span class="keyword">CHANGE</span>|<span class="keyword">MODIFY</span>] <span class="comment">#添加|删除|重命名|修改</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 修改表选项</span></span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name 新的表选型</span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> pet <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> UTF8;</span><br></pre></td></tr></table></figure><h3 id="数据操作">数据操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name (field_list) <span class="keyword">VALUES</span> (<span class="keyword">values</span>); <span class="comment">#</span></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="keyword">SELECT</span> field_list <span class="keyword">FROM</span> tbl_name conditions;</span><br><span class="line"><span class="keyword">SELECT</span> field_list <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> conditions <span class="keyword">LIKE</span> <span class="string">'a%'</span>; <span class="comment"># %为通配符</span></span><br><span class="line"><span class="keyword">SELECT</span> field_list <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> <span class="keyword">REGEXP_LIKE</span>(field_name,regex); <span class="comment"># 使用正则表达式匹配</span></span><br><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tbl_name conditions;</span><br><span class="line"><span class="comment"># 修改数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> tbl_name <span class="keyword">SET</span> <span class="keyword">field</span>=new_value, conditions;</span><br></pre></td></tr></table></figure><h2 id="mysql-数据类型">Mysql 数据类型</h2><h3 id="整型-默认有符号-无符号要指定-unsigned">整型:默认有符号，无符号要指定 unsigned</h3><p>TINYINT:1 字节 无符号：-128—127  有符号： 0—255SMALLINT:2 字节 无符号：-32768—32767 有符号：0-65536MEDIUMINT：3 字节INT：4 字节BIGINT:8 字节可以听过类似 INT(2)表示显示的宽度，显示宽度不影响数值的范围，只是为了表示</p><h3 id="小数">小数</h3><p><strong>浮点数： **  可以通过</strong>TYPE(M,D)**控制数值位数，M 为所有的数值位数，D 为小数位数float：单精度浮点数，默认精度位数为 6 左右double：双精度浮点数，默认精度 16 左右** 定点数： DECIMAL(M,D) **同样的 M 为所有的数值位数，D 为小数位数，M 默认为 10，D 默认为 0</p><h3 id="日期和时间">日期和时间</h3><table><thead><tr><th style="text-align:center">DATATIME</th><th style="text-align:center">8</th><th style="text-align:center">YYYY-MM-DD HH:MM:SS</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">TIMESTAMP</td><td style="text-align:center">4</td><td style="text-align:center">YYYY-MM-DD HH:MM:SS</td><td style="text-align:center">从 1970 年开始</td></tr><tr><td style="text-align:center">DATE</td><td style="text-align:center">3</td><td style="text-align:center">YYYY-MM-DD</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TIME</td><td style="text-align:center">3</td><td style="text-align:center">HH:MM:SS</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">YEAR</td><td style="text-align:center">1</td><td style="text-align:center">YYYY</td><td style="text-align:center">范围为 1901-2155</td></tr></tbody></table><h3 id="字符串">字符串</h3><p>**CHAR(M) :**表示固定长度。M 表示允许的字符串长度,限制了字符串的长度**VARCHAR(M): **可变长度 。M 表示允许的最大长度，在内存中表示，需要多一个字节保存字符串的总长度，因此如果有时候不是很需要改变长度的话，尽量用固定长度的 CHAR</p><h2 id="列属性">列属性</h2><h3 id="主键">主键</h3><p>可以唯一标识某条记录的字段或字段的集合。通常的做法是，设计每个表存在一个可以唯一标识的主键字段，最好利用与实体信息不相关的属性，作为唯一标识，与业务逻辑不发生关系，只用来记录标识，例如 ID。设置方式：在字段上设置或者定义完字段后再定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在字段上设置</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> (<span class="number">5</span>));</span><br><span class="line"><span class="comment"># 定义完字段后再设置</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet1 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> (<span class="number">5</span>),PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>));</span><br></pre></td></tr></table></figure><h3 id="自动增长">自动增长</h3><p>为每条记录提供唯一的标识，每次插入记录时，某个字段的值都自动加 1，使用 auto_increment 标识。要求需要整型和索引。在插入数据的时候，可以选择插入 null 也可以不插入。  自动增长的初始值默认是 1，也可以通过 auto_increment n 重新设置从 n 开始增长。也可以手动插入自动增长的值，但是如果是主键的话，不能重复。</p><h1 id="注意事项">注意事项</h1><ul><li>数据库语言关键字一般用大写，虽然大小写都可以，但是为了区分。</li><li>数据库名的大小写取决于系统，所以操作的时候尽量有自己的规范，进行大小写区分。</li><li>NULL 是区别于 0 或者’ '的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库和-sql&quot;&gt;数据库和 SQL&lt;/h1&gt;
&lt;p&gt;SQL(Structured
Query Language)：结构化查询语言。包括 DDL（Data Definition Language 数据定义语言）、DML（Data Management Langua
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="http://www.yuguocong.cn/2018/12/16/yuque/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://www.yuguocong.cn/2018/12/16/yuque/2018年终总结/</id>
    <published>2018-12-16T11:02:22.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018 年总结。</p></blockquote><a id="more"></a>  <blockquote><p>2018 已经到了尾声了，还从来没好好总结一年，该养成及时总结反思的习惯。</p></blockquote><h1 id="学习">学习</h1><ul><li><p>找工作相关的内容：编程语言 C++/Python/Shell 脚本等，计算机网络、数据库、操作系统、服务器 Nginx 都有了一定的学习和总结，但是还是理论的较多一些，实践倒是有，但是还远远不够。</p></li><li><p>跟着 github 上写了个 C++的 web 服务器，不过还是有很多不明白，只是面试的时候能讲一讲。</p></li><li><p>另外找完工作后，开始要学习 Go 语言，还有数据库的基础，其实总觉得数据库自己掌握的还是很少，而且以后就是 DBA 了，更要把基础打劳一点。</p></li></ul><h1 id="工作">工作</h1><p>首先今年最重要的就是找工作了，说实话，找工作的策略并不是很好，但是也是跟自己的复习有关系吧，对于数据结构和算法，看了很多，自己也刷了很多题，但是一些复杂的算法，以及广度还是不够，所以在面试的时候遇到难点的算法题就很虚。另外就是找工作的策略上，海投的时候投了很多，以至于找工作的很多的精力都花在了不想去的公司上，而好几个大公司都没有准备好。</p><p>拿到的 Offer 还是很乱的，国企、研究所、互联网基本上都有。总结下 Offer 有：  国企银行：银联、招银网络  研究所：航天 804、中电 20 所、中电 54 所、中船重工 701  互联网：老虎证券、竞技世界、vipkid、好未来、新思科技、oppo、海康威视、大华、小米等  最后看其实找到的工作也不是很好，其实也有个原因是小米很早给了意向就不是很想找了，很多面试都没去。策略有些问题，不过最后的结果也还不错，能回武汉工作。当然找工作的过程其实也有很大的收获，不只是技术上的，还有心理上的。</p><p>关于实验室的工作，就还是那样，感觉自己的态度有一些问题，就是太不重视了，总是以老板为驱动，总想着自己以后也不从事这方面，就比较不在意，这样就有些问题。</p><h1 id="生活">生活</h1><p>关于身体健康。减肥这个事情，说了很多遍，也有的时候能坚持，但是还是一直保重的状态。而且年底马上就要去当伴郎了，作为伴郎里最胖的一个，压力很大呀。今年看来希望渺茫了，把 flag 留给明年吧。</p><p>关于读书。最近也都很久没看了。今年除了找工作看的一些专业书外，别的都看的很少了，需要加强呀。</p><p>关于感情。跟亲爱的在一起了，到今天也已经 300 天了，时间过得很快，异地恋其实在一起的时间也不是很多，刚刚到一个月，但是互相很能为对方着想，有问题积极解决，保持几乎每天都开视频。不过关于两人的相处，还有很多需要慢慢改进。也剩明年半年的异地了，期待明年。</p><p>关于家人朋友。爷爷今年去世了，享年 85 岁。小时候爸妈不在家，基本上爷爷奶奶从小把我带大，远在西安的我没能看到最后一面，虽然知道这一天总是会来，但是觉得太快了，以后再也没有过年在家吃饭的时候还叫上我一起陪着喝个白酒的了，喝了酒又开始讲自己小时候躲日本鬼子，年轻的时候修长江大桥了，讲以前穷日子的时候了。。你总是在长大，只是时间让你感觉长大的方式不再那么温柔了。</p><h1 id="流水">流水</h1><ul><li><p>2.24 开始跟亲爱的在一起</p></li><li><p>3 月，开始准备 miniweb</p></li><li><p>4 月，参加华为的比赛，但是没有进 64</p></li><li><p>7 月，爷爷</p></li><li><p>8-9 月，找工作</p></li></ul><h1 id="总结">总结</h1><p>总之，关于 2018 年，是失去也是收获的一年，但是不管怎么样，那都是这一年的自己，也需要更好的总结来让新的一年变得更好。</p><ul><li><p>保持专注和思考。一直觉得认真是自己的优势之一，但是今年却感觉做很多事情的时候，不是很能专注，做事的效率不是很高了。另一个是抓住重点，时间有限，尽量做更有价值的事情，把时间看做重要的成本。这永远是核心竞争力的保证。</p></li><li><p>学会沟通。通过谈恋爱，以前觉得自己是一个很爱说话的人，很喜欢开玩笑的人，但现在发现自己不是一个很会沟通的人。现在发现这两个还是有区别的，笑的再好，不会沟通，问题还在那，只不过暂时忘了而已。</p></li><li><p>学会自律。自律才能自由，用自己的想法约束自己的行为，这才是更高程度的自由，而不是想吃就吃，想玩就玩。</p></li><li><p>提高自己。身体上，精神上。看书和锻炼，</p></li></ul><h1 id="2019-计划">2019 计划</h1><p>一年之计在于春，先提前订点小目标吧。等年底了再来看。</p><ul><li><p>看 50 本书，包括专业书和业余书。专业书主要是接下来工作需要的，数据库和 Go 语言方面。业余书主要关注历史和经济。</p></li><li><p>锻炼身体。把肚子减下去，要在 130 一下了吧，咳咳。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018 年总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.yuguocong.cn/categories/life/"/>
    
    
      <category term="生活" scheme="http://www.yuguocong.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="http://www.yuguocong.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title> CentOS7安装并使用MySQL</title>
    <link href="http://www.yuguocong.cn/2018/12/07/yuque/CentOS7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8MySQL/"/>
    <id>http://www.yuguocong.cn/2018/12/07/yuque/CentOS7安装并使用MySQL/</id>
    <published>2018-12-07T09:41:58.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MySQL 在 CentOS 上的安装和使用</p></blockquote><a id="more"></a>  <h1 id="yum-安装">yum 安装</h1><p>date: 2018-12-9 21:57:59update: 2018-12-9 21:57:59 1.首先找到官网 yum 的地址：<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a>，找到 redhat 的版本<strong>Red Hat Enterprise Linux 7 / Oracle Linux 7 (Architecture Independent), RPM Package</strong>,并复制 download 的地址，然后下载下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.进行 rpm 解包并安装 mysql-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">yum update</span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure><p>3.修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown mysql:mysql -R /var/lib/mysql</span><br></pre></td></tr></table></figure><p>4.然后就可以启动 mysql 了。。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><h1 id="问题记录">问题记录</h1><p>当然，看着上面好像很爽，很快的样子，但是没想到接下来坑还是很多的。都有点怀疑自己了，到现在装个 mysql 还这么多问题。关键是，网上的解决办法，都是什么乱七八糟的。</p><h2 id="1-状态查看-灰色">1.状态查看-灰色</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl status mysqld</span><br><span class="line">● mysqld.service - MySQL Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:mysqld(<span class="number">8</span>)</span><br><span class="line">           http://dev.mysql.com/doc/refman/en/using<span class="literal">-systemd</span>.html</span><br><span class="line"></span><br><span class="line">➜  ~ ps ajx | grep mysql</span><br><span class="line"> <span class="number">1768</span>  <span class="number">1784</span>  <span class="number">1784</span>  <span class="number">1784</span> ?           <span class="literal">-1</span> Ssl    <span class="number">999</span>   <span class="number">0</span>:<span class="number">19</span> mysqld</span><br></pre></td></tr></table></figure><p>1.看了一下版本号，没错是 8.0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mysqladmin --version</span><br><span class="line">mysqladmin  Ver 8.0.13 <span class="keyword">for</span> Linux on x86_64 (MySQL Community Server - GPL)</span><br></pre></td></tr></table></figure><p>2.然后 mysql 连一波，出问题，连不上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mysql</span><br><span class="line">ERROR 2002 (HY000): Can<span class="string">'t connect to local MySQL server through socket '</span>/var/lib/mysql/mysql.sock<span class="string">' (2)</span></span><br></pre></td></tr></table></figure><p>看样子是没有这个 socket，应该是位置不对，于是<code>sudo find / -name mysql.sock</code>赶紧搜一下，什么都没有，没有办法，重启一下试试吧。 3.重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo systemctl restart mysqld</span><br><span class="line">Job <span class="keyword">for</span> mysqld.service failed because the control process exited with error code. See <span class="string">"systemctl status mysqld.service"</span> and <span class="string">"journalctl -xe"</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>不行，换种方式重启看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ service mysqld start</span><br><span class="line">Redirecting to /bin/systemctl start mysqld.service</span><br><span class="line">==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===</span><br><span class="line">Authentication is required to manage system services or units.</span><br><span class="line">Authenticating as: root</span><br><span class="line">Password:</span><br><span class="line">polkit-agent-helper-1: pam_authenticate failed: Authentication failure</span><br><span class="line">==== AUTHENTICATION FAILED ===</span><br><span class="line">Failed to start mysqld.service: Access denied</span><br><span class="line">See system logs and <span class="string">'systemctl status mysqld.service'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><h2 id="2-错误：2002">2.错误：2002</h2><p>错误详情：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2)</p><p>这个错误网上找了一下，有看起来还可以的处理:<a href="http://blog.51cto.com/pengjc/1861088" target="_blank" rel="noopener">http://blog.51cto.com/pengjc/1861088</a> 。但是实际上我打开都没有这个文件，搜也没有搜到，于是放弃，这个问题应该不算个问题，先放着解决别的。</p><h2 id="3-错误：service-failed">3.错误：service failed</h2><p>错误详情：Job for mysqld.service failed because the control process exited with error code. See “systemctl status mysqld.service” and “journalctl -xe” for details.看了一下网上的解决办法，说是由于权限的问题：<a href="https://www.cnblogs.com/ivictor/p/5146247.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivictor/p/5146247.html</a> ，通过命令<code>chown mysql.mysql /var/run/mysqld/</code>，但是问题还是没有解决。  看了一下<a href="https://stackoverflow.com/questions/42317139/job-for-mysqld-service-failed-see-systemctl-status-mysqld-service" target="_blank" rel="noopener">stackoverflow</a>上面的说法，先通过<code>tail -f /var/log/mysqld.log</code>查看一下,，但是我的这个问题不是因为没有权限，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~  tail /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line">2018-12-07T09:13:21.651467Z 0 [ERROR] [MY-010119] [Server] Aborting</span><br><span class="line">2018-12-07T09:13:21.655750Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.13)  MySQL Community Server - GPL.</span><br><span class="line">2018-12-07T09:15:40.466437Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.13) starting as process 12759</span><br><span class="line">2018-12-07T09:15:40.965670Z 0 [ERROR] [MY-012681] [InnoDB] mmap(137428992 bytes) failed; errno 12</span><br><span class="line">2018-12-07T09:15:40.965740Z 1 [ERROR] [MY-012956] [InnoDB] Cannot allocate memory <span class="keyword">for</span> the buffer pool</span><br><span class="line">2018-12-07T09:15:40.965766Z 1 [ERROR] [MY-012930] [InnoDB] Plugin initialization aborted with error Generic error.</span><br><span class="line">2018-12-07T09:15:40.965794Z 1 [ERROR] [MY-010334] [Server] Failed to initialize DD Storage Engine</span><br><span class="line">2018-12-07T09:15:40.965949Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed.</span><br><span class="line">2018-12-07T09:15:40.965977Z 0 [ERROR] [MY-010119] [Server] Aborting</span><br><span class="line">2018-12-07T09:15:40.966835Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.13)  MySQL Community Server - GPL.</span><br></pre></td></tr></table></figure><p>搜了一下这个问题：<code>[ERROR] [MY-012681] [InnoDB] mmap(137428992 bytes) failed; errno 12</code>看样子是内存映射出错，再通过命令<code>journalctl -xe</code>看一下,同时也找到了原因：原来是<strong>swap 分区是 0(https://blog.csdn.net/sxyandapp/article/details/77091007),于是一阵操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ free -m</span><br><span class="line">/dev/vda1            /                    ext4       noatime,acl,user_xattr 1 1</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            992         516         304           0         171         321</span><br><span class="line">Swap:             0           0           0</span><br><span class="line"></span><br><span class="line">➜  ~ dd <span class="keyword">if</span>=/dev/zero of=/swap bs=1M count=512</span><br><span class="line">dd: failed to open ‘/swap’: Permission denied</span><br><span class="line"></span><br><span class="line">➜  ~ sudo dd <span class="keyword">if</span>=/dev/zero of=/swap bs=1M count=512</span><br><span class="line">512+0 records <span class="keyword">in</span></span><br><span class="line">512+0 records out</span><br><span class="line">536870912 bytes (537 MB) copied, 4.01658 s, 134 MB/s</span><br><span class="line"></span><br><span class="line">➜  ~ sudo mkswap /swap</span><br><span class="line">Setting up swapspace version 1, size = 524284 KiB</span><br><span class="line">no label, UUID=9bbac588-e6ee-4b1c-a398-4ac460ad476a</span><br><span class="line"></span><br><span class="line">➜  ~ sudo swapon /swap</span><br><span class="line">swapon: /swap: insecure permissions 0644, 0600 suggested.</span><br><span class="line"></span><br><span class="line">➜  ~ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            992         516          64           0         410         317</span><br><span class="line">Swap:           511           0         511</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vi /etc/fstab</span><br><span class="line"><span class="comment">#在其中添加如下一行,保证下次系统启动后，此swap分区被自动加载，需要修改系统的fstab文件</span></span><br><span class="line">/swap swap swap defaults 0 0</span><br></pre></td></tr></table></figure><p>之后再重启就好了。</p><h2 id="4-错误：登录问题">4.错误：登录问题</h2><p>错误详情：error: ‘Access denied for user ‘root’@‘localhost’ (using password: NO)’</p><p>这个其实是密码的问题，没有设置密码的时候，mysql 会生成一个临时的密码，通过命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo grep <span class="string">'temporary password'</span> /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line">2018-12-07T09:08:22.908621Z 5 [Note] [MY-010454] [Server] A temporary password is generated <span class="keyword">for</span> root@localhost: TdqPeZ-n;4Ah</span><br></pre></td></tr></table></figure><p>可以看到生成的临时密码，然后用临时密码登录即可。</p><h2 id="5-修改密码">5.修改密码</h2><p>可能因为 8.0 的版本，修改的密码不能过于简单，并且命令好像也有些不一样了，用的是``</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'MyNewPass'</span>;</span><br></pre></td></tr></table></figure><p>看到一个别人的回答：<img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1544177770052-39cd9fe0-1c11-4059-be21-08de2d19446b.png#align=left&amp;display=inline&amp;height=148&amp;originHeight=148&amp;originWidth=695&amp;status=done&amp;width=695" alt="">应该是后面才改的？</p><h1 id="6-外网连接-mysql">6.外网连接 mysql</h1><p>由于两台服务器的版本有点不一样，修改外网连接也有点不一样。</p><h2 id="mysql5-7"><a href="https://blog.csdn.net/w20228396/article/details/70143500" target="_blank" rel="noopener">MySQL5.7</a></h2><p>1.修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf   <span class="comment"># bind-address=127.0.0.1 修改成 bind-address=0.0.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">service mysql restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程连接mysql的账号</span></span><br><span class="line">&gt; grant all on *.* to root@<span class="string">'%'</span> identified by <span class="string">'123456'</span>;</span><br><span class="line">&gt; flush privileges;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">*.*          第一个*表示库，第二个*表示表; *.*对全部数据库的全部表授权，so.ok 表示只对so这个库中的ok表授权</span><br><span class="line">root        表示要给哪个用户授权，这个用户可以是存在的用户，也可以是不存在的</span><br><span class="line"><span class="string">'%'</span>          表示允许远程连接的IP地址，%代表允许所有IP连接</span><br></pre></td></tr></table></figure><h2 id="mysql8-0"><a href="https://stackoverflow.com/questions/50177216/how-to-grant-all-privileges-to-root-user-in-mysql-8-0" target="_blank" rel="noopener">MySQL8.0</a></h2><p>8.0 的版本总结的对权限的管理严格很多，毕竟数据很重要，只有安全才能放心。尝试过上述方式，但是连接不上。最终在 Stack Overflow 上找到了办法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'root'</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>但是修改之后还是会有问题，出现了 2059 错误：  <img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1544449883818-59e9985f-7a74-47f5-954e-4e8aa80ced7c.png#align=left&amp;display=inline&amp;height=129&amp;originHeight=129&amp;originWidth=586&amp;status=done&amp;width=586" alt="">解决方式可以采用修改密码为简单密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL validate_password.policy=0;</span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'12345678'</span>;</span><br></pre></td></tr></table></figure><h1 id="使用过程问题">使用过程问题</h1><h2 id="1-导入数据出错">1.导入数据出错</h2><p>错误代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD DATA LOCAL INFILE &#39;&#x2F;home&#x2F;mianhk&#x2F;pet.txt&#39; INTO TABLE pet;</span><br><span class="line">ERROR 1148 (42000): The used command is not allowed with this MySQL version</span><br><span class="line"></span><br><span class="line">mysql&gt; LOAD DATA INFILE &#39;&#x2F;home&#x2F;mianhk&#x2F;pet.txt&#39; INTO TABLE pet;</span><br><span class="line">ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it ca</span><br><span class="line">nnot execute this statement</span><br><span class="line"></span><br><span class="line">mysql&gt; LOAD DATA INFILE &#39;&#x2F;home&#x2F;mianhk&#x2F;pet.txt&#39; INTO TABLE pet LINES TERMINATED BY &#39;\r\n&#39;;</span><br><span class="line">ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it ca</span><br><span class="line">nnot execute this statement</span><br></pre></td></tr></table></figure><p>原因：secure_file_priv 设置了指定目录，需要在指定的目录下进行数据导出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%secure%&#39;;</span><br><span class="line">+--------------------------+-----------------------+</span><br><span class="line">| Variable_name            | Value                 |</span><br><span class="line">+--------------------------+-----------------------+</span><br><span class="line">| require_secure_transport | OFF                   |</span><br><span class="line">| secure_file_priv         | &#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F; |+--------------------------+-----------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>数据导入需要注意的:</p><ul><li>空值要用 <code>\N</code>  代替，而不能直接使用空</li><li>分隔符一般用 <code>tab</code></li><li>注意换行符</li></ul><h1 id="总结">总结</h1><p>总之，感觉之前 windows 和 ubuntu 下都没有这么麻烦，这里总结一下吧，感觉以后会用的很多，不想踩坑了。</p><h1 id="参考：">参考：</h1><p><a href="https://juejin.im/entry/5af5d2786fb9a07aaf3547cc" target="_blank" rel="noopener">MySQL8.0.11 连接错误 2059 解决方法</a><a href="https://stackoverflow.com/questions/50177216/how-to-grant-all-privileges-to-root-user-in-mysql-8-0" target="_blank" rel="noopener">How to grant all privileges to root user in MySQL 8.0</a><a href="https://www.cnblogs.com/echo-coding/p/9172636.html" target="_blank" rel="noopener">centos mysql 初探 – 配置、基本操作及问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MySQL 在 CentOS 上的安装和使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.yuguocong.cn/tags/MySQL/"/>
    
      <category term="学习" scheme="http://www.yuguocong.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title> 使用语雀编辑器写静态博客</title>
    <link href="http://www.yuguocong.cn/2018/11/14/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.yuguocong.cn/2018/11/14/yuque/使用语雀编辑器写静态博客/</id>
    <published>2018-11-14T14:27:10.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本来以为已经是最后一次折腾了，但是总是生活不停，折腾不止，觉得本地文件管起来还是有点麻烦，看到语雀 markdown 又做的这么好，前几天还准备拿它当云笔记用，但是据说底层存的都是 md 格式，有的时候又还是不太方便，不过做编辑器来说确实很爽了，自带图床，还有 github 上开源的一个接口。</p></blockquote><a id="more"></a><h1 id="准备工作">准备工作</h1><h2 id="更新-node-js-和-npm">更新 node.js 和 npm</h2><p>刚刚来就是坑，不过还是准备从正常的步骤开始说吧，就是博客基于的是 nodejs，很多包的安装都是采用 npm 统一管理的，因为有些插件需要使用新的版本，所以需要先更新一下，这里只说一下 windows 下面的操作。</p><h3 id="更新-node-js">更新 node.js</h3><p>window 下并没有网上说的乱七八糟的命令行更新方式，直接在<a href="http://nodejs.cn/" target="_blank" rel="noopener">官网</a>下载最新的安装包就可以。然后安装在之前的位置进行覆盖就可以更新了。更新之后通过命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$node -v</span><br><span class="line">v10.13.0</span><br></pre></td></tr></table></figure><h3 id="更新-npm">更新 npm</h3><p>通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$npm install -g npm</span><br><span class="line"></span><br><span class="line">#更新后的版本可以看到</span><br><span class="line">$npm -v</span><br><span class="line">6.4.1</span><br></pre></td></tr></table></figure><h3 id="更新包">更新包</h3><p>可以使用命令查看可以更新的包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$npm outdated         #查看需要更新的包：</span><br><span class="line">Package                 Current  Wanted  Latest  Location</span><br><span class="line">hexo-helper-live2d      MISSING   3.1.0   3.1.0  hexo-site</span><br><span class="line">hexo                      3.3.9   3.8.0   3.8.0  hexo-site</span><br><span class="line">hexo-douban              0.2.14  0.2.16   1.0.6  hexo-site</span><br><span class="line">hexo-generator-archive    0.1.4   0.1.5   0.1.5  hexo-site</span><br><span class="line">hexo-generator-search     2.2.5   2.3.0   2.3.0  hexo-site</span><br><span class="line">hexo-renderer-ejs         0.2.0   0.2.0   0.3.1  hexo-site</span><br><span class="line">hexo-renderer-marked     0.2.11  0.2.11   0.3.2  hexo-site</span><br><span class="line">hexo-server               0.2.2   0.2.2   0.3.3  hexo-site</span><br><span class="line">$npm install --save  #</span><br></pre></td></tr></table></figure><p>之后修改<code>package.json</code>文件，修改到对应的版本。然后执行命令，进行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install --save</span><br></pre></td></tr></table></figure><h2 id="安装语雀文章下载插件">安装语雀文章下载插件</h2><p>首先这里鸣谢开源的插件：[<a href="https://github.com/x-cold/yuque-hexo" target="_blank" rel="noopener">yuque-hexo</a>](https://github.com/x-cold/yuque-hexo)，通过工具可以将语雀知识库中的文件同步到本地，大部分功能和步骤在仓库中都有些，但是自己做的时候还是踩了坑，这里就还是写一下吧。</p><h3 id="1-创建语雀知识库">1.创建语雀知识库</h3><p>打开<a href="https://www.yuque.com/" target="_blank" rel="noopener">语雀</a> 创建自己的博客知识库，并且要<strong>设置成公开的。可以在设置中看到链接如下：</strong><img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1542204775155-271c9311-4643-4ccd-8692-24ab7351e0cb.png#width=375" alt="">同时打开<a href="https://www.yuque.com/mianhk/gaqqwc" target="_blank" rel="noopener">blog 知识库</a>:<a href="https://www.yuque.com/mianhk/gaqqwc" target="_blank" rel="noopener">https://www.yuque.com/mianhk/gaqqwc</a>可以打开知识库。</p><h3 id="2-在本地安装-yuque-hexo">2.在本地安装 yuque-hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g yuque-hexo</span><br></pre></td></tr></table></figure><h3 id="3-配置-package-json">3.配置 package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;clean&quot;: &quot;npm run clean:yuque &amp;&amp; hexo clean&quot;,</span><br><span class="line">  &quot;clean:yuque&quot;: &quot;DEBUG&#x3D;yuque-hexo.* yuque-hexo clean&quot;,</span><br><span class="line">  &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class="line">  &quot;publish&quot;: &quot;npm run clean &amp;&amp; npm run deploy&quot;,</span><br><span class="line">  &quot;dev&quot;: &quot;hexo s&quot;,</span><br><span class="line">  &quot;sync&quot;: &quot;DEBUG&#x3D;yuque-hexo.* yuque-hexo sync&quot;,</span><br><span class="line">  &quot;reset&quot;: &quot;npm run clean:yuque &amp;&amp; npm run sync&quot;</span><br><span class="line">&#125;, </span><br><span class="line">  &quot;yuqueConfig&quot;: &#123;</span><br><span class="line">  &quot;baseUrl&quot;: &quot;https:&#x2F;&#x2F;www.yuque.com&#x2F;api&#x2F;v2&quot;,    #这是语雀的永久链接，直接复制就可以</span><br><span class="line">  &quot;login&quot;: &quot;mianhk&quot;,                      #用户名，上个链接的第一个下划线</span><br><span class="line">  &quot;repo&quot;: &quot;gaqqwc&quot;,                      #知识库链接，第二个下划线</span><br><span class="line">  &quot;mdNameFormat&quot;: &quot;slug&quot;,               #导出本地的文件名为随机的数字，比直接的中文title要好看，</span><br><span class="line">                                              可以直接用了</span><br><span class="line">  &quot;postPath&quot;: &quot;source&#x2F;_posts&#x2F;yuque&quot;     #存在本地文件夹的位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-删除和同步文章">4.删除和同步文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#删除文章</span><br><span class="line">$yuque-clean</span><br><span class="line">[INFO] yuque-hexo clean start.</span><br><span class="line">[INFO] remove yuque posts: F:\blog\mianhk.github.io\source\_posts\yuque\</span><br><span class="line">[INFO] remove yuque local file: F:\blog\mianhk.github.io\yuque.json</span><br><span class="line">[INFO] yuque-hexo clean finished.</span><br><span class="line"></span><br><span class="line">#同步文章</span><br><span class="line">$yuque-hexo sync</span><br><span class="line">[INFO] yuque-hexo sync start.</span><br><span class="line">[INFO] remove yuque posts: F:\blog\mianhk.github.io\source\_posts\yuque\</span><br><span class="line">[INFO] loading config: F:\blog\mianhk.github.io\package.json</span><br><span class="line">[INFO] downloading articles: &#123;&quot;baseUrl&quot;:&quot;https:&#x2F;&#x2F;www.yuque.com&#x2F;api&#x2F;v2&quot;,&quot;login&quot;:&quot;mianhk&quot;,&quot;repo&quot;:&quot;gaqqwc&quot;,&quot;mdNameFormat&quot;:&quot;slug&quot;,&quot;postPath&quot;:&quot;source&#x2F;_posts&#x2F;yuque&quot;&#125;</span><br><span class="line">[INFO] reading from local file: F:\blog\mianhk.github.io\yuque.json</span><br><span class="line">[INFO] download article body: 11月生活小结</span><br><span class="line">[INFO] download articls done!</span><br><span class="line">[INFO] writing to local file: F:\blog\mianhk.github.io\yuque.json</span><br><span class="line">[INFO] create posts director (if it not exists): F:\blog\mianhk.github.io\source\_posts\yuque</span><br><span class="line">[INFO] generate post file: F:\blog\mianhk.github.io\source\_posts\yuque\xzxhcv.md</span><br><span class="line">[INFO] yuque-hexo sync finished.</span><br></pre></td></tr></table></figure><h3 id="5-修改文章的-title-和-tag-等">5.修改文章的 title 和 tag 等</h3><p>还是跟之前的格式直接写即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">update:</span><br><span class="line">categories:</span><br><span class="line">tags: []</span><br></pre></td></tr></table></figure><h3 id="6-部署博客">6.部署博客</h3><h1 id="记录一些坑">记录一些坑</h1><ul><li><p>知识库一定要是公开的</p></li><li><p>windows 下更新 nodejs 不能用 n，即使强制使用了也还是无法更新</p></li><li><p>新版本的 npm。如果改了 package.json，且 package.json 和 lock 文件不同，那么执行<code>npm i</code>时 npm 会根据 package 中的版本号以及语义含义去下载最新的包，并更新至 lock。</p></li></ul><h2 id="reference">Reference:</h2><ul><li><p><a href="https://github.com/x-cold/yuque-hexo" target="_blank" rel="noopener">https://github.com/x-cold/yuque-hexo</a></p></li><li><p><a href="https://luan.ma/post/yuque2blog/" target="_blank" rel="noopener">https://luan.ma/post/yuque2blog/</a></p></li><li><p><a href="https://www.zhihu.com/question/62331583" target="_blank" rel="noopener">https://www.zhihu.com/question/62331583</a></p></li><li><p><a href="https://tommy.net.cn/2018/02/26/upgrade-hexo-to-v3-5-0/" target="_blank" rel="noopener">将 Hexo 升级到 v3.5.0</a></p></li><li><p><a href="https://github.com/x-cold/blog/blob/master/package.json#L26" target="_blank" rel="noopener">Demo Json</a></p></li></ul><p><a href="https://segmentfault.com/a/1190000017797561" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017797561</a><a href="https://lkc.im/archives/1d99.html" target="_blank" rel="noopener">https://lkc.im/archives/1d99.html</a><a href="https://x-d.xyz/2019/04/02/yuque/Hexo%E5%8D%9A%E5%AE%A2%E4%BA%91%E7%AB%AF%E5%86%99%E4%BD%9C%EF%BC%8C%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/" target="_blank" rel="noopener">https://x-d.xyz/2019/04/02/yuque/Hexo%E5%8D%9A%E5%AE%A2%E4%BA%91%E7%AB%AF%E5%86%99%E4%BD%9C%EF%BC%8C%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本来以为已经是最后一次折腾了，但是总是生活不停，折腾不止，觉得本地文件管起来还是有点麻烦，看到语雀 markdown 又做的这么好，前几天还准备拿它当云笔记用，但是据说底层存的都是 md 格式，有的时候又还是不太方便，不过做编辑器来说确实很爽了，自带图床，还有 github 上开源的一个接口。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.yuguocong.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="折腾" scheme="http://www.yuguocong.cn/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="Hexo" scheme="http://www.yuguocong.cn/tags/Hexo/"/>
    
      <category term="语雀" scheme="http://www.yuguocong.cn/tags/%E8%AF%AD%E9%9B%80/"/>
    
  </entry>
  
  <entry>
    <title> 11月生活小结(2018)</title>
    <link href="http://www.yuguocong.cn/2018/11/05/yuque/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%93(2018)/"/>
    <id>http://www.yuguocong.cn/2018/11/05/yuque/11月生活小结(2018)/</id>
    <published>2018-11-05T12:04:46.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近又到了生活有点不知道干什么的时候，有的时候觉得自己对什么都很有信心，有的时候又觉得什么都做不好。想起来以前总是站在自己的角度看一些事情，看自己。直到现在有时候看看，自己的问题，一直放在那，并没有好多少，只不过我像对待其他人一样宽容的对待了自己。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1541420058802-2a13e83c-eb31-4adb-9ce0-5b8443a9ff3b.png#width=596" alt=""></p><h2 id="专注的做自己该做的事情">专注的做自己该做的事情</h2><p>发现自己原来一直是个喜欢折腾的人，平时折腾 Linux，折腾 chrome 的插件，学一些东西的时候，好像总是把关注点搞错了。先以几件事举个例子吧。</p><h3 id="学习-c">学习 C++</h3><p>比如学个语言，C++，先在网上搜 Windows 下 C 好用的编辑器，嗯，找到了 Dev C，觉得还挺好的，确实，直接编译就能运行，而且还是 gcc 的编译，也比较符合现在吧，总比那些 VC6.0 要好。然后写了一段，刷题的时候发现怎么有的时候中文粘贴会有问题，垃圾，赶紧换一个。</p><p>于是就看到了网上的很多说 vim 搭建 IDE 很酷，而且 vim 自己也用过，自己也恰好有台云服务器，自己要做的也是 Linux 下的 C++开发，也恰好可以练习一些比如 gcc 工具链呀，写写 Makefile 呀，嗯，于是网上找了一堆 vim 的配置，配置的很酷，找了很多，各种修改，甚至白天都没心思干活了也要搞好，中午回宿舍开着电脑马上开始弄，到了后面折腾的都累了，在 github 上找到了一个别人配好的，看了一下界面，唉，算了就这个吧。于是 vim 下一阵操作，还学了配置的一些快捷键：诸如切换窗口，切换文件，语法错误之类的，还有即时运行之类的操作。就像下面这样。。</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1541417270624-4fa02e68-1d4c-4852-8be2-24498600aff1.png#width=504" alt=""></p><p>过段时间发现，这个云服务器下面写代码还是不太好，1M 的小水管，有的时候会卡，这就很难受了，而且说得联系 Makefile 那些，其实能练的也比较少，一般都是直接 make 一下文件就好了，或者是一个写好的 Makefile 直接全编译了。于是又转回了 Windows，试了一下宇宙 IDE–VS，果然不一样，先下个最新版吧，2017 怎么这么大呀，算了，换 2015 吧，额，2015 好像也有点大，要不就试试 2013 吧，这个大小好像还凑和，于是下载下来，一顿折腾，终于可以写了，唉，这个怎么每次还要加 pause 才行呀，而且这个小黑框输入也太难受了，而且打开一下这么大，算了，溜了溜了。</p><p>又看到 Idea 家的跨平台的 Clion，因为之前用过 idea，所以觉得还不错，现代的 IDE，那就用用看吧，但是这个环境，还要配置MINGW64 呀，算了，配置吧，网上一大堆了，虽然有些有坑，虽然有的时候网速很慢，但是没事，我能克服困难。。于是就用了这个，确实还挺好看的，用着也还算顺手吧，赶紧把主题呀，各种呀配置一下呀，哦，还有 vim，这么好用的工具。试了一段时间写项目确实不错，做个小项目，写起来还可以的。但是是要在 Linux 下编译的呀，于是又找到了 ftp 工具。。。</p><p>讲道理到这应该也差不多了，但是，Clion 每次打开也是很大了，总感觉不是很方便，要不还是？ 哦，最近正好出了一个编辑器还挺好用的，网上看着各种推荐，vscode，网上都说还可以，微软做的，我试试吧。哎，做编辑器确实可以，平时写个算法之类的呀。于是又是各种插件折腾，对了，再弄个 c++的编译环境吧，但是这个编译也有点慢呀，算了，忍忍吧。</p><p>上面大概是这一年多以来学习 C++过程的坑了，不知道很多 Programmer 是不是也跟我一样，但是回头想想真的花了很多乱七八糟的时间来做一些无关紧要的事情，其实就是没有抓住重点吧。</p><h3 id="服务器和博客的折腾">服务器和博客的折腾</h3><p>因为一直有台服务器，为了不用开虚拟机就做 Linux 操作，自己在上面的折腾也算是蛮多吧，从最开始想跑个微信（一个 github 上的项目），然后折腾 vim，折腾挖矿（收益当然是不用说，但是当时感觉还不错），后面又折腾 Jupyter notebook，tmux，zsh，也是花费了不少的时间，但是结果是，关于真正技术方面的，反而学到的比较少。</p><h2 id="what-s-next">What’s Next</h2><p>有的时候自己也在想这些原因，以前可能也会有些这样，但是至少能在一方面能够保持很好的一个学习状态，但是直到最近，可能也是找完了工作吧，心态也有些放松了，所以就更。但是，真正的自由，是在自律的条件下的。所以计划和要求也还是要有的：</p><ul><li><p>学习 MySQL 和 Go 语言</p></li><li><p>每周至少一篇技术博客</p></li><li><p>上班时间，就干该干的事情</p></li><li><p>玩的时候，一定不要想着学习</p></li><li><p>不吃夜宵</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近又到了生活有点不知道干什么的时候，有的时候觉得自己对什么都很有信心，有的时候又觉得什么都做不好。想起来以前总是站在自己的角度看一些事情，看自己。直到现在有时候看看，自己的问题，一直放在那，并没有好多少，只不过我像对待其他人一样宽容的对待了自己。
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.yuguocong.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.yuguocong.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://www.yuguocong.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="日常总结" scheme="http://www.yuguocong.cn/tags/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Travis CI 自动部署博客</title>
    <link href="http://www.yuguocong.cn/2018/10/26/tools/hexo_travis-ci/"/>
    <id>http://www.yuguocong.cn/2018/10/26/tools/hexo_travis-ci/</id>
    <published>2018-10-26T14:44:30.000Z</published>
    <updated>2021-09-25T04:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hexo的又双叒一次折腾，以前觉得hexo部署博客还是很麻烦，除了每次操作完都得等待生成一下，还有的就是有时候很久一生成，都是看人品出错，以前也弄过那种自动的脚本，每天自己生成然后push，但是出错的时候就又是很麻烦。直到这次看到了Travis CI…</p></blockquote><a id="more"></a><p>听到持续集成这个词还是最近逛github的时候，看到一些讨论才搜了一下这个，不过之前也是想过这个问题，毕竟有痛点就会想。之前折腾hexo博客的时候，试过在windows下面写个bat脚本，定时<code>hexo clean hexo g -d</code>一下，但是有时候文件太多搞乱了，就出问题了，一段时间没弄，就又得回来折腾。后面也试过就不在windows下面操作了，干脆只在博客文件夹弄，然后编辑器自动ftp到服务器上，再在服务器上自动生成，好像也没啥区别。直到看到Travis CI，才知道大佬们为啥都这么青睐hexo了。那就开整吧。</p><h1 id="travis思想">Travis思想</h1><p>简单点就是，当我们的github公开仓库与Travis CI绑定后，在仓库中建立一个Travis CI<code>.travis.yml</code>文件，每当<code>.travis.yml</code>文件中监听的分支发现有变动时，会根据<code>.travis.yml</code>中的配置进行操作。</p><h1 id="github准备">Github准备</h1><p>首先是准备gitpages，仓库之前已经有了，这个是放生成的静态页面的，还有一个仓库，放的是博客的源码。之前的一般操作都是在源码博客中通过<code>hexo g -d</code>后push到gitpages目录中，所以大部分操作一般都是在这个源码中进行的，gitpages仓库是用来展示的，准确来说是gitpages仓库的master分支。</p><p>由于Travis CI可以监听某个分支，所以这样一想，就不用弄两个仓库了，只需要弄两个分支即可：源码放在source分支，并又Travis CI监听，每次push后会自动push到master分支，完成博客的自动部署。</p><p>Travis CI连接到仓库需要token才能操作，就相当于一把钥匙，可以在<code>Settings</code>-&gt;<code>Developer settings</code>-&gt;<code>Personal access tokens</code>-&gt;<code>Generate new token</code>,填写<code>Token description</code>，之后勾选<code>repo</code>，选择<code>generate token</code>。如图：</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026151507.png" /> </div><br><p>点击复制按钮复制<code>token</code>：</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026151704.png" /> </div><br><h1 id="travis-ci设置">Travis CI设置</h1><h2 id="github账号登录">github账号登录</h2><p>在<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI网站</a>通过github账号登录后，开启gitpages仓库的同步，然后点击<code>settings</code>进行设置。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026155513.png" /> </div><br><h2 id="通用设置和配置环境变量">通用设置和配置环境变量</h2><p>之后开启设置，并设置环境变量(主要是为了travis的自动部署，但是token直接公开有风险，因此需要在这里设置):</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026155627.png" /> </div><br><h1 id="在source分支创建-travis-yml文件">在source分支创建<code>.travis.yml</code>文件</h1><p>在gitpages仓库的source分支创建。这里涉及几个git的操作，真是坑踩多了，自然就会多用几个命令了。。</p><h2 id="拉取远程仓库并创建新分支">拉取远程仓库并创建新分支</h2><p>操作步骤为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 克隆项目到本地</span><br><span class="line">&gt; git clone git@github.com:mianhk&#x2F;mianhk.github.io.git</span><br><span class="line"># 创建并切换到source分支</span><br><span class="line">&gt; git checkout -b source</span><br></pre></td></tr></table></figure><p>切换到source分支后，将本地除<code>.git</code>文件夹的其他文件删除，并将之前的源码文件拷贝到当前文件夹，然后提交到远程的source分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提交本地hexo分支到远程仓库的hexo分支</span><br><span class="line">git push origin hexo:hexo</span><br></pre></td></tr></table></figure><h2 id="创建-travis-yml文件">创建.travis.yml文件</h2><p>当然这个文件网上一找一大堆，也不是我自己写的，参考：https://juejin.im/post/5a1fa30c6fb9a045263b5d2a  自己进行了一点修改：具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 使用语言</span><br><span class="line">language: node_js</span><br><span class="line"># node版本</span><br><span class="line">node_js: stable</span><br><span class="line"># 设置只监听哪个分支</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - source</span><br><span class="line"># 缓存，可以节省集成的时间，这里我用了yarn，如果不用可以删除</span><br><span class="line">cache:</span><br><span class="line">  apt: true</span><br><span class="line">  directories:</span><br><span class="line">    - node_modules</span><br><span class="line"># tarvis生命周期执行顺序详见官网文档</span><br><span class="line">before_install:</span><br><span class="line">- export TZ&#x3D;&#39;Asia&#x2F;Shanghai&#39; # 更改时区</span><br><span class="line">- git config --global user.name &quot;mianhk&quot;</span><br><span class="line">- git config --global user.email &quot;gcyu@gmail.com&quot;</span><br><span class="line"># 由于使用了yarn，所以需要下载，如不用yarn这两行可以删除</span><br><span class="line">#- curl -o- -L https:&#x2F;&#x2F;yarnpkg.com&#x2F;install.sh | bash</span><br><span class="line">#- export PATH&#x3D;$HOME&#x2F;.yarn&#x2F;bin:$PATH</span><br><span class="line">- npm install -g hexo-cli</span><br><span class="line">install:</span><br><span class="line"># 不用yarn的话这里改成 npm i 即可</span><br><span class="line">#- yarn</span><br><span class="line">- npm i</span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo generate</span><br><span class="line">after_success:</span><br><span class="line">- cd .&#x2F;public</span><br><span class="line">- git init</span><br><span class="line">- git add --all .</span><br><span class="line"># commit 中间添加时间信息</span><br><span class="line">- git commit -m &quot;Travis CI Auto Builder at &#96;date +&quot;%Y-%m-%d %H:%M&quot;&#96;&quot;  </span><br><span class="line"># 这里的 REPO_TOKEN 即之前在 travis 项目的环境变量里添加的</span><br><span class="line">- git push --quiet --force https:&#x2F;&#x2F;$REPO_TOKEN@github.com&#x2F;mianhk&#x2F;mianhk.github.io.git</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>之后便可以通过在本地或者其他电脑上通过git在source分支上的操作实现自动部署了。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026161116.png" /> </div><br> <h1 id="一些坑">一些坑</h1><p>一些拷贝文件产生的错误，导致中间出错了好几次，通过调整文件进行本地测试的时候，没有问题，但是自动构建就还是出问题。需要将原来的源码中的<code>config.yml</code>的push选项进行一下修改。</p><h1 id="reference">Reference</h1><p><a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" target="_blank" rel="noopener">使用Travis CI自动部署Hexo博客</a><br><a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener">Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hexo的又双叒一次折腾，以前觉得hexo部署博客还是很麻烦，除了每次操作完都得等待生成一下，还有的就是有时候很久一生成，都是看人品出错，以前也弄过那种自动的脚本，每天自己生成然后push，但是出错的时候就又是很麻烦。直到这次看到了Travis CI…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.yuguocong.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="博客" scheme="http://www.yuguocong.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="折腾" scheme="http://www.yuguocong.cn/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-操作系统</title>
    <link href="http://www.yuguocong.cn/2018/06/24/interview/interview_operation/"/>
    <id>http://www.yuguocong.cn/2018/06/24/interview/interview_operation/</id>
    <published>2018-06-24T22:03:43.000Z</published>
    <updated>2021-09-25T04:04:54.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统的分页分段">操作系统的分页分段</h1><p><a href="https://www.cnblogs.com/onepeace/p/5066736.html" target="_blank" rel="noopener">操作系统之分页分段介绍</a></p><h2 id="分页存储">分页存储</h2><ul><li>思想：将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)或物理块，每个物理块的大小一般取2的整数幂。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）。</li><li>逻辑地址道物理地址变化原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。</li><li>优点：没有外碎片，提高内存的利用率。一个程序不必连续存放。便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。</li><li>缺点：无论数据有多少，都只能按照页面大小分配，容易产生内部碎片。无法体现程序逻辑。页长与程序的逻辑大小不相关。不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。</li></ul><h2 id="分段存储">分段存储</h2><ul><li>思想：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中（写c程序时会用到），并且每个程序可以有多个相同类型的段。段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。<br>在为某个段分配物理内存时，可以采用<strong>首先适配法、下次适配法、最佳适配法</strong>等方法。在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。</li><li>地址映射: 在分段存储中，整个进程的地址空间是<strong>二维</strong>的，即其逻辑地址由段号和段内地址两部分组成。</li><li>优点：分段对程序员可见。段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。方便编程，分段共享，分段保护，动态链接，动态增长。</li><li>缺点：主存空间分配比较麻烦。外部碎片。由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚拟地址和实存地址的最低若干二进制位作为段内地址，并与段号进行直接拼接，必须用加法操作通过段起址与段内地址的求和运算得到物理地址。</li></ul><h2 id="分页存储和分段存储的区别">分页存储和分段存储的区别</h2><ol><li>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；段则是信息的逻辑单位，它含有一组其意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。</li><li>页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li><li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址是，即需给出段名，又需给出段内地址。</li><li>分页信息很难保护和共享、分段存储按逻辑存储所以容易实现对段的保存和共享。</li></ol><h2 id="段页存储">段页存储</h2><p>程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180622105842.png" /> </div><br>  为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块<p>它首先将程序按其逻辑结构划分为若干个大小不等的逻辑段，然后再将每个逻辑段划分为若干个大小相等的逻辑页。主存空间也划分为若干个同样大小的物理页。辅存和主存之间的信息调度以页为基本传送单位，每个程序段对应一个段表，每页对应一个页表。</p><p>段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量</p><p>CPU访问时，段表指示每段对应的页表地址，每一段的页表确定页所在的主存空间的位置，最后与页表内地址拼接，确定CPU要访问单元的物理地址。</p><p>段页存储管理方式综合了段式管理和页式管理的优点，但需要经过两级查表才能完成地址转换，消耗时间多。</p><ul><li>过程：检查是否越界。利用段表始址和段号来求出该段所对应的段表项在段表中的位置，得到该段的页表始址。读出该页所在的物理块号b。构建物理地址。</li><li>优点：提供了大量的虚拟存储空间。有效地利用主存，为组织多道程序运行提供了方便。</li><li>缺点：增加了硬件成本、系统的复杂性和管理上的开销。存在系统抖动的风险。存在内碎片。各种表占用更多的空间。</li></ul><h1 id="linux自旋锁">Linux自旋锁</h1><h1 id="线程同步">线程同步</h1><p>http://bestmind.space/posts/%E5%B8%B8%E8%A7%81C-%E9%9D%A2%E8%AF%95%E9%A2%98/<br>线程同步和线程互斥的区别线程同步的方式:互斥锁、读写锁(共享-独占锁)、条件变量和信号量</p><h1 id="进程间通信">进程间通信</h1><p>进程间的通信方式管道、有名管道、信号、共享内存、消息队列、信号量、套接字、文件.(1)管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。  管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的首端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。分为普通管道、流管道、命名管道。<br>(2)命名管道(named pipe):命名管道也是半双工的通信方式，它克服了管道没有名字的限制，并且它允许无亲缘关系进程间的通信。命令管道在文件系统中有对应的文件名，命名管道通过命令mkfifo或系统调用mkfifo来创建。<br>(3)信号:信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。除了用于进程通信外，进程还可以发送信号给进程本身。<br>(4)消息队列：克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小的限制。由消息链表的结构实现。<br>(5)信号量(semophore):信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br>(6)共享内存：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<br>(7)套接字: 与其他通信机制不同的是，它可用于不同机器间的进程通信。但是将通信转移到了应用层。</p><h1 id="select-poll-epoll的区别">select、poll、epoll的区别</h1><h1 id="死锁">死锁</h1><p>指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><p>死锁产生的四个必要条件:互斥条件:一个资源每次只能被一个进程使用不可剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系.</p><h2 id="死锁避免">死锁避免</h2><p>银行家算法：检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。</p><h2 id="死锁解除">死锁解除</h2><ol><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li><li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol><h1 id="进程有哪几种状态？">进程有哪几种状态？</h1><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；阻塞状态： 进程等待某种条件，在条件满足之前无法执行；</p><h1 id="操作系统中进程调度策略有哪几种？">操作系统中进程调度策略有哪几种？</h1><p>FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU</p><p>SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度</p><p>优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化</p><p>时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</p><p>多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</p><p>多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p><h1 id="虚拟内存">虚拟内存</h1><p>为什么有虚拟内存：对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上缺页：如果虚拟内存的页并不存在于物理内存中，会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。</p><p>页面置换算法：FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p><p>LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；</p><p>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</p><p>OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p><h2 id="多线程中栈与堆是公有的还是私有的">多线程中栈与堆是公有的还是私有的</h2><p>一般来说栈是私有的，堆是公有的。但是在多线程中，可以为特定的线程创建私有的堆。</p><h2 id="进程是资源分配的最小单位-线程是cpu调度的最小单位">进程是资源分配的最小单位，线程是CPU调度的最小单位</h2><p>进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。<br>与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。<br>线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。<br>因此一个简单的解释就是：进程拥有PCB，而多个线程共享一个进程的PCB。</p><h3 id="进程和线程的区别">进程和线程的区别</h3><p><a href="https://segmentfault.com/a/1190000005884656" target="_blank" rel="noopener">进程与线程的一个简单解释</a>地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。<br>通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。<br>调度和切换：线程上下文切换比进程上下文切换要快得多。<br>在多线程OS中，进程不是一个可执行的实体。</p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180622095406.png" /> </div><br><h2 id="进程的基本状态">进程的基本状态</h2><p>状态：运行、阻塞、挂起阻塞、就绪、挂起就绪<br>状态之间的转换：准备就绪的进程，被CPU调度执行，变成运行态；<br>运行中的进程，进行I/O请求或者不能得到所请求的资源，变成阻塞态；<br>运行中的进程，进程执行完毕（或时间片已到），变成就绪态；<br>将阻塞态的进程挂起，变成挂起阻塞态，当导致进程阻塞的I/O操作在用户重启进程前完成（称之为唤醒），挂起阻塞态变成挂起就绪态，当用户在I/O操作结束之前重启进程，挂起阻塞态变成阻塞态；<br>将就绪（或运行）中的进程挂起，变成挂起就绪态，当该进程恢复之后，挂起就绪态变成就绪态；</p><figure class="highlight plain"><figcaption><span>const char * const task_state_array[] </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &quot;R (running)&quot;,        &#x2F;*   0 *&#x2F;</span><br><span class="line">  &quot;S (sleeping)&quot;,        &#x2F;*   1 *&#x2F;</span><br><span class="line">  &quot;D (disk sleep)&quot;,    &#x2F;*   2 *&#x2F;</span><br><span class="line">  &quot;T (stopped)&quot;,        &#x2F;*   4 *&#x2F;</span><br><span class="line">  &quot;t (tracing stop)&quot;,    &#x2F;*   8 *&#x2F;</span><br><span class="line">  &quot;X (dead)&quot;,        &#x2F;*  16 *&#x2F;</span><br><span class="line">  &quot;Z (zombie)&quot;,        &#x2F;*  32 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180622100813.png" /> </div><br>         <h3 id="1-进程管理-cpu">1.进程管理-&gt;CPU</h3><h4 id="任务调度算法">任务调度算法</h4><p>1.先来先服务算法优点：简单，易于理解和实现。缺点：一批任务的平均周转时间取决于各个任务到达的顺序，如果短任务位于长任务之后，那么将增大平均周转时间。<br>2.短作业优先算法<br>SJF算法的基本思路是：各个任务在开始执行之前，必须事先预计好它的执行时间，然后调度器将根据这些时间，从中选择用时较短的任务优先执行。SJF算法有两种：不可抢占方式和可抢占方式。其中可抢占方式又叫最短剩余时间优先算法（Shortest Remaining Time First，SRTF）。<br>3.时间片轮转算法时间片轮转算法（Round Robin，RR）的基本思路是：把系统当中的所有就绪任务按照先来先服务的原则，排成一个队列，然后再每次调度的时候，把处理器分派给队列当中的第一个任务，让它去执行一小段CPU时间（即时间片，time slice）。当这个时间片结束时，如果任务还没有执行完成的话，将会发生时钟中断，在时钟中断里面，调度器将会暂停当前任务的执行，并把它送到就绪队列的末尾，然后执行当前的队首任务。反之，如果一个任务在它的时间片用完之前就已经结束了或者阻塞了，那么它就会立即让出CPU给其他任务。<br>优点：公平性，各个就绪任务能得到相同的时间片；活动性，每个就绪任务能一直保持活动。<br>缺点：时间片的大小q要适当选取，如果选择不当，将会影响到系统的性能和效率。如果q太大，每个任务都在一个时间片内完成，这就退化为先来先服务算法了。如果q太小，每个任务需要更多的时间片才能运行结束，这就使任务之间的切换次数增加，从而增大了系统的管理开销，降低了CPU的使用效率。一般来说，q值选取在20ms~50ms比较合适。<br>4.优先级算法<br>优先级调度算法（priority）的基本思路是：给每个任务都设置一个优先级，然后在任务调度的时候，在所有处于就绪状态的任务中选择优先级最高的任务去运行。上文提到的短作业优先算法其实也是一种优先级算法，每个任务的优先级就是它的运行时间，运行时间越短，优先级越高。</p><h4 id="进程与线程">进程与线程</h4><p>简单的一句话：进程是资源分配的基本单位、线程是资源调度的基本单位。这句话看起来很简单，但是核心却不仅仅如此。</p><h4 id="进程">进程</h4><h5 id="进程间通信方式">进程间通信方式</h5><ul><li>管道（pipe）,流管道(s_pipe)和有名管道（FIFO）<br>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。<br>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。</li><li>信号（signal）<br>信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</li><li>消息队列消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享内存共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li><li>信号量信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li></ul><h3 id="linux-的启动流程">Linux 的启动流程</h3><p>BIOS-&gt;主引导记录-&gt;操作系统-&gt;<strong>加载内核(/boot)</strong>:载入内核文件-&gt;<strong>启动初始化进程</strong>：运行第一个程序 /sbin/init，初始化系统环境。-&gt;<strong>确定运行级别</strong>:运行这些开机启动的程序。-&gt;<strong>加载开机启动程序</strong>-&gt;<strong>用户登录</strong>-&gt;<strong>进入 login shell</strong>-&gt;打开 non-login shell</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180622222745.png" /> </div><br>[Linux 的启动流程-阮一峰](https://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html)]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统的分页分段&quot;&gt;操作系统的分页分段&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/onepeace/p/5066736.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作系统之分页分段介绍&lt;/a
      
    
    </summary>
    
      <category term="面试经验" scheme="http://www.yuguocong.cn/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="Linux" scheme="http://www.yuguocong.cn/tags/Linux/"/>
    
      <category term="面试" scheme="http://www.yuguocong.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="工作" scheme="http://www.yuguocong.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="操作系统" scheme="http://www.yuguocong.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-C++</title>
    <link href="http://www.yuguocong.cn/2018/06/24/interview/interview_cpp/"/>
    <id>http://www.yuguocong.cn/2018/06/24/interview/interview_cpp/</id>
    <published>2018-06-24T22:02:20.000Z</published>
    <updated>2021-09-25T04:04:54.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程基础">编程基础</h2><h3 id="c-内存管理方式">C++ 内存管理方式</h3><p>堆、栈、自由存储区、全局/静态存储区、常量存储区自由存储区存储malloc申请的内存<br>(1)从静态存储区域分配 。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如 全局变量， static 变量 。(2)在栈上创建 。在执行函数时， 函数内局部变量的存储单元都可以在栈上创建 ，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。(3)从堆上分配 ， 亦称动态内存分配 。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</p><h3 id="extern-c-和extern的作用">extern &quot;C&quot;和extern的作用</h3><p>extern &quot;C&quot;的主要作用就是为了能够正确实现C<ins>代码调用其他C语言代码。加上extern &quot;C&quot;后，会指示编译器这部分代码按C语言的进行编译，而不是C</ins>的。<br>(http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)</p><h3 id="为什么需要内存对齐">为什么需要内存对齐</h3><h3 id="c-内存问题">c++内存问题</h3><ol><li><p>缓冲区溢出（buffer overrun）。<br>用 std::vector<char>/std::string 或自己编写 Buffer class 来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。</p></li><li><p>空悬指针/野指针。<br>用 shared_ptr/weak_ptr</p></li><li><p>重复释放（double delete）。</p></li><li><p>内存泄漏（memory leak）。</p></li><li><p>不配对的 new[]/delete。<br>把 new[] 统统替换为 std::vector/scoped_array。</p></li><li><p>内存碎片（memory fragmentation）。</p></li></ol><h3 id="static关键字">static关键字</h3><h4 id="作用：">作用：</h4><ul><li>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值</li><li>在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问</li><li>在模块内的 static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内。起到了隐藏的作用</li><li>在类的 static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝</li><li>在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量</li></ul><h4 id="静态全局变量不要放在头文件里">静态全局变量不要放在头文件里</h4><p>(https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)  第6条</p><p><a href="https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html" target="_blank" rel="noopener">C++中的static关键字的总结</a></p><h3 id="几个复制的声明">几个复制的声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void * ( * (*fp1)(int))[10];  &#x2F;&#x2F;fp1是一个指针，指向一个函数，函数参数为int，函数返回参数是一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个void* 指针。</span><br><span class="line">float (*(* fp2)(int,int,int))(int);  &#x2F;&#x2F;fp2是一个指针，指向一个函数，函数参数为3个int，函数的返回值是一个指针，指针指向一个函数，函数的参数是1个int，返回float。 </span><br><span class="line">int (* ( * fp3)())[10]();  &#x2F;&#x2F;fp3是一个指针，指向一个函数，函数没有参数，函数返回值为一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个函数指针，函数没有参数，返回int。</span><br></pre></td></tr></table></figure><h3 id="strlen-和sizeof">strlen()和sizeof()</h3><p>区别与联系：</p><ol><li>种类：<br>sizeof是运算符，并不是函数，结果在编译时得到,因此sizeof不能用来返回动态分配的内存空间的大小。用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系；strlen是字符处理的库<strong>函数</strong>,当数组名作为参数传入时，实际上数组就退化成指针了。。</li><li>输入参数：<br>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化），还可以用函数做参数；strlen的参数只能是字符指针且结尾是’\0’的字符串。</li><li>功能：<br>sizeof():获得保证能容纳实现所建立的最大对象的字节大小<br>strlen():返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。</li><li>返回：<br>当适用于一个结构类型时或变量， sizeof 返回实际的大小，当适用于一静态地空间数组， sizeof 归还全部数组的尺寸。sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸</li></ol><p>https://blog.csdn.net/21aspnet/article/details/1539951</p><h3 id="变量声明和定义">变量声明和定义</h3><ul><li><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p></li><li><p>相同变量可以再多处声明（外部变量extern），但只能在一处定义。</p></li></ul><h3 id="结构体和union">结构体和union</h3><p>1.在存储多个成员信息时，编译器会自动给struct第个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。</p><p>2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。</p><p>3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。</p><p><strong>未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。</strong><br>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct sTest</span><br><span class="line">&#123;</span><br><span class="line">int a;  &#x2F;&#x2F;sizeof(int) &#x3D; 4</span><br><span class="line">char b;  &#x2F;&#x2F;sizeof(char) &#x3D; 1</span><br><span class="line">short c； &#x2F;&#x2F;sizeof(short) &#x3D; 2       </span><br><span class="line">&#125;x;  #最终实际占用不止4+1+2，因为要考虑内存对齐的问题</span><br><span class="line"></span><br><span class="line">union uTest</span><br><span class="line">&#123;</span><br><span class="line">int a;   &#x2F;&#x2F;sizeof(int) &#x3D; 4</span><br><span class="line">double b;  &#x2F;&#x2F;sizeof(double) &#x3D; 8</span><br><span class="line">char c;  &#x2F;&#x2F;sizeof(char) &#x3D; 1</span><br><span class="line">&#125;x;   #分配的内存 size 就是8 byte</span><br></pre></td></tr></table></figure><p><strong>pragma pack () 取消指定对齐，恢复缺省对齐</strong></p><h3 id="static">static</h3><h3 id="malloc-new和free-delete">malloc/new和free/delete</h3><ul><li><p>malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。</p></li><li><p>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</p></li><li><p>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</p></li><li><p>free和delete对应。当delete一个对象数组时，delete只删除了一个，需要使用delete[]</p></li></ul><h3 id="const">const</h3><h4 id="宏定义和const函数的区别">宏定义和const函数的区别</h4><ul><li>宏在编译时完成替换，直接进行替换，执行起来更快，但是可能会存在一些风险；函数调用在运行时需要跳转到具体调用函数。如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define area(x) x*x</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int y&#x3D;area(2+2);</span><br><span class="line">std::cout&lt;&lt;y&lt;&lt;std::endl;   # 输出为8&#x3D;2+2*2+2，而不是以为的16</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。</p></li><li><p>宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</p></li><li><p>一般可以对const常量进行调试，但不能对宏常量进行调试。</p></li><li><p>宏函数不要在最后加分号。</p></li></ul><p>总之，一般尽量用const比较好。</p><h4 id="const的分辨-顶层const和底层const">const的分辨(顶层const和底层const)</h4><p>一般来说，const的分辨可以直接通过看const的最左侧，如果是指针，则指针是const，若为类型，则变量为const。当const在最左侧时，看const右侧。</p><ul><li>常量指针和指针常量： 常量指针是一个指针，读成常量的指针，指向一个只读变量。如<code>int const *p</code>或<code>const int *p</code>。<br>指针常量是一个常量，指针的值可以改变。如<code>int *const p</code>。</li></ul><h3 id="指针和引用">指针和引用</h3><h4 id="区别">区别</h4><ol><li>指针是具体的变量，需要占存储空间。引用只是别名，不占用具体存储空间。这是最基本的一点，其他的特点也就可想而知了。</li><li>指针可以先声明，但是引用声明的时候就必须初始化，不存在空的引用很容易理解。</li><li>指针变量可以改变所指的对象。但是引用一旦声明了就不能再改变引用的对象了。</li></ol><h4 id="引用相关问题">引用相关问题</h4><ol><li>引用是某个变量的别名，因此定义的时候必须初始化，也不能把该引用再改成其他变量的别名。</li><li>声明一个引用并没有定义新变量，引用本身不是一种数据类型。也不占用存储空间。</li><li><s>不能建立数组的引用</s>。其实这句话的意思是：不能建立引用的数组，例如：int &amp; ref[3] = { 2, 3, 5}; 但是可以建立数组的引用:例如：int arr[3]; int (&amp;tef)[3] = arr;<br>原因是：引用时不占空间的，声明引用数组没法分配空间。见<a href="https://blog.csdn.net/tkp2014/article/details/48858377" target="_blank" rel="noopener">为什么不能建立引用数组</a></li><li>将引用作为函数的参数时，可以避免对变量或者对象的复制，因此不会调用对象的拷贝构造函数。当不希望传入的引用参数不被改变时，使用const引用。</li><li>函数中不能返回局部变量的引用，不能返回函数内部ne分配的内存的引用。（虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄露。）。 可以返回类成员的引用，但最好是const。</li><li>当类中存在const或者引用时成员变量时，必须使用初始化表。</li></ol><h4 id="指针相关问题">指针相关问题</h4><h5 id="指针的相关判断">指针的相关判断</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    int *p[10]</span><br><span class="line">    int (*p)[10]</span><br><span class="line">    int *p(int)</span><br><span class="line">    int (*p)(int)</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">  </span><br><span class="line">- int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。  </span><br><span class="line">    </span><br><span class="line">- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</span><br><span class="line">    </span><br><span class="line">- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</span><br><span class="line">    </span><br><span class="line">- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 指针与数组名</span><br><span class="line">- 二者均可通过增减偏移量来访问数组中的元素。</span><br><span class="line"></span><br><span class="line">- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</span><br><span class="line"></span><br><span class="line">- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</span><br><span class="line"></span><br><span class="line">##### 野指针</span><br><span class="line">空悬指针，不是指向null的指针，是指向垃圾内存的指针。  </span><br><span class="line">- 产生原因及解决办法：</span><br><span class="line">    - 指针变量未及时初始化 &#x3D;&gt; 定义指针变量及时初始化，要么置空。</span><br><span class="line">- 指针free或delete之后没有及时置空 &#x3D;&gt; 释放操作后立即置空。</span><br><span class="line">##### 指针和数组的区别</span><br><span class="line">数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。  </span><br><span class="line">1. 修改内容上的差别:指针可能指向一块内存，但是指向的常量却无法通过下标计算。</span><br></pre></td></tr></table></figure><p>char a[] = “hello”;a[0] = ‘X’;char *p = “world”; // 注意p 指向常量字符串，指向的是常量区p[0] = ‘X’; // 编译器不能发现该错误，运行时错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++&#x2F;C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</span><br></pre></td></tr></table></figure><p>char a[] = “hello world”;char *p = a;cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节cout&lt;&lt; sizeof§ &lt;&lt; endl; // 4 字节//计算数组和指针的内存容量void Func(char a[100]){cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### volatile</span><br><span class="line">- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。</span><br><span class="line">    </span><br><span class="line">- 多线程中被几个任务共享的变量需要定义为volatile类型。  </span><br><span class="line"></span><br><span class="line">### 堆栈</span><br><span class="line">#### 区别</span><br><span class="line">1. 申请方式不同：栈由系统自动分配，堆由程序员手动分配  </span><br><span class="line">2. 申请大小不同：栈顶和栈底都是设定好的，大小固定，可以通过&#96;ulimit -a&#96;查看，通过&#96;ulimit -s&#96;修改。堆向高地址扩展，是不连续的内存区域，大小可以调整。    </span><br><span class="line">3. 申请效率不同：栈由系统分配，速度快，没有碎片。堆速度慢，且有碎片。</span><br><span class="line"></span><br><span class="line">#### 内存分配</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;nkguohao&#x2F;article&#x2F;details&#x2F;8771867 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 面向对象</span><br><span class="line">### 面向对象三大特性</span><br><span class="line">- 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。</span><br><span class="line">    </span><br><span class="line">- 继承性：让某种类型对象获得另一个类型对象的属性和方法。</span><br><span class="line"></span><br><span class="line">- 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。</span><br><span class="line"></span><br><span class="line">### 构造函数和析构函数</span><br><span class="line">1.构造函数、析构函数中都不要调用虚函数  </span><br><span class="line">   </span><br><span class="line">我们知道，构造函数一般不能是虚函数，而析构函数一般必须是虚函数。原理也很清晰，构造函数，由于构造顺序是从基类到派生类，所以调用虚函数，可能派生类还没有构造出来，没有意义。而对于析构函数来说，又必须是虚函数，因为只有先从子类对象进行销毁，才能保证资源不泄露。    </span><br><span class="line">   </span><br><span class="line">在构造函数和析构函数中都不要调用虚函数也是这个道理。  </span><br><span class="line"></span><br><span class="line">### 成员变量和成员函数</span><br><span class="line">1.静态成员变量是需要初始化  </span><br><span class="line">其实这样说的是有点问题的，应该是静态成员是需要定义的。</span><br><span class="line">因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。    </span><br><span class="line">《c++primer》里面说在类外定义和初始化是保证static成员变量只被定义一次的好方法。 但static const int就可以在类里面初始化</span><br></pre></td></tr></table></figure><p>class Base{public:static int class_p;   //只有声明，而没有定义，不能直接调用};int Base::class_p=3;   //进行定义  https://blog.csdn.net/qq_16209077/article/details/52602601</p><pre><code>### 拷贝构造函数调用情况：  1. 用一个类的对象去初始化该类的另一个对象时。  2. 函数形参是类的对象时，调用函数将函数的形参和实参结合的时候。   3. 函数返回值是类的对象，函数调用完成返回时。     #### 重写拷贝构造函数一般会默认生成类的拷贝构造函数，但是当涉及动态分配存储空间时，默认的拷贝构造函数就会有问题，因此需要重写拷贝构造函数，并且采用深拷贝。  浅拷贝和深拷贝：### 多态多态：对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：  编译时多态：函数和运算符的重载。  运行时多态：继承和虚函数。  ### 友元特性：单向的，传递性，不能继承  ## 标准模板库## 编译和调试### 编译过程预处理-&gt;编译-&gt;汇编-&gt;链接- 预处理：展开宏定义；处理条件编译；处理#include指令；去掉注释；添加行号和文件名标识；保留所有#pragma编译器指令。  - 编译：词法分析；语法分析；语义分析；中间语言生成；目标代码生成与优化。  - 链接：各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。### 静态库和动态库二者的不同点在于代码被载入的时刻不同。静态库和动态库的最大区别,静态情况下,把库直接加载到程序中,而动态库链接的时候,它只是保留接口,将动态库与程序代码独立,这样就可以提高代码的可复用度，和降低程序的耦合度。  - 静态库的代码在编译过程中已经被载入可执行程序,程序运行时将不再需要该静态库，因此可执行程序体积比较大。在Linux中以`.a`结尾  - 动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小,在程序运行时还需要动态库存在。不同的应用程序如果调用相同的库,那么在内存中只需要有一份该动态库(共享库)的实例。在Linux中以`.so`结尾  当静态库和动态库同名时， gcc命令将优先使用动态库.为了确保使用的是静态库, 编译时可以加上 -static 选项，因此多第三方程序为了确保在没有相应动态库时运行正常，喜欢在编译最后应用程序时加入-static  **优缺点**：  1.动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。     2.动态库更新很容易，当库发生变化时，接口没变只需要用新的动态库替换掉就可以。静态库需要重新编译。  3.静态库静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会高一些。  ## 安全相关### 类型安全类型安全很大程度上可以理解为内存安全。类型安全的代码不会试图去访问自己没有被授权的内存区域。  对于C语言来说，很多操作都不是类型安全的。例如打印的时候:`printf(&quot;%f\n&quot;,10)  //编译通过，没有报错，结果为0.000000`.  对于C++来说，有些操作也不是类型安全的，比如不同类型指针之间可以强制转换(reinterpret cast)    注：C#、Java是类型安全的  C++使用得当，可以远比C更有类型安全性。（1）操作符new返回的指针类型严格与对象匹配，而不是void*；  （2）C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；  （3）引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；  （4）一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；  （5）C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。  ### 线程安全如果代码在多线程运行和单线程运行具有相同的结果，那就是线程安全的。  线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。  ### 异常安全 当异常抛出时，带有异常安全的函数会：（1）不泄露任何资源一般采用RAII技术，即以对象管(智能指针)理资源来防止资源泄漏。(2)不允许数据被破坏（例如正常指针变野指针）(3)少些try catch，因为大量的try catch会影响代码逻辑。导致代码丑陋混乱不优雅  解决异常安全的问题：1.多使用RAII，使用智能指针来管理内存。由于unwind机制的保证，当异常发生时，函数栈内已构造的局部对象的析构函数会被一一调用，在析构函数内释放资源，也就杜绝了内存泄漏的问题。   2.做好程序设计。特别是异常发生时的回滚机制的正确使用，copy-and-swap是有效的方法。  3.注意需要异常保证的函数内部的调用函数，异常安全等级是以有最低等级异常保证的函数确定的。一个系统即使只有一个函数不是异常安全的，那么系统作为一个整体就不是异常安全的。  4.流对象，资源对象，new对象，不应该直接作为参数，一旦抛出异常，就可能会导致严重的问题，函数也许会被错误的执行，资源也许会泄漏。  5.减少全局变量的使用。   6.如果不知道如何处理异常，就不要捕获异常，直接终止比吞掉异常不处理要好。  7.保证构造、析构、swap不会失败     [类型安全 与 线程安全 、异常安全、事务安全](https://blog.csdn.net/lingling_1/article/details/46924991)## 其他### 为什么说栈比堆要快1. 分配和释放：堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，具体可以看看MALLOC和FREE的源代码，他们做了很多额外的工作，而栈却不需要这些。  2. 访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。  3. 堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。### c++协程的实现[ucontext-人人都可以实现的简单协程库](https://blog.csdn.net/qq910894904/article/details/41911175)## 设计模式### 单例模式### 工厂方法### 观察者模式### 怎么判断两个结构体变量是否相等？1，元素的话，一个个比咯：if(p1-&gt;age==p2-&gt;age)...有一个元素不等，即是两个实例不相等！没什么效率高的方法吧！2，指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真！3，重载==运算符；### ### Refeence:[常见C++面试题](http://bestmind.space/posts/%E5%B8%B8%E8%A7%81C-%E9%9D%A2%E8%AF%95%E9%A2%98/)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编程基础&quot;&gt;编程基础&lt;/h2&gt;
&lt;h3 id=&quot;c-内存管理方式&quot;&gt;C++ 内存管理方式&lt;/h3&gt;
&lt;p&gt;堆、栈、自由存储区、全局/静态存储区、常量存储区
自由存储区存储malloc申请的内存&lt;br&gt;
(1)从静态存储区域分配 。内存在程序编译的时候就已经分配好，
      
    
    </summary>
    
      <category term="面试经验" scheme="http://www.yuguocong.cn/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="C++" scheme="http://www.yuguocong.cn/tags/C/"/>
    
      <category term="面试" scheme="http://www.yuguocong.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="工作" scheme="http://www.yuguocong.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
</feed>
