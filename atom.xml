<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mianhk&#39;s notes</title>
  
  <subtitle>这个人很懒，什么都不想写</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-15T03:00:21.172Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mianhk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL-0</title>
    <link href="http://yoursite.com/2017/11/15/STL-0/"/>
    <id>http://yoursite.com/2017/11/15/STL-0/</id>
    <published>2017-11-15T02:59:47.000Z</published>
    <updated>2017-11-15T03:00:21.172Z</updated>
    
    <content type="html"><![CDATA[<h4 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;STL简介&quot;&gt;&lt;a href=&quot;#STL简介&quot; class=&quot;headerlink&quot; title=&quot;STL简介&quot;&gt;&lt;/a&gt;STL简介&lt;/h4&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的专业书阅读</title>
    <link href="http://yoursite.com/2017/11/12/%E7%94%9F%E6%B4%BB/%E6%88%91%E7%9A%84%E4%B8%93%E4%B8%9A%E4%B9%A6/"/>
    <id>http://yoursite.com/2017/11/12/生活/我的专业书/</id>
    <published>2017-11-12T12:47:37.000Z</published>
    <updated>2017-11-14T12:07:24.668Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>《Python核心编程》 ed2</li><li>《C++　Primer 》ed5</li><li>《STL 源码剖析》</li><li>《Effective C++》</li><li>《Unix 网络编程》卷一</li><li>《Unix 网络编程》卷二</li><li>《Unix 环境高级编程》</li><li>《Linux多线程服务端编程》陈硕</li><li>《TCP/IP详解》卷一</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;《Python核心编程》 ed2&lt;/li&gt;
&lt;li&gt;《C++　Primer 》ed5&lt;/li&gt;
&lt;li&gt;《STL 源码剖析》&lt;/li&gt;
&lt;li&gt;《Effective C++》&lt;/li&gt;
&lt;li&gt;《Unix 网络编程》卷一&lt;/l
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我看的电影</title>
    <link href="http://yoursite.com/2017/11/12/%E7%94%9F%E6%B4%BB/%E6%88%91%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/"/>
    <id>http://yoursite.com/2017/11/12/生活/我看的电影/</id>
    <published>2017-11-12T12:27:30.000Z</published>
    <updated>2017-11-14T12:30:21.749Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h5 id="记录我看的电影"><a href="#记录我看的电影" class="headerlink" title="记录我看的电影"></a>记录我看的电影</h5><ul><li><a href="">幸福终点站</a></li><li><a href="">加勒比海盗</a></li><li><a href="">速度与激情8</a></li><li><a href="">百万美元宝贝( Million Dollor baby)</a></li><li><a href="">陪安东尼度过漫长岁月</a></li><li><a href="">看不见的客人</a></li><li><a href="">致命ID</a></li><li><a href="">雷神3</a></li><li><a href="">罗生门（日本）</a></li><li><a href="">心迷宫</a></li><li><a href="">情遇曼哈顿</a></li><li><a href="">复仇者联盟</a></li></ul><h5 id="记录看的电视剧"><a href="#记录看的电视剧" class="headerlink" title="记录看的电视剧"></a>记录看的电视剧</h5><blockquote><p>电视剧看的不多，但是一看就要看完啊。等不了啊</p></blockquote><ul><li><a href="">权力的游戏s7</a></li><li><a href="">白夜追凶</a></li><li><a href="">无证之罪</a></li><li><a href="">激战玄武门（纪录片）</a></li><li><a href="">Justice（公开课）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h5 id=&quot;记录我看的电影&quot;&gt;&lt;a href=&quot;#记录我看的电影&quot; class=&quot;headerlink&quot; title=&quot;记录我看的电影&quot;&gt;&lt;/a&gt;记录我看的电影&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;幸福终点站&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="娱乐" scheme="http://yoursite.com/tags/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习1-Linux的基本命令（1）</title>
    <link href="http://yoursite.com/2017/11/12/Linux/linux-learn-1/"/>
    <id>http://yoursite.com/2017/11/12/Linux/linux-learn-1/</id>
    <published>2017-11-12T11:33:00.000Z</published>
    <updated>2017-11-13T03:49:07.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux的命令比较多，而且后台开发的时候基本操作服务器的时候都是采用命令行，当然不需要所有的都一次掌握，但是很多重要的用的多的还是需要掌握，不需要直接去记，还是需要多用才会熟练</p></blockquote><h5 id="shell相关"><a href="#shell相关" class="headerlink" title="shell相关"></a>shell相关</h5><h6 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h6><p><code>cat /etc/shells   //查看当前系统有那些shell</code><br><code>cat $SHELL</code></p><h6 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h6><p><code>cd ~    //切换路径到家目录</code></p><h6 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h6><p><code>history  //显示最近使用的命令</code><br><code>cd -  //在上下两个目录之间切换</code><br>``<br>主键盘快捷键：<br><img src="https://github.com/mianhk/image-save/blob/master/mingling1.jpg?raw=true" alt=""></p><h5 id="目录和文件"><a href="#目录和文件" class="headerlink" title="目录和文件"></a>目录和文件</h5><h6 id="类Unix系统目录结构"><a href="#类Unix系统目录结构" class="headerlink" title="类Unix系统目录结构"></a>类Unix系统目录结构</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/ 根目录</div><div class="line">    bin //系统可执行程序，如命令</div><div class="line">    boot //内核和启动程序，所有和启动相关的文件都保存在这里</div><div class="line">    grub //引导器相关文件</div><div class="line">    dev //设备文件</div><div class="line">    etc //系统软件的启动和配置文件，系统在启动过程中需要读取的文件都在这个目录。如LILO参数、用</div><div class="line">户账户和密码。</div><div class="line">    home //用户的主目录。下面是自己定义的用户名的文件夹</div><div class="line">    lib //系统程序库文件,这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32</div><div class="line">目录，几乎所有的应用程序都需要用到这些共享库。</div><div class="line">    media //挂载媒体设备，如光驱、U盘等</div><div class="line">    mnt //目录是让用户临时挂载别的文件系统，如挂载Windows下的某个分区，ubuntu默认还是挂载在/media</div><div class="line">目录。</div><div class="line">    opt //可选的应用软件包（很少使用）</div><div class="line">    proc //这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录</div><div class="line">的内容不在硬盘上而是在内存里。</div><div class="line">    sbin //管理员系统程序</div><div class="line">    selinux</div><div class="line">    srv</div><div class="line">    sys //udev用到的设备目录树，/sys反映你机器当前所接的设备</div><div class="line">    tmp //临时文件夹</div><div class="line">    usr //这是个最庞大的目录，我们要用到的很多应用程序和文件几乎都存放在这个目录下。]</div><div class="line">    bin // 应用程序</div><div class="line">    game //游戏程序</div><div class="line">    include</div><div class="line">    lib //应用程序的库文件</div><div class="line">    lib64</div><div class="line">    local //包含用户程序等</div><div class="line">    sbin //管理员应用程序</div></pre></td></tr></table></figure><h6 id="ls（列出文件夹中的文件）"><a href="#ls（列出文件夹中的文件）" class="headerlink" title="ls（列出文件夹中的文件）"></a>ls（列出文件夹中的文件）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-a 列出隐藏文件，文件中以“.”开头的均为隐藏文件，如：~/.bashrc</div><div class="line">-l 列出文件的详细信息</div><div class="line">-R 连同子目录中的内容一起列出</div></pre></td></tr></table></figure><p>ls -l开头显示的10个字符串，第一个表示的是文件类型，后面的9个分别表示：分为3组，每组3位。第一组表示文件属主的权<br>限，第二组表示同组用户的权限，第三组表示其他用户的权限。每一组的三个字符分别表示对文件的读、写和执行权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">首位表示：</div><div class="line">- 普通文件</div><div class="line">d 目录</div><div class="line">l 符号链接</div><div class="line">b 块设备文件</div><div class="line">c 字符设备文件</div><div class="line">s socket文件，网络套接字</div><div class="line">p 管道</div></pre></td></tr></table></figure></p><p>后九位对应的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">r 读</div><div class="line">w 写</div><div class="line">x 可执行。对于目录，表示进入权限。</div><div class="line">s 当文件被执行时，把该文件的UID或GID赋予执行进程的UID（用户ID）或GID（组 ID）。</div><div class="line">t 设置标志位（sticky bit）。如果是有sticky bit的目录，在该目录下任何用户只要有适当的权限即可创建文</div><div class="line">件，但文件只能被超级用户、目录拥有者或文件属主删除。如果是有sticky bit的可执行文件，在该文件执行后，</div><div class="line">指向其正文段的指针仍留在内存。这样再次执行它时，系统就能更快地装入该文件。</div><div class="line">- 没有相应位置的权限。</div></pre></td></tr></table></figure></p><h6 id="which-查看命令所在的位置"><a href="#which-查看命令所在的位置" class="headerlink" title="which(查看命令所在的位置)"></a>which(查看命令所在的位置)</h6><p><code>which ls    //查看ls命令所在的位置</code></p><h6 id="mv（移动）和cp（复制）"><a href="#mv（移动）和cp（复制）" class="headerlink" title="mv（移动）和cp（复制）"></a>mv（移动）和cp（复制）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv file1 file2  //文件重命名，file1和file2分别是原文件名和重命名的文件名</div><div class="line">mv file /dir     //移动文件</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//拷贝文件</div><div class="line">cp file1 file2</div><div class="line">cp file1 dir/</div><div class="line"></div><div class="line">//拷贝目录</div><div class="line">cp dir1 dir2 -r  //-r 选项在文件夹操作中，一般表示对文件夹中的文件递归操作</div><div class="line">cp dir1 ~/ -r</div></pre></td></tr></table></figure><h6 id="cat-查看文件里内容，输出到终端"><a href="#cat-查看文件里内容，输出到终端" class="headerlink" title="cat(查看文件里内容，输出到终端)"></a>cat(查看文件里内容，输出到终端)</h6><p>如果cat后面没有文件名，则读取标准输入</p><h6 id="ln-链接"><a href="#ln-链接" class="headerlink" title="ln(链接)"></a>ln(链接)</h6><p>链接分为两种，一种是硬链接（hard link），另一种是符号链接（Symbolic link）。建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。如果给ln命令加上-s选项，则建立符号链接。</p><h6 id="tree（显示目录的结构树）"><a href="#tree（显示目录的结构树）" class="headerlink" title="tree（显示目录的结构树）"></a>tree（显示目录的结构树）</h6><h6 id="wc-word-count"><a href="#wc-word-count" class="headerlink" title="wc(word count)"></a>wc(word count)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wc -l file //或–lines 只显示列数</div><div class="line">wc -w file //或–words 只显示字数</div><div class="line">wc -c file //或–bytes 或–chars 只显示 Bytes 数</div></pre></td></tr></table></figure><h6 id="od-显示数据"><a href="#od-显示数据" class="headerlink" title="od(显示数据)"></a>od(显示数据)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">od -tcx file1 //-t 指定数据的显示格式</div></pre></td></tr></table></figure><h6 id="du-显示目录的大小"><a href="#du-显示目录的大小" class="headerlink" title="du(显示目录的大小)"></a>du(显示目录的大小)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">du -hm /dir //以M为单位显示</div><div class="line">du -hb /dir //以B为单位</div><div class="line">du -hk /dir //以K为单位</div></pre></td></tr></table></figure><h6 id="df-查看磁盘的使用状况"><a href="#df-查看磁盘的使用状况" class="headerlink" title="df(查看磁盘的使用状况)"></a>df(查看磁盘的使用状况)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df --block-size=GB //以GB为单位显示</div><div class="line">df --block-size=MB //以MB为单位显示</div></pre></td></tr></table></figure><h5 id="文件属性和用户、用户组"><a href="#文件属性和用户、用户组" class="headerlink" title="文件属性和用户、用户组"></a>文件属性和用户、用户组</h5><h6 id="chmod（改变权限）"><a href="#chmod（改变权限）" class="headerlink" title="chmod（改变权限）"></a>chmod（改变权限）</h6><p>一种数字表示法一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0表示没有权限，</div><div class="line">1表示可执行权限，</div><div class="line">2表示可写权限，</div><div class="line">4表示可读权限，</div></pre></td></tr></table></figure></p><h6 id="whoami（显示当前用户名）"><a href="#whoami（显示当前用户名）" class="headerlink" title="whoami（显示当前用户名）"></a>whoami（显示当前用户名）</h6><h6 id="chown（更改某个文件或目录的属主和属组）"><a href="#chown（更改某个文件或目录的属主和属组）" class="headerlink" title="chown（更改某个文件或目录的属主和属组）"></a>chown（更改某个文件或目录的属主和属组）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown itcast:nogroup file1 //把一个文件改为itcast用户和nogroup用户组所有</div></pre></td></tr></table></figure><h6 id="chgrp-改变指定文件所属的用户组"><a href="#chgrp-改变指定文件所属的用户组" class="headerlink" title="chgrp(改变指定文件所属的用户组)"></a>chgrp(改变指定文件所属的用户组)</h6><h5 id="查找与检索"><a href="#查找与检索" class="headerlink" title="查找与检索"></a>查找与检索</h5><h6 id="find（在目录中搜索）"><a href="#find（在目录中搜索）" class="headerlink" title="find（在目录中搜索）"></a>find（在目录中搜索）</h6><p><code>find . -name &#39;file*&#39;  //在当前目录中搜索以file开头的文件</code></p><h6 id="grep-根据内容检索"><a href="#grep-根据内容检索" class="headerlink" title="grep(根据内容检索)"></a>grep(根据内容检索)</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Linux的命令比较多，而且后台开发的时候基本操作服务器的时候都是采用命令行，当然不需要所有的都一次掌握，但是很多重要的用的多的还是需要掌握，不需要直接去记，还是需要多用才会熟练&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;shell相关&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux 后台开发" scheme="http://yoursite.com/tags/Linux-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习0-开始</title>
    <link href="http://yoursite.com/2017/11/12/Linux/linux-learn-0/"/>
    <id>http://yoursite.com/2017/11/12/Linux/linux-learn-0/</id>
    <published>2017-11-12T10:59:12.000Z</published>
    <updated>2017-11-14T12:55:00.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong> 写在前面：</strong>关于Linux，是从大学的时候就开始用的，记得最开始的时候还是大二的暑假，那时候拿着一块嵌入式的开发板，还记得开发板的名字，友善之臂6440，cpu还是arm11的，第一次看到板子的时候是觉得这么大一块名字应该很吊了。于是拷了两个光盘的视频，在那个寒假就基本一直在家看那个视频。从像单片机一样点亮上面的二极管，基本上差不多的步骤，在没有系统的时候，觉得也还好。直到后来把整个系统写到板子上，便开始接触Linux了。</p></blockquote><a id="more"></a><blockquote><p>于是开始在虚拟机上抛弃了ubuntu，开始知道nat和桥接，开始ifconfig，开始折腾在vim的退出上。直到后面的一个课程设计上，做了一个嵌入式的小车，自己去找了很多开源的东西，越来越觉得Linux的神（ma）奇（fan）。后来考研了，然后来到了一个以为会搞嵌入式的老师。。。</p><p>好吧，反正中间陆陆续续看了看，其实真正拿来当找工作的成分还是少的，自己知道的也都是皮毛。于是现在开始了新的系统化的学习。希望这是另一个有趣且有用的过程。</p></blockquote><h4 id="学习大纲"><a href="#学习大纲" class="headerlink" title="学习大纲"></a>学习大纲</h4><h5 id="Linux的基本使用"><a href="#Linux的基本使用" class="headerlink" title="Linux的基本使用"></a>Linux的基本使用</h5><ul><li><a href="./linux-learn-0.md">Linux的基本命令</a></li><li><a href="ch3/README.md">vim编辑器</a></li><li><a href="ch4/README.md">GNU工具链</a></li></ul><h5 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h5><ul><li><a href="ch2/README.md">文件I/O</a></li><li><a href="ch3/README.md">文件系统</a></li><li><a href="ch4/README.md">进程</a></li><li><a href="ch2/README.md">信号</a></li><li><a href="ch3/README.md">线程</a></li><li><a href="ch4/README.md">网络编程</a><h5 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h5><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; 写在前面：&lt;/strong&gt;关于Linux，是从大学的时候就开始用的，记得最开始的时候还是大二的暑假，那时候拿着一块嵌入式的开发板，还记得开发板的名字，友善之臂6440，cpu还是arm11的，第一次看到板子的时候是觉得这么大一块名字应该很吊了。于是拷了两个光盘的视频，在那个寒假就基本一直在家看那个视频。从像单片机一样点亮上面的二极管，基本上差不多的步骤，在没有系统的时候，觉得也还好。直到后来把整个系统写到板子上，便开始接触Linux了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux 后台开发" scheme="http://yoursite.com/tags/Linux-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch6 函数</title>
    <link href="http://yoursite.com/2017/11/12/cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/11/12/cpp/cpp-primer/《cpp primer》ch6函数/</id>
    <published>2017-11-12T10:56:56.438Z</published>
    <updated>2017-11-14T12:33:53.446Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。</p></blockquote><a id="more"></a><h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><h2 id="形参和实参："><a href="#形参和实参：" class="headerlink" title="形参和实参："></a>形参和实参：</h2><p>实参是形参的初始值，函数的形参列表可以为空。<br>局部静态对象，定义成static类型，在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><p>如果形参是引用类型，它将绑定到对应的实参上，称为引用传递；否则，将实参的值拷贝后赋给形参，称为值传递。</p><h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2><p>将实参的值拷贝给形参。当是指针形参时，指针的行为和其他非引用类型一样，执行指针拷贝类型时，拷贝的是指针的值。拷贝之后是不同的指针，但是指向的是相同的值，我们可以在函数中修改指针所指对象的值。在C++中，建议使用引用类型的形参替代指针。</p><h2 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h2><p><strong> 1.使用引用避免拷贝。 </strong>因为有的类类型是不能拷贝的，或者在拷贝一些大的类类型对象或者容器对象比较低效。<br>如果函数不需要改变引用参数的值，最好将其声明为常量引用。<br><strong> 2.使用引用形参返回额外信息。</strong>由于函数不能有多个返回值，在我们需要返回多个值的时候，可以额外传一个引用参数。<br><strong> 3.可以直接操作引用形参所引的对象。 </strong></p><h2 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h2><p>和其它初始化一样，当用实参初始化形参时会忽略掉顶层const。也就是，形参的顶层const会被忽略掉。（这个可以思考一下，我们可以通过形参的const在参数中控制是否需要改变形参，以及对应的实参，这样更方便我们传参数。当然有了这个我们就不能重载有无const的两个函数了，因为会被编译器相同对待。）<br>尽量使用常量引用，除了在使用的时候，无法把常量引用初始化为引用（很简单的道理），另外，也会给调用者一种误导。</p><h2 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h2><p>无法以值传递的方式使用数组参数。数组的特点：不允许拷贝、使用数组会将其转化为指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void print(const int*);</div><div class="line">void print(const int[]);</div><div class="line">void print(const int[10]);  //这里的维度表示我们期望数组含有多少个元素，实际不一定</div></pre></td></tr></table></figure></p><h3 id="关于数组长度"><a href="#关于数组长度" class="headerlink" title="关于数组长度"></a>关于数组长度</h3><p>由于传递数组引用的时候，只是数组的首元素指针，所以有时候我们需要在形参定义的时候，就将数组大小传递给形参。这里有几种方式。</p><h2 id="6-2-5-mian处理命令行选项"><a href="#6-2-5-mian处理命令行选项" class="headerlink" title="6.2.5 mian处理命令行选项"></a>6.2.5 mian处理命令行选项</h2><p>当使用argv[]中的实参时，第一个实参保存的是程序名，所以应该从第二个开始。</p><h2 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h2><p>有时候我们预先不知道向函数传递几个实参。1.如果所有的实参类型相同，可以传递名为initializee_list的标准库类型；2.如果实参类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。</p><h1 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h1><p>return语句终止当前执行的函数，并将控制权返回到调用该函数的地方。<br>return语句不要返回局部对象的引用或引用（因为局部对象会在函数调用完成后删除，会产生未定义的结果）。<br>c++11新标准中函数可以返回花括号包围的值列表，主函数main的返回值，非0的返回值由机器决定。</p><h1 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h1><p>拥有顶层const不影响传入函数的对象。另外，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。<br>不能仅仅通过函数的返回值区分两个同名的函数</p><h2 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h2><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。在不同的作用域中无法重载函数名。<br>在c++中，名字查找发生在类型检查之前。</p><h1 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h1><p>大多数程序都有用的特性：默认实参、内联函数、constexpr函数。</p><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>一旦某个形参赋予了默认值，后面的所有形参必须有默认值。函数调用时，实参按其位置进行解析，只能省略尾部的实参。<br>一个函数被声明多次的时候，在给定的作用域中一个形参只能被赋予一次默认实参，也就是函数的后续声明。</p><h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>将它在每个调用点上“内联的”展开，一般来说用于优化规模较小、流程直接、频繁调用的函数。</p><h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>constexpr函数指能用于常量表达式的函数。函数的返回值及所有形参的类型都得是字面值类型，并且函数体中必须有且只有一条return语句。<br>编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式的指定 为内联函数.<br>内联函数和constexpr函数通常定义在头文件中.</p><h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>assert预处理宏,以一个表达式作为条件.<br>我们可以使用一个#define 语句定义NDEBUG，关闭调试状态</p><h1 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h1><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换得来时。</p><h2 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h2><p>函数匹配第一步：选定本次调用对应的重载函数集。<br>候选函数的两个特征：与被调用的函数同名，其声明在调用点可见。<br>第二步考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数。</p><h2 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h2><p>确定最佳匹配的排序：</p><ul><li>1.精确匹配：实参形参类型相同，实参从数组或函数类型转化为对应的指针类型，实参添加顶层const或者从实参中删除顶层const。</li><li>2.通过const转换实现的匹配。</li><li>3.通过类型提升实现的匹配。</li><li>4.通过算术类型转换或指针转换实现的匹配。</li><li>5.通过类类型转换实现的匹配。</li></ul><h1 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h1><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p><h2 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h2><p>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。</p><h2 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h2><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上是被当成指针使用。<br>可以直接把函数当成实参使用，会自动转换成指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-剑指offer-2</title>
    <link href="http://yoursite.com/2017/10/27/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-2/"/>
    <id>http://yoursite.com/2017/10/27/刷题/牛客网-剑指offer-2/</id>
    <published>2017-10-27T11:50:52.000Z</published>
    <updated>2017-10-27T14:03:44.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="T2：二维数组的查找"><a href="#T2：二维数组的查找" class="headerlink" title="T2：二维数组的查找"></a>T2：二维数组的查找</h4><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回</p></blockquote><p>二叉树是觉得很烦的东西了，比链表复杂很多倍</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;T2：二维数组的查找&quot;&gt;&lt;a href=&quot;#T2：二维数组的查找&quot; class=&quot;headerlink&quot; title=&quot;T2：二维数组的查找&quot;&gt;&lt;/a&gt;T2：二维数组的查找&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++ 剑指offer 牛客网" scheme="http://yoursite.com/tags/C-%E5%89%91%E6%8C%87offer-%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>win7下安装Ubuntu双系统</title>
    <link href="http://yoursite.com/2017/10/22/%E5%B7%A5%E5%85%B7/win7%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/10/22/工具/win7下安装Ubuntu双系统/</id>
    <published>2017-10-22T14:37:21.000Z</published>
    <updated>2017-11-14T12:56:09.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学(xian)习(de)所(dan)需(teng)，觉得一个虚拟机确实装的Ubuntu确实有点烦了，除了没有一个系统那样直接用起来爽以外，总觉得感受不到一个纯正的系统。而且虚拟机有时候懒得开了就算了。但是又舍不得直接把我换了固态之后就没有换过的系统直接换掉，毕竟我已经不是那个年轻的爱折腾的22岁的小伙子了，我23了。。于是就看着教程和xjbg装了双系统。同时的难度是，我的固态硬盘里放的系统，但是又不想把系统直接放在固态硬盘，只是希望通过固态启动一下，然后把其他的目录放在机械硬盘中</p></blockquote><h5 id="Win7准备"><a href="#Win7准备" class="headerlink" title="Win7准备"></a>Win7准备</h5><p>双系统的准备主要就是硬盘了，毕竟这么多学习资料是吧。。总还是要谨慎一点的。因为win7和linux系统的磁盘格式不一样，所以我们不能直接在win7里面分好磁盘。这里的工作是：将固态硬盘压缩300MB空间，作为Ubuntu的<code>/boot</code>分区，以供系统启动用。另外在机械硬盘中分出80GB空间，作为其他的<code>/</code>和<code>swap</code>分区。</p><h5 id="通过U盘做系统盘"><a href="#通过U盘做系统盘" class="headerlink" title="通过U盘做系统盘"></a>通过U盘做系统盘</h5><p>使用工具UtralISO，将下载好的Ubuntu系统，通过正常的模式写入到U盘中(这个随便百度一下就有了，经常装系统的这个就差不多知道了)</p><h5 id="重启装系统"><a href="#重启装系统" class="headerlink" title="重启装系统"></a>重启装系统</h5><p>首先还是熟悉的修改bios，按一下各种类似<code>F2</code>之类的键，进入BIOS设置，将启动项第一位改成U盘，然后重启。。<br>之后就是进去装系统了，主要是选磁盘的时候，把 固态硬盘中的未分配空间格式化为<code>/boot</code>，然后其他的机械硬盘中的，按照需要格式化为<code>/</code>和<code>/swap</code>,之后等着装完就好了。</p><h5 id="修改启动选项"><a href="#修改启动选项" class="headerlink" title="修改启动选项"></a>修改启动选项</h5><p>系统装完之后就要重启进入新系统了，这是惊喜而又刺激的发现，Ubuntu真好看，但是我的Win7去哪儿了。不过装了一百遍系统的我知道肯定还是个引导的问题，在网上找到了解决办法。在Ubuntu中输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo gedit /etc/default/grub</div><div class="line">#修改</div><div class="line">GRUB_DEFAULT=0 为：GRUB_DEFAULT=4</div><div class="line">#更新grub</div><div class="line">sudo update-grub</div><div class="line">在终端中找到：</div><div class="line">found win7...</div><div class="line">就说明win7引导被找到了，重启可以开始愉快的用了</div></pre></td></tr></table></figure></p><h6 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h6><p><a href="http://m.jb51.net/article/110288.htm" target="_blank" rel="external">http://m.jb51.net/article/110288.htm</a><br><a href="https://jingyan.baidu.com/article/e4d08ffdace06e0fd2f60d39.html" target="_blank" rel="external">https://jingyan.baidu.com/article/e4d08ffdace06e0fd2f60d39.html</a><br><a href="http://www.jianshu.com/p/c6750e459a94" target="_blank" rel="external">http://www.jianshu.com/p/c6750e459a94</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学(xian)习(de)所(dan)需(teng)，觉得一个虚拟机确实装的Ubuntu确实有点烦了，除了没有一个系统那样直接用起来爽以外，总觉得感受不到一个纯正的系统。而且虚拟机有时候懒得开了就算了。但是又舍不得直接把我换了固态之后就没有换过的系统
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>牛客网刷题总结-剑指offer(1)</title>
    <link href="http://yoursite.com/2017/10/15/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-1/"/>
    <id>http://yoursite.com/2017/10/15/刷题/牛客网-剑指offer-1/</id>
    <published>2017-10-15T13:26:46.000Z</published>
    <updated>2017-10-15T13:54:34.891Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说在前面：刷题真的是一件残酷的事情，就好比以前大学的时候只剩两天就考试了，刚刚看了一遍就开始先做题一样的感觉，面对无数的套路，幸运的时候还能庆幸自己能发现他们的套路。。<br>刷题的开始总是艰难的，希望有一天我能以上帝视角看清这些芸芸众生的时候，还能想起来当年我不止一次的一道题怼了一晚上照样白怼。</p></blockquote><h4 id="T1：二维数组的查找"><a href="#T1：二维数组的查找" class="headerlink" title="T1：二维数组的查找"></a>T1：二维数组的查找</h4><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>这里一般的思路肯定是，从行或者列开始找，根据递增的顺序，找到行或者列之后再判断列或者行，知道找到为止。最好的方法是，从左下角或者右上角开始找。原因是：这样的一行和一列的顺序是不一样的，这样我们找一行的时候没有就可以直接找下一行，充分利用递增的顺序，减少循环的次数。<br>其他的就是循环的写法了，关于数组，一定注意的是不要越界，这真的是我的痛啊，日常越界一百遍。<em>^</em>^_<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</div><div class="line">        bool found=false;</div><div class="line">        if(array.size()==0 ||array[0].size()==0)</div><div class="line">            return found;</div><div class="line">        for(int i=array[0].size()-1;i&gt;=0;--i)&#123;</div><div class="line">            if(target&gt;=array[0][i])&#123;</div><div class="line">                for(int j=0;j!=array.size();++j)&#123;</div><div class="line">                    if(target==array[j][i])</div><div class="line">                        found=true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                continue;</div><div class="line">        &#125;</div><div class="line">        return found;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T2：替换空格"><a href="#T2：替换空格" class="headerlink" title="T2：替换空格"></a>T2：替换空格</h4><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>替换的过程是，先找到这个空格，正常想法是，从前往后找，然后遇到就开始替换。但是注意到<em>对于一般题目，最直观的解法总不是最好的</em>，都是需要多从<strong>时间复杂度和空间复杂度想一想</strong>。就这个题目而言，直接从前往后替换，因为替换后的字符比原来多2个，所以每次替换我们都需要将后面的字符串向后移2个，这无疑会增加复杂度。一个很好的办法是：先统计空格的个数，计算出替换后的字符串长度，然后从后往前开始替换，这样就减少了移动的复杂度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void replaceSpace(char *str,int length) &#123;</div><div class="line">        if(length&lt;=0)</div><div class="line">            return;</div><div class="line">        int move_length=0;</div><div class="line">        int original_length=0;</div><div class="line">        for(int i=0;str[i]!=&apos;\0&apos;;++i)&#123;</div><div class="line">            ++original_length;</div><div class="line">            if(str[i]==&apos; &apos;)</div><div class="line">                ++move_length;</div><div class="line">        &#125;</div><div class="line">        int new_length=original_length+2*move_length;</div><div class="line">        if(new_length&gt;length)</div><div class="line">            return;</div><div class="line">        str[new_length]=&apos;\0&apos;;</div><div class="line">        while(original_length&gt;0)&#123;</div><div class="line">            --original_length;</div><div class="line">            if(str[original_length]==&apos; &apos;)&#123;</div><div class="line">                str[--new_length]=&apos;0&apos;;</div><div class="line">                str[--new_length]=&apos;2&apos;;</div><div class="line">                str[--new_length]=&apos;%&apos;;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                str[--new_length]=str[original_length];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T3-从尾到头打印链表"><a href="#T3-从尾到头打印链表" class="headerlink" title="T3:从尾到头打印链表"></a>T3:从尾到头打印链表</h4><blockquote><p>输入一个链表，从尾到头打印链表每个节点的值。</p></blockquote><p>链表我们一般都是从头到尾处理的，要从尾到头打印，这里想到一个数据结构：<strong>栈</strong>，后入先出的特点。从头到尾遍历链表，并把节点的值存入栈中，再从栈一一弹出即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  struct ListNode &#123;</div><div class="line">*        int val;</div><div class="line">*        struct ListNode *next;</div><div class="line">*        ListNode(int x) :</div><div class="line">*              val(x), next(NULL) &#123;</div><div class="line">*        &#125;</div><div class="line">*  &#125;;</div><div class="line">*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</div><div class="line">        stack&lt;int&gt; stack;</div><div class="line">        vector&lt;int&gt; result;</div><div class="line">        while(head!=nullptr)&#123;</div><div class="line">            stack.push(head-&gt;val);</div><div class="line">            head=head-&gt;next;</div><div class="line">        &#125;</div><div class="line">        while(stack.size()!=0)&#123;</div><div class="line">            result.push_back(stack.top());</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;说在前面：刷题真的是一件残酷的事情，就好比以前大学的时候只剩两天就考试了，刚刚看了一遍就开始先做题一样的感觉，面对无数的套路，幸运的时候还能庆幸自己能发现他们的套路。。&lt;br&gt;刷题的开始总是艰难的，希望有一天我能以上帝视角看清这些芸芸众生的时候，还
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++ 剑指offer 牛客网" scheme="http://yoursite.com/tags/C-%E5%89%91%E6%8C%87offer-%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>《effective C++》from line 1 to line 12</title>
    <link href="http://yoursite.com/2017/10/09/cpp/effective-cpp-1/"/>
    <id>http://yoursite.com/2017/10/09/cpp/effective-cpp-1/</id>
    <published>2017-10-09T11:16:31.000Z</published>
    <updated>2017-11-14T12:34:49.605Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面两章的内容主要是习惯使用c++，大部分都是《C++ primer》中的需要注意的一些东西，由于刚刚看完前面一本，所以有些还是有些印象的。这里大体总结一下。</p></blockquote><h4 id="L1-C-是一个语言联邦。"><a href="#L1-C-是一个语言联邦。" class="headerlink" title="L1:C++是一个语言联邦。"></a>L1:C++是一个语言联邦。</h4><p>包含着最初的以c语言为基础的C，面向对象的C++，C++的泛型编程，以及STL。在我们使用的过程中，可能会穿插，但是我们需要根据不同的情况使用不同的策略。</p><h4 id="L2：代替-define"><a href="#L2：代替-define" class="headerlink" title="L2：代替#define"></a>L2：代替#define</h4><p><code>#define</code>是在编译之前，也就是预处理的阶段就会被替换，这样我们在调试程序的时候看到的就是被替换的数字，会给别人甚至是之后调试的我们自己带来理解上的困难。另外，预处理器的工作是，直接把define的内容进行替换，当我们在define中写的表达式，并且在接下来使用的时候，可能产生无法理解的结果。所以当我们使用不想改变的常量时，使用<code>const</code>代替<code>#define</code>。<br>我们还可以使用<code>enum</code>来代替<code>#define</code>。这样显得会更接近一些，因为<code>enum</code>和<code>#define</code>一样，同时也不会被pointer或reference指向。<br>使用<code>inline</code>函数。</p><h4 id="L3-尽量使用const"><a href="#L3-尽量使用const" class="headerlink" title="L3:尽量使用const"></a>L3:尽量使用const</h4><p>这是一个很好理解的问题，就像你把东西给别人用，不想让别人动的地方就加一个<code>const</code>不让别人动一样。。。<br>具体的体现为：指针，不想被改变的变量，迭代器，成员函数等等。<br>我们可能还会为一个函数定义<code>const</code>和<code>非const</code>版本。</p><h4 id="L4：在使用对象前先初始化"><a href="#L4：在使用对象前先初始化" class="headerlink" title="L4：在使用对象前先初始化"></a>L4：在使用对象前先初始化</h4><p>嗯，记住。</p><h4 id="L5：了解c-会默认编写并调用哪些函数"><a href="#L5：了解c-会默认编写并调用哪些函数" class="headerlink" title="L5：了解c++会默认编写并调用哪些函数"></a>L5：了解c++会默认编写并调用哪些函数</h4><p>在面向对象编程时，记住三五法则。构造函数、拷贝构造函数、拷贝赋值运算符、移动赋值运算符、析构函数。记住这几个函数的作用，其在什么时候会被使用，如果没有的时候，系统会不会为我们生成。我们需不需要系统为我们生成。</p><h4 id="L6：不想编译器默认生成的函数，应该明确拒绝"><a href="#L6：不想编译器默认生成的函数，应该明确拒绝" class="headerlink" title="L6：不想编译器默认生成的函数，应该明确拒绝"></a>L6：不想编译器默认生成的函数，应该明确拒绝</h4><p>比如我们不希望编译器为我们生成默认的函数，我们应该将其定义为删除的或者定义为<code>private</code>的，也可以定义类似于uncopyable类似的base class。</p><h4 id="L7：为多态的基类声明virtual析构函数"><a href="#L7：为多态的基类声明virtual析构函数" class="headerlink" title="L7：为多态的基类声明virtual析构函数"></a>L7：为多态的基类声明virtual析构函数</h4><p>通常我们希望派生类覆盖或重写的函数，定义为virtual函数。析构函数作为对象被销毁时调用的函数，如果不是虚函数，那么可能在销毁的时候只会销毁基类的部分，局部销毁，造成资源泄露。</p><h4 id="L8：不要让异常逃离析构函数"><a href="#L8：不要让异常逃离析构函数" class="headerlink" title="L8：不要让异常逃离析构函数"></a>L8：不要让异常逃离析构函数</h4><p>析构函数绝对不要吐出异常，当遇到异常的时候应该捕捉任何异常，然后吞下或结束程序。<br>如果需要对某个操作函数运行期间抛出的异常做出反应，应该提供一个普通的函数执行操作，而不是在析构函数中。</p><h4 id="L9：绝不在构造和析构过程中调用virtual函数"><a href="#L9：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="L9：绝不在构造和析构过程中调用virtual函数"></a>L9：绝不在构造和析构过程中调用virtual函数</h4><p>构造和析构过程中，调用virtual函数的对象可能还没有产生，也就是派生类的对象，此时会产生未定义的行为。</p><h4 id="L10：另operator-返回一个reference-to-this"><a href="#L10：另operator-返回一个reference-to-this" class="headerlink" title="L10：另operator=返回一个reference to *this"></a>L10：另operator=返回一个reference to *this</h4><p>并不强制，只是为了防止一些调皮的调用者使用：<code>x=y=z=15</code>这样的操作。</p><h4 id="L11：在operator-中处理自赋值的情况"><a href="#L11：在operator-中处理自赋值的情况" class="headerlink" title="L11：在operator=中处理自赋值的情况"></a>L11：在operator=中处理自赋值的情况</h4><p>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，行为仍然正确。</p><h4 id="L12：复制对象时不忘每一个成分"><a href="#L12：复制对象时不忘每一个成分" class="headerlink" title="L12：复制对象时不忘每一个成分"></a>L12：复制对象时不忘每一个成分</h4><p>Copying函数应该确保复制对象内的所有成员变量和所有base class成分。<br>不要使用一个copying函数实现另一个copying函数，而是创建一个新的函数避免代码重复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前面两章的内容主要是习惯使用c++，大部分都是《C++ primer》中的需要注意的一些东西，由于刚刚看完前面一本，所以有些还是有些印象的。这里大体总结一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;L1-C-是一个语言联邦。&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>不知道怎么开的船？</title>
    <link href="http://yoursite.com/2017/09/25/%E7%94%9F%E6%B4%BB/%E4%B8%8D%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E5%BC%80%E7%9A%84%E8%88%B9/"/>
    <id>http://yoursite.com/2017/09/25/生活/不知道怎么开的船/</id>
    <published>2017-09-25T15:36:13.000Z</published>
    <updated>2017-11-12T12:54:26.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2017-9-25-记录学习"><a href="#2017-9-25-记录学习" class="headerlink" title="2017-9-25 记录学习"></a>2017-9-25 记录学习</h3><h4 id="额，打开sublime，打出来第一个-号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。"><a href="#额，打开sublime，打出来第一个-号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。" class="headerlink" title="额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。"></a>额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。</h4><p>最近开始再一次准备看数据结构和算法，再一次，是不能再跟闹着玩的一次了。看着实验室最近找工作的师兄师姐，一边心疼他们，一边更心疼明年的自己。所以我也想到了也许很好的办法，不如抓紧时间现在先好好学习，头疼起来了，心就不疼了吧。<br>断断续续看完了c++ primer，加上之前看过一些数据结构，但是当我打开牛客网第一题的时候还是觉得自己像个傻逼，于是按照我通常的习惯，换了第二题，觉得更傻逼了。于是还是先打开书看看了。。<br>看看书啊，又刷刷题啊，自己还是经常在骂自己和夸自己和强行夸自己这几种有限状态中跳来跳去。<br>晚上，刷到那个链表翻转的题目，又是好久没搞出来，各种数组越界。明明只是就那么几个指针而已，反复看了好几遍。当方法论出了问题的时候，有的时候会忍不住怀疑世界观。作为一个还是对这个世界充满疑惑和兴趣的青年，我好奇地又在网上搜了一遍：C++学什么，C++怎么学，C++学习路线。。于是一晚上又没了，留下一份写有听过好多遍名字的书的TXT文档，一如一个多月前的某一个晚上。。<br>可能距离我们找工作也有快一年吧，时间说长不长，说短不短吧。其实我觉得能担心的可能一直不是时间，而是利用时间。<br>先写一下接下来一段时间的任务吧，不要又乱跑了：</p><ul><li>《Effictive C++》认真看，主线</li><li>有空看数据结构，刷题，不随便放弃题目。搞懂会写，写好了为止</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2017-9-25-记录学习&quot;&gt;&lt;a href=&quot;#2017-9-25-记录学习&quot; class=&quot;headerlink&quot; title=&quot;2017-9-25 记录学习&quot;&gt;&lt;/a&gt;2017-9-25 记录学习&lt;/h3&gt;&lt;h4 id=&quot;额，打开sublime，打出来第一
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂想" scheme="http://yoursite.com/tags/%E6%9D%82%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch16 模板与泛型编程</title>
    <link href="http://yoursite.com/2017/09/19/cpp/cpp-primer/ch16-notes/"/>
    <id>http://yoursite.com/2017/09/19/cpp/cpp-primer/ch16-notes/</id>
    <published>2017-09-19T04:47:04.000Z</published>
    <updated>2017-11-14T12:36:54.894Z</updated>
    
    <content type="html"><![CDATA[<p>泛型编程与面向对象编程的区别是：面向对象编程能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。</p><h4 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h4><p>模板程序应该尽量减少对实参类型的要求。<br>模板的头文件通常包括声明和定义。<br>模板直到实例化时才生成代码。<br>泛型编程的一个目标就是另算法是“通用的”-适合于不同类型。所有标准库容器都定义了<code>==</code>和<code>!=</code>，但只有少数定义了<code>&lt;</code>运算符。因此尽量使用<code>!=</code>而不是<code>&lt;</code>。<br><strong> 类模板</strong>用来生成类的蓝图，一个类模板的每个实例都形成一个独立的类。默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。在类模板的作用域类，我们可以直接使用模板名而不必指定模板实参。<br>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给 所有友元模板实例，也可以只授权给特定实例。<br>当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。<br><strong> 成员模板</strong>：一个类（不管是模板类还是普通类）可以包含本身是模板的成员函数。这些成员函数被称为成员模板。成员模板不能是虚函数。<br>控制实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extern template class Blob&lt;string&gt;;  //声明，遇到extern模板声明时，编译器不会在本文件中生成实例化代码。，对于一个给定的实例化版本，可以有多个extern声明，但只能有一个定义。</div><div class="line">template int compare(const int&amp;,const int&amp;); //定义</div></pre></td></tr></table></figure></p><h4 id="16-2-模板实参推断"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断</h4><p>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。<br>一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。<br>如果函数参数类型不是模板参数，则可以进行正常的类型转换。<br><strong> 显式模板实参</strong>按由左至右的顺序与对应的模板参数匹配。</p><h4 id="16-3-重载与模板"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板</h4><h4 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h4><h4 id="16-5-模板特例化"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;泛型编程与面向对象编程的区别是：面向对象编程能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。&lt;/p&gt;
&lt;h4 id=&quot;16-1-定义模板&quot;&gt;&lt;a href=&quot;#16-1-定义模板&quot; class=&quot;headerlink&quot; title=&quot;16.1 
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch15-面向对象程序设计</title>
    <link href="http://yoursite.com/2017/09/19/cpp/cpp-primer/ch15-notes/"/>
    <id>http://yoursite.com/2017/09/19/cpp/cpp-primer/ch15-notes/</id>
    <published>2017-09-19T04:44:24.000Z</published>
    <updated>2017-11-14T12:36:35.325Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面向对象三个基本概念：数据抽象、继承和动态绑定（java里说的多态）。这章主要内容是继承和动态绑定。</p></blockquote><h4 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h4><h4 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h4><p>基类希望派生类进行覆盖的函数，通常将其定义为<strong> 虚函数</strong>，另一种是基类希望派生类继承但不要改变的函数。<br><code>protected</code>访问运算符：派生类可以访问，但是其他用户无法访问。<br>定义派生类：通过访问说明符控制派生类从基类继承而来的成员是否对派生类可见。<br>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为跟其他类一样，派生类会直接继承其在基类中的版本。<br>派生类到基类的转换。这可以让我们把派生类对象或者派生类对象的引用用在需要基类引用的地方，也可以把派生类指针用在需要基类指针的地方。但是，这里会出现一个问题，当我们使用基类的指针或者引用时，就不知道这个所绑定的对象到底是基类还是派生类了。<br>派生类构造函数。必须使用基类的构造函数初始化。（每个类控制自己的初始化过程。）<br>每个类定义各自的接口，派生类要遵循基类的接口。<br>如果基类中定义了静态成员，则在整个继承体系中只存在唯一的定义，不管定义了多少遍，都只存在唯一的实例。<br>对派生类的声明，不需要包含派生列表。<br>当我们不想让类被继承的时候，可以使用<code>final</code>关键字，跟在类名之后。<br>表达式的<strong> 静态类型</strong>在编译时是已知的，是变量声明时或者表达式生成式生成的类型。<strong> 动态类型</strong>则是变量或表达式表示的内存中的对象的类型。因此，基类的指针或引用的静态类型可能与动态类型不一致。<br>派生类向基类的自动类型转换只对指针和引用有效，在类型之间不存在这样的转换。当我们用一个派生类对象初始化或给一个基类对象赋值时，只有该派生类的对象中的基类部分会被拷贝、移动或赋值，派生类部分则会被忽略掉。</p><h4 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h4><p>我们必须为每一个虚函数提供定义，因为连编译器也无法确定到底使用的是哪一个虚函数。<br>如果我们在派生类中覆盖了某个虚函数时，可以再次使用<code>virtual</code>指出该函数的性质，但实际上并不一定要这么做。因为某个函数被声明成虚函数，则在所有的派生类中都是虚函数。</p><h4 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h4><p>在函数体声明的语句的分号前使用<code>=0</code>可以将一个函数声明为纯虚函数。<br>含有纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类负责覆盖该接口。我们不能直接创建一个抽象基类的对象。GCC的编译器中可能前面还是要加上<code>virtual</code><br><strong> 重构</strong>：重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。</p><h4 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h4><p>protected:对于类的用户来说是不可访问的，对于派生类的成员和友元来说是可访问的。但是只能通过<strong> 派生类对象</strong>来访问，<strong> 派生类</strong>对于一个基类中受保护的成员是无法访问的。<br>派生类向基类的转换：只有当D公有的继承B时，<strong> 用户代码</strong>才能使用基类向派生类的转换。无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换。如果D继承B的方式是公有的或受保护的，则D的派生类可以使用D向B的类型转换。<br>友元关系不能继承。基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员。<br>派生类可以使用<code>using</code>为那些可以访问的名字提供声明，以改变这些名字在它的派生类中的可访问性。</p><h4 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h4><p>每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。<br>当名字相同时，派生类的成员将隐藏基类的成员。基类可以通过<strong> 作用域运算符</strong>来使用隐藏的成员。一般情况下，我们应该不会这么使用，所以，平时继承类尽量不要覆盖继承而来的虚函数以外的基类的名字。<br><strong> 名字查找先于类型检查</strong>：如果派生类的成员与基类中的某个成员同名，则派生类将在其作用域内隐藏该基类成员。一旦编译器查找到名字后，不管形参列表是否相同，都不会再继续查找，这也是我们需要在覆盖虚函数时，保证形参列表是相同的。<br><code>using</code>声明语句指定一个名字而不是形参列表，所以我们在基类中使用一个<code>using</code>就可以把该函数的所有重载实例添加到派生类作用域中，派生类只需要定义特有的函数即可。</p><h4 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h4><p>位于继承体系中的类也需要控制当其对象执行一系列操作时发生怎样的行为：包括创建、移动、拷贝、赋值和销毁。<br>一般讲基类中的析构函数定义为虚函数，这样，继承体系中的派生类都会是虚析构函数，否则，若基类中的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。<br>虚析构函数将组织合成移动操作。<br>和普通成员的using声明不同，构造函数的using声明不会改变该构造函数的访问级别。<br>using声明语句不能指定explicit或constexpr。<br>当一个基类构造函数含有默认实参时，这些实参并不会被继承。派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p><h4 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8 容器与继承"></a>15.8 容器与继承</h4><p>容器不能直接存放继承体系中的对象，通常采用间接存储的方式。因为当我们把基类存储到一个容器中，当存入派生类对象，实际存入的只是派生类中基类的部分，显然不符合我们的需要。所以我们希望在具有继承关系的对象时，实际上存储的是基类的指针。（最好使用智能指针）</p><h4 id="15-9-文本查询程序再探"><a href="#15-9-文本查询程序再探" class="headerlink" title="15.9 文本查询程序再探"></a>15.9 文本查询程序再探</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;面向对象三个基本概念：数据抽象、继承和动态绑定（java里说的多态）。这章主要内容是继承和动态绑定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;15-1-OOP：概述&quot;&gt;&lt;a href=&quot;#15-1-OOP：概述&quot; class=&quot;head
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch14 重载运算符和类型转换</title>
    <link href="http://yoursite.com/2017/09/14/cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch14/"/>
    <id>http://yoursite.com/2017/09/14/cpp/cpp-primer/《cpp primer》ch14/</id>
    <published>2017-09-14T03:55:33.000Z</published>
    <updated>2017-11-14T12:41:34.367Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ch14-重载运算与类型转化"><a href="#ch14-重载运算与类型转化" class="headerlink" title="ch14 重载运算与类型转化"></a>ch14 重载运算与类型转化</h3><blockquote><p>当运算符作用于类的对象的时，通过重载运算符，使不同的运算符对于不同的类有着特定的含义，一方面能够简化类的使用者的逻辑，另一方面也能是程序更易于编写和阅读，而不至于编写更多的函数。</p></blockquote><a id="more"></a><h4 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h4><p>重载的运算符是特殊的函数：由operator关键字加上要定义的运算符号共同组成。作为函数，也包含返回类型、参数列表和函数体。参数列表个数与该运算符作用的算数对象数量一样多。<br>不应该被重载的运算符：逻辑与、逻辑或、逗号运算符、取地址运算符。<br>定义成成员还是非成员的判断：</p><ul><li>赋值、下标、调用、成员访问箭头等运算符必须是类的成员。</li><li>复合赋值运算符一般是类的成员</li><li>递增、递减、解引用等运算符。通常是类的成员</li><li>具有对称性的运算符可能转换任意一端的运算对象。如算数、相等性、关系、位运算符，通常应该是普通的成员函数。</li></ul><h4 id="14-2-输入输出运算符"><a href="#14-2-输入输出运算符" class="headerlink" title="14.2 输入输出运算符"></a>14.2 输入输出运算符</h4><p>输出的运算符尽量减少格式化操作，只需要打印信息就可以了。<br>输入输出运算符必须是非成员函数。<br>输入时可能会发生错误，例如：当流含有错误类型的数据时读取可能失败，当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。所以在输入操作中，输入运算符应该负责读取错误发生时，从错误中恢复。</p><h4 id="14-3-算术和关系运算符"><a href="#14-3-算术和关系运算符" class="headerlink" title="14.3 算术和关系运算符"></a>14.3 算术和关系运算符</h4><p>代码的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data</div><div class="line">operator-(const Sales_data &amp;lhs,const Sales_data &amp;rhs)&#123;</div><div class="line">    Sales_data item=lhs;</div><div class="line">    item-=rhs;  //调用重载的-=运算符来定义。性能相同，只是增加代码的 复用，增加可读性</div><div class="line">    return item;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong> 相等运算符</strong>的定义：如果定义了<code>==</code>，那么这个类也要定义<code>!=</code>（因为对于用户来说，当他们使用了<code>==</code>时，他们应该也希望能使用<code>!=</code>），并且相等运算符和不相等运算符的一个应该把工作委托给另外一个，这样一个预算负责实际比较，另外一个负责调用。<br><strong> 关系运算符</strong>:一般定义了相等运算符后，也会定义关系运算符，特别是<code>&lt;</code>运算符。<br>关系运算符的原则：如果存在唯一逻辑可靠的<code>&lt;</code>定义，就考虑定义<code>&lt;</code>运算符。如果该类同时包含<code>==</code>运算符，则当且仅当<code>&lt;</code>的定义与<code>==</code>产生一致的结果时才定义<code>&lt;</code>运算符。</p><h4 id="14-4-赋值运算符"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符</h4><p>赋值运算符<code>=</code>和符合赋值运算符<code>+=</code>，通常都定义为类的成员，并且都应该返回左侧运算对象的引用。</p><h4 id="14-5-下标运算符"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符</h4><p>当我们需要按元素在容器中的位置访问元素时，通常定义一个下标运算符<code>operator[]</code>，必须是成员函数。通常会定义两个版本，一个返回普通引用，一个返回常量引用。</p><h4 id="14-6-递增和递减运算符"><a href="#14-6-递增和递减运算符" class="headerlink" title="14.6 递增和递减运算符"></a>14.6 递增和递减运算符</h4><p>后置运算符接受一个额外的（不被使用）int类型的形参，当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参<br>。前置运算符返回递增或者递减后的对象的引用，后置运算符返回对象的原值（即递增或递减之前的原值），返回的是一个值而非引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class StrBlobPtr&#123;</div><div class="line">    public:</div><div class="line">        StrBlobPtr&amp; operator++();  //前置递增运算符</div><div class="line">        StrBlobPtr&amp; operator++(int); //后置递增运算符</div><div class="line">&#125;</div><div class="line">...</div><div class="line">p.operator++(0); //显式的调用后置递增运算符</div><div class="line">p.operator++(); // 显式的调用前置递增运算符</div></pre></td></tr></table></figure></p><h4 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h4><p>箭头运算符必须是类的成员，解引用运算符通常也是类的成员，即使并非必须这么做。<br>箭头运算符永远不能丢掉成员访问的这个基本含义，当我们重载箭头运算符时，可以改变的是从哪个对象中获取成员，而获取成员这一事实永远不变。<br>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p><h4 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h4><p>如果类重载了函数调用运算符，我们就可以像调用函数一样使用该类的对象。函数调用运算符必须是成员函数，一个类可以定义多个函数运算符，之间用参数的数量和类型进行区分。<br>函数对象通常作为泛型算法的实参<br>lambda表达式：当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在这个类中，含有一个重载的函数调用运算符。捕获的对象相当于类内含有数据成员。是否含有默认/移动构造函数通常视捕获的对象而定。<br>标准库定义了一组表示算数运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。<br>标准库规定其函数对象对于指针同样适用。eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vector&lt;string *&gt; nameTable;</div><div class="line">sort(nameTable.begin(),nameTable.end(),</div><div class="line">[](string *a,string *b)&#123;return a&lt;b&#125;);   //错误，nameTable中的指针之间没有关系，所以&lt;将产生未定义的行为</div><div class="line"></div><div class="line">sort(nameTable.begin(),nameTable.end(),less&lt;string* &gt;()); //正确</div></pre></td></tr></table></figure></p><p>C++中的<strong>  可调用对象</strong>：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。可调用的对象也有类型。<br>不同类型可能具有相同的调用形式，可以定义一个<strong> 函数表</strong>用于存储指向这些可调用对象的“指针”。<br><strong> 标准库function类型</strong>：是一个模板，当创建具体的function类型时，需要我们提供额外的信息。eg：<code>function&lt;int (int,int)&gt;</code>表示接受2个int、返回1个int的可调用对象。不能直接将重载函数的名字存入function类型的对象中，可存储函数指针而不是函数的名字。</p><h4 id="14-9-重载、类型转换与运算符"><a href="#14-9-重载、类型转换与运算符" class="headerlink" title="14.9 重载、类型转换与运算符"></a>14.9 重载、类型转换与运算符</h4><p><strong> 转换构造函数和类型转换运算符</strong>共同定义了类类型转换，有时也被称作用户定义的类型转换。<br><code>operator type() const; //type表示某种类型</code>因为类型转换运算符是隐式执行的，所以无法传递实参，也不能定义形参。为了避免具有误导性的类型转换，在不存在明显映射关系的时候，应不适用。<br>显式的类型转换运算符。eg:<code>explicit operator int() const;</code>当类型转换运算符是显式的，必须通过显式的强制类型转换才可以。<strong> 如果表达式被用作条件，编译器会显式的自动转换。</strong><br>无论我们什么时候在条件中使用了流对象，都会使用为IO类型定义operator bool。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct Integral&#123;</div><div class="line">    operator const int(); //将对象转换成 const int</div><div class="line">    operator int() const; //将对象转换成 int，用的相对较多</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>应该避免使用二义性的类型转换，总体原则：除了显式的向bool类型的转换外，应该尽量避免定义类型转换函数，并且尽可能限制某些看起来显然正确的显式构造函数。<br>错误eg：定义了两种将B类转换为A类的方法，一种使用B的类型转换运算符，一种使用A的以B为参数的构造函数。</p><ul><li>不要另两个类执行相同的类型转换。</li><li>避免转换目标是内置算数类型的类型转换。<br>函数重载的类型匹配：当调用重载函数时，如果两个或多个用户定义的类型转换都提供了可行的匹配，那么这些类型转换被认为一样好。这意味着我们设计的不足。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ch14-重载运算与类型转化&quot;&gt;&lt;a href=&quot;#ch14-重载运算与类型转化&quot; class=&quot;headerlink&quot; title=&quot;ch14 重载运算与类型转化&quot;&gt;&lt;/a&gt;ch14 重载运算与类型转化&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当运算符作用于类的对象的时，通过重载运算符，使不同的运算符对于不同的类有着特定的含义，一方面能够简化类的使用者的逻辑，另一方面也能是程序更易于编写和阅读，而不至于编写更多的函数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch13 拷贝控制</title>
    <link href="http://yoursite.com/2017/09/14/cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch13/"/>
    <id>http://yoursite.com/2017/09/14/cpp/cpp-primer/《cpp primer》ch13/</id>
    <published>2017-09-14T03:55:33.000Z</published>
    <updated>2017-11-14T12:40:34.086Z</updated>
    
    <content type="html"><![CDATA[<p>通过定义的五种特殊的成员函数，控制类的对象在拷贝。赋值、移动或销毁时做什么。包括：拷贝构造函数、拷贝赋值运算符、拷贝赋值运算符、移动赋值运算符以及析构函数。</p><h4 id="13-1-拷贝、赋值、销毁"><a href="#13-1-拷贝、赋值、销毁" class="headerlink" title="13.1 拷贝、赋值、销毁"></a>13.1 拷贝、赋值、销毁</h4><h4 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h4><p>在旧标准的标准库中，容器中所保存的类必须是可以拷贝的，新标准中，可以在容器中保存不可拷贝的类型，只要他们能够被移动就可以。</p><h5 id="13-6-1-右值引用"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用</h5><p>通过&amp;&amp;来获得右值引用，意为绑定到右值的引用。<br><strong> 重要性质：只能绑定到一个将要销毁的对象。</strong><br><strong> 所引用的对象将要被销毁，该对象没有其他用户</strong><br>– 左值引用：返回左值引用的函数，赋值、下标、解引用、前置递增/递减运算符。<br>– 右值引用：返回非引用的函数，算数、关系、位以及后置递增/递减运算符。<br>区分的方法：一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。<a href="http://blog.csdn.net/yapian8/article/details/42341307" target="_blank" rel="external">右值引用比较</a></p><p><strong> move函数(utility头文件中)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int &amp;&amp;rr3=std::move(rr1);  //相当于告诉编译器，我们希望像处理右值一样处理左值rr1。</div><div class="line">                           //调用move后，除了赋值和销毁rr1外不会再使用它</div><div class="line">                           //使用move直接用std::move</div></pre></td></tr></table></figure></p><h6 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h6><p>目的：让类支持移动操作。<br>移动构造函数：第一个参数是一个该类类型的右值引用，任何其他额外的参数都要有默认实参。不需要分配新内存，直接接管原来的内存。不会跑异常，不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。（原因是标准库很多对于存在异常的处理方式，例如vector）<br>移动赋值运算符：首先要处理自赋值的情况。（为什么检查自赋值？因为右值可能是move调用返回的结果，不能在使用右侧运算符对象之前释放左侧运算对象的资源。）<br><strong> 如果类有拷贝构造函数和拷贝赋值运算符，没有定义移动操作时，编译器不会为其分配默认的移动操作，而是会采用对应的拷贝进行代替。如果没有定义任何的拷贝操作，才会为其合成移动构造函数或移动赋值运算符。</strong><br>移动操作不会被隐式的定义为删除的操作,定义为删除元素的原则：</p><ul><li>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或有类成员未定义自己的拷贝构造函数且编译器不能为其合成默认移动构造函数</li><li>有类成员的移动构造函数或移动赋值运算符被定义为删除的或不可访问的</li><li>类的析构函数被定义为删除的</li><li>有类成员是const的或是引用</li></ul><p><strong> 三/五法则 </strong>：<br>通常，拥有一个资源的类，必须定义拷贝构造函数、拷贝赋值运算符、析构函数才能工作，而由于大量的拷贝会影响资源的额外开销，定义移动构造函数和移动赋值运算符可以避免此类问题。</p><h5 id="13-6-1-右值引用和成员函数"><a href="#13-6-1-右值引用和成员函数" class="headerlink" title="13.6.1 右值引用和成员函数"></a>13.6.1 右值引用和成员函数</h5><p>区分移动和拷贝的重载函数通常有一个版本接受<code>const T&amp;</code>，另一个版本接受一个<code>T&amp;&amp;</code>。很多时候它们看起来调用的是一个函数，通常它们内部的构造也很接近，有一点差别。我们可以根据实参的类型进行判断，我们用的是左值和右值区分调用的版本。<br>有的时候我们想要避免对右值进行赋值（在旧的标准中是有可能发生的，并且新的标准为了向后兼容没有禁止），可以在参数列表后放置一个<strong> 引用限定符</strong>。还可以通过使用<code>&amp;</code>或者<code>&amp;&amp;</code>指出指向一个左值或者一个右值。eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    public:</div><div class="line">        Foo &amp;operator=(const Foo&amp;) &amp;; //只能向可修改的左值赋值。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>引用限定符可以区分重载版本，如同const可以用来区分一个成员函数的重载版本。一般当我们定义两个或两个以上的具有相同名字和相同参数列表的成员函数，就必须对所有函数加上引用限定符，或者都不加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    public:</div><div class="line">        Foo sorted() &amp;&amp;;</div><div class="line">        Foo sorted() const; //错误，需要加上引用限定符</div><div class="line">        /////////////////</div><div class="line">        Foo sorted(Comp*);</div><div class="line">        Foo sorted(Comp*) const; //正确，两个版本都没有引用限定符</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过定义的五种特殊的成员函数，控制类的对象在拷贝。赋值、移动或销毁时做什么。包括：拷贝构造函数、拷贝赋值运算符、拷贝赋值运算符、移动赋值运算符以及析构函数。&lt;/p&gt;
&lt;h4 id=&quot;13-1-拷贝、赋值、销毁&quot;&gt;&lt;a href=&quot;#13-1-拷贝、赋值、销毁&quot; class=
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我的书单2017</title>
    <link href="http://yoursite.com/2017/09/10/%E7%94%9F%E6%B4%BB/%E6%88%91%E7%9C%8B%E7%9A%84%E6%9D%82%E4%B9%A6/"/>
    <id>http://yoursite.com/2017/09/10/生活/我看的杂书/</id>
    <published>2017-09-09T16:40:49.000Z</published>
    <updated>2017-11-15T12:15:44.040Z</updated>
    
    <content type="html"><![CDATA[<h5 id="2017要看完的书，生活总得有一些flag是吧"><a href="#2017要看完的书，生活总得有一些flag是吧" class="headerlink" title="2017要看完的书，生活总得有一些flag是吧"></a>2017要看完的书，生活总得有一些flag是吧</h5><p><a href="http://item.jd.com/12125924.html" target="_blank" rel="external">《人类简史》尤瓦尔·赫拉利</a><br><a href="http://item.jd.com/12099462.html" target="_blank" rel="external">《未来简史》尤瓦尔·赫拉利</a></p><hr><h5 id="2015-2016看的书："><a href="#2015-2016看的书：" class="headerlink" title="2015-2016看的书："></a>2015-2016看的书：</h5><p><a href="http://item.jd.com/12125924.html" target="_blank" rel="external">经济学通识</a><br><a href="">霍乱时期的爱情</a><br><a href="">围城</a><br><a href="">雅库玛的诅咒</a><br><a href="">今天你真好看</a><br><a href="">鬼吹灯1</a><br><a href="">北京折叠</a><br><a href="">百年孤独</a><br><a href="">活着</a></p><hr><h5 id="东野圭吾-专场"><a href="#东野圭吾-专场" class="headerlink" title=" 东野圭吾 专场"></a><strong> 东野圭吾 </strong>专场</h5><p><a href="">白夜行</a><br><a href="">嫌疑人X的现身</a><br><a href="">秘密</a><br><a href="">信</a><br><a href="">恶意</a><br><a href="">假面饭店</a><br><a href="">放学后</a><br><a href="">解忧杂货店</a><br><a href="">彷徨之刃</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;2017要看完的书，生活总得有一些flag是吧&quot;&gt;&lt;a href=&quot;#2017要看完的书，生活总得有一些flag是吧&quot; class=&quot;headerlink&quot; title=&quot;2017要看完的书，生活总得有一些flag是吧&quot;&gt;&lt;/a&gt;2017要看完的书，生活总得有一些
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用总结</title>
    <link href="http://yoursite.com/2017/09/10/%E5%B7%A5%E5%85%B7/hexo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/09/10/工具/hexo使用总结/</id>
    <published>2017-09-09T16:24:59.000Z</published>
    <updated>2017-11-14T12:56:50.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hexo的使用总结"><a href="#Hexo的使用总结" class="headerlink" title="Hexo的使用总结"></a>Hexo的使用总结</h3><blockquote><p>没错，这几天又开始折腾一下博客了，最近的节奏天天白天待在实验室怼论文，晚上看C++，时间安排比较紧凑，就觉得更需要阶段性的总结吧，所以又来写博客了，github始终是一个好的选择，于是入了Hexo的坑。。折腾的过程心情总是有些复杂，在激动和mmp之间徘徊，虽然很多问题在wiki和issue里都有，但还是想总结一下自己亲自踩的坑。</p></blockquote><a id="more"></a><h5 id="页面中文无法显示的问题"><a href="#页面中文无法显示的问题" class="headerlink" title="页面中文无法显示的问题"></a>页面中文无法显示的问题</h5><p>这种中文问题，基本上都是编码的问题，但是开始各种都没找到原因，改了language里面的配置文件，最后发现是文件的编码，需要改成’无bom的utf-8的编码格式 ‘</p><h5 id="主界面无法显示categories和tags的问题"><a href="#主界面无法显示categories和tags的问题" class="headerlink" title="主界面无法显示categories和tags的问题"></a>主界面无法显示categories和tags的问题</h5><p>这个问题真的是搞的有点久，因为基本上都被人忽略了，也可能很多人都没遇到而我恰好遇到了吧，不懂前端的我只能对于这种玄学问题强行百度了。<br>解决办法：将categories和tags目录下的index文件分别改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">categories:</div><div class="line">type: &quot;categories&quot;</div><div class="line">layout: &quot;categories&quot;</div><div class="line">tags:</div><div class="line">type: &quot;tags&quot;</div><div class="line">layout: &quot;tags&quot;</div></pre></td></tr></table></figure></p><p>折腾完又不早了，希望以后好好看书，好好编程吧，最近没有什么特别大的梦想，只想安静的学习。。。<br><strong> Reference: </strong><br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo文档</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">Next主题文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hexo的使用总结&quot;&gt;&lt;a href=&quot;#Hexo的使用总结&quot; class=&quot;headerlink&quot; title=&quot;Hexo的使用总结&quot;&gt;&lt;/a&gt;Hexo的使用总结&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;没错，这几天又开始折腾一下博客了，最近的节奏天天白天待在实验室怼论文，晚上看C++，时间安排比较紧凑，就觉得更需要阶段性的总结吧，所以又来写博客了，github始终是一个好的选择，于是入了Hexo的坑。。折腾的过程心情总是有些复杂，在激动和mmp之间徘徊，虽然很多问题在wiki和issue里都有，但还是想总结一下自己亲自踩的坑。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch7 类</title>
    <link href="http://yoursite.com/2017/06/27/cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch7%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/06/27/cpp/cpp-primer/《cpp primer》ch7类/</id>
    <published>2017-06-27T09:55:33.000Z</published>
    <updated>2017-11-14T12:47:37.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>类是面向对象编程的基础，使用类定义自己的数据类型，可以更方便的解决问题中的各种概念，使我们更容易编写、调试和修改程序。</p></blockquote><a id="more"></a><h3 id="7-1-定义抽象的数据类型"><a href="#7-1-定义抽象的数据类型" class="headerlink" title="7.1 定义抽象的数据类型"></a>7.1 定义抽象的数据类型</h3><ul><li>定义在类内部的函数时隐式的inline函数。</li><li>类的所有成员都必须在类的内部声明，但是成员函数体可以定义在类的内部或外部。</li><li>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。</li><li>成员函数体可以随意使用类中的其他成员而不需要在意这些成员出现的次序。</li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>编译器创建的构造函数又被称为合成的默认构造函数，合成的默认构造函数初始化类的数据成员规则为：存在类内初始值的时候，用它来初始化成员；否则，默认初始化该成员。<br>对于一个普通的类，一般要定义自己的默认构造函数：</p><ol><li>编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</li><li>对于某些类来说，合成的默认构造函数可能执行错误的操作。</li><li>有的时候编译器不能为某些类合成默认的构造函数。</li></ol><ul><li>构造函数没有返回类型。</li></ul><h4 id="拷贝。赋值和析构"><a href="#拷贝。赋值和析构" class="headerlink" title="拷贝。赋值和析构"></a>拷贝。赋值和析构</h4><p>除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象的时候发生的行为。<br>当我们不主动定义这些操作的的时候，编译器将替我们合成他们。但是有些类不能依赖于合成的版本。当类需要分配类对象之外的资源时，合成的版本常常会失效。</p><h3 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h3><p>在类的定义中，可以包含0个或多个访问说明符，每个访问说明符指定接下来的成员访问级别，一般来说，作为接口的一部分，构造函数和一部分成员函数应该定义在public说明符之后，而数据成员和作为实现部分的函数跟在private说明符之后。<br>class和struct唯一的区别是默认访问权限不同。</p><h3 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h3><p>类型成员、类的成员的类内初始值、可变数据成员、内联数据成员、从成员函数返回*this、关于如何定义类类型及友元类等。</p><h4 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h4><p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制。</p><h4 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h4><p>在类中，一些规模较小的函数常被定义为内联函数<br>两种方式：1、直接把函数定义放在类的内部<br>          2、把函数定义放在类的外部，显式的使用inline</p><ul><li>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</li><li>在实践中，设计良好的代码常常包含很多的小函数，通过调用这些小函数，可以完成其他一组函数的“实际”工作。</li></ul><h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><ul><li>对于一个类来说，它的成员和其他任何类的成员都不是一回事。</li><li>类的声明：不完全类型的使用：可以定义指向这种类型的指针或引用，也可以声明（但不能完全定义）以不完全类型作为参数或者返回类型的函数。</li></ul><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类中包括非公有成员在内的所有成员。</p><ul><li>还可以另一个类的成员函数为自己的友元。</li><li>如果一个类想把一组重载函数声明称它的友元，需要对每一个分别声明。</li><li>友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。</li></ul><h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><ul><li>一个类就是一个作用域</li><li>函数的返回类型通常出现在函数名之前，所以返回类型是在类的作用域外的。</li><li>名字查找规则：首先名字所在快寻找声明语句；查找外层作用；报错。</li></ul><h4 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h4><ul><li>如果成员是const或引用的话，必须进行初始化；当成员属于某种类类型且该类没有定义构造函数时，也必须初始化。</li><li>使用构造函数初始值：不仅仅是底层效率的问题。另有一些数据成员必须被初始化。</li><li>成员初始化顺序：构造函数初始化列表值说明用于初始化成员的值，而不限定初始化的具体执行顺序。（尽量按照顺序初始化，并且避免使用某些成员初始化其他成员）</li><li>委托构造函数：</li><li>默认构造函数的作用：当对象被默认初始化或值初始化时自动执行默认构造函数</li><li>默认初始化发生:</li></ul><ol><li>块作用域内不适用任何初始值定义一个非静态变量或数组时。</li><li>一个类本身含有类类型的成员且使用合成的默认构造函数。</li><li>类类型的成员没有在构造函数初始值列表中显式的初始化。</li></ol><ul><li>值初始化发生：</li></ul><ol><li>数组初始化时提供的初始值数量小于数组的大小</li><li>不使用初始值定义一个局部的静态变量</li><li>书写形如T()的表达式显式的请求值初始化</li></ol><ul><li><p>隐式的类类型转换：能通过一个实参调用的构造函数定义一条从构造函数的参数类型向类类型隐式转换的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string null_book=&quot;2132321&quot;;</div><div class="line">item.combine(null_book);//将一个string的实参传递给了combine成员。</div></pre></td></tr></table></figure></li><li><p>隐式类型转换只能一步，可以使用explicit阻止隐式类型转换。</p></li><li>字面值常量类至少提供一个constexpr构造函数<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;类是面向对象编程的基础，使用类定义自己的数据类型，可以更方便的解决问题中的各种概念，使我们更容易编写、调试和修改程序。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch4 表达式</title>
    <link href="http://yoursite.com/2017/06/05/cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch4%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/06/05/cpp/cpp-primer/《cpp primer》ch4表达式/</id>
    <published>2017-06-05T09:55:33.000Z</published>
    <updated>2017-11-14T12:49:45.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不管学习什么语言都会有这么一章，不管是c、java、Python，这都是会经历的一章，唉，无奈当时年少无知不止梦想是什么的我每每看到这些的时候都觉得很烦。当再一次翻开c++的这一章的时候，也有这样的感觉，似曾相识燕归来，却又无可奈何花落去。<br>我认为这一章的很多都不是需要太多的去深究，只需要有个大概的概念，然后更多的是在今后的编程过程中，不断的实践自然就知道了，是怎样写的。而且累死一些优先级的问题，更多的时候就像书里建议的那样，一个括号来的简单粗暴实用的多，所以，这章，就记一下实在有违常规的理解的内容吧。</p></blockquote><a id="more"></a><h3 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h3><ul><li>运算对象转换：小整数类型（如bool、char、short等）通常会被提升为较大的整数类型，主要是int。</li><li>左值和右值：一个左值表达式的求值结果时一个对象或者一个函数，以常量对象为代表的某些左值不能作为赋值语句的左侧运算对象。<strong> 简单归纳：当对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置） </strong></li><li>左值右值使用原则：需要右值的地方可以用左值代替，但是不能把右值当成左值使用。当一个左值被当成一个右值使用的时候，实际上使用的是它的内容（值  ）</li><li>需要用到左值的地方：<br>1.赋值运算符。需要左值作为其左值运算对象，得到结果仍然是一个左值<br>2.取地址符。返回一个指向该运算对象的指针，这个指针是一个右值<br>3.内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值<br>4.内置类型和迭代器的递增递减运算符作用于左值运算对象，得到的结果是左值。</li><li>关键字decltype中左值和右值的不同</li><li>处理复合表达式的经验：使用括号；如果改变了某个运算对象的值，就不要在表达式的其它地方再使用这个运算对象</li></ul><h3 id="4-2-算数运算符"><a href="#4-2-算数运算符" class="headerlink" title="4.2 算数运算符"></a>4.2 算数运算符</h3><p>溢出的情况，值会发生“环绕”</p><h3 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h3><p>进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值作为运算对象</p><h3 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h3><p>赋值运算满足右结合律<br>参与连续赋值的变量必须是相同的类型</p><h3 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h3><h3 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h3><p>解应用运算符的优先级低于点运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cond?expr1:expr2;</div><div class="line">//输出表达式中使用条件运算符</div><div class="line">cout&lt;&lt;((grade&lt;60)?&quot;fail&quot;:&quot;pass&quot;); //输出pass或者fail</div></pre></td></tr></table></figure></p><p>条件运算符可以嵌套，一般为了代码的可读性，嵌套不要超过三层。</p><h3 id="4-7-sizeof运算符"><a href="#4-7-sizeof运算符" class="headerlink" title="4.7 sizeof运算符"></a>4.7 sizeof运算符</h3><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得值是一个size_t类型的常量表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sizeof(type)</div><div class="line">sizeof expr</div></pre></td></tr></table></figure></p><h3 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h3><p>首先对左侧表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。</p><h3 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h3><h4 id="发生隐式类型转换"><a href="#发生隐式类型转换" class="headerlink" title="发生隐式类型转换"></a>发生隐式类型转换</h4><ul><li>比int小的整形值首先提升为较大的整数类型</li><li>条件中，非bool值转为bool值。</li><li>初始化过程中，初始值转化为变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型</li><li>如果算数预算或关系运算对象有多种类型，需要转换成同一种类型。</li><li>函数调用时，也可能发生类型转换</li></ul><h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cast-name&lt;type&gt;(expression)</div><div class="line">cast-name:static_cast,dynamic_cast,const_cast,reinterpret_cast</div></pre></td></tr></table></figure><p>static_cast:任何具有明确定义的类型转换，只要不包含底层const都可以使用。<br>const_cast:只能改变运算对象的底层const<br>dynamic_cast：支持运行时类型识别<br>reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释。（使用起来非常危险）</p><p><strong> 尽量避免强制类型转换 </strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不管学习什么语言都会有这么一章，不管是c、java、Python，这都是会经历的一章，唉，无奈当时年少无知不止梦想是什么的我每每看到这些的时候都觉得很烦。当再一次翻开c++的这一章的时候，也有这样的感觉，似曾相识燕归来，却又无可奈何花落去。&lt;br&gt;我认为这一章的很多都不是需要太多的去深究，只需要有个大概的概念，然后更多的是在今后的编程过程中，不断的实践自然就知道了，是怎样写的。而且累死一些优先级的问题，更多的时候就像书里建议的那样，一个括号来的简单粗暴实用的多，所以，这章，就记一下实在有违常规的理解的内容吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch3 字符串、向量和数组</title>
    <link href="http://yoursite.com/2017/06/04/cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch3/"/>
    <id>http://yoursite.com/2017/06/04/cpp/cpp-primer/《cpp primer》ch3/</id>
    <published>2017-06-04T09:55:33.000Z</published>
    <updated>2017-09-09T17:03:23.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><h3 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h3><h3 id="头文件中不应该包含using声明"><a href="#头文件中不应该包含using声明" class="headerlink" title="头文件中不应该包含using声明"></a>头文件中不应该包含using声明</h3><p>因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。</p><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string s1;   //默认初始化</div><div class="line">string s2=s1;  //s2是s1的副本</div><div class="line">string s2(s1); //等价于string s2=s1,s2是s1的副本</div><div class="line">string s3=&quot;hiya&quot;;  //s3是字面值的副本，但是不包含字面值最后的那个空字符</div><div class="line">string s3(&quot;hiya&quot;);  //等价于string s3=&quot;hiya&quot;</div><div class="line">string s4(n,&apos;c&apos;);  //把s4初始化为连续n个字符c组成的字符串</div></pre></td></tr></table></figure><h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><ul><li>读写string对象</li><li>读取未知数量的string对象</li><li>使用getline读取一整行</li><li>string的empty和size操作<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3>size_type是一种无符号整形数，如果在表达式中混用了带符号数和无符号数会产生意想不到的后果。<h3 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h3>按字典顺序<h3 id="字面值和string类型相加"><a href="#字面值和string类型相加" class="headerlink" title="字面值和string类型相加"></a>字面值和string类型相加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//错误的方式</div><div class="line">string s=&quot;hello&quot;+&quot;,&quot; //错误，因为两个运算对象都不是string，不能把两个字面值直接相加</div><div class="line">string s1=&quot;hello&quot;+s1+&quot;,&quot; //正确</div></pre></td></tr></table></figure></li></ul><p><strong> 字符串字面值与string是不同的类型 </strong></p><h3 id="ex3-3-string类的输入运算和getline函数分别如何处理字符串"><a href="#ex3-3-string类的输入运算和getline函数分别如何处理字符串" class="headerlink" title="ex3.3 string类的输入运算和getline函数分别如何处理字符串"></a>ex3.3 string类的输入运算和getline函数分别如何处理字符串</h3><p>string的标准输入：自动忽略字符串开头的空白，从第一个真正的字符开始读取，直到下一个空白为止<br>getline函数：从给定的输入流中读取，直到遇到换行符为止。</p><h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><p>vector是一种类模板，需要后加一堆尖括号，在括号内放上信息。</p><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><ul><li>1.使用拷贝初始化</li><li>2.如果提供一个类内的初始值，只能使用拷贝初始化或者花括号形式初始化</li><li>3.如果提供的是初始值元素值的列表，则只能使用花括号初始化，而不能使用圆括号</li><li>4.创建指定数量的元素：采用圆括号<h3 id="3-3-2-像vector中添加元素"><a href="#3-3-2-像vector中添加元素" class="headerlink" title="3.3.2 像vector中添加元素"></a>3.3.2 像vector中添加元素</h3>push_back：像一个值添加到vector的尾部。（如果开始不知道有多少元素，c++中，一般先创建一个空的vector然后像其中添加元素最好）<br>不能使用下标形式添加元素，只能对确知已存在的元素执行下标操作。</li></ul><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p>迭代器这个名词可能有三种不同的含义：可能是迭代器概念本身，可能是容器定义的类型，还可能指某个迭代器对象。<br>某些对Vector对象的操作回事迭代器失效：一个是不能在范围for循环内向vector中添加元素，另一个是任何一种可能改变vector对象容量的操作，都有可能是vector对象的迭代器失效。</p><h3 id="迭代器的算数运算"><a href="#迭代器的算数运算" class="headerlink" title="迭代器的算数运算"></a>迭代器的算数运算</h3><p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。<br>迭代器之间的比较：参与比较的迭代器必须合法且指向同一个容器的元素（或者尾元素的下一个位置）</p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组与vector的区别：数组的大小确定不变，不能随意像数组中添加元素。性能很好，但是损失了灵活性。</p><h3 id="3-5-1-定义和初始化数组"><a href="#3-5-1-定义和初始化数组" class="headerlink" title="3.5.1 定义和初始化数组"></a>3.5.1 定义和初始化数组</h3><p>数组是一种复合类型，数组的维度必须是一个常量表达式。<br>定义数组的时候必须指定数组的类型。同时，数组的元素应该为对象，不存在引用的数组。</p><h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char a1[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，没有空字符</div><div class="line">char a2[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，含有显式的空字符</div><div class="line">char a3[]=&quot;C++&quot;;   //自动添加表示字符串结束的空字符</div></pre></td></tr></table></figure><h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p><strong> 要想理解数组的声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int &amp;refs[10]=...  //  错误！不存在数组的引用</div><div class="line">int (*Parray)[10]=&amp;arr; //Parray指向一个含有10个整数的数组</div><div class="line">int (&amp;arrRef)[10]=arr   //arrRef引用一个含有10个整数的数组</div><div class="line">int *ptrs[10];  //ptrs是一个含有10个整型指针的数组</div></pre></td></tr></table></figure></p><h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><ul><li>数组下标为<strong> size_t类型 </strong>，是一种机器相关的无符号类型。<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3>使用数组的时候编译器一般会把它转化成指针<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4>允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。<br>C风格字符串和字符数组的关系，尤其需要考虑串尾是否含有空字符。<br><strong> 问题：为什么没有指针相加？ </strong><br>指着也是一个对象，与指针有关的属性有三个，分别是指针的值（是一个内存地址值）、指针所指的对象、指针本身在内存中的存储位置。显然把两个地址加在一起是没有意义的。<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><h4 id="混用string对象和C风格字符串"><a href="#混用string对象和C风格字符串" class="headerlink" title="混用string对象和C风格字符串"></a>混用string对象和C风格字符串</h4></li><li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</li><li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（但不能两个都是）；在string对象的赋值运算中允许以空字符串结束的字符数组作为右侧的运算对象。<h4 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h4>允许使用数组初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址即可。但不能使用一个数组为另一个内置类型的数组赋初值，也不能使用vector对象初始化数组。<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。<br>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int ia[3][4] //大小为3的数组，每个元素是含有4个整数的数组</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-字符串、向量和数组&quot;&gt;&lt;a href=&quot;#第3章-字符串、向量和数组&quot; class=&quot;headerlink&quot; title=&quot;第3章 字符串、向量和数组&quot;&gt;&lt;/a&gt;第3章 字符串、向量和数组&lt;/h1&gt;&lt;h2 id=&quot;3-1-命名空间的using声明&quot;&gt;&lt;a href=&quot;#3-1-命名空间的using声明&quot; class=&quot;headerlink&quot; title=&quot;3.1 命名空间的using声明&quot;&gt;&lt;/a&gt;3.1 命名空间的using声明&lt;/h2&gt;&lt;h3 id=&quot;每个名字都需要独立的using声明&quot;&gt;&lt;a href=&quot;#每个名字都需要独立的using声明&quot; class=&quot;headerlink&quot; title=&quot;每个名字都需要独立的using声明&quot;&gt;&lt;/a&gt;每个名字都需要独立的using声明&lt;/h3&gt;&lt;h3 id=&quot;头文件中不应该包含using声明&quot;&gt;&lt;a href=&quot;#头文件中不应该包含using声明&quot; class=&quot;headerlink&quot; title=&quot;头文件中不应该包含using声明&quot;&gt;&lt;/a&gt;头文件中不应该包含using声明&lt;/h3&gt;&lt;p&gt;因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。&lt;/p&gt;
&lt;h2 id=&quot;3-2-标准库类型string&quot;&gt;&lt;a href=&quot;#3-2-标准库类型string&quot; class=&quot;headerlink&quot; title=&quot;3.2 标准库类型string&quot;&gt;&lt;/a&gt;3.2 标准库类型string&lt;/h2&gt;&lt;h3 id=&quot;3-2-1-定义和初始化string对象&quot;&gt;&lt;a href=&quot;#3-2-1-定义和初始化string对象&quot; class=&quot;headerlink&quot; title=&quot;3.2.1 定义和初始化string对象&quot;&gt;&lt;/a&gt;3.2.1 定义和初始化string对象&lt;/h3&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
