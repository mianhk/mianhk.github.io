<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mianhk&#39;s notes</title>
  
  <subtitle>这个人很懒，什么都不想写</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-25T15:38:05.726Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mianhk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>不知道怎么开的船？</title>
    <link href="http://yoursite.com/2017/09/25/za1/"/>
    <id>http://yoursite.com/2017/09/25/za1/</id>
    <published>2017-09-25T15:36:13.000Z</published>
    <updated>2017-09-25T15:38:05.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2017-9-25-记录学习"><a href="#2017-9-25-记录学习" class="headerlink" title="2017-9-25 记录学习"></a>2017-9-25 记录学习</h3><h4 id="额，打开sublime，打出来第一个-号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。"><a href="#额，打开sublime，打出来第一个-号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。" class="headerlink" title="额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。"></a>额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。</h4><p>最近开始再一次准备看数据结构和算法，再一次，是不能再跟闹着玩的一次了。看着实验室最近找工作的师兄师姐，一边心疼他们，一边更心疼明年的自己。所以我也想到了也许很好的办法，不如抓紧时间现在先好好学习，头疼起来了，心就不疼了吧。<br>断断续续看完了c++ primer，加上之前看过一些数据结构，但是当我打开牛客网第一题的时候还是觉得自己像个傻逼，于是按照我通常的习惯，换了第二题，觉得更傻逼了。于是还是先打开书看看了。。<br>看看书啊，又刷刷题啊，自己还是经常在骂自己和夸自己和强行夸自己这几种有限状态中跳来跳去。<br>晚上，刷到那个链表翻转的题目，又是好久没搞出来，各种数组越界。明明只是就那么几个指针而已，反复看了好几遍。当方法论出了问题的时候，有的时候会忍不住怀疑世界观。作为一个还是对这个世界充满疑惑和兴趣的青年，我好奇地又在网上搜了一遍：C++学什么，C++怎么学，C++学习路线。。于是一晚上又没了，留下一份写有听过好多遍名字的书的TXT文档，一如一个多月前的某一个晚上。。<br>可能距离我们找工作也有快一年吧，时间说长不长，说短不短吧。其实我觉得能担心的可能一直不是时间，而是利用时间。<br>先写一下接下来一段时间的任务吧，不要又乱跑了：</p><ul><li>《Effictive C++》认真看，主线</li><li>有空看数据结构，刷题，不随便放弃题目。搞懂会写，写好了为止</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2017-9-25-记录学习&quot;&gt;&lt;a href=&quot;#2017-9-25-记录学习&quot; class=&quot;headerlink&quot; title=&quot;2017-9-25 记录学习&quot;&gt;&lt;/a&gt;2017-9-25 记录学习&lt;/h3&gt;&lt;h4 id=&quot;额，打开sublime，打出来第一
      
    
    </summary>
    
      <category term="杂想" scheme="http://yoursite.com/categories/%E6%9D%82%E6%83%B3/"/>
    
    
      <category term="杂想" scheme="http://yoursite.com/tags/%E6%9D%82%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>ch16-notes</title>
    <link href="http://yoursite.com/2017/09/19/ch16-notes/"/>
    <id>http://yoursite.com/2017/09/19/ch16-notes/</id>
    <published>2017-09-19T04:47:04.000Z</published>
    <updated>2017-09-19T04:47:39.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ch16-模板与泛型编程"><a href="#ch16-模板与泛型编程" class="headerlink" title="ch16 模板与泛型编程"></a>ch16 模板与泛型编程</h3><p>泛型编程与面向对象编程的区别是：面向对象编程能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。</p><h4 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h4><p>模板程序应该尽量减少对实参类型的要求。<br>模板的头文件通常包括声明和定义。<br>模板直到实例化时才生成代码。<br>泛型编程的一个目标就是另算法是“通用的”-适合于不同类型。所有标准库容器都定义了<code>==</code>和<code>!=</code>，但只有少数定义了<code>&lt;</code>运算符。因此尽量使用<code>!=</code>而不是<code>&lt;</code>。<br><strong> 类模板</strong>用来生成类的蓝图，一个类模板的每个实例都形成一个独立的类。默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。在类模板的作用域类，我们可以直接使用模板名而不必指定模板实参。<br>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给 所有友元模板实例，也可以只授权给特定实例。<br>当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。<br><strong> 成员模板</strong>：一个类（不管是模板类还是普通类）可以包含本身是模板的成员函数。这些成员函数被称为成员模板。成员模板不能是虚函数。<br>控制实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extern template class Blob&lt;string&gt;;  //声明，遇到extern模板声明时，编译器不会在本文件中生成实例化代码。，对于一个给定的实例化版本，可以有多个extern声明，但只能有一个定义。</div><div class="line">template int compare(const int&amp;,const int&amp;); //定义</div></pre></td></tr></table></figure></p><h4 id="16-2-模板实参推断"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断</h4><p>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。<br>一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。<br>如果函数参数类型不是模板参数，则可以进行正常的类型转换。<br><strong> 显式模板实参</strong>按由左至右的顺序与对应的模板参数匹配。</p><h4 id="16-3-重载与模板"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板</h4><h4 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h4><h4 id="16-5-模板特例化"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ch16-模板与泛型编程&quot;&gt;&lt;a href=&quot;#ch16-模板与泛型编程&quot; class=&quot;headerlink&quot; title=&quot;ch16 模板与泛型编程&quot;&gt;&lt;/a&gt;ch16 模板与泛型编程&lt;/h3&gt;&lt;p&gt;泛型编程与面向对象编程的区别是：面向对象编程能处理类型在程序
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ch15-notes</title>
    <link href="http://yoursite.com/2017/09/19/ch15-notes/"/>
    <id>http://yoursite.com/2017/09/19/ch15-notes/</id>
    <published>2017-09-19T04:44:24.000Z</published>
    <updated>2017-09-19T04:45:12.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ch15-面向对象程序设计"><a href="#ch15-面向对象程序设计" class="headerlink" title="ch15 面向对象程序设计"></a>ch15 面向对象程序设计</h3><blockquote><p>面向对象三个基本概念：数据抽象、继承和动态绑定（java里说的多态）。这章主要内容是继承和动态绑定。</p></blockquote><h4 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h4><h4 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h4><p>基类希望派生类进行覆盖的函数，通常将其定义为<strong> 虚函数</strong>，另一种是基类希望派生类继承但不要改变的函数。<br><code>protected</code>访问运算符：派生类可以访问，但是其他用户无法访问。<br>定义派生类：通过访问说明符控制派生类从基类继承而来的成员是否对派生类可见。<br>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为跟其他类一样，派生类会直接继承其在基类中的版本。<br>派生类到基类的转换。这可以让我们把派生类对象或者派生类对象的引用用在需要基类引用的地方，也可以把派生类指针用在需要基类指针的地方。但是，这里会出现一个问题，当我们使用基类的指针或者引用时，就不知道这个所绑定的对象到底是基类还是派生类了。<br>派生类构造函数。必须使用基类的构造函数初始化。（每个类控制自己的初始化过程。）<br>每个类定义各自的接口，派生类要遵循基类的接口。<br>如果基类中定义了静态成员，则在整个继承体系中只存在唯一的定义，不管定义了多少遍，都只存在唯一的实例。<br>对派生类的声明，不需要包含派生列表。<br>当我们不想让类被继承的时候，可以使用<code>final</code>关键字，跟在类名之后。<br>表达式的<strong> 静态类型</strong>在编译时是已知的，是变量声明时或者表达式生成式生成的类型。<strong> 动态类型</strong>则是变量或表达式表示的内存中的对象的类型。因此，基类的指针或引用的静态类型可能与动态类型不一致。<br>派生类向基类的自动类型转换只对指针和引用有效，在类型之间不存在这样的转换。当我们用一个派生类对象初始化或给一个基类对象赋值时，只有该派生类的对象中的基类部分会被拷贝、移动或赋值，派生类部分则会被忽略掉。</p><h4 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h4><p>我们必须为每一个虚函数提供定义，因为连编译器也无法确定到底使用的是哪一个虚函数。<br>如果我们在派生类中覆盖了某个虚函数时，可以再次使用<code>virtual</code>指出该函数的性质，但实际上并不一定要这么做。因为某个函数被声明成虚函数，则在所有的派生类中都是虚函数。</p><h4 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h4><p>在函数体声明的语句的分号前使用<code>=0</code>可以将一个函数声明为纯虚函数。<br>含有纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类负责覆盖该接口。我们不能直接创建一个抽象基类的对象。GCC的编译器中可能前面还是要加上<code>virtual</code><br><strong> 重构</strong>：重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。</p><h4 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h4><p>protected:对于类的用户来说是不可访问的，对于派生类的成员和友元来说是可访问的。但是只能通过<strong> 派生类对象</strong>来访问，<strong> 派生类</strong>对于一个基类中受保护的成员是无法访问的。<br>派生类向基类的转换：只有当D公有的继承B时，<strong> 用户代码</strong>才能使用基类向派生类的转换。无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换。如果D继承B的方式是公有的或受保护的，则D的派生类可以使用D向B的类型转换。<br>友元关系不能继承。基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员。<br>派生类可以使用<code>using</code>为那些可以访问的名字提供声明，以改变这些名字在它的派生类中的可访问性。</p><h4 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h4><p>每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。<br>当名字相同时，派生类的成员将隐藏基类的成员。基类可以通过<strong> 作用域运算符</strong>来使用隐藏的成员。一般情况下，我们应该不会这么使用，所以，平时继承类尽量不要覆盖继承而来的虚函数以外的基类的名字。<br><strong> 名字查找先于类型检查</strong>：如果派生类的成员与基类中的某个成员同名，则派生类将在其作用域内隐藏该基类成员。一旦编译器查找到名字后，不管形参列表是否相同，都不会再继续查找，这也是我们需要在覆盖虚函数时，保证形参列表是相同的。<br><code>using</code>声明语句指定一个名字而不是形参列表，所以我们在基类中使用一个<code>using</code>就可以把该函数的所有重载实例添加到派生类作用域中，派生类只需要定义特有的函数即可。</p><h4 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h4><p>位于继承体系中的类也需要控制当其对象执行一系列操作时发生怎样的行为：包括创建、移动、拷贝、赋值和销毁。<br>一般讲基类中的析构函数定义为虚函数，这样，继承体系中的派生类都会是虚析构函数，否则，若基类中的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。<br>虚析构函数将组织合成移动操作。<br>和普通成员的using声明不同，构造函数的using声明不会改变该构造函数的访问级别。<br>using声明语句不能指定explicit或constexpr。<br>当一个基类构造函数含有默认实参时，这些实参并不会被继承。派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p><h4 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8 容器与继承"></a>15.8 容器与继承</h4><p>容器不能直接存放继承体系中的对象，通常采用间接存储的方式。因为当我们把基类存储到一个容器中，当存入派生类对象，实际存入的只是派生类中基类的部分，显然不符合我们的需要。所以我们希望在具有继承关系的对象时，实际上存储的是基类的指针。（最好使用智能指针）</p><h4 id="15-9-文本查询程序再探"><a href="#15-9-文本查询程序再探" class="headerlink" title="15.9 文本查询程序再探"></a>15.9 文本查询程序再探</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ch15-面向对象程序设计&quot;&gt;&lt;a href=&quot;#ch15-面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;ch15 面向对象程序设计&quot;&gt;&lt;/a&gt;ch15 面向对象程序设计&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面向对象三个基本概念：数据
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch13 拷贝控制</title>
    <link href="http://yoursite.com/2017/09/14/%E3%80%8Acpp%20primer%E3%80%8Bch13/"/>
    <id>http://yoursite.com/2017/09/14/《cpp primer》ch13/</id>
    <published>2017-09-14T03:55:33.000Z</published>
    <updated>2017-09-14T05:01:05.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ch13-拷贝控制"><a href="#ch13-拷贝控制" class="headerlink" title="ch13 拷贝控制"></a>ch13 拷贝控制</h3><p>通过定义的五种特殊的</p><h4 id="13-1-拷贝、赋值、销毁"><a href="#13-1-拷贝、赋值、销毁" class="headerlink" title="13.1 拷贝、赋值、销毁"></a>13.1 拷贝、赋值、销毁</h4><h4 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h4><p>在旧标准的标准库中，容器中所保存的类必须是可以拷贝的，新标准中，可以在容器中保存不可拷贝的类型，只要他们能够被移动就可以。</p><h5 id="13-6-1-右值引用"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用</h5><p>通过&amp;&amp;来获得右值引用，意为绑定到右值的引用。<br><strong> 重要性质：只能绑定到一个将要销毁的对象。</strong><br><strong> 所引用的对象将要被销毁，该对象没有其他用户</strong><br>– 左值引用：返回左值引用的函数，赋值、下标、解引用、前置递增/递减运算符。<br>– 右值引用：返回非引用的函数，算数、关系、位以及后置递增/递减运算符。<br>区分的方法：一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。<a href="http://blog.csdn.net/yapian8/article/details/42341307" target="_blank" rel="external">右值引用比较</a></p><p><strong> move函数(utility头文件中)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int &amp;&amp;rr3=std::move(rr1);  //相当于告诉编译器，我们希望像处理右值一样处理左值rr1。</div><div class="line">                           //调用move后，除了赋值和销毁rr1外不会再使用它</div><div class="line">                           //使用move直接用std::move</div></pre></td></tr></table></figure></p><h6 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h6><p>目的：让类支持移动操作。<br>移动构造函数：第一个参数是一个该类类型的右值引用，任何其他额外的参数都要有默认实参。不需要分配新内存，直接接管原来的内存。不会跑异常，不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。（原因是标准库很多对于存在异常的处理方式，例如vector）<br>移动赋值运算符：首先要处理自赋值的情况。（为什么检查自赋值？因为右值可能是move调用返回的结果，不能在使用右侧运算符对象之前释放左侧运算对象的资源。）<br><strong> 如果类有拷贝构造函数和拷贝赋值运算符，没有定义移动操作时，编译器不会为其分配默认的移动操作，而是会采用对应的拷贝进行代替。如果没有定义任何的拷贝操作，才会为其合成移动构造函数或移动赋值运算符。</strong><br>移动操作不会被隐式的定义为删除的操作,定义为删除元素的原则：</p><ul><li>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或有类成员未定义自己的拷贝构造函数且编译器不能为其合成默认移动构造函数</li><li>有类成员的移动构造函数或移动赋值运算符被定义为删除的或不可访问的</li><li>类的析构函数被定义为删除的</li><li>有类成员是const的或是引用</li></ul><p>三/五法则：<br>通常，拥有一个资源的类，必须定义拷贝构造函数、拷贝赋值运算符、析构函数才能工作，而由于大量的拷贝会影响资源的额外开销，定义移动构造函数和移动赋值运算符可以避免此类问题。</p><h5 id="13-6-1-右值引用和成员函数"><a href="#13-6-1-右值引用和成员函数" class="headerlink" title="13.6.1 右值引用和成员函数"></a>13.6.1 右值引用和成员函数</h5><p>区分移动和拷贝的重载函数通常有一个版本接受<code>const T&amp;</code>，另一个版本接受一个<code>T&amp;&amp;</code>。很多时候它们看起来调用的是一个函数，通常它们内部的构造也很接近，有一点差别。我们可以根据实参的类型进行判断，我们用的是左值和右值区分调用的版本。<br>有的时候我们想要避免对右值进行赋值（在旧的标准中是有可能发生的，并且新的标准为了向后兼容没有禁止），可以在参数列表后放置一个<strong> 引用限定符</strong>。还可以通过使用<code>&amp;</code>或者<code>&amp;&amp;</code>指出指向一个左值或者一个右值。eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    public:</div><div class="line">        Foo &amp;operator=(const Foo&amp;) &amp;; //只能向可修改的左值赋值。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>引用限定符可以区分重载版本，如同const可以用来区分一个成员函数的重载版本。一般当我们定义两个或两个以上的具有相同名字和相同参数列表的成员函数，就必须对所有函数加上引用限定符，或者都不加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    public:</div><div class="line">        Foo sorted() &amp;&amp;;</div><div class="line">        Foo sorted() const; //错误，需要加上引用限定符</div><div class="line">        /////////////////</div><div class="line">        Foo sorted(Comp*);</div><div class="line">        Foo sorted(Comp*) const; //正确，两个版本都没有引用限定符</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ch13-拷贝控制&quot;&gt;&lt;a href=&quot;#ch13-拷贝控制&quot; class=&quot;headerlink&quot; title=&quot;ch13 拷贝控制&quot;&gt;&lt;/a&gt;ch13 拷贝控制&lt;/h3&gt;&lt;p&gt;通过定义的五种特殊的&lt;/p&gt;
&lt;h4 id=&quot;13-1-拷贝、赋值、销毁&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch14 重载运算符和类型转换</title>
    <link href="http://yoursite.com/2017/09/14/%E3%80%8Acpp%20primer%E3%80%8Bch14/"/>
    <id>http://yoursite.com/2017/09/14/《cpp primer》ch14/</id>
    <published>2017-09-14T03:55:33.000Z</published>
    <updated>2017-09-14T04:56:40.750Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ch14-重载运算与类型转化"><a href="#ch14-重载运算与类型转化" class="headerlink" title="ch14 重载运算与类型转化"></a>ch14 重载运算与类型转化</h3><blockquote><p>当运算符作用于类的对象的时，通过重载运算符，使不同的运算符对于不同的类有着特定的含义，一方面能够简化类的使用者的逻辑，另一方面也能是程序更易于编写和阅读，而不至于编写更多的函数。</p><h4 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h4><p>重载的运算符是特殊的函数：由operator关键字加上要定义的运算符号共同组成。作为函数，也包含返回类型、参数列表和函数体。参数列表个数与该运算符作用的算数对象数量一样多。<br>不应该被重载的运算符：逻辑与、逻辑或、逗号运算符、取地址运算符。<br>定义成成员还是非成员的判断：</p><ul><li>赋值、下标、调用、成员访问箭头等运算符必须是类的成员。</li><li>复合赋值运算符一般是类的成员</li><li>递增、递减、解引用等运算符。通常是类的成员</li><li>具有对称性的运算符可能转换任意一端的运算对象。如算数、相等性、关系、位运算符，通常应该是普通的成员函数。<h4 id="14-2-输入输出运算符"><a href="#14-2-输入输出运算符" class="headerlink" title="14.2 输入输出运算符"></a>14.2 输入输出运算符</h4>输出的运算符尽量减少格式化操作，只需要打印信息就可以了。<br>输入输出运算符必须是非成员函数。<br>输入时可能会发生错误，例如：当流含有错误类型的数据时读取可能失败，当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。所以在输入操作中，输入运算符应该负责读取错误发生时，从错误中恢复。<h4 id="14-3-算术和关系运算符"><a href="#14-3-算术和关系运算符" class="headerlink" title="14.3 算术和关系运算符"></a>14.3 算术和关系运算符</h4>代码的解释：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data</div><div class="line">operator-(const Sales_data &amp;lhs,const Sales_data &amp;rhs)&#123;</div><div class="line">    Sales_data item=lhs;</div><div class="line">    item-=rhs;  //调用重载的-=运算符来定义。性能相同，只是增加代码的 复用，增加可读性</div><div class="line">    return item;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></blockquote><p><strong> 相等运算符</strong>的定义：如果定义了<code>==</code>，那么这个类也要定义<code>!=</code>（因为对于用户来说，当他们使用了<code>==</code>时，他们应该也希望能使用<code>!=</code>），并且相等运算符和不相等运算符的一个应该把工作委托给另外一个，这样一个预算负责实际比较，另外一个负责调用。<br><strong> 关系运算符</strong>:一般定义了相等运算符后，也会定义关系运算符，特别是<code>&lt;</code>运算符。<br>关系运算符的原则：如果存在唯一逻辑可靠的<code>&lt;</code>定义，就考虑定义<code>&lt;</code>运算符。如果该类同时包含<code>==</code>运算符，则当且仅当<code>&lt;</code>的定义与<code>==</code>产生一致的结果时才定义<code>&lt;</code>运算符。</p><h4 id="14-4-赋值运算符"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符</h4><p>赋值运算符<code>=</code>和符合赋值运算符<code>+=</code>，通常都定义为类的成员，并且都应该返回左侧运算对象的引用。</p><h4 id="14-5-下标运算符"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符</h4><p>当我们需要按元素在容器中的位置访问元素时，通常定义一个下标运算符<code>operator[]</code>，必须是成员函数。通常会定义两个版本，一个返回普通引用，一个返回常量引用。</p><h4 id="14-6-递增和递减运算符"><a href="#14-6-递增和递减运算符" class="headerlink" title="14.6 递增和递减运算符"></a>14.6 递增和递减运算符</h4><p>后置运算符接受一个额外的（不被使用）int类型的形参，当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参<br>。前置运算符返回递增或者递减后的对象的引用，后置运算符返回对象的原值（即递增或递减之前的原值），返回的是一个值而非引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class StrBlobPtr&#123;</div><div class="line">    public:</div><div class="line">        StrBlobPtr&amp; operator++();  //前置递增运算符</div><div class="line">        StrBlobPtr&amp; operator++(int); //后置递增运算符</div><div class="line">&#125;</div><div class="line">...</div><div class="line">p.operator++(0); //显式的调用后置递增运算符</div><div class="line">p.operator++(); // 显式的调用前置递增运算符</div></pre></td></tr></table></figure></p><h4 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h4><p>箭头运算符必须是类的成员，解引用运算符通常也是类的成员，即使并非必须这么做。<br>箭头运算符永远不能丢掉成员访问的这个基本含义，当我们重载箭头运算符时，可以改变的是从哪个对象中获取成员，而获取成员这一事实永远不变。<br>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p><h4 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h4><p>如果类重载了函数调用运算符，我们就可以像调用函数一样使用该类的对象。函数调用运算符必须是成员函数，一个类可以定义多个函数运算符，之间用参数的数量和类型进行区分。<br>函数对象通常作为泛型算法的实参<br>lambda表达式：当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在这个类中，含有一个重载的函数调用运算符。捕获的对象相当于类内含有数据成员。是否含有默认/移动构造函数通常视捕获的对象而定。<br>标准库定义了一组表示算数运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。<br>标准库规定其函数对象对于指针同样适用。eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vector&lt;string *&gt; nameTable;</div><div class="line">sort(nameTable.begin(),nameTable.end(),</div><div class="line">[](string *a,string *b)&#123;return a&lt;b&#125;);   //错误，nameTable中的指针之间没有关系，所以&lt;将产生未定义的行为</div><div class="line"></div><div class="line">sort(nameTable.begin(),nameTable.end(),less&lt;string* &gt;()); //正确</div></pre></td></tr></table></figure></p><p>C++中的<strong>  可调用对象</strong>：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。可调用的对象也有类型。<br>不同类型可能具有相同的调用形式，可以定义一个<strong> 函数表</strong>用于存储指向这些可调用对象的“指针”。<br><strong> 标准库function类型</strong>：是一个模板，当创建具体的function类型时，需要我们提供额外的信息。eg：<code>function&lt;int (int,int)&gt;</code>表示接受2个int、返回1个int的可调用对象。不能直接将重载函数的名字存入function类型的对象中，可存储函数指针而不是函数的名字。</p><h4 id="14-9-重载、类型转换与运算符"><a href="#14-9-重载、类型转换与运算符" class="headerlink" title="14.9 重载、类型转换与运算符"></a>14.9 重载、类型转换与运算符</h4><p><strong> 转换构造函数和类型转换运算符</strong>共同定义了类类型转换，有时也被称作用户定义的类型转换。<br><code>operator type() const; //type表示某种类型</code>因为类型转换运算符是隐式执行的，所以无法传递实参，也不能定义形参。为了避免具有误导性的类型转换，在不存在明显映射关系的时候，应不适用。<br>显式的类型转换运算符。eg:<code>explicit operator int() const;</code>当类型转换运算符是显式的，必须通过显式的强制类型转换才可以。<strong> 如果表达式被用作条件，编译器会显式的自动转换。</strong><br>无论我们什么时候在条件中使用了流对象，都会使用为IO类型定义operator bool。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct Integral&#123;</div><div class="line">    operator const int(); //将对象转换成 const int</div><div class="line">    operator int() const; //将对象转换成 int，用的相对较多</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>应该避免使用二义性的类型转换，总体原则：除了显式的向bool类型的转换外，应该尽量避免定义类型转换函数，并且尽可能限制某些看起来显然正确的显式构造函数。<br>错误eg：定义了两种将B类转换为A类的方法，一种使用B的类型转换运算符，一种使用A的以B为参数的构造函数。</p><ul><li>不要另两个类执行相同的类型转换。</li><li>避免转换目标是内置算数类型的类型转换。<br>函数重载的类型匹配：当调用重载函数时，如果两个或多个用户定义的类型转换都提供了可行的匹配，那么这些类型转换被认为一样好。这意味着我们设计的不足。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ch14-重载运算与类型转化&quot;&gt;&lt;a href=&quot;#ch14-重载运算与类型转化&quot; class=&quot;headerlink&quot; title=&quot;ch14 重载运算与类型转化&quot;&gt;&lt;/a&gt;ch14 重载运算与类型转化&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当运算符作用于类的
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我的书单2017</title>
    <link href="http://yoursite.com/2017/09/10/9-10/"/>
    <id>http://yoursite.com/2017/09/10/9-10/</id>
    <published>2017-09-09T16:40:49.000Z</published>
    <updated>2017-09-09T16:45:56.477Z</updated>
    
    <content type="html"><![CDATA[<p>2017要看完的书，生活总得有一些flag是吧<br><a href="http://item.jd.com/12125924.html" target="_blank" rel="external">《人类简史》尤瓦尔·赫拉利</a><br><a href="http://item.jd.com/12099462.html" target="_blank" rel="external">《未来简史》尤瓦尔·赫拉利</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017要看完的书，生活总得有一些flag是吧&lt;br&gt;&lt;a href=&quot;http://item.jd.com/12125924.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《人类简史》尤瓦尔·赫拉利&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http:/
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用总结</title>
    <link href="http://yoursite.com/2017/09/10/hexo/"/>
    <id>http://yoursite.com/2017/09/10/hexo/</id>
    <published>2017-09-09T16:24:59.000Z</published>
    <updated>2017-09-09T17:06:29.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hexo的使用总结"><a href="#Hexo的使用总结" class="headerlink" title="Hexo的使用总结"></a>Hexo的使用总结</h3><blockquote><p>没错，这几天又开始折腾一下博客了，最近的节奏天天白天待在实验室怼论文，晚上看C++，时间安排比较紧凑，就觉得更需要阶段性的总结吧，所以又来写博客了，github始终是一个好的选择，于是入了Hexo的坑。。折腾的过程心情总是有些复杂，在激动和mmp之间徘徊，虽然很多问题在wiki和issue里都有，但还是想总结一下自己亲自踩的坑。</p><h5 id="页面中文无法显示的问题"><a href="#页面中文无法显示的问题" class="headerlink" title="页面中文无法显示的问题"></a>页面中文无法显示的问题</h5><p>这种中文问题，基本上都是编码的问题，但是开始各种都没找到原因，改了language里面的配置文件，最后发现是文件的编码，需要改成’无bom的utf-8的编码格式 ‘</p><h5 id="主界面无法显示categories和tags的问题"><a href="#主界面无法显示categories和tags的问题" class="headerlink" title="主界面无法显示categories和tags的问题"></a>主界面无法显示categories和tags的问题</h5><p>这个问题真的是搞的有点久，因为基本上都被人忽略了，也可能很多人都没遇到而我恰好遇到了吧，不懂前端的我只能对于这种玄学问题强行百度了。<br>解决办法：将categories和tags目录下的index文件分别改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">categories:</div><div class="line">type: &quot;categories&quot;</div><div class="line">layout: &quot;categories&quot;</div><div class="line">tags:</div><div class="line">type: &quot;tags&quot;</div><div class="line">layout: &quot;tags&quot;</div></pre></td></tr></table></figure></p></blockquote><p>折腾完又不早了，希望以后好好看书，好好编程吧，最近没有什么特别大的梦想，只想安静的学习。。。<br><strong> Reference: </strong><br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo文档</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">Next主题文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hexo的使用总结&quot;&gt;&lt;a href=&quot;#Hexo的使用总结&quot; class=&quot;headerlink&quot; title=&quot;Hexo的使用总结&quot;&gt;&lt;/a&gt;Hexo的使用总结&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;没错，这几天又开始折腾一下博客了，最近的节奏天天白天待在实
      
    
    </summary>
    
      <category term="日常" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch7 类</title>
    <link href="http://yoursite.com/2017/06/27/%E3%80%8Acpp%20primer%E3%80%8Bch7%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/06/27/《cpp primer》ch7类/</id>
    <published>2017-06-27T09:55:33.000Z</published>
    <updated>2017-09-09T17:03:42.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>类是面向对象编程的基础，使用类定义自己的数据类型，可以更方便的解决问题中的各种概念，使我们更容易编写、调试和修改程序。<br><a id="more"></a></p><h1 id="7-1-定义抽象的数据类型"><a href="#7-1-定义抽象的数据类型" class="headerlink" title="7.1 定义抽象的数据类型"></a>7.1 定义抽象的数据类型</h1><ul><li>定义在类内部的函数时隐式的inline函数。</li><li>类的所有成员都必须在类的内部声明，但是成员函数体可以定义在类的内部或外部。</li><li>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。</li><li>成员函数体可以随意使用类中的其他成员而不需要在意这些成员出现的次序。<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2>编译器创建的构造函数又被称为合成的默认构造函数，合成的默认构造函数初始化类的数据成员规则为：存在类内初始值的时候，用它来初始化成员；否则，默认初始化该成员。<br>对于一个普通的类，一般要定义自己的默认构造函数：</li></ul><ol><li>编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</li><li>对于某些类来说，合成的默认构造函数可能执行错误的操作。</li><li>有的时候编译器不能为某些类合成默认的构造函数。</li></ol><ul><li>构造函数没有返回类型。<h2 id="拷贝。赋值和析构"><a href="#拷贝。赋值和析构" class="headerlink" title="拷贝。赋值和析构"></a>拷贝。赋值和析构</h2>除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象的时候发生的行为。<br>当我们不主动定义这些操作的的时候，编译器将替我们合成他们。但是有些类不能依赖于合成的版本。当类需要分配类对象之外的资源时，合成的版本常常会失效。<h1 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h1>在类的定义中，可以包含0个或多个访问说明符，每个访问说明符指定接下来的成员访问级别，一般来说，作为接口的一部分，构造函数和一部分成员函数应该定义在public说明符之后，而数据成员和作为实现部分的函数跟在private说明符之后。<br>class和struct唯一的区别是默认访问权限不同。<h1 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h1>类型成员、类的成员的类内初始值、可变数据成员、内联数据成员、从成员函数返回*this、关于如何定义类类型及友元类等。<h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制。<h2 id="另成员作为内联函数"><a href="#另成员作为内联函数" class="headerlink" title="另成员作为内联函数"></a>另成员作为内联函数</h2>在类中，一些规模较小的函数常被定义为内联函数<br>两种方式：1、直接把函数定义放在类的内部<pre><code>2、把函数定义放在类的外部，显式的使用inline</code></pre></li><li>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</li><li>在实践中，设计良好的代码常常包含很多的小函数，通过调用这些小函数，可以完成其他一组函数的“实际”工作。<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2></li><li>对于一个类来说，它的成员和其他任何类的成员都不是一回事。</li><li>类的声明：不完全类型的使用：可以定义指向这种类型的指针或引用，也可以声明（但不能完全定义）以不完全类型作为参数或者返回类型的函数。<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2>如果一个类指定了友元类，则友元类的成员函数可以访问此类中包括非公有成员在内的所有成员。</li><li>还可以另一个类的成员函数为自己的友元。</li><li>如果一个类想把一组重载函数声明称它的友元，需要对每一个分别声明。</li><li>友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。<h1 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h1></li><li>一个类就是一个作用域</li><li>函数的返回类型通常出现在函数名之前，所以返回类型是在类的作用域外的。</li><li>名字查找规则：首先名字所在快寻找声明语句；查找外层作用；报错。<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2></li><li>如果成员是const或引用的话，必须进行初始化；当成员属于某种类类型且该类没有定义构造函数时，也必须初始化。</li><li>使用构造函数初始值：不仅仅是底层效率的问题。另有一些数据成员必须被初始化。</li><li>成员初始化顺序：构造函数初始化列表值说明用于初始化成员的值，而不限定初始化的具体执行顺序。（尽量按照顺序初始化，并且避免使用某些成员初始化其他成员）</li><li>委托构造函数：</li><li>默认构造函数的作用：当对象被默认初始化或值初始化时自动执行默认构造函数</li><li>默认初始化发生:</li></ul><ol><li>块作用域内不适用任何初始值定义一个非静态变量或数组时。</li><li>一个类本身含有类类型的成员且使用合成的默认构造函数。</li><li>类类型的成员没有在构造函数初始值列表中显式的初始化。</li></ol><ul><li>值初始化发生：</li></ul><ol><li>数组初始化时提供的初始值数量小于数组的大小</li><li>不使用初始值定义一个局部的静态变量</li><li>书写形如T()的表达式显式的请求值初始化</li></ol></blockquote><ul><li><p>隐式的类类型转换：能通过一个实参调用的构造函数定义一条从构造函数的参数类型向类类型隐式转换的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string null_book=&quot;2132321&quot;;</div><div class="line">item.combine(null_book);//将一个string的实参传递给了combine成员。</div></pre></td></tr></table></figure></li><li><p>隐式类型转换只能一步，可以使用explicit阻止隐式类型转换。</p></li><li>字面值常量类至少提供一个constexpr构造函数<h1 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h1></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;类是面向对象编程的基础，使用类定义自己的数据类型，可以更方便的解决问题中的各种概念，使我们更容易编写、调试和修改程序。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch6 函数</title>
    <link href="http://yoursite.com/2017/06/06/%E3%80%8Acpp%20primer%E3%80%8Bch6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/06/06/《cpp primer》ch6函数/</id>
    <published>2017-06-06T15:17:14.724Z</published>
    <updated>2017-09-09T17:03:39.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。<br><a id="more"></a></p><h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><h2 id="形参和实参："><a href="#形参和实参：" class="headerlink" title="形参和实参："></a>形参和实参：</h2><p>实参是形参的初始值，函数的形参列表可以为空。<br>局部静态对象，定义成static类型，在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><p>如果形参是引用类型，它将绑定到对应的实参上，称为引用传递；否则，将实参的值拷贝后赋给形参，称为值传递。</p><h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2><p>将实参的值拷贝给形参。当是指针形参时，指针的行为和其他非引用类型一样，执行指针拷贝类型时，拷贝的是指针的值。拷贝之后是不同的指针，但是指向的是相同的值，我们可以在函数中修改指针所指对象的值。在C++中，建议使用引用类型的形参替代指针。</p><h2 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h2><p><strong> 1.使用引用避免拷贝。 </strong>因为有的类类型是不能拷贝的，或者在拷贝一些大的类类型对象或者容器对象比较低效。<br>如果函数不需要改变引用参数的值，最好将其声明为常量引用。<br><strong> 2.使用引用形参返回额外信息。</strong>由于函数不能有多个返回值，在我们需要返回多个值的时候，可以额外传一个引用参数。<br><strong> 3.可以直接操作引用形参所引的对象。 </strong></p><h2 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h2><p>和其它初始化一样，当用实参初始化形参时会忽略掉顶层const。也就是，形参的顶层const会被忽略掉。（这个可以思考一下，我们可以通过形参的const在参数中控制是否需要改变形参，以及对应的实参，这样更方便我们传参数。当然有了这个我们就不能重载有无const的两个函数了，因为会被编译器相同对待。）<br>尽量使用常量引用，除了在使用的时候，无法把常量引用初始化为引用（很简单的道理），另外，也会给调用者一种误导。</p><h2 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h2><p>无法以值传递的方式使用数组参数。数组的特点：不允许拷贝、使用数组会将其转化为指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void print(const int*);</div><div class="line">void print(const int[]);</div><div class="line">void print(const int[10]);  //这里的维度表示我们期望数组含有多少个元素，实际不一定</div></pre></td></tr></table></figure></p></blockquote><h3 id="关于数组长度"><a href="#关于数组长度" class="headerlink" title="关于数组长度"></a>关于数组长度</h3><p>由于传递数组引用的时候，只是数组的首元素指针，所以有时候我们需要在形参定义的时候，就将数组大小传递给形参。这里有几种方式。</p><h2 id="6-2-5-mian处理命令行选项"><a href="#6-2-5-mian处理命令行选项" class="headerlink" title="6.2.5 mian处理命令行选项"></a>6.2.5 mian处理命令行选项</h2><p>当使用argv[]中的实参时，第一个实参保存的是程序名，所以应该从第二个开始。</p><h2 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h2><p>有时候我们预先不知道向函数传递几个实参。1.如果所有的实参类型相同，可以传递名为initializee_list的标准库类型；2.如果实参类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。</p><h1 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h1><p>return语句终止当前执行的函数，并将控制权返回到调用该函数的地方。<br>return语句不要返回局部对象的引用或引用（因为局部对象会在函数调用完成后删除，会产生未定义的结果）。<br>c++11新标准中函数可以返回花括号包围的值列表，主函数main的返回值，非0的返回值由机器决定。</p><h1 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h1><p>拥有顶层const不影响传入函数的对象。另外，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。<br>不能仅仅通过函数的返回值区分两个同名的函数</p><h2 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h2><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。在不同的作用域中无法重载函数名。<br>在c++中，名字查找发生在类型检查之前。</p><h1 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h1><p>大多数程序都有用的特性：默认实参、内联函数、constexpr函数。</p><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>一旦某个形参赋予了默认值，后面的所有形参必须有默认值。函数调用时，实参按其位置进行解析，只能省略尾部的实参。<br>一个函数被声明多次的时候，在给定的作用域中一个形参只能被赋予一次默认实参，也就是函数的后续声明。</p><h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>将它在每个调用点上“内联的”展开，一般来说用于优化规模较小、流程直接、频繁调用的函数。</p><h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>constexpr函数指能用于常量表达式的函数。函数的返回值及所有形参的类型都得是字面值类型，并且函数体中必须有且只有一条return语句。<br>编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式的指定 为内联函数.<br>内联函数和constexpr函数通常定义在头文件中.</p><h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>assert预处理宏,以一个表达式作为条件.<br>我们可以使用一个#define 语句定义NDEBUG，关闭调试状态</p><h1 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h1><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换得来时。</p><h2 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h2><p>函数匹配第一步：选定本次调用对应的重载函数集。<br>候选函数的两个特征：与被调用的函数同名，其声明在调用点可见。<br>第二步考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数。</p><h2 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h2><p>确定最佳匹配的排序：</p><ul><li>1.精确匹配：实参形参类型相同，实参从数组或函数类型转化为对应的指针类型，实参添加顶层const或者从实参中删除顶层const。</li><li>2.通过const转换实现的匹配。</li><li>3.通过类型提升实现的匹配。</li><li>4.通过算术类型转换或指针转换实现的匹配。</li><li>5.通过类类型转换实现的匹配。<h1 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h1>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。<h2 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h2>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。<h2 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h2>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上是被当成指针使用。<br>可以直接把函数当成实参使用，会自动转换成指针。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch4 表达式</title>
    <link href="http://yoursite.com/2017/06/05/%E3%80%8Acpp%20primer%E3%80%8Bch4%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/06/05/《cpp primer》ch4表达式/</id>
    <published>2017-06-05T09:55:33.000Z</published>
    <updated>2017-09-09T17:03:34.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不管学习什么语言都会有这么一章，不管是c、java、Python，这都是会经历的一章，唉，无奈当时年少无知不止梦想是什么的我每每看到这些的时候都觉得很烦。当再一次翻开c++的这一章的时候，也有这样的感觉，似曾相识燕归来，却又无可奈何花落去。<br>我认为这一章的很多都不是需要太多的去深究，只需要有个大概的概念，然后更多的是在今后的编程过程中，不断的实践自然就知道了，是怎样写的。而且累死一些优先级的问题，更多的时候就像书里建议的那样，一个括号来的简单粗暴实用的多，所以，这章，就记一下实在有违常规的理解的内容吧。<br><a id="more"></a></p><h1 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h1><ul><li>运算对象转换：小整数类型（如bool、char、short等）通常会被提升为较大的整数类型，主要是int。</li><li>左值和右值：一个左值表达式的求值结果时一个对象或者一个函数，以常量对象为代表的某些左值不能作为赋值语句的左侧运算对象。<strong> 简单归纳：当对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置） </strong></li><li>左值右值使用原则：需要右值的地方可以用左值代替，但是不能把右值当成左值使用。当一个左值被当成一个右值使用的时候，实际上使用的是它的内容（值  ）</li><li>需要用到左值的地方：<br>1.赋值运算符。需要左值作为其左值运算对象，得到结果仍然是一个左值<br>2.取地址符。返回一个指向该运算对象的指针，这个指针是一个右值<br>3.内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值<br>4.内置类型和迭代器的递增递减运算符作用于左值运算对象，得到的结果是左值。</li><li>关键字decltype中左值和右值的不同</li><li>处理复合表达式的经验：使用括号；如果改变了某个运算对象的值，就不要在表达式的其它地方再使用这个运算对象<h1 id="4-2-算数运算符"><a href="#4-2-算数运算符" class="headerlink" title="4.2 算数运算符"></a>4.2 算数运算符</h1>溢出的情况，值会发生“环绕”<h1 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h1>进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值作为运算对象<h1 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h1>赋值运算满足右结合律<br>参与连续赋值的变量必须是相同的类型<h1 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h1><h1 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h1>解应用运算符的优先级低于点运算符<br>#<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cond?expr1:expr2;</div><div class="line">//输出表达式中使用条件运算符</div><div class="line">cout&lt;&lt;((grade&lt;60)?&quot;fail&quot;:&quot;pass&quot;); //输出pass或者fail</div></pre></td></tr></table></figure></li></ul></blockquote><p>条件运算符可以嵌套，一般为了代码的可读性，嵌套不要超过三层。</p><h1 id="4-7-sizeof运算符"><a href="#4-7-sizeof运算符" class="headerlink" title="4.7 sizeof运算符"></a>4.7 sizeof运算符</h1><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得值是一个size_t类型的常量表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sizeof(type)</div><div class="line">sizeof expr</div></pre></td></tr></table></figure></p><h1 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h1><p>首先对左侧表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。</p><h1 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h1><h2 id="发生隐式类型转换"><a href="#发生隐式类型转换" class="headerlink" title="发生隐式类型转换"></a>发生隐式类型转换</h2><ul><li>比int小的整形值首先提升为较大的整数类型</li><li>条件中，非bool值转为bool值。</li><li>初始化过程中，初始值转化为变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型</li><li>如果算数预算或关系运算对象有多种类型，需要转换成同一种类型。</li><li>函数调用时，也可能发生类型转换<h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cast-name&lt;type&gt;(expression)</div><div class="line">cast-name:static_cast,dynamic_cast,const_cast,reinterpret_cast</div></pre></td></tr></table></figure></li></ul><p>static_cast:任何具有明确定义的类型转换，只要不包含底层const都可以使用。<br>const_cast:只能改变运算对象的底层const<br>dynamic_cast：支持运行时类型识别<br>reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释。（使用起来非常危险）</p><p><strong> 尽量避免强制类型转换 </strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不管学习什么语言都会有这么一章，不管是c、java、Python，这都是会经历的一章，唉，无奈当时年少无知不止梦想是什么的我每每看到这些的时候都觉得很烦。当再一次翻开c++的这一章的时候，也有这样的感觉，似曾相识燕归来，却又无可奈何花落去。&lt;br&gt;我认为这一章的很多都不是需要太多的去深究，只需要有个大概的概念，然后更多的是在今后的编程过程中，不断的实践自然就知道了，是怎样写的。而且累死一些优先级的问题，更多的时候就像书里建议的那样，一个括号来的简单粗暴实用的多，所以，这章，就记一下实在有违常规的理解的内容吧。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch2 变量和基本类型</title>
    <link href="http://yoursite.com/2017/06/04/%E3%80%8Acpp%20primer%E3%80%8Bch2/"/>
    <id>http://yoursite.com/2017/06/04/《cpp primer》ch2/</id>
    <published>2017-06-04T09:55:33.000Z</published>
    <updated>2017-09-09T17:03:10.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ch2 变量和基本类型<br>数据类型决定了程序中数据和操作的意义。</p><h1 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h1><p>基本数据类型：<strong> 算数类型  空类型（void） </strong>,其中算数类型包括：字符、正整数、布尔值、浮点数。空类型不对应具体的值，用于一些特殊的场合。<br><a id="more"></a></p><h2 id="2-1-1-算数类型"><a href="#2-1-1-算数类型" class="headerlink" title="2.1.1 算数类型"></a>2.1.1 算数类型</h2><p>分为整形和浮点型。</p><h3 id="整形："><a href="#整形：" class="headerlink" title="整形："></a>整形：</h3><ul><li>bool:取值为true或者false。</li><li>char：基本的字符类型，一个char的大小与一个机器字节一样。</li><li>wchar_t,char16_t,char32_t<br><strong> rules: </strong>一个int至少和一个short一样大，一个long至少跟一个int一样大，一个long long至少跟一个long一样大。</li></ul></blockquote><h3 id="浮点型："><a href="#浮点型：" class="headerlink" title="浮点型："></a>浮点型：</h3><ul><li>float：一般一个字，32bit</li><li>double：2个字，64bit</li><li>long double：3或4个字，96或128bit<h3 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a>带符号类型和无符号类型</h3><h2 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h2><h3 id="转换过程："><a href="#转换过程：" class="headerlink" title="转换过程："></a>转换过程：</h3></li><li>非bool到bool：初始为0则为false，其他为true</li><li>bool到非bool：初始值为false则为0，初始值为true为1</li><li>浮点数到整型：仅保留浮点数中的<strong> 小数点部分 </strong></li><li>整数到浮点数：小数部分记为0，如果整数所占的空间超过浮点类型的容量，会报错。</li><li>赋给无符号类型，当超出它表示范围的时候，转换为该无符号类型表示数值总数取模后的余数。</li><li>给带符号的数输出超过范围的值是，结果时<strong> 未定义的 </strong></li></ul><p>tips:一般不在算数表达式中使用bool值</p><h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p>一般不要混用无符号和有符号的类型，当无符号超过范围时，可能会出现取模的情况，放在循环中，或者计算结果中，会产生无法预计的结果</p><h2 id="2-1-3-字面值常量"><a href="#2-1-3-字面值常量" class="headerlink" title="2.1.3 字面值常量"></a>2.1.3 字面值常量</h2><p>顾名思义，字面值常量一望而知。每个字面值常量对应一种数据类型，字面量常量得形式和值决定了它的数据类型。</p><h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><p>严格来说，十进制字面值不会是负数，通常，负号并不在字面值内，它的作用仅仅是对字面值取负值而已。</p><h3 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h3><ul><li>char型字面值：由单引号括起来的一个字符</li><li>字符串字面值：由双引号括起来的零个或多个字符<br><strong> Note：字符串字面值的类型实际上是由常量字符组成的数组，编译器在每个字符串的结尾处添加一个空字符（’\0’），字符串的字面值的实际长度比它的内容多1。 </strong><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3>有两类不能直接使用的字符。不可打印的和特殊含义的字符（单引号，双引号，问号，反斜线），这些情况下需要使用转义字符。<h3 id="指定字面值类型"><a href="#指定字面值类型" class="headerlink" title="指定字面值类型"></a>指定字面值类型</h3>添加一定的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。前缀有：u（Unicode16）、U（Unicode32）、L（宽字符）、u8（UTF-8）。后缀有：u或者U（unsigned）、l或者L（ling）、ll或者LL（long long），f或者F（float）、l或者L（long double）。<h3 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h3>bool：true、false<br>指针：nullptr<h1 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h1>对于c++来说，一般“变量”和“对象”可以互换使用。对象时具有某种数据类型的内存空间。<h2 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h2>基本形式：类型说明符+一个或多个变量名组成的列表（变量名以逗号分隔）+分号<h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3>当对象在创建时获得了一个特定的值，称为被初始化了。<strong> 初始化和复制是两个完全不同的操作，注意这个概念很重要 </strong><br>初始化：在创建变量是赋予其一个初始值。<br>复制：把对象的当前值擦除，以一个新的值代替。<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3>无论是初始化对象还是某些时候为对象赋新值，都可以使用一组又花括号括起来的初始值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int units_sold=0;</div><div class="line">int units_sold=&#123;0&#125;;</div><div class="line">int units_sold&#123;0&#125;;</div><div class="line">int units_sold(0);</div></pre></td></tr></table></figure></li></ul><h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式的初始化，则其值由类确定。。建议初始化每一个内置类型的变量。</p><h2 id="2-2-2-变量声明与定义的关系"><a href="#2-2-2-变量声明与定义的关系" class="headerlink" title="2.2.2 变量声明与定义的关系"></a>2.2.2 变量声明与定义的关系</h2><p>声明使得名字为程序所知，定义负责创建与名字关联的实体。<br><strong> extern </strong>关键字：如果想声明一个变量而不是定义它，就在变量名前添加extern，而不显示的初始化变量。如果在函数体内部试图初始化一个有extern关键字标记的变量，会引发错误。</p><h2 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h2><p>用户自定义的标识符中不能出现两个连续的下划线，也不能以下划线紧连大写字母开头。定义在函数体内的标识符不能以下划线开头。</p><h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><ul><li>标识符要能体现实际含义</li><li>变量名一般小写字母</li><li>自定义的类名一般大写字母开头</li><li>标识符由多个单词组成时，单词应有明显区分，使用下划线<h2 id="2-2-4-名字的作用域"><a href="#2-2-4-名字的作用域" class="headerlink" title="2.2.4 名字的作用域"></a>2.2.4 名字的作用域</h2>当内层出现与外层相同的名字时，使用内层定义的名字。<h1 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h1>复合类型指的是基于其他类型定义的类型。这里介绍两种：引用和指针。<h2 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h2>引用为对象起了另外一个名字，引用；类型引用另外一种类型。通过将生命符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用必须初始化。<h3 id="引用即别名"><a href="#引用即别名" class="headerlink" title="引用即别名"></a>引用即别名</h3>引用并不是对象，只是一个已经存在的对象起的另外一个名字。定义了一个引用之后，对其做的所有操作都是在与之绑定的对象上进行的。<br>因为引用本身只是一个别名，不是一个对象，所以不能定义引用的引用。<h3 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h3>除了两种例外的情况，其他所有的引用类型都要与之绑定的对象严格比配。<br>引用只能绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。<h2 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h2>指针是“指向point to”的另外一种类型的复合引用。指针也实现了对其他对象的间接访问。<br>两者的不同点：</li><li>1.指针本身就是一个对象，允许对指针赋值和拷贝，而且指针的生命周期内可以指向多个不同的对象。</li><li>2.指针无需在定义时赋初值。<h3 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h3>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）<br>不能定义指向引用的指针（因为引用不是一个对象）。<br>除了两种例外的情况，所有指针的类型都要和它指向的对象严格匹配。<h3 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h3>指针的值（即地址）应该属于下面四种状态之一：</li><li>1.指向一个对象</li><li>2.指向紧邻对象所占空间的下一个位置</li><li>3.空指针，表示没有指向任何对象。</li><li>4.无效指针，上述之外的其他值。<h3 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h3>如果指针指向了一个对象，允许使用解引用符（操作符*）来访问对象。<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3>空指针不指向任何对象，得到空指针的办法：直接用字面值nullptr初始化指针或者将指针初始化为字面值0来生成空指针。<br><strong> 建议 </strong>：初始化所有指针<h3 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h3>记住赋值永远改变的是等号左侧的对象。<h3 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h3>只要一个指针拥有合法值，就能将它用在条件表达式中，只要不为空，条件都为true。<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h3>void* 是一种特殊的指针类型，可用于存放任意对象的地址。<h2 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h2>变量的定义包括：一个基本数据类型+一组声明符。基本数据类型只有一个，但是声明符的形式可以不同。<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3>当有多个修饰符连写在一起的时候，按照逻辑关系解释。<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3>引用本身不是对象，但是指针是对象，所以可以对指针引用。<br>面对一条复杂的指针或引用的声明语句时，从右向左阅读有助于弄清真实含义。<h1 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h1><h3 id="初始化和const"><a href="#初始化和const" class="headerlink" title="初始化和const"></a>初始化和const</h3>const与非const对象的区别就是，const类型的对象执行不改变起内容的操作。如：const int也能像int一样参与算术运算，也能转化为bool值。<h3 id="默认状态下，const对象仅在文件内有效"><a href="#默认状态下，const对象仅在文件内有效" class="headerlink" title="默认状态下，const对象仅在文件内有效"></a>默认状态下，const对象仅在文件内有效</h3>如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字。<h2 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h2>可以把引用绑定到const对象上，就像绑定到其他对象上一样，称为对常量引用，对常量的引用不能修改它所绑定的对象。<br><strong> 术语：常量引用是对const的引用 </strong>：并不存在常量引用，是对const的引用。<h3 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h3>引用情况的例外：第一种是，在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。<h3 id="对const的引用可能引用一个非const的对象"><a href="#对const的引用可能引用一个非const的对象" class="headerlink" title="对const的引用可能引用一个非const的对象"></a>对const的引用可能引用一个非const的对象</h3>此种行为是合法的，但是不能通过对const的引用改变对象的值，兑现可以通过其他的方式改变值。<h2 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h2>指向常量的指针不能改变其所指对象的值，要想存放常量对象的地址，只能只用指向常量的指针。<br>所谓指向常量的指针和引用，只是自以为指向了一个常量，所以自觉不去改变所指对象的值。<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3>*const：不变的是指针的值而不是指向的那个值。采用从右向左的方式阅读，看离最近的符号。<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3>顶层const表示指针本身是个常量，底层const表示指针指的对象是一个常量。<br>当对象执行拷贝操作时，顶层const不受影响，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转化。<h2 id="2-4-4-constexpr和常量表达式"><a href="#2-4-4-constexpr和常量表达式" class="headerlink" title="2.4.4 constexpr和常量表达式"></a>2.4.4 constexpr和常量表达式</h2>常量表达式指：值不会改变且在编译过程就能得到计算结果的表达式。（字面值、用常量表达式初始化的const对象）<h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3>声明为constexpr的变量一定是一个变量，且必须用常量表达式初始化。<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><h3 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h3>在constexpr如果定义了一个指针，则constexpr只对指针有效，与指针所指的对象无关。<h1 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h1><h2 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h2>类型别名是一个名字，是某种类型的同义词。使用方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef double wages  //wages 是double的别名</div><div class="line">typedef wages base,*p</div><div class="line"></div><div class="line">#别名声明</div><div class="line">using SI=Scales_item;</div></pre></td></tr></table></figure></li></ul><h3 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h3><h2 id="2-5-2-auto类型说明符"><a href="#2-5-2-auto类型说明符" class="headerlink" title="2.5.2 auto类型说明符"></a>2.5.2 auto类型说明符</h2><h3 id="复合类型、常量和auto"><a href="#复合类型、常量和auto" class="headerlink" title="复合类型、常量和auto"></a>复合类型、常量和auto</h3><ul><li>引用时的auto，以引用对象的类型作为auto的类型</li><li>auto一般会忽略掉顶层const，底层const会保留下来。</li><li>可以将引用的类型设为auto<h2 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h2>选择并返回操作数的类型，编译器分析表达式并得到类型，但并不实际计算值<h3 id="decltype和引用"><a href="#decltype和引用" class="headerlink" title="decltype和引用"></a>decltype和引用</h3>有些表达式将向decltype返回一个引用类型。如果表达式的内容是解引用操作，则decltype将得到引用类型。<br>解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。<br>decltype和auto的重要区别：decltype的结果类型与表达式形式密切相关。<br><strong> 如果给变量加上一层或多层括号，decltype就会得到引用类型。decltype((val))的结果永远是引用，decltype(val)只有当val本身是一个引用时才是引用。另外，赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型 </strong></li></ul><h1 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h1><h2 id="定义自己的数据结构"><a href="#定义自己的数据结构" class="headerlink" title="定义自己的数据结构"></a>定义自己的数据结构</h2><h2 id="定义自己的头文件"><a href="#定义自己的头文件" class="headerlink" title="定义自己的头文件"></a>定义自己的头文件</h2><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ch2 变量和基本类型&lt;br&gt;数据类型决定了程序中数据和操作的意义。&lt;/p&gt;
&lt;h1 id=&quot;2-1-基本内置类型&quot;&gt;&lt;a href=&quot;#2-1-基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;2.1 基本内置类型&quot;&gt;&lt;/a&gt;2.1 基本内置类型&lt;/h1&gt;&lt;p&gt;基本数据类型：&lt;strong&gt; 算数类型  空类型（void） &lt;/strong&gt;,其中算数类型包括：字符、正整数、布尔值、浮点数。空类型不对应具体的值，用于一些特殊的场合。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch2 变量和基本类型</title>
    <link href="http://yoursite.com/2017/06/04/%E3%80%8Acpp%20primer%E3%80%8Bch3%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2017/06/04/《cpp primer》ch3字符串、向量、数组/</id>
    <published>2017-06-04T09:55:33.000Z</published>
    <updated>2017-09-09T17:03:30.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><h3 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h3><h3 id="头文件中不应该包含using声明"><a href="#头文件中不应该包含using声明" class="headerlink" title="头文件中不应该包含using声明"></a>头文件中不应该包含using声明</h3><p>因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。</p><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string s1;   //默认初始化</div><div class="line">string s2=s1;  //s2是s1的副本</div><div class="line">string s2(s1); //等价于string s2=s1,s2是s1的副本</div><div class="line">string s3=&quot;hiya&quot;;  //s3是字面值的副本，但是不包含字面值最后的那个空字符</div><div class="line">string s3(&quot;hiya&quot;);  //等价于string s3=&quot;hiya&quot;</div><div class="line">string s4(n,&apos;c&apos;);  //把s4初始化为连续n个字符c组成的字符串</div></pre></td></tr></table></figure><h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><ul><li>读写string对象</li><li>读取未知数量的string对象</li><li>使用getline读取一整行</li><li>string的empty和size操作<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3>size_type是一种无符号整形数，如果在表达式中混用了带符号数和无符号数会产生意想不到的后果。<h3 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h3>按字典顺序<h3 id="字面值和string类型相加"><a href="#字面值和string类型相加" class="headerlink" title="字面值和string类型相加"></a>字面值和string类型相加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//错误的方式</div><div class="line">string s=&quot;hello&quot;+&quot;,&quot; //错误，因为两个运算对象都不是string，不能把两个字面值直接相加</div><div class="line">string s1=&quot;hello&quot;+s1+&quot;,&quot; //正确</div></pre></td></tr></table></figure></li></ul><p><strong> 字符串字面值与string是不同的类型 </strong></p><h3 id="ex3-3-string类的输入运算和getline函数分别如何处理字符串"><a href="#ex3-3-string类的输入运算和getline函数分别如何处理字符串" class="headerlink" title="ex3.3 string类的输入运算和getline函数分别如何处理字符串"></a>ex3.3 string类的输入运算和getline函数分别如何处理字符串</h3><p>string的标准输入：自动忽略字符串开头的空白，从第一个真正的字符开始读取，直到下一个空白为止<br>getline函数：从给定的输入流中读取，直到遇到换行符为止。</p><h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><p>vector是一种类模板，需要后加一堆尖括号，在括号内放上信息。</p><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><ul><li>1.使用拷贝初始化</li><li>2.如果提供一个类内的初始值，只能使用拷贝初始化或者花括号形式初始化</li><li>3.如果提供的是初始值元素值的列表，则只能使用花括号初始化，而不能使用圆括号</li><li>4.创建指定数量的元素：采用圆括号<h3 id="3-3-2-像vector中添加元素"><a href="#3-3-2-像vector中添加元素" class="headerlink" title="3.3.2 像vector中添加元素"></a>3.3.2 像vector中添加元素</h3>push_back：像一个值添加到vector的尾部。（如果开始不知道有多少元素，c++中，一般先创建一个空的vector然后像其中添加元素最好）<br>不能使用下标形式添加元素，只能对确知已存在的元素执行下标操作。</li></ul><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p>迭代器这个名词可能有三种不同的含义：可能是迭代器概念本身，可能是容器定义的类型，还可能指某个迭代器对象。<br>某些对Vector对象的操作回事迭代器失效：一个是不能在范围for循环内向vector中添加元素，另一个是任何一种可能改变vector对象容量的操作，都有可能是vector对象的迭代器失效。</p><h3 id="迭代器的算数运算"><a href="#迭代器的算数运算" class="headerlink" title="迭代器的算数运算"></a>迭代器的算数运算</h3><p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。<br>迭代器之间的比较：参与比较的迭代器必须合法且指向同一个容器的元素（或者尾元素的下一个位置）</p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组与vector的区别：数组的大小确定不变，不能随意像数组中添加元素。性能很好，但是损失了灵活性。</p><h3 id="3-5-1-定义和初始化数组"><a href="#3-5-1-定义和初始化数组" class="headerlink" title="3.5.1 定义和初始化数组"></a>3.5.1 定义和初始化数组</h3><p>数组是一种复合类型，数组的维度必须是一个常量表达式。<br>定义数组的时候必须指定数组的类型。同时，数组的元素应该为对象，不存在引用的数组。</p><h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char a1[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，没有空字符</div><div class="line">char a2[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，含有显式的空字符</div><div class="line">char a3[]=&quot;C++&quot;;   //自动添加表示字符串结束的空字符</div></pre></td></tr></table></figure><h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p><strong> 要想理解数组的声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int &amp;refs[10]=...  //  错误！不存在数组的引用</div><div class="line">int (*Parray)[10]=&amp;arr; //Parray指向一个含有10个整数的数组</div><div class="line">int (&amp;arrRef)[10]=arr   //arrRef引用一个含有10个整数的数组</div><div class="line">int *ptrs[10];  //ptrs是一个含有10个整型指针的数组</div></pre></td></tr></table></figure></p><h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><ul><li>数组下标为<strong> size_t类型 </strong>，是一种机器相关的无符号类型。<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3>使用数组的时候编译器一般会把它转化成指针<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4>允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。<br>C风格字符串和字符数组的关系，尤其需要考虑串尾是否含有空字符。<br><strong> 问题：为什么没有指针相加？ </strong><br>指着也是一个对象，与指针有关的属性有三个，分别是指针的值（是一个内存地址值）、指针所指的对象、指针本身在内存中的存储位置。显然把两个地址加在一起是没有意义的。<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><h4 id="混用string对象和C风格字符串"><a href="#混用string对象和C风格字符串" class="headerlink" title="混用string对象和C风格字符串"></a>混用string对象和C风格字符串</h4></li><li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</li><li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（但不能两个都是）；在string对象的赋值运算中允许以空字符串结束的字符数组作为右侧的运算对象。<h4 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h4>允许使用数组初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址即可。但不能使用一个数组为另一个内置类型的数组赋初值，也不能使用vector对象初始化数组。<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。<br>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int ia[3][4] //大小为3的数组，每个元素是含有4个整数的数组</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-字符串、向量和数组&quot;&gt;&lt;a href=&quot;#第3章-字符串、向量和数组&quot; class=&quot;headerlink&quot; title=&quot;第3章 字符串、向量和数组&quot;&gt;&lt;/a&gt;第3章 字符串、向量和数组&lt;/h1&gt;&lt;h2 id=&quot;3-1-命名空间的using声明&quot;&gt;&lt;a href=&quot;#3-1-命名空间的using声明&quot; class=&quot;headerlink&quot; title=&quot;3.1 命名空间的using声明&quot;&gt;&lt;/a&gt;3.1 命名空间的using声明&lt;/h2&gt;&lt;h3 id=&quot;每个名字都需要独立的using声明&quot;&gt;&lt;a href=&quot;#每个名字都需要独立的using声明&quot; class=&quot;headerlink&quot; title=&quot;每个名字都需要独立的using声明&quot;&gt;&lt;/a&gt;每个名字都需要独立的using声明&lt;/h3&gt;&lt;h3 id=&quot;头文件中不应该包含using声明&quot;&gt;&lt;a href=&quot;#头文件中不应该包含using声明&quot; class=&quot;headerlink&quot; title=&quot;头文件中不应该包含using声明&quot;&gt;&lt;/a&gt;头文件中不应该包含using声明&lt;/h3&gt;&lt;p&gt;因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。&lt;/p&gt;
&lt;h2 id=&quot;3-2-标准库类型string&quot;&gt;&lt;a href=&quot;#3-2-标准库类型string&quot; class=&quot;headerlink&quot; title=&quot;3.2 标准库类型string&quot;&gt;&lt;/a&gt;3.2 标准库类型string&lt;/h2&gt;&lt;h3 id=&quot;3-2-1-定义和初始化string对象&quot;&gt;&lt;a href=&quot;#3-2-1-定义和初始化string对象&quot; class=&quot;headerlink&quot; title=&quot;3.2.1 定义和初始化string对象&quot;&gt;&lt;/a&gt;3.2.1 定义和初始化string对象&lt;/h3&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch3 字符串、向量和数组</title>
    <link href="http://yoursite.com/2017/06/04/%E3%80%8Acpp%20primer%E3%80%8Bch3/"/>
    <id>http://yoursite.com/2017/06/04/《cpp primer》ch3/</id>
    <published>2017-06-04T09:55:33.000Z</published>
    <updated>2017-09-09T17:03:23.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><h3 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h3><h3 id="头文件中不应该包含using声明"><a href="#头文件中不应该包含using声明" class="headerlink" title="头文件中不应该包含using声明"></a>头文件中不应该包含using声明</h3><p>因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。</p><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string s1;   //默认初始化</div><div class="line">string s2=s1;  //s2是s1的副本</div><div class="line">string s2(s1); //等价于string s2=s1,s2是s1的副本</div><div class="line">string s3=&quot;hiya&quot;;  //s3是字面值的副本，但是不包含字面值最后的那个空字符</div><div class="line">string s3(&quot;hiya&quot;);  //等价于string s3=&quot;hiya&quot;</div><div class="line">string s4(n,&apos;c&apos;);  //把s4初始化为连续n个字符c组成的字符串</div></pre></td></tr></table></figure><h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><ul><li>读写string对象</li><li>读取未知数量的string对象</li><li>使用getline读取一整行</li><li>string的empty和size操作<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3>size_type是一种无符号整形数，如果在表达式中混用了带符号数和无符号数会产生意想不到的后果。<h3 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h3>按字典顺序<h3 id="字面值和string类型相加"><a href="#字面值和string类型相加" class="headerlink" title="字面值和string类型相加"></a>字面值和string类型相加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//错误的方式</div><div class="line">string s=&quot;hello&quot;+&quot;,&quot; //错误，因为两个运算对象都不是string，不能把两个字面值直接相加</div><div class="line">string s1=&quot;hello&quot;+s1+&quot;,&quot; //正确</div></pre></td></tr></table></figure></li></ul><p><strong> 字符串字面值与string是不同的类型 </strong></p><h3 id="ex3-3-string类的输入运算和getline函数分别如何处理字符串"><a href="#ex3-3-string类的输入运算和getline函数分别如何处理字符串" class="headerlink" title="ex3.3 string类的输入运算和getline函数分别如何处理字符串"></a>ex3.3 string类的输入运算和getline函数分别如何处理字符串</h3><p>string的标准输入：自动忽略字符串开头的空白，从第一个真正的字符开始读取，直到下一个空白为止<br>getline函数：从给定的输入流中读取，直到遇到换行符为止。</p><h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><p>vector是一种类模板，需要后加一堆尖括号，在括号内放上信息。</p><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><ul><li>1.使用拷贝初始化</li><li>2.如果提供一个类内的初始值，只能使用拷贝初始化或者花括号形式初始化</li><li>3.如果提供的是初始值元素值的列表，则只能使用花括号初始化，而不能使用圆括号</li><li>4.创建指定数量的元素：采用圆括号<h3 id="3-3-2-像vector中添加元素"><a href="#3-3-2-像vector中添加元素" class="headerlink" title="3.3.2 像vector中添加元素"></a>3.3.2 像vector中添加元素</h3>push_back：像一个值添加到vector的尾部。（如果开始不知道有多少元素，c++中，一般先创建一个空的vector然后像其中添加元素最好）<br>不能使用下标形式添加元素，只能对确知已存在的元素执行下标操作。</li></ul><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p>迭代器这个名词可能有三种不同的含义：可能是迭代器概念本身，可能是容器定义的类型，还可能指某个迭代器对象。<br>某些对Vector对象的操作回事迭代器失效：一个是不能在范围for循环内向vector中添加元素，另一个是任何一种可能改变vector对象容量的操作，都有可能是vector对象的迭代器失效。</p><h3 id="迭代器的算数运算"><a href="#迭代器的算数运算" class="headerlink" title="迭代器的算数运算"></a>迭代器的算数运算</h3><p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。<br>迭代器之间的比较：参与比较的迭代器必须合法且指向同一个容器的元素（或者尾元素的下一个位置）</p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组与vector的区别：数组的大小确定不变，不能随意像数组中添加元素。性能很好，但是损失了灵活性。</p><h3 id="3-5-1-定义和初始化数组"><a href="#3-5-1-定义和初始化数组" class="headerlink" title="3.5.1 定义和初始化数组"></a>3.5.1 定义和初始化数组</h3><p>数组是一种复合类型，数组的维度必须是一个常量表达式。<br>定义数组的时候必须指定数组的类型。同时，数组的元素应该为对象，不存在引用的数组。</p><h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char a1[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，没有空字符</div><div class="line">char a2[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，含有显式的空字符</div><div class="line">char a3[]=&quot;C++&quot;;   //自动添加表示字符串结束的空字符</div></pre></td></tr></table></figure><h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p><strong> 要想理解数组的声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int &amp;refs[10]=...  //  错误！不存在数组的引用</div><div class="line">int (*Parray)[10]=&amp;arr; //Parray指向一个含有10个整数的数组</div><div class="line">int (&amp;arrRef)[10]=arr   //arrRef引用一个含有10个整数的数组</div><div class="line">int *ptrs[10];  //ptrs是一个含有10个整型指针的数组</div></pre></td></tr></table></figure></p><h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><ul><li>数组下标为<strong> size_t类型 </strong>，是一种机器相关的无符号类型。<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3>使用数组的时候编译器一般会把它转化成指针<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4>允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。<br>C风格字符串和字符数组的关系，尤其需要考虑串尾是否含有空字符。<br><strong> 问题：为什么没有指针相加？ </strong><br>指着也是一个对象，与指针有关的属性有三个，分别是指针的值（是一个内存地址值）、指针所指的对象、指针本身在内存中的存储位置。显然把两个地址加在一起是没有意义的。<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><h4 id="混用string对象和C风格字符串"><a href="#混用string对象和C风格字符串" class="headerlink" title="混用string对象和C风格字符串"></a>混用string对象和C风格字符串</h4></li><li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</li><li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（但不能两个都是）；在string对象的赋值运算中允许以空字符串结束的字符数组作为右侧的运算对象。<h4 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h4>允许使用数组初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址即可。但不能使用一个数组为另一个内置类型的数组赋初值，也不能使用vector对象初始化数组。<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。<br>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int ia[3][4] //大小为3的数组，每个元素是含有4个整数的数组</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-字符串、向量和数组&quot;&gt;&lt;a href=&quot;#第3章-字符串、向量和数组&quot; class=&quot;headerlink&quot; title=&quot;第3章 字符串、向量和数组&quot;&gt;&lt;/a&gt;第3章 字符串、向量和数组&lt;/h1&gt;&lt;h2 id=&quot;3-1-命名空间的using声明&quot;&gt;&lt;a href=&quot;#3-1-命名空间的using声明&quot; class=&quot;headerlink&quot; title=&quot;3.1 命名空间的using声明&quot;&gt;&lt;/a&gt;3.1 命名空间的using声明&lt;/h2&gt;&lt;h3 id=&quot;每个名字都需要独立的using声明&quot;&gt;&lt;a href=&quot;#每个名字都需要独立的using声明&quot; class=&quot;headerlink&quot; title=&quot;每个名字都需要独立的using声明&quot;&gt;&lt;/a&gt;每个名字都需要独立的using声明&lt;/h3&gt;&lt;h3 id=&quot;头文件中不应该包含using声明&quot;&gt;&lt;a href=&quot;#头文件中不应该包含using声明&quot; class=&quot;headerlink&quot; title=&quot;头文件中不应该包含using声明&quot;&gt;&lt;/a&gt;头文件中不应该包含using声明&lt;/h3&gt;&lt;p&gt;因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。&lt;/p&gt;
&lt;h2 id=&quot;3-2-标准库类型string&quot;&gt;&lt;a href=&quot;#3-2-标准库类型string&quot; class=&quot;headerlink&quot; title=&quot;3.2 标准库类型string&quot;&gt;&lt;/a&gt;3.2 标准库类型string&lt;/h2&gt;&lt;h3 id=&quot;3-2-1-定义和初始化string对象&quot;&gt;&lt;a href=&quot;#3-2-1-定义和初始化string对象&quot; class=&quot;headerlink&quot; title=&quot;3.2.1 定义和初始化string对象&quot;&gt;&lt;/a&gt;3.2.1 定义和初始化string对象&lt;/h3&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>简单脚本git一键提交代码</title>
    <link href="http://yoursite.com/2017/06/01/%E7%AE%80%E5%8D%95%E8%84%9A%E6%9C%ACgit%E4%B8%80%E9%94%AE%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2017/06/01/简单脚本git一键提交代码/</id>
    <published>2017-06-01T10:55:29.000Z</published>
    <updated>2017-09-09T15:39:24.755Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>git是我们每天都会使用的工具，但是一般的使用还是直接通过几个简单的命令，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;...&quot;</div><div class="line">git push origin master</div></pre></td></tr></table></figure></p></blockquote><a id="more"></a><p>对于这种简单的步骤，我们每天都会重复无数次，所以巨懒如我就干脆搞个小脚本，直接点一下就提交了。。</p><h2 id="一、Window使用bat脚本一键提交代码"><a href="#一、Window使用bat脚本一键提交代码" class="headerlink" title="一、Window使用bat脚本一键提交代码"></a>一、Window使用bat脚本一键提交代码</h2><p>直接新建文件，保存成.bat格式，编辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">title GIT提交批处理——小二三不乌</div><div class="line">color 16</div><div class="line"></div><div class="line"></div><div class="line">echo 开始提交代码到本地仓库</div><div class="line">echo 当前目录是：%cd%</div><div class="line"></div><div class="line">echo 开始添加变更</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git add -A .</div><div class="line">echo 执行结束！</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 提交变更到本地仓库</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">set /p declation=输入修改:</div><div class="line">git commit -m &quot;%declation%&quot;</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 将变更情况提交到远程git服务器</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git push origin master</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 批处理执行完毕！</div><div class="line">echo;</div><div class="line"></div><div class="line">pause</div></pre></td></tr></table></figure></p><h2 id="二、编写Python脚本一键提交代码"><a href="#二、编写Python脚本一键提交代码" class="headerlink" title="二、编写Python脚本一键提交代码"></a>二、编写Python脚本一键提交代码</h2><p><strong>额，用Python 好像就比较简单，但是还得cmd输一下，所以还是算了吧。。。 </strong></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;git是我们每天都会使用的工具，但是一般的使用还是直接通过几个简单的命令，例如:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git add .&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git commit -m &amp;quot;...&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git push origin master&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Tips" scheme="http://yoursite.com/categories/Tips/"/>
    
    
  </entry>
  
  <entry>
    <title>使用gitpage+Hexo搭建自己的博客</title>
    <link href="http://yoursite.com/2017/05/31/hexo+gitpage/"/>
    <id>http://yoursite.com/2017/05/31/hexo+gitpage/</id>
    <published>2017-05-31T00:55:29.000Z</published>
    <updated>2017-09-09T15:41:54.626Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。"><a href="#如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。" class="headerlink" title="如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。"></a>如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。</h2><a id="more"></a><h2 id="一、准备工作，准备需要准备好以下软件："><a href="#一、准备工作，准备需要准备好以下软件：" class="headerlink" title="一、准备工作，准备需要准备好以下软件："></a>一、准备工作，准备需要准备好以下软件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Node.js环境</div><div class="line">Git</div></pre></td></tr></table></figure><h3 id="1-Windows配置Node-js环境下载Node-js安装文件："><a href="#1-Windows配置Node-js环境下载Node-js安装文件：" class="headerlink" title="1.Windows配置Node.js环境下载Node.js安装文件："></a>1.Windows配置Node.js环境下载Node.js安装文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Windows Installer 32-bit</div><div class="line">Windows Installer 64-bit</div></pre></td></tr></table></figure><ul><li><p>根据自己的Windows版本选择相应的安装文件。<br><img src="https://xuanwo.org/imgs/opinion/Nodejs-install.png" alt=""></p></li><li><p>保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口：<br><img src="http://upload-images.jianshu.io/upload_images/6054281-bc2e6deb5f394f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li>在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~） 在打开的命令行界面中，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node -v</div><div class="line">npm -v</div></pre></td></tr></table></figure></li></ul><p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。<br>(<a href="https://xuanwo.org/imgs/opinion/Nodejs-test.png" target="_blank" rel="external">https://xuanwo.org/imgs/opinion/Nodejs-test.png</a>)</p><h3 id="2-配置Git环境下载Git安装文件："><a href="#2-配置Git环境下载Git安装文件：" class="headerlink" title="2.配置Git环境下载Git安装文件："></a>2.配置Git环境下载Git安装文件：</h3><p><a href="https://github.com/git-for-windows/git/releases/download/v2.6.3.windows.1/Git-2.6.3-64-bit.exe" target="_blank" rel="external">Git-2.6.3-64-bit.exe</a></p><p>然后就进入了Git的安装界面，如图：<br><img src="https://xuanwo.org/imgs/opinion/Git-install.png" alt=""><br>和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择：<br><img src="https://xuanwo.org/imgs/opinion/Git-path-setting.png" alt=""></p><blockquote><p>这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。</p></blockquote><p>一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git --version</div></pre></td></tr></table></figure></p><p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。<br><img src="https://xuanwo.org/imgs/opinion/Git-test.png" alt=""></p><h2 id="二、新建仓库"><a href="#二、新建仓库" class="headerlink" title="二、新建仓库"></a>二、新建仓库</h2><h3 id="1-打开https-github-com-，在下图的框中，分别输入自己的用户名，邮箱，密码。"><a href="#1-打开https-github-com-，在下图的框中，分别输入自己的用户名，邮箱，密码。" class="headerlink" title="1.打开https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。"></a>1.打开<a href="https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。" target="_blank" rel="external">https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。</a></h3><h3 id="2-创建代码库登陆之后，点击页面右上角的加号，选择New-repository："><a href="#2-创建代码库登陆之后，点击页面右上角的加号，选择New-repository：" class="headerlink" title="2.创建代码库登陆之后，点击页面右上角的加号，选择New repository："></a>2.创建代码库登陆之后，点击页面右上角的加号，选择New repository：</h3><p>进入代码库创建页面：<br>在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示：<br><img src="https://xuanwo.org/imgs/opinion/Github-new-repo-setting.png" alt=""><br>正确创建之后，你将会看到如下界面：<br><img src="https://xuanwo.org/imgs/opinion/Github-new-repo-look-like.png" alt=""><br>开启gh-pages功能点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图：<br><img src="https://xuanwo.org/imgs/opinion/Github-pages.png" alt=""><br>点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。<br>配置Hexo安装Hexo在自己认为合适的地方创建一个文件夹，然后在文件夹空白处按住Shift+鼠标右键，然后点击在此处打开命令行窗口。（同样要记住啦，下文中会使用在当前目录打开命令行来代指上述的操作）<br>在命令行中输入：<br><code>npm install hexo-cli -g</code><br>然后你将会看到:<br><img src="https://xuanwo.org/imgs/opinion/npm-install-hexo-cli.png" alt=""><br>可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入<br><code>npm install hexo --save</code></p><p>然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入：<br><code>hexo -v</code></p><p>如果你看到了如图文字，则说明已经安装成功了。<br><img src="https://xuanwo.org/imgs/opinion/hexo-v.png" alt=""><br>初始化Hexo接着上面的操作，输入：<br><code>hexo init</code></p><p>如图：<br><img src="https://xuanwo.org/imgs/opinion/hexo-init.png" alt=""><br>然后输入：<br><code>npm install</code></p><p>之后npm将会自动安装你需要的组件，只需要等待npm操作即可。</p><h2 id="首次体验Hexo"><a href="#首次体验Hexo" class="headerlink" title="首次体验Hexo"></a>首次体验Hexo</h2><p>继续操作，同样是在命令行中，输入：<br><code>hexo g</code></p><p>如图：<br><img src="https://xuanwo.org/imgs/opinion/hexo-g.png" alt=""><br>然后输入：<br><code>hexo s</code></p><p>然后会提示：<br><code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p><p>在浏览器中打开<code>http://localhost:4000/</code>，你将会看到：<br><img src="https://xuanwo.org/imgs/opinion/hexo-first-time.png" alt=""><br>到目前为止，Hexo在本地的配置已经全都结束了。</p><h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><blockquote><p>在配置过程中请使用yamllint来保证自己的yaml语法正确<br>修改全局配置文件此段落引用自<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo官方文档</a><br>您可以在 _config.yml 中修改大部份的配置。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>参数 | 描述<br>title | 网站标题<br>subtitle | 网站副标题<br>description | 网站描述<br>author | 您的名字<br>language | 网站使用的语言<br>timezone | 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</p><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>url</td><td>网址</td></tr><tr><td>root</td><td>网站根目录</td><td>permalink文章的 永久链接 格式:year/:month/:day/:title/permalink_default永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 <a href="http://yoursite.com/blog，则请将您的">http://yoursite.com/blog，则请将您的</a> url 设为 <a href="http://yoursite.com/blog">http://yoursite.com/blog</a> 并把 root 设为 /blog/。</td></tr></tbody></table><p>目录参数描述默认值source_dir资源文件夹，这个文件夹用来存放内容。sourcepublic_dir公共文件夹，这个文件夹用于存放生成的站点文件。publictag_dir标签文件夹tagsarchive_dir归档文件夹archivescategory_dir分类文件夹categoriescode_dirInclude code 文件夹`downloads/codei18n_dir国际化（i18n）文件夹:langskip_render跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 文章参数描述默认值new_post_name新文章的文件名称:title.mddefault_layout预设布局postauto_spacing在中文和英文之间加入空格falsetitlecase把标题转换为 title casefalseexternal_link在新标签中打开链接truefilename_case把文件名称转换为 (1) 小写或 (2) 大写0render_drafts显示草稿falsepost_asset_folder启动 Asset 文件夹falserelative_link把链接改为与根目录的相对位址falsefuture显示未来的文章truehighlight代码块的设置 分类 &amp; 标签参数描述默认值default_category默认分类uncategorizedcategory_map分类别名 tag_map标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。<br>参数描述默认值date_format日期格式MMM D YYYYtime_format时间格式H:mm:ss分页参数描述默认值per_page每页显示的文章量 (0 = 关闭分页功能)10pagination_dir分页目录page扩展参数描述theme当前主题名称。值为false时禁用主题deploy部署部分的设置配置Deployment首先，你需要为自己配置身份信息，打开命令行，然后输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;yourname&quot;</div><div class="line">git config --global user.email &quot;youremail&quot;</div></pre></td></tr></table></figure></p></blockquote><p>同样在_config.yml文件中，找到Deployment，然后按照如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git@github.com:yourname/yourname.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p><p>如果使用git方式进行部署，执行npm install hexo-deployer-git –save来安装所需的插件<br>然后在当前目录打开命令行，输入：<br><code>hexo d</code></p><p>随后按照提示，分别输入自己的Github账号用户名和密码，开始上传。 然后通过<a href="http://yourname.github.io/来访问自己刚刚上传的网站。" target="_blank" rel="external">http://yourname.github.io/来访问自己刚刚上传的网站。</a><br>添加新文章打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就能在执行hexo g的时候被渲染。 新建的文章头需要添加一些yml信息，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: hello-world   //在此处添加你的标题。</div><div class="line">date: 2017-5-11 08:55:29   //在此处输入你编辑这篇文章的时间。</div><div class="line">categories: Exercise   //在此处输入这篇文章的分类。</div><div class="line">toc: true    //在此处设定是否开启目录，需要主题支持。</div></pre></td></tr></table></figure></p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>如果成功完成了上述的全部步骤，恭喜你，你已经搭建了一个最为简单且基础的博客。但是这个博客还非常简单， 没有个人的定制，操作也比较复杂，下面的进阶技巧将会让你获得对Hexo更为深入的了解。<br>更换主题可以在此处寻找自己喜欢的主题 下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改：</p><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><h4 id="Plugins-http-hexo-io-plugins"><a href="#Plugins-http-hexo-io-plugins" class="headerlink" title="Plugins: http://hexo.io/plugins/"></a>Plugins: <a href="http://hexo.io/plugins/" target="_blank" rel="external">http://hexo.io/plugins/</a></h4><h4 id="Themes-http-hexo-io-themes"><a href="#Themes-http-hexo-io-themes" class="headerlink" title="Themes: http://hexo.io/themes/"></a>Themes: <a href="http://hexo.io/themes/" target="_blank" rel="external">http://hexo.io/themes/</a></h4><p>theme: landscape //themes文件夹中对应文件夹的名称</p><p>然后先执行<code>hexo clean</code>，然后重新<code>hexo g</code>，并且<code>hexo d</code>，很快就能看到新主题的效果了~<br>更换域名首先，需要注册一个域名。在中国的话，.cn全都需要进行备案，如果不想备案的话，请注册别的顶级域名，可以使用godaddy或新网或万网中的任意一家，自己权衡价格即可。 然后，我们需要配置一下域名解析。推荐使用DNSPod的服务，比较稳定，解析速度比较快。在域名注册商出修改NS服务器地址为：<br>f1g1ns1.dnspod.net<br>f1g1ns2.dnspod.net</p><p>以新网为例，首先点击域名管理进入管理页面：</p><p>然后点击域名后面的管理：</p><p>进入域名管理的操作界面，点击域名管理，来到域名管理界面：</p><p>点击修改域名DNS，然后选择填写具体信息，在下面的空框中填入DNSPod的NS服务器：</p><p>然后我们进入DNSPod的界面，开始真正进入域名解析的配置= =。在DNSPod中，首先添加域名，然后分别添加如下条目：</p><p>最后，我们对Github进行一下配置。<br>在自己本地的hexo目录下的source文件夹中，新建一个CNAME文件（注意，没有后缀名。），内容为yourdomin.xxx。然后再执行一下hexo d -g，重新上传自己的博客。 在github中打开你自己的库，进入库的setting界面，如果看到了如下提示，说明配置成功了。</p><p>在这一系列的操作中，包括修改NS服务器，设置A解析等等，都需要一定的时间。短则10分钟，长则24小时，最长不会超过72小时。如果超过72小时，请检查自己的配置过程，或者修改自己本地的DNS服务器。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。&quot;&gt;&lt;a href=&quot;#如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。&quot; class=&quot;headerlink&quot; title=&quot;如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。&quot;&gt;&lt;/a&gt;如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。&lt;/h2&gt;
    
    </summary>
    
      <category term="Tips" scheme="http://yoursite.com/categories/Tips/"/>
    
    
  </entry>
  
  <entry>
    <title>我为什么写博客？</title>
    <link href="http://yoursite.com/2017/05/15/%E6%96%B0%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/05/15/新建博客/</id>
    <published>2017-05-15T11:56:31.000Z</published>
    <updated>2017-09-09T15:42:22.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开博客的第一天–谈学习与博客"><a href="#开博客的第一天–谈学习与博客" class="headerlink" title="开博客的第一天–谈学习与博客"></a>开博客的第一天–谈学习与博客</h1><hr><h4 id="作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。"><a href="#作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。" class="headerlink" title="作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。"></a>作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。</h4><p>###<br><a id="more"></a></p><h4 id="那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。"><a href="#那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。" class="headerlink" title="那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。"></a>那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。</h4><p>###</p><h4 id="然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99-可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？"><a href="#然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99-可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？" class="headerlink" title="然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99.可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？"></a>然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99.可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？</h4><p>###</p><h4 id="今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。"><a href="#今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。" class="headerlink" title="今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。"></a>今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。</h4><p>###</p><h4 id="所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧："><a href="#所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧：" class="headerlink" title="所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧："></a>所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧：</h4><blockquote><p> When nothing seems to help,I go and look at a stonecutter hammering away at his rock perhaps a hundred times without as much as a crack showing in it.Yet at the hundred and first blow it will split in two,and I know it was not that blow that did it——but all that had gone before.<br>——Jacob Riis</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开博客的第一天–谈学习与博客&quot;&gt;&lt;a href=&quot;#开博客的第一天–谈学习与博客&quot; class=&quot;headerlink&quot; title=&quot;开博客的第一天–谈学习与博客&quot;&gt;&lt;/a&gt;开博客的第一天–谈学习与博客&lt;/h1&gt;&lt;hr&gt;
&lt;h4 id=&quot;作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。&quot;&gt;&lt;a href=&quot;#作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。&quot; class=&quot;headerlink&quot; title=&quot;作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。&quot;&gt;&lt;/a&gt;作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。&lt;/h4&gt;&lt;p&gt;###&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="http://yoursite.com/categories/Life/"/>
    
    
      <category term="日常" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>day5(面向对象2)</title>
    <link href="http://yoursite.com/2017/03/09/day17(%E9%9B%86%E5%90%884-%E5%B7%A5%E5%85%B7%E7%B1%BB)/"/>
    <id>http://yoursite.com/2017/03/09/day17(集合4-工具类)/</id>
    <published>2017-03-09T04:55:17.000Z</published>
    <updated>2017-09-09T15:41:22.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合（工具类）"><a href="#集合（工具类）" class="headerlink" title="集合（工具类）"></a>集合（工具类）</h1><hr><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><h2 id="binarySerch"><a href="#binarySerch" class="headerlink" title="binarySerch"></a>binarySerch</h2><h2 id="替换反转"><a href="#替换反转" class="headerlink" title="替换反转"></a>替换反转</h2><h2 id="reserveOrder"><a href="#reserveOrder" class="headerlink" title="reserveOrder"></a>reserveOrder</h2><h2 id="Synlist"><a href="#Synlist" class="headerlink" title="Synlist"></a>Synlist</h2><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>用于操作数组的工具类，里面都是静态方法。</p><h2 id="集合变数组"><a href="#集合变数组" class="headerlink" title="集合变数组"></a>集合变数组</h2><p>1.指定类型的数组到底要定义多长呢？<br>当指定类型的数组长度小于集合的size，那么该方法会创建一个新的数组，长度为集合的size。当指定类型的数组长度小于了集合的size，就不会创建新数组，而是使用传递进来的数组，所以创建一个刚刚好的数组最优。<br>2.为什么要将集合变数组？<br>为了限定对元素的操作。</p><p>##增强for循环</p><p>##可变参数<br>方法的可变参数注意：<br>可变参数一定要定义在参数列表的最后面。</p><p>##静态导入<br>当类名方法重名时，需要指定具体的包名。<br>当方法重名时，指定具备所属的对象或者类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合（工具类）&quot;&gt;&lt;a href=&quot;#集合（工具类）&quot; class=&quot;headerlink&quot; title=&quot;集合（工具类）&quot;&gt;&lt;/a&gt;集合（工具类）&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;sort&quot;&gt;&lt;a href=&quot;#sort&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>day5(面向对象2)</title>
    <link href="http://yoursite.com/2017/03/09/day8(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14)/"/>
    <id>http://yoursite.com/2017/03/09/day8(面向对象4)/</id>
    <published>2017-03-09T04:55:17.000Z</published>
    <updated>2017-09-09T15:39:53.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象（4）–多态"><a href="#面向对象（4）–多态" class="headerlink" title="面向对象（4）–多态"></a>面向对象（4）–多态</h1><hr><h2 id="多态概念"><a href="#多态概念" class="headerlink" title="多态概念"></a>多态概念</h2><p>多态：可以理解为事物存在的多种体现形态</p><h2 id="多态的扩展性"><a href="#多态的扩展性" class="headerlink" title="多态的扩展性"></a>多态的扩展性</h2><ol><li>多态的体现<br> 父类的引用指向了自己的子类对象<br> 父类的引用也可以接收自己的子类对象</li><li>多态的前提<br> 必须是类与类之间有关系，要么继承，要么实现。<br> 通常还有一个前提：存在覆盖</li><li>多态的好处<br> 多态的出现大大的提高程序的扩展性</li><li>多态的弊端：<br> 提高了扩展性，但是只能用父类的引用访问父类中的成员</li><li>多态的应用</li></ol><h2 id="多态–转型"><a href="#多态–转型" class="headerlink" title="多态–转型"></a>多态–转型</h2><p>向上转型，向上转型<br>千万不要出现这样的操作，就是将父类对象转换成子类类型。<br>我们能转换的是父类应用指向了自己的子类对象时，该引用可以被提升，也可以被强制转换。<br>多态自始至终都是子类对象在做着变化</p><h2 id="多态成员的特点"><a href="#多态成员的特点" class="headerlink" title="多态成员的特点"></a>多态成员的特点</h2><p>在多态中成员函数的特点：<br>在编译时期：参阅引用型变量所属的类中是否有调用的方法，如果有，编译通过，如果没有，编译失败。<br>在运行时期：参阅对象所属的类中是否有调用的方法。<br>简单总结就是：成员函数在多态调用时，编译看左边，运行看右边。<br>在多态中，成员变量的特点：无论编译还是运行，都参考左边（引用型变量所属的类）。<br>在多态中，静态成员函数的特点：无论编译还是运行，都参考左边（引用型变量所属的类）。</p><h2 id="多态的实例"><a href="#多态的实例" class="headerlink" title="多态的实例"></a>多态的实例</h2><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象（4）–多态&quot;&gt;&lt;a href=&quot;#面向对象（4）–多态&quot; class=&quot;headerlink&quot; title=&quot;面向对象（4）–多态&quot;&gt;&lt;/a&gt;面向对象（4）–多态&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;多态概念&quot;&gt;&lt;a href=&quot;#多态概念&quot; class=
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>day5(面向对象2)</title>
    <link href="http://yoursite.com/2017/03/09/day7(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13)/"/>
    <id>http://yoursite.com/2017/03/09/day7(面向对象3)/</id>
    <published>2017-03-09T04:55:17.000Z</published>
    <updated>2017-09-09T15:39:48.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象（3）"><a href="#面向对象（3）" class="headerlink" title="面向对象（3）"></a>面向对象（3）</h1><h1 id="（继承，final，抽象类，接口）"><a href="#（继承，final，抽象类，接口）" class="headerlink" title="（继承，final，抽象类，接口）"></a><em>（继承，final，抽象类，接口）</em></h1><hr><h2 id="1-继承（概述）"><a href="#1-继承（概述）" class="headerlink" title="1.继承（概述）"></a>1.继承（概述）</h2><ul><li><strong>继承：</strong></li></ul><p>1.提高了代码的复用性</p><p>2.继承让类与类之间有了关系，有了关系才有了多态的特性。</p><p>注意：千万不要为了获取其他类的功能，简化代码而继承。<br>必须是类与类之间有所属关系才可以继承，所属关系 is a。</p><p><strong>java语言中：java只支持单继承，不支持多继承。</strong></p><p>  因为多继承容易带来安全隐患：当多个父类中定义了相同的功能，当功能内容不同时，子类对象不确定要运行哪一个。<br>  但是java保留了这种机制，并用另一种体现形式来完成表示，多实现。</p><ul><li><strong>java支持多层继承。</strong></li></ul><ul><li><strong>如何使用一个继承体系中的功能？</strong></li></ul><p>想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系的共性功能。</p><p>通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了<br>那么在具体调用时，要创建最子类的对象。<br>因为：1.可能父类不能创建对象 2.创建子类可以使用更多的功能，包括基本的也包括特有的<br>简单的说，就是查阅父类，创建子类</p><h2 id="2-聚集关系"><a href="#2-聚集关系" class="headerlink" title="2.聚集关系"></a>2.聚集关系</h2><p>聚集：has a<br>聚合：<br>组合：</p><p>子父类出现后，类成员的特点<br>类成员：<br>1.变量<br>2.函数<br>3.构造函数</p><h2 id="3-1-子父类中的变量的特点"><a href="#3-1-子父类中的变量的特点" class="headerlink" title="3.1.子父类中的变量的特点"></a>3.1.子父类中的变量的特点</h2><p>如果子类中出现非私有的同名成员变量时，子类要访问本类中的变量，用this<br>super代表的是父类对象的引用</p><h2 id="3-2-子父类中的函数的特点"><a href="#3-2-子父类中的函数的特点" class="headerlink" title="3.2.子父类中的函数的特点"></a>3.2.子父类中的函数的特点</h2><p>当子类和父类中出现一样的函数时，当子类对象调用该函数，会运行子类函数的内容。如同父类的函数被覆盖一样。<br>这种情况是函数的另一个特性：重写（覆盖）<br>当子类继承父类，沿袭了父类的功能，但是功能的内容却和父类不一致。这时没有必要定义新功能，而是使用覆盖特殊，保留父类的功能定义，并重写功能内容。</p><p>覆盖：<br>1.子类覆盖父类，必须保证子类权限大于父类权限，否则编译失败<br>2.静态只能覆盖静态。</p><h2 id="3-3-子父类中构造函数的特点–子类的实例化过程"><a href="#3-3-子父类中构造函数的特点–子类的实例化过程" class="headerlink" title="3.3.子父类中构造函数的特点–子类的实例化过程"></a>3.3.子父类中构造函数的特点–子类的实例化过程</h2><p>重载：只看重名函数的参数列表。<br>重写：子类父类方法要一模一样。</p><p>子父类中的构造函数：<br>在对子类对象进行初始化 时，弗父类的构造函数也会运行，那是因为子类的构造函数第一行默认有一条隐式语句super()；<br>super()：会访问父类中空参数的构造函数。而且子类中所有的构造函数默认第一行都是super()<br>为什么子类一定要访问父类中的构造函数？<br>因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要先查看父类如何对这些数据进行初始化的，所以子类在对象进行初始化时，要先访问一下父类中的构造函数<br>如果要访问父类中指定的构造函数，可以用super语句来指定。</p><p>注意：super语句一定定义在子类构造函数的第一行。</p><ul><li>子类的实例化过程：</li></ul><p>结论：子类所有的构造函数默认都会访问父类中空参数的构造函数，因为子类每一个构造函数的第一行都有一句隐式的super()<br>当父类中没有空的构造函数时，子类必须手动通过super或者this语句形式来指定要访问父类中的构造函数。<br>当然：子类中的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数</p><h2 id="4-final关键字"><a href="#4-final关键字" class="headerlink" title="4.final关键字"></a>4.final关键字</h2><p>final：最终，作为一个修饰符</p><ol><li>可以修饰类，函数，变量</li><li>被final修饰的类不可以被继承,为了避免被继承，被子类复写功能</li><li>被final修饰的方法不可以被复写</li><li>被final修饰的变量是一个常量只能赋值一次，既可以修饰局部变量，也可以修饰成员变量。<br> 在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这值起个名字，方便于阅读，而这个值不需要改变，所以加个final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成，单词间通过_连接。</li><li>内部类定义在类中的局部位置时，只能访问该局部被final修饰的局部变量。</li></ol><h2 id="5-抽象类"><a href="#5-抽象类" class="headerlink" title="5.抽象类"></a>5.抽象类</h2><p>当多个类中出现相同功能，但是功能的主体不同，这时可以向上抽取，这时只能抽取功能定义，而不抽取功能主题<br>抽象：看不懂<br>抽象类的特点：</p><ol><li>抽象方法一定在抽象类中。</li><li>抽象方法和抽象类都必须被abstract关键字修饰。</li><li>抽象类不可以用new创建对象，因为调用抽象方法没意义。</li><li>抽象类中的方法要被使用，必须由子类复写起所有的抽象方法之后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。</li></ol><p>抽象类和一般类没有太大的不同。<br>该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。<br>这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。</p><p>抽象类比一般类多了个抽象函数。就是在类中可以定义抽象方法。<br>抽象类不可以实例化。<br>特殊：抽象类中可以不定义抽象方法，这样做仅仅是为了不让该类建立对象。</p><h2 id="6-模板方法设计模式"><a href="#6-模板方法设计模式" class="headerlink" title="6.模板方法设计模式"></a>6.模板方法设计模式</h2><p>在定义功能时，功能的一部分是确定的，但是有一部分功能时不确定的，而确定的部分在使用不确定的部分，就将不确定的部分暴露出去，</p><h2 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h2><ul><li><strong>接口</strong>：初期理解，可以认为是一个特殊的抽象类<br>当抽象类中的方法都是抽象的，那么该类可以通过接口的形式实现<br>class 用于定义类<br>interface 用于定义接口<br>接口定义时，格式特点：</li></ul><ol><li>接口中常见定义：常量，抽象方法。</li><li>接口中的成员都有固定的修饰符。常量：public static final<br>方法：public abstract<br>记住，接口中的成员都是public的<br>接口是不可以创建对象的，因为有抽象方法。<br>需要被子类实现，子类对接口中的抽象方法全部覆盖后，子类才可以实例化。否则子类是一个抽象类</li></ol><ul><li><strong>接口可以被类多实现</strong><br><strong>接口与接口之间可以多继承</strong><h2 id="8-接口的特点"><a href="#8-接口的特点" class="headerlink" title="8.接口的特点"></a>8.接口的特点</h2></li></ul><ol><li>接口是对外暴露的规则</li><li>接口是程序的程序扩展</li><li>接口可以用来多实现</li><li>类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口</li><li>接口与接口之间可以有继承关系</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象（3）&quot;&gt;&lt;a href=&quot;#面向对象（3）&quot; class=&quot;headerlink&quot; title=&quot;面向对象（3）&quot;&gt;&lt;/a&gt;面向对象（3）&lt;/h1&gt;&lt;h1 id=&quot;（继承，final，抽象类，接口）&quot;&gt;&lt;a href=&quot;#（继承，final，抽象类，接口
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>day5(面向对象2)</title>
    <link href="http://yoursite.com/2017/03/09/day9(%E5%86%85%E9%83%A8%E7%B1%BB)/"/>
    <id>http://yoursite.com/2017/03/09/day9(内部类)/</id>
    <published>2017-03-09T04:55:17.000Z</published>
    <updated>2017-09-09T15:39:58.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><hr><h2 id="内部类访问规则"><a href="#内部类访问规则" class="headerlink" title="内部类访问规则"></a>内部类访问规则</h2><ol><li>内部类可以直接访问外部类中的成员，包括私有<br> 之所以可以直接访问外部类中的成员，是因为内部类中持有了 一个外部类的引用，格式：外部类名.this</li><li>外部类要访问内部类，必须建立内部类对象。<br> 直接访问内部类中的成员<br>访问格式：<br>当内部类定义在外部类的成员位置上，就可以被成员修饰符所修饰。<br>比如，private：将内部类在外部类中进行封装。<br> static：内部类就具备static的特性。<br>当内部类被static修饰后，只能直接访问外部类中的static成员，出现了访问局限。<br>在外部其他类中，如何访问内部类的非静态成员呢？<h2 id="内部类定义的原则"><a href="#内部类定义的原则" class="headerlink" title="内部类定义的原则"></a>内部类定义的原则</h2>当描述事物时，事物的内部还有事物，该事物用内部类来描述。因为内部事物在使用外部事物的内容。</li></ol><p>内部类定义在局部时，</p><ol><li>不可以被成员修饰符修饰</li><li>可以直接访问外部类中的成员，因为还持有外部类中的引用。但是不可以访问它所在的局部中的变量，只能访问被final修饰的局部变量  、<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2></li><li>匿名内部类其实就是内部类的简写格式</li><li>定义匿名内部类的前提：内部类必须是继承一个类或者实现接口。</li><li>匿名内部类的格式：new 父类或者接口（）{定义子类的内容}</li><li>其实匿名内部类就是一个匿名子类对象，而且这个对象有点胖。可以理解为带内容的对象</li><li>匿名内部类中定义的方法最多不要超过三个</li></ol><h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><p>异常：就是程序在运行时出现不正常的情况。<br>异常的由来：问题也是现实生活中一个具体的事物，也可以通过java的类的形式进行描述。并封装成对象。其实就是java对不正常情况进行描述后的对象体现<br>对于问题的划分：两种：一种是严重的问题，一种是不严重的问题</p><p>对于严重的，java通过Error类进行描述。<br>对于Error，一般不编写针对性的代码进行处理<br>对于非严重的，java通过Exception类进行描述。（可以使用针对性的处理方式进行处理 ）</p><h2 id="异常try-catch"><a href="#异常try-catch" class="headerlink" title="异常try-catch"></a>异常try-catch</h2><p>异常的处理：java提供了特有的语句进行处理<br>对捕获到的异常对象进行常见的方法操作。<br>String getMessage</p><h2 id="异常声明throws"><a href="#异常声明throws" class="headerlink" title="异常声明throws"></a>异常声明throws</h2><h2 id="多异常处理"><a href="#多异常处理" class="headerlink" title="多异常处理"></a>多异常处理</h2><p>对多异常的处理。</p><ol><li>声明异常时，建议声明更为具体的异常。这样处理的可以更具体。</li><li>对方声明几个异常，就对应有几个catch块。不要定义多余的catch块<br> 如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面<br>建立在进行catch处理时，catch中一定要具体的处理方式。不要简单的定义一句e.peintStackTrace()，也不要简单的就书写一条输出语句。</li></ol><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>项目中会出现特有的问题，而这些问题并未被java所描述并封装对象。所以对于这些特有的问题可以按照java对问题封装的思想。将特有的问题。进行自定义的异常封装。<br>当在函数内部出现了throw抛出异常对象，那么就必须要给对应的处理动作。<br>要么在内部try catch处理，要么在函数上声明让调用者处理。<br>发现打印的结果中只有异常的名称，缺没有异常的信息。<br>因为自定义的异常并未定义信息。<br>父类中已经把异常信息的操作都完成了。所以子类只要在构造时，将异常信息传递给父类通过super语句。那么直接就可以通过getMessage方法获取自定义的异常。</p><hr><p>自定义异常：必须是自定义类继承Exception。原因是：<br>异常体系有一个特点：因为异常类和异常对象都被抛出。他们都具备可抛性。这个可抛性是Throwable这个体系中的独有特点。只有这个体系中的类和对象才可以被throw和throws操作。</p><h2 id="throws-和throw的区别：throws使用在函数上。throw使用在函数内。"><a href="#throws-和throw的区别：throws使用在函数上。throw使用在函数内。" class="headerlink" title="throws 和throw的区别：throws使用在函数上。throw使用在函数内。"></a>throws 和throw的区别：throws使用在函数上。throw使用在函数内。</h2><p>throws后面跟的异常类，可以跟多个。用逗号隔开。throw后面跟的是异常对象。</p><h2 id="RuntimeException运行时异常。"><a href="#RuntimeException运行时异常。" class="headerlink" title="RuntimeException运行时异常。"></a>RuntimeException运行时异常。</h2><p>如果在函数内抛出该异常，函数上可以不用声明，编译一样通过。<br>如果在函数上声明了该异常。调用者可以不用进行处理。编译一样通过。<br>之所以不用在函数声明，是因为不需要让调用者处理，当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，对代码尽心修正。<br>自定义异常时，如果该异常的发生，无法再继续进行运算，就让自定义异常继承RuntimeException<br>对于异常分两种：</p><ol><li>编译时被检测的异常。</li><li>编译时不被检测的异常（运行时异常。RuntimeException以及其子类）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;内部类访问规则&quot;&gt;&lt;a href=&quot;#内部类访问规则&quot; class=&quot;headerlink&quot; title=&quot;内部
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
