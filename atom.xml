<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mianhk&#39;s notes</title>
  
  <subtitle>这个人很懒，动不动就不想写</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-27T02:28:47.068Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mianhk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《c++primer》ch6 函数</title>
    <link href="http://yoursite.com/27-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/27-cpp/cpp-primer/《cpp primer》ch6函数/</id>
    <published>2018-06-27T14:50:05.871Z</published>
    <updated>2018-04-27T02:28:47.068Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。</p></blockquote><a id="more"></a><h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><h2 id="形参和实参："><a href="#形参和实参：" class="headerlink" title="形参和实参："></a>形参和实参：</h2><p>实参是形参的初始值，函数的形参列表可以为空。<br>局部静态对象，定义成static类型，在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><p>如果形参是引用类型，它将绑定到对应的实参上，称为引用传递；否则，将实参的值拷贝后赋给形参，称为值传递。</p><h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2><p>将实参的值拷贝给形参。当是指针形参时，指针的行为和其他非引用类型一样，执行指针拷贝类型时，拷贝的是指针的值。拷贝之后是不同的指针，但是指向的是相同的值，我们可以在函数中修改指针所指对象的值。在C++中，建议使用引用类型的形参替代指针。</p><h2 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h2><p><strong> 1.使用引用避免拷贝。 </strong>因为有的类类型是不能拷贝的，或者在拷贝一些大的类类型对象或者容器对象比较低效。<br>如果函数不需要改变引用参数的值，最好将其声明为常量引用。<br><strong> 2.使用引用形参返回额外信息。</strong>由于函数不能有多个返回值，在我们需要返回多个值的时候，可以额外传一个引用参数。<br><strong> 3.可以直接操作引用形参所引的对象。 </strong></p><h2 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h2><p>和其它初始化一样，当用实参初始化形参时会忽略掉顶层const。也就是，形参的顶层const会被忽略掉。（这个可以思考一下，我们可以通过形参的const在参数中控制是否需要改变形参，以及对应的实参，这样更方便我们传参数。当然有了这个我们就不能重载有无const的两个函数了，因为会被编译器相同对待。）<br>尽量使用常量引用，除了在使用的时候，无法把常量引用初始化为引用（很简单的道理），另外，也会给调用者一种误导。</p><h2 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h2><p>无法以值传递的方式使用数组参数。数组的特点：不允许拷贝、使用数组会将其转化为指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void print(const int*);</div><div class="line">void print(const int[]);</div><div class="line">void print(const int[10]);  //这里的维度表示我们期望数组含有多少个元素，实际不一定</div></pre></td></tr></table></figure></p><h3 id="关于数组长度"><a href="#关于数组长度" class="headerlink" title="关于数组长度"></a>关于数组长度</h3><p>由于传递数组引用的时候，只是数组的首元素指针，所以有时候我们需要在形参定义的时候，就将数组大小传递给形参。这里有几种方式。</p><h2 id="6-2-5-mian处理命令行选项"><a href="#6-2-5-mian处理命令行选项" class="headerlink" title="6.2.5 mian处理命令行选项"></a>6.2.5 mian处理命令行选项</h2><p>当使用argv[]中的实参时，第一个实参保存的是程序名，所以应该从第二个开始。</p><h2 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h2><p>有时候我们预先不知道向函数传递几个实参。1.如果所有的实参类型相同，可以传递名为initializee_list的标准库类型；2.如果实参类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。</p><h1 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h1><p>return语句终止当前执行的函数，并将控制权返回到调用该函数的地方。<br>return语句不要返回局部对象的引用或引用（因为局部对象会在函数调用完成后删除，会产生未定义的结果）。<br>c++11新标准中函数可以返回花括号包围的值列表，主函数main的返回值，非0的返回值由机器决定。</p><h1 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h1><p>拥有顶层const不影响传入函数的对象。另外，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。<br>不能仅仅通过函数的返回值区分两个同名的函数</p><h2 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h2><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。在不同的作用域中无法重载函数名。<br>在c++中，名字查找发生在类型检查之前。</p><h1 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h1><p>大多数程序都有用的特性：默认实参、内联函数、constexpr函数。</p><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>一旦某个形参赋予了默认值，后面的所有形参必须有默认值。函数调用时，实参按其位置进行解析，只能省略尾部的实参。<br>一个函数被声明多次的时候，在给定的作用域中一个形参只能被赋予一次默认实参，也就是函数的后续声明。</p><h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>将它在每个调用点上“内联的”展开，一般来说用于优化规模较小、流程直接、频繁调用的函数。</p><h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>constexpr函数指能用于常量表达式的函数。函数的返回值及所有形参的类型都得是字面值类型，并且函数体中必须有且只有一条return语句。<br>编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式的指定 为内联函数.<br>内联函数和constexpr函数通常定义在头文件中.</p><h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>assert预处理宏,以一个表达式作为条件.<br>我们可以使用一个#define 语句定义NDEBUG，关闭调试状态</p><h1 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h1><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换得来时。</p><h2 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h2><p>函数匹配第一步：选定本次调用对应的重载函数集。<br>候选函数的两个特征：与被调用的函数同名，其声明在调用点可见。<br>第二步考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数。</p><h2 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h2><p>确定最佳匹配的排序：</p><ul><li>1.精确匹配：实参形参类型相同，实参从数组或函数类型转化为对应的指针类型，实参添加顶层const或者从实参中删除顶层const。</li><li>2.通过const转换实现的匹配。</li><li>3.通过类型提升实现的匹配。</li><li>4.通过算术类型转换或指针转换实现的匹配。</li><li>5.通过类类型转换实现的匹配。</li></ul><h1 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h1><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p><h2 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h2><p>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。</p><h2 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h2><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上是被当成指针使用。<br>可以直接把函数当成实参使用，会自动转换成指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-刷题总结</title>
    <link href="http://yoursite.com/20-interview/re_sword_to_offer/"/>
    <id>http://yoursite.com/20-interview/re_sword_to_offer/</id>
    <published>2018-06-20T13:40:02.000Z</published>
    <updated>2018-06-28T14:33:06.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>重刷剑指offer总结  </p></blockquote><a id="more"></a><h2 id="01-二维数组中的查找"><a href="#01-二维数组中的查找" class="headerlink" title="01.二维数组中的查找"></a>01.二维数组中的查找</h2><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。  </p></blockquote><p>分析：由于每一行都有递增的特性，我们可以采用类似二分搜索的方法。将数组分成行列来进行搜索。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</div><div class="line">        if(0==array.size())</div><div class="line">            return false;</div><div class="line">        int raw=array.size();</div><div class="line">        int col=array[0].size();</div><div class="line">        for(int i=0;i&lt;raw;++i)&#123;</div><div class="line">            if(array[i][col-1]&gt;=target)&#123;</div><div class="line">                for(int j=0;j&lt;col;++j)&#123;</div><div class="line">                    if(array[i][j]==target)</div><div class="line">                        return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="02-替换空格"><a href="#02-替换空格" class="headerlink" title="02.替换空格"></a>02.替换空格</h2><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。  </p></blockquote><p>考虑到是在原字符串上操作，如果遇到一个空格就替换的话，需要把后面的都要后移两位，这个复杂度就大了，所以可以先遍历第一遍，找到空格的总数，之后就可以计算替换后的字符串长度。再经过第二遍遍历，从后往前开始替换，这样就不用移动了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">void replaceSpace(char *str,int length) &#123;</div><div class="line">         if(length&lt;=0)</div><div class="line">             return;</div><div class="line">        int origin_length=0,new_length=0,space_num=0;</div><div class="line">        for(int i=0;str[i]!=&apos;\0&apos;;++i)&#123;</div><div class="line">            origin_length++;</div><div class="line">            if(str[i]==&apos; &apos;)</div><div class="line">                space_num++;</div><div class="line">        &#125;</div><div class="line">        new_length=origin_length+2*space_num;</div><div class="line">        if(new_length&gt;length)</div><div class="line">            return;</div><div class="line">        str[new_length]=&apos;\0&apos;;</div><div class="line">        while(origin_length&gt;0)&#123;</div><div class="line">            --origin_length;</div><div class="line">            if(str[origin_length]==&apos; &apos;)&#123;</div><div class="line">                str[--new_length]=&apos;0&apos;;</div><div class="line">                str[--new_length]=&apos;2&apos;;</div><div class="line">                str[--new_length]=&apos;%&apos;;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                str[--new_length]=str[origin_length];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="03-从尾到头打印链表"><a href="#03-从尾到头打印链表" class="headerlink" title="03.从尾到头打印链表"></a>03.从尾到头打印链表</h2><blockquote><p>输入一个链表，从尾到头打印链表每个节点的值。  </p></blockquote><p>分析：由于链表我们必须从头到尾遍历才能从链表尾开始，所以直接打印的话，需要先从前往后遍历一遍找到链表尾节点，再从后往前遍历打印。能够进行的改善是，通过增加O(N)的空间复杂度，第一次遍历的时候，将数据放在一个栈中，之后再从栈中把所有的数都弹出来就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  struct ListNode &#123;</div><div class="line">*        int val;</div><div class="line">*        struct ListNode *next;</div><div class="line">*        ListNode(int x) :</div><div class="line">*              val(x), next(NULL) &#123;</div><div class="line">*        &#125;</div><div class="line">*  &#125;;</div><div class="line">*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</div><div class="line">        vector&lt;int&gt; res;</div><div class="line">        if(!head)</div><div class="line">            return res;</div><div class="line">        stack&lt;int&gt; istack;</div><div class="line">        while(head)&#123;</div><div class="line">            istack.push(head-&gt;val);</div><div class="line">            head=head-&gt;next;</div><div class="line">        &#125;</div><div class="line">        while(!istack.empty())&#123;</div><div class="line">            res.push_back(istack.top());</div><div class="line">            istack.pop();</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="04-重建二叉树"><a href="#04-重建二叉树" class="headerlink" title="04.重建二叉树"></a>04.重建二叉树</h2><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。  </p></blockquote><p>分析：首先需要知道的是前序遍历和后续遍历的特点，程序中可以维护4个子数组，当进行递归调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for binary tree</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</div><div class="line">        if(pre.empty() || pre.size()!=vin.size())</div><div class="line">            return nullptr;</div><div class="line">        vector&lt;int&gt; pre1,pre2,vin1,vin2;</div><div class="line">        TreeNode* root=new TreeNode(pre[0]);</div><div class="line">        int i=0;</div><div class="line">        for(;i&lt;vin.size();++i)&#123;</div><div class="line">            if(pre[0]==vin[i])</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        //不需要判断i ==0 或者i==vin.size()-1的情况</div><div class="line">        for(int j=0;j&lt;i;++j)&#123;</div><div class="line">            pre1.push_back(pre[1+j]);</div><div class="line">            vin1.push_back(vin[j]);</div><div class="line">        &#125;</div><div class="line">        for(int j=i+1;j&lt;pre.size();++j)&#123;</div><div class="line">            pre2.push_back(pre[j]);</div><div class="line">            vin2.push_back(vin[j]);</div><div class="line">        &#125;</div><div class="line">        root-&gt;left=reConstructBinaryTree(pre1,vin1);</div><div class="line">        root-&gt;right=reConstructBinaryTree(pre2,vin2);</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>不过上述的方法有个问题，虽然看起来比较好理解，但是增加了空间复杂度，其实这里可以多加一个递归函数就好了，所以觉得还是需要重新写一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for binary tree</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    TreeNode* recurse(vector&lt;int&gt;&amp; pre,int begin1,int end1,vector&lt;int &gt;&amp; vin,int begin2,int end2)&#123;</div><div class="line">        if(begin1&gt;end1 || begin2&gt;end2)  //退出条件</div><div class="line">            return nullptr;</div><div class="line">        TreeNode* root=new TreeNode(pre[begin1]);</div><div class="line">        for(int i=begin2;i&lt;=end2;++i)&#123;</div><div class="line">            if(pre[begin1]==vin[i])&#123;</div><div class="line">                root-&gt;left=recurse(pre,begin1+1,begin1+i-begin2,vin,begin2,i-1);  //递归的重点，这个要考虑清楚</div><div class="line">                root-&gt;right=recurse(pre,begin1+1+i-begin2,end1,vin,1+i,end2);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</div><div class="line">        if(pre.empty() || pre.size()!=vin.size())</div><div class="line">            return nullptr;</div><div class="line">        return recurse(pre,0,pre.size()-1,vin,0,vin.size()-1);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="05-用两个栈实现队列"><a href="#05-用两个栈实现队列" class="headerlink" title="05.用两个栈实现队列"></a>05.用两个栈实现队列</h2><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。  </p></blockquote><p>分析：由于栈是先进后出，队列是先进先出，于是可以想到，两个栈，必然能够实现一个队列。原理就是，当push的时候就往第一个栈push，pop的时候就从第二个栈pop，当第二个栈的数为空时，从第一个栈pop再push到第二个栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int pop() &#123;</div><div class="line">        if(stack2.empty())&#123;</div><div class="line">            while(!stack1.empty())&#123;</div><div class="line">                stack2.push(stack1.top());</div><div class="line">                stack1.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int top=stack2.top();</div><div class="line">        stack2.pop();</div><div class="line">        return top;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    stack&lt;int&gt; stack1;</div><div class="line">    stack&lt;int&gt; stack2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="06-旋转数组的最小数字"><a href="#06-旋转数组的最小数字" class="headerlink" title="06.旋转数组的最小数字"></a>06.旋转数组的最小数字</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。  </p></blockquote><p>分析：对于排序的数组，即使被旋转过，也能想到的是，采用二分查找。不过可能会存在的问题的是：当整个数组的值都是<code>1 0 0 1 1</code>之类的时候，就会失效了，只是非递减，但是不一定递增。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</div><div class="line">        if(0==rotateArray.size())&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        int begin=0,end=rotateArray.size()-1;</div><div class="line">        while(begin&lt;end-1)&#123;</div><div class="line">            int mid=begin+(end-begin)/2;</div><div class="line">            if(rotateArray[begin]&lt;rotateArray[mid])</div><div class="line">                begin=mid;</div><div class="line">            else if(rotateArray[begin]&gt;rotateArray[mid])</div><div class="line">                end=mid;</div><div class="line">            else&#123;</div><div class="line">                int res=begin;</div><div class="line">                for(size_t i=1;i&lt;rotateArray.size();++i)&#123;</div><div class="line">                    res=(res&lt;rotateArray[i]?res:rotateArray[i]);</div><div class="line">                &#125;</div><div class="line">                return res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return rotateArray[end];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="07-斐波那契数列"><a href="#07-斐波那契数列" class="headerlink" title="07.斐波那契数列"></a>07.斐波那契数列</h2><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39    </p></blockquote><p>分析：斐波拉契数列原理很简单，不过按照原理写的显然复杂度过高了，这里我们可以采用变量存下之前计算过的数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Fibonacci(int n) &#123;</div><div class="line">        if(n==0)</div><div class="line">            return 0;</div><div class="line">        if(n==1||n==2)</div><div class="line">            return 1;</div><div class="line">        int first=1,second=1,res=0;</div><div class="line">        while(--n&gt;1)&#123;</div><div class="line">            res=first+second;</div><div class="line">            first=second;</div><div class="line">            second=res;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="08-跳台阶"><a href="#08-跳台阶" class="headerlink" title="08.跳台阶"></a>08.跳台阶</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。  </p></blockquote><p>分析：原理同斐波拉契数列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int jumpFloor(int number) &#123;</div><div class="line">        if(number&lt;=2)</div><div class="line">            return number;</div><div class="line">        int first=1,second=2,res=0;</div><div class="line">        while(--number&gt;1)&#123;</div><div class="line">            res=first+second;</div><div class="line">            first=second;</div><div class="line">            second=res;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="09-变态跳台阶"><a href="#09-变态跳台阶" class="headerlink" title="09.变态跳台阶"></a>09.变态跳台阶</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。  </p></blockquote><p>分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">f(n)=f(1)+f(2)+...+f(n-1)</div><div class="line">f(n+1)=f(1)+f(2)+...+f(n-1)+f(n)=2f(n)</div><div class="line">//代码如下：</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int jumpFloorII(int number) &#123;</div><div class="line">        if(number&lt;=2)</div><div class="line">            return number;</div><div class="line">        int res=2;</div><div class="line">        while(--number&gt;=2)&#123;</div><div class="line">            res*=2;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="10-矩形覆盖-TODO"><a href="#10-矩形覆盖-TODO" class="headerlink" title="10.矩形覆盖 /TODO:"></a>10.矩形覆盖 /TODO:</h2><h2 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11.二进制中1的个数"></a>11.二进制中1的个数</h2><blockquote><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。  </p></blockquote><p>分析：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">     int  NumberOf1(int n) &#123;</div><div class="line">         int count=0;</div><div class="line">         while(n)&#123;</div><div class="line">             count++;</div><div class="line">             n=n&amp;(n-1);</div><div class="line">         &#125;</div><div class="line">         return count;</div><div class="line">     &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h2><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。  </p></blockquote><p>分析：求一个数的次方，一个就是幂数是负数的处理，另一个就是，对幂的处理，连乘必然带来复杂度，可以想到的是2^4可以表示为(2^2)^2，想到这里，考虑的开水奇偶exponent的奇偶性了，奇数的时候直接乘以base，偶数的时候自乘。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    double Power(double base, int exponent) &#123;</div><div class="line">        bool flag=true;</div><div class="line">        if(exponent&lt;0)&#123;</div><div class="line">            flag=false;</div><div class="line">            exponent*=-1;</div><div class="line">        &#125;</div><div class="line">        double res=1;</div><div class="line">        while(exponent)&#123;</div><div class="line">            if(exponent&amp;1)&#123;</div><div class="line">                res*=base;</div><div class="line">                exponent--;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                exponent=exponent/2;</div><div class="line">                res*=res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return flag?res:(1/res);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h2><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</div><div class="line">if(array.empty())</div><div class="line">return;</div><div class="line">int begin=0,end=array.size();</div><div class="line">int even=-1;</div><div class="line"></div><div class="line">while(begin&lt;end)&#123;</div><div class="line">while((array[begin]&amp;1) &amp;&amp; (begin&lt;end))&#123;</div><div class="line">begin++;</div><div class="line">&#125;</div><div class="line">even=begin;</div><div class="line">while((!(array[begin]&amp;1)))&#123;</div><div class="line">begin++;</div><div class="line">&#125;</div><div class="line">if(begin&gt;=end)</div><div class="line">return;</div><div class="line">int temp=array[begin];</div><div class="line">while(even&lt;begin)&#123;</div><div class="line">array[begin]=array[begin-1];</div><div class="line">begin--;</div><div class="line">&#125;</div><div class="line">array[even]=temp;</div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="14-链表中倒数第k个结点"><a href="#14-链表中倒数第k个结点" class="headerlink" title="14.链表中倒数第k个结点"></a>14.链表中倒数第k个结点</h2><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。  </p></blockquote><p>分析：采用两个指针一起移动是一个很好的办法，不过需要考虑是否越界。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct ListNode &#123;</div><div class="line">int val;</div><div class="line">struct ListNode *next;</div><div class="line">ListNode(int x) :</div><div class="line">val(x), next(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</div><div class="line">        ListNode* p1=pListHead;</div><div class="line">        for(int i=0;i&lt;k;++i)&#123;</div><div class="line">            if(!p1)</div><div class="line">               return nullptr;</div><div class="line">            p1=p1-&gt;next;</div><div class="line">        &#125;</div><div class="line">        while(p1)&#123;</div><div class="line">            p1=p1-&gt;next;</div><div class="line">            pListHead=pListHead-&gt;next;</div><div class="line">        &#125;</div><div class="line">        return pListHead;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h2><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。   </p></blockquote><p>分析：注意断开链表重连的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct ListNode &#123;</div><div class="line">int val;</div><div class="line">struct ListNode *next;</div><div class="line">ListNode(int x) :</div><div class="line">val(x), next(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">//最开始的一版代码，采用的是栈，看起来比较复杂。</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</div><div class="line">        if((!pHead)||(!pHead-&gt;next))</div><div class="line">            return pHead;</div><div class="line">        stack&lt;ListNode*&gt; list_stack;</div><div class="line">        while(pHead-&gt;next)&#123;</div><div class="line">            list_stack.push(pHead);</div><div class="line">            pHead=pHead-&gt;next;</div><div class="line">        &#125;</div><div class="line">        ListNode *newHead=pHead;</div><div class="line">        while(!list_stack.empty())&#123;</div><div class="line">            pHead-&gt;next=list_stack.top();</div><div class="line">            pHead=pHead-&gt;next;</div><div class="line">            list_stack.pop();</div><div class="line">        &#125;</div><div class="line">        pHead-&gt;next=nullptr;</div><div class="line">        return newHead;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//采用在链表中的穿针引线。涉及到链表的断开与重连，维护三个指针，分别为：pre,cur,next</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</div><div class="line">        ListNode* pre=nullptr;</div><div class="line">        ListNode* cur=pHead;</div><div class="line">        while(cur)&#123;</div><div class="line">            ListNode* next=cur-&gt;next;</div><div class="line">            cur-&gt;next=pre;</div><div class="line">            pre=cur;</div><div class="line">            cur=next;</div><div class="line">        &#125;</div><div class="line">        return pre;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//采用递归实现</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</div><div class="line">        if(!pHead||!pHead-&gt;next)</div><div class="line">            return pHead;</div><div class="line">        ListNode* rHead=ReverseList(pHead-&gt;next);</div><div class="line">        // head-&gt;next此刻指向head后面的链表的尾节点</div><div class="line">        // head-&gt;next-&gt;next = head把head节点放在了尾部</div><div class="line">        pHead-&gt;next-&gt;next=pHead;</div><div class="line">        pHead-&gt;next=nullptr;</div><div class="line">        </div><div class="line">        return rHead;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h2><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct ListNode &#123;</div><div class="line">int val;</div><div class="line">struct ListNode *next;</div><div class="line">ListNode(int x) :</div><div class="line">val(x), next(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</div><div class="line">    &#123;</div><div class="line">        //当一个链表为空时，直接返回另一个链表</div><div class="line">        if(!pHead1)</div><div class="line">            return pHead2;</div><div class="line">        if(!pHead2)</div><div class="line">            return pHead1;</div><div class="line">        ListNode* vHead=new ListNode(0);  //设立虚拟的头节点</div><div class="line">        ListNode* vHeadHead=vHead;</div><div class="line">        while(pHead1 &amp;&amp; pHead2)&#123;  //一旦有一个链表为空，就退出循环</div><div class="line">            if(pHead1-&gt;val&lt;=pHead2-&gt;val)&#123;</div><div class="line">                vHead-&gt;next=pHead1;</div><div class="line">                pHead1=pHead1-&gt;next;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                vHead-&gt;next=pHead2;</div><div class="line">                pHead2=pHead2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            vHead=vHead-&gt;next;</div><div class="line">        &#125;</div><div class="line">        //另一个链表不为空时，加在后面</div><div class="line">        if(!pHead1)</div><div class="line">            vHead-&gt;next=pHead2;</div><div class="line">        else</div><div class="line">            vHead-&gt;next=pHead1;</div><div class="line">        return vHeadHead-&gt;next;  //返回虚拟头节点的下一个节点</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//采用递归实现</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</div><div class="line">    &#123;</div><div class="line">        if(!pHead1)</div><div class="line">            return pHead2;</div><div class="line">        if(!pHead2)</div><div class="line">            return pHead1;</div><div class="line">        ListNode* vHead=nullptr;</div><div class="line">        if(pHead1-&gt;val&lt;=pHead2-&gt;val)&#123;</div><div class="line">            vHead=pHead1;</div><div class="line">            vHead-&gt;next=Merge(pHead1-&gt;next,pHead2);</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            vHead=pHead2;</div><div class="line">            vHead-&gt;next=Merge(pHead1,pHead2-&gt;next);</div><div class="line">        &#125;</div><div class="line">        return vHead;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h2><blockquote><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool dfs(TreeNode* pRoot1,TreeNode* pRoot2)&#123;</div><div class="line">        if(!pRoot2)    //注意不能先判断pRoot1再判断pRoot2，因为，只要pRoot2为空的时候，都是true了，而不管这时候pRoot1是不是为空。</div><div class="line">            return true;</div><div class="line">        if(!pRoot1)</div><div class="line">            return false;</div><div class="line">        if(pRoot1-&gt;val!=pRoot2-&gt;val)</div><div class="line">            return false;</div><div class="line">        return dfs(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;dfs(pRoot1-&gt;right,pRoot2-&gt;right);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</div><div class="line">    &#123;</div><div class="line">        if((!pRoot2)||(!pRoot1))</div><div class="line">            return false;</div><div class="line">        return (dfs(pRoot1,pRoot2)||HasSubtree(pRoot1-&gt;left,pRoot2)||HasSubtree(pRoot1-&gt;right,pRoot2));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h2><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。   </p></blockquote><p>分析：简单的递归解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct TreeNode &#123;</div><div class="line">int val;</div><div class="line">struct TreeNode *left;</div><div class="line">struct TreeNode *right;</div><div class="line">TreeNode(int x) :</div><div class="line">val(x), left(NULL), right(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void Mirror(TreeNode *pRoot) &#123;</div><div class="line">        if(pRoot==nullptr)</div><div class="line">            return;</div><div class="line">        Mirror(pRoot-&gt;left);</div><div class="line">        Mirror(pRoot-&gt;right);</div><div class="line">        swap(pRoot-&gt;left,pRoot-&gt;right);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h2><h2 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h2><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。   </p></blockquote><p>分析：维护两个栈，其中一个是压入数据的栈，另一个是min栈，存储当前数据的最小的值。只有压入的数小于min栈的时候，才压入新值，否则继续压入最小值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void push(int value) &#123;</div><div class="line">        stk.push(value);</div><div class="line">        if(!stk_min.empty())&#123;</div><div class="line">            if(value&lt;stk_min.top())</div><div class="line">                stk_min.push(value);</div><div class="line">            else&#123;</div><div class="line">                int temp=stk_min.top();</div><div class="line">                stk_min.push(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            stk_min.push(value);</div><div class="line">    &#125;</div><div class="line">    void pop() &#123;</div><div class="line">        stk_min.pop();</div><div class="line">        stk.pop();</div><div class="line">    &#125;</div><div class="line">    int top() &#123;</div><div class="line">        return stk.top();</div><div class="line">    &#125;</div><div class="line">    int min() &#123;</div><div class="line">        return stk_min.top();</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    stack&lt;int&gt; stk;</div><div class="line">    stack&lt;int&gt; stk_min;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h2><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）  </p></blockquote><p>思路：判断是否是压入弹出序列，可以直接使用一个栈进行压入，然后在压入的过程中判断是否跟弹出序列的值相同，是的话则先弹出，最后判断栈是否为空即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</div><div class="line">        stack&lt;int&gt; istack;</div><div class="line">        int i=0,j=0;</div><div class="line">        while(i&lt;pushV.size())&#123;</div><div class="line">        istack.push(pushV[i++]);</div><div class="line">        while(j&lt;popV.size() &amp;&amp; istack.top()==popV[j])&#123;</div><div class="line">        istack.pop();</div><div class="line">        ++j;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return istack.empty();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h2><blockquote><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。  </p></blockquote><p>分析：层序遍历，需要每遍历一个节点，就将他们的左右节点保存起来，当前层遍历完后，再顺序遍历他们的孩子节点。于是很容易想到先入先出的结构，队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct TreeNode &#123;</div><div class="line">int val;</div><div class="line">struct TreeNode *left;</div><div class="line">struct TreeNode *right;</div><div class="line">TreeNode(int x) :</div><div class="line">val(x), left(NULL), right(NULL) &#123;</div><div class="line">&#125;</div><div class="line">&#125;;*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</div><div class="line">        vector&lt;int&gt; res;</div><div class="line">        if(root==nullptr)</div><div class="line">            return res;</div><div class="line">        queue&lt;TreeNode*&gt; ique;</div><div class="line">        ique.push(root);</div><div class="line">        while(!ique.empty())&#123;</div><div class="line">            TreeNode* temp=ique.front();</div><div class="line">            res.push_back(temp-&gt;val);</div><div class="line">            ique.pop();</div><div class="line">            </div><div class="line">            if(temp-&gt;left)</div><div class="line">                ique.push(temp-&gt;left);</div><div class="line">            if(temp-&gt;right)</div><div class="line">                ique.push(temp-&gt;right);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h2><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</div><div class="line">return Verify(sequence,0,sequence.size());</div><div class="line">    &#125;</div><div class="line">    bool Verify(vector&lt;int&gt; sequence,int start,int end)&#123;</div><div class="line">        int i=start;</div><div class="line">        if(start==end)</div><div class="line">            return false;</div><div class="line">for(;i&lt;end-1;++i)&#123;</div><div class="line">if(sequence[i]&gt;sequence[end-1])&#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">&#125;</div><div class="line">        for(int j=i;j!=end;++j)&#123;</div><div class="line">            if(sequence[j]&lt;sequence[end-1])&#123;</div><div class="line">                 return false;</div><div class="line">                &#125;</div><div class="line">             &#125;</div><div class="line">        bool left=true;</div><div class="line">        if(i&gt;start)</div><div class="line">            left=Verify(sequence,start,i);</div><div class="line">        </div><div class="line">        bool right=true;</div><div class="line">        if(i&lt;end-1)</div><div class="line">            right=Verify(sequence,i,end-1);</div><div class="line">        return left&amp;&amp;right;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h2><blockquote><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">    vector&lt;int&gt; temp;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</div><div class="line">        if(!root)</div><div class="line">            return res;</div><div class="line">        temp.push_back(root-&gt;val);</div><div class="line">        if(expectNumber-root-&gt;val==0 &amp;&amp; root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)</div><div class="line">            res.push_back(temp);</div><div class="line">        FindPath(root-&gt;left,expectNumber-root-&gt;val);</div><div class="line">        FindPath(root-&gt;right,expectNumber-root-&gt;val);</div><div class="line">        if(!temp.empty())</div><div class="line">            temp.pop_back();</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h2><p>代码问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">        while(pHead-&gt;next)&#123;</div><div class="line">//        cout&lt;&lt;pHead-&gt;label&lt;&lt;endl;</div><div class="line">//            RandomListNode* pTemp=pHead;   //傻了吧</div><div class="line">            RandomListNode* pTemp=new RandomListNode(pHead-&gt;label);  </div><div class="line">            pTemp-&gt;next=pHead-&gt;next;</div><div class="line">            cout&lt;&lt;pTemp-&gt;next-&gt;label&lt;&lt;endl;</div><div class="line">            pHead-&gt;next=pTemp;</div><div class="line">            pHead=pTemp-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">                //拆分</div><div class="line">        pNode=pHead;</div><div class="line">RandomListNode* newHead=pHead-&gt;next;</div><div class="line">        RandomListNode* pTemp=pNode-&gt;next;</div><div class="line">while(pNode)&#123;</div><div class="line">pNode-&gt;next=pTemp-&gt;next;</div><div class="line">pNode=pNode-&gt;next;</div><div class="line">pTemp-&gt;next=pNode?pNode-&gt;next:NULL;</div><div class="line">//pTemp-&gt;next=pNode-&gt;next;</div><div class="line">//cout&lt;&lt;&quot;pTemp: &quot;&lt;&lt;pTemp-&gt;label&lt;&lt;endl;</div><div class="line">pTemp=pTemp-&gt;next;</div><div class="line">//cout&lt;&lt;&quot;text&quot;&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    RandomListNode* Clone(RandomListNode* pHead)</div><div class="line">    &#123;</div><div class="line">    if(!pHead)</div><div class="line">    return pHead;</div><div class="line">    RandomListNode* pNode=pHead;</div><div class="line"></div><div class="line">    while(pNode)&#123;</div><div class="line">    RandomListNode* pClone=new RandomListNode(pNode-&gt;label);</div><div class="line">    pClone-&gt;next=pNode-&gt;next;</div><div class="line">    pNode-&gt;next=pClone;</div><div class="line">    pNode=pClone-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">pNode=pHead;</div><div class="line">while(pNode)&#123;</div><div class="line">RandomListNode* pClone=pNode-&gt;next;</div><div class="line">if(pNode-&gt;random)</div><div class="line">pClone-&gt;random=pNode-&gt;random-&gt;next;</div><div class="line">pNode=pClone-&gt;next;</div><div class="line">&#125;</div><div class="line">pNode=pHead;</div><div class="line">RandomListNode* newHead=pNode-&gt;next;</div><div class="line"></div><div class="line"></div><div class="line">while(pNode-&gt;next)&#123;</div><div class="line">RandomListNode* pTemp=pNode-&gt;next;</div><div class="line">pNode-&gt;next=pTemp-&gt;next;</div><div class="line">pNode=pTemp;</div><div class="line">//pNode=pNode-&gt;next;                  //这种不行，搞得我折腾了很久</div><div class="line">//pTemp-&gt;next=pNode-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return newHead;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h2><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br>TODO:</p></blockquote><h2 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27.字符串的排列"></a>27.字符串的排列</h2><h2 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28.数组中出现次数超过一半的数字"></a>28.数组中出现次数超过一半的数字</h2><p>解决一个问题，最终输出的判断，是1，还是0。如果大于1的话，万一最后只剩下了一个呢。所以还需要再判断最后剩下的结果是不是符合条件的，即是大于一般数目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</div><div class="line">        if(numbers.empty())</div><div class="line">            return 0;</div><div class="line">        int count=1;</div><div class="line">        int num=numbers[0];</div><div class="line">        for(int i=1;i&lt;numbers.size();++i)&#123;</div><div class="line">            if(numbers[i]==num)</div><div class="line">                count++;</div><div class="line">            else&#123;</div><div class="line">                if((--count)&lt;=0)&#123;</div><div class="line">                    num=numbers[i];</div><div class="line">                    count=1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //判断结果是否符合条件</div><div class="line">        count=0;</div><div class="line">        for(int i=0;i&lt;numbers.size();++i)&#123;</div><div class="line">            if(num==numbers[i])&#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return count*2&gt;numbers.size()?num:0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h2><p>存在的问题，写程序的时候越界，没有判断好边界条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</div><div class="line">        vector&lt;int&gt; min_stack;</div><div class="line">        if(input.empty()||(k&lt;=0)||(k&gt;input.size()))  //边界条件的判断</div><div class="line">            return min_stack;</div><div class="line">        for(int i=0;i&lt;input.size();++i)&#123;</div><div class="line">            sort(min_stack.begin(),min_stack.end());</div><div class="line">            if(min_stack.size()&lt;k)&#123;</div><div class="line">                min_stack.push_back(input[i]);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">            //cout&lt;&lt;&quot;min_stack[min_stack.size()-1]: &quot;&lt;&lt;min_stack[min_stack.size()-1]&lt;&lt;endl;</div><div class="line">                if(input[i]&lt;min_stack[min_stack.size()-1])&#123;</div><div class="line">                    min_stack.pop_back();</div><div class="line">                    min_stack.push_back(input[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return min_stack;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a>30.连续子数组的最大和</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</div><div class="line">    int  res=array[0];</div><div class="line">    int cur=array[0];</div><div class="line">    for(int i=1;i&lt;array.size();++i)&#123;</div><div class="line">    cur+=array[i];</div><div class="line">    if(cur&lt;array[i])</div><div class="line">    cur=array[i];</div><div class="line">    res=(res&gt;cur?res:cur);</div><div class="line">&#125;</div><div class="line">return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="31-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#31-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="31.整数中1出现的次数（从1到n整数中1出现的次数）"></a>31.整数中1出现的次数（从1到n整数中1出现的次数）</h2><blockquote><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。  </p></blockquote><p>分析：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析。<br>当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)<em>100个点的百位为1<br>当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10</em>100）+(b+1)，这些点百位对应为1<br>当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）<br>综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1<br>之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int NumberOf1Between1AndN_Solution(int n)</div><div class="line">    &#123;</div><div class="line">    int count=0;</div><div class="line">        //n=1的情况</div><div class="line">        if(n==1)</div><div class="line">            return 1;</div><div class="line">        //考虑的边界情况，n=10,100,1000之类的，同时循环中没有考虑n=0的情况</div><div class="line">        if(n&gt;1&amp;&amp;n%10==0)</div><div class="line">            count++;</div><div class="line">        //没有考虑n=1的情况</div><div class="line">        for(int i=1;i&lt;n;i*=10)&#123;</div><div class="line">            int a=n/i,b=n%i;</div><div class="line">            count+=(a+8)/10*i+(a%10==1)*(b+1);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32.把数组排成最小的数"></a>32.把数组排成最小的数</h2><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    static bool equal(int a,int b)&#123;</div><div class="line">        string str1=to_string(a)+to_string(b);</div><div class="line">        string str2=to_string(b)+to_string(a);</div><div class="line">        return str1&lt;str2;</div><div class="line">    &#125;</div><div class="line">    string PrintMinNumber(vector&lt;int&gt; numbers)</div><div class="line">    &#123;</div><div class="line">        string result;</div><div class="line">        sort(numbers.begin(),numbers.end(),equal);</div><div class="line">        for(int i=0;i&lt;numbers.size();++i)&#123;</div><div class="line">            result+=to_string(numbers[i]);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h2><blockquote><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int GetUglyNumber_Solution(int index) &#123;</div><div class="line">        if(index&lt;=0)        </div><div class="line">            return 0;</div><div class="line">        vector&lt;int &gt; res(index);</div><div class="line">        res[0]=1;</div><div class="line">        int x=0,y=0,z=0;</div><div class="line">        for(int i=1;i&lt;index;++i)&#123;</div><div class="line">            res[i]=min(2*res[x],min(3*res[y],5*res[z]));</div><div class="line">            if(res[i]==2*res[x])</div><div class="line">                x++;</div><div class="line">            if(res[i]==3*res[y])</div><div class="line">                y++;</div><div class="line">            if(res[i]==5*res[z])</div><div class="line">                z++;</div><div class="line">        &#125;</div><div class="line">        return res[index-1];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="34-第一个只出现一次的字符位置"><a href="#34-第一个只出现一次的字符位置" class="headerlink" title="34.第一个只出现一次的字符位置"></a>34.第一个只出现一次的字符位置</h2><blockquote><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置  </p></blockquote><p>一般对于这种字符的处理，因为字符一般都是不超过256的，所以尤其是计数之类的，我们可以首先考虑数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    int FirstNotRepeatingChar(string str)</div><div class="line">    &#123;</div><div class="line">        if(str.size()&lt;=0)</div><div class="line">            return -1;</div><div class="line">        int array[256]=&#123;0&#125;;</div><div class="line">        for(int i=0;i&lt;str.size();++i)&#123;</div><div class="line">            array[int(str[i])]++;</div><div class="line">        &#125;</div><div class="line">        for(int i=0;i&lt;str.size();++i)&#123;</div><div class="line">            if(array[int(str[i])]==1)</div><div class="line">                return i;</div><div class="line">        &#125;</div><div class="line">        return str.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35.数组中的逆序对"></a>35.数组中的逆序对</h2><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007  </p></blockquote><h2 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36.两个链表的第一个公共结点"></a>36.两个链表的第一个公共结点</h2><blockquote><p>输入两个链表，找出它们的第一个公共结点。  </p></blockquote><p>需要知道的一个常识是，对于只有一个单链表，两个链表有公共节点，意味着从公共节点开始，之后两个链表都是公共的，因此他们有共同的终点。有了这个就好办了。可以将两个链表一直遍历，当遍历到链表尾的时候，就换另一个链表，当他们有公共节点时，在他们遍历到同一个节点时停止遍历，此节点即为第一个公共节点。   </p><p><strong>对于这种将两个不同的长度，通过两个结合在一起，使两个长度相等的方法，其实我们用到过很多次。例如本题中的找公共节点，原因是两个链表长度不同。还有之前的一个判断两个string的大小，可以把他们放在一起，这样他们的长度就相同了，可以直接用string的方法进行比较。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</div><div class="line">        ListNode* p1=pHead1;</div><div class="line">        ListNode* p2=pHead2;</div><div class="line">        while(p1!=p2)&#123;</div><div class="line">            p1=(p1==nullptr?pHead2:p1-&gt;next);</div><div class="line">            p2=(p2==nullptr?pHead1:p2-&gt;next);</div><div class="line">        &#125;</div><div class="line">        return p1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h2><blockquote><p>统计一个数字在排序数组中出现的次数。  </p></blockquote><p>显然很容易想到的是二分法,没有用函数的话，就存在一个找到没找到的问题，在这采用了一个返回值的处理。如果没找到，(end-begin-1)<0，则可以判断是没有找到。 <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</div><div class="line">        if(data.empty())</div><div class="line">            return 0;</div><div class="line">        int begin=0,end=data.size()-1;</div><div class="line">        int count=0;</div><div class="line">        int mid;</div><div class="line">        while(begin&lt;=end)&#123;</div><div class="line">        mid=(begin+end)/2;</div><div class="line">//        cout&lt;&lt;&quot;dsdasads&quot;&lt;&lt;endl;</div><div class="line">if(data[mid]==k)</div><div class="line">break;</div><div class="line">            else if(data[mid]&lt;k)&#123;</div><div class="line">                begin=mid+1;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            else if(data[mid]&gt;k)&#123;</div><div class="line">                end=mid-1;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        begin=end=mid;</div><div class="line">        while(data[begin]==k)</div><div class="line">            --begin;</div><div class="line">        while(data[end]==k)</div><div class="line">            ++end;</div><div class="line">        count=(end-begin-1)&gt;0?(end-begin-1):0;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></0，则可以判断是没有找到。></p><h2 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h2><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int TreeDepth(TreeNode* pRoot)</div><div class="line">    &#123;</div><div class="line">        if(!pRoot)</div><div class="line">            return 0;</div><div class="line">        return max(1+TreeDepth(pRoot-&gt;left),1+TreeDepth(pRoot-&gt;right));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39.平衡二叉树"></a>39.平衡二叉树</h2><blockquote><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。  </p></blockquote><h2 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h2><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。  </p></blockquote><p>数组中只出现一次的数字，当有一个的时候，很容易利用的特性是：全部异或，最后剩下的那个就是。原因是一个数跟自身异或，结果为0.那么出现有两个的时候呢。很容易想到的还是异或，最后的结果是两个只出现一次数字异或的结果，再进行分组解决。分组的依据是：因为有两个不同的数字只出现一次，所以整个数组异或的结果必然不为0，不为0就肯定有一位为1.按该位是否为1来进行划分即可。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</div><div class="line">        if(data.empty())</div><div class="line">            return;</div><div class="line">        //第一次遍历一遍，求两个数字最后的异或</div><div class="line">        int res=data[0];</div><div class="line">        for(int i=1;i&lt;data.size();++i)&#123;</div><div class="line">            res=res^data[i];</div><div class="line">        &#125;</div><div class="line">        if(res==0)</div><div class="line">            return;</div><div class="line">        //由于存在两个只出现一次的数字，所以res的值为这两个数字的异或，因此肯定不为0，肯定不为0意味着肯定有一位是1.找出这一位是1的</div><div class="line">        int index=0;</div><div class="line">        while((res&amp;1)==0)&#123;</div><div class="line">            res=res&gt;&gt;1;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        *num1=*num2=0;        </div><div class="line">        //根据index位为不为1，将数组分为两部分。</div><div class="line">        int x;</div><div class="line">        for(int i=0;i&lt;data.size();++i)&#123;</div><div class="line">            if((x=data[i]&gt;&gt;index)&amp;1)</div><div class="line">                *num1^=data[i];</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                *num2^=data[i];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="41-和为S的连续正数序列"><a href="#41-和为S的连续正数序列" class="headerlink" title="41.和为S的连续正数序列"></a>41.和为S的连续正数序列</h2><blockquote><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">        vector&lt;int&gt; temp;</div><div class="line">        //边界条件的判断</div><div class="line">        if(sum&lt;0)</div><div class="line">            return res;</div><div class="line">            </div><div class="line">        int end=0;</div><div class="line">        int tempSum=0;</div><div class="line">        //遍历数组</div><div class="line">        while(end&lt;sum)&#123;</div><div class="line">            if(tempSum==sum)&#123;</div><div class="line">                res.push_back(temp);</div><div class="line">                end=temp[0];  //这一句其实很重要,因为要考虑将end从最开始重新开始计算，不然可能会有所遗漏,eg:9=2+3+4=4+5，其中4会重复</div><div class="line">                temp.erase(temp.begin(),temp.end());</div><div class="line">                tempSum=0;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            if(tempSum&gt;sum)&#123;</div><div class="line">                tempSum-=temp[0];</div><div class="line">                temp.erase(temp.begin());</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            temp.push_back(++end);</div><div class="line">            tempSum+=end;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="42-和为S的两个数字"><a href="#42-和为S的两个数字" class="headerlink" title="42.和为S的两个数字"></a>42.和为S的两个数字</h2><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。  </p></blockquote><p>输出乘积最小的，显然距离最大的乘积就越小，所以，可以直接前后两个指针搜索，搜到的第一个就是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum)</div><div class="line">    &#123;</div><div class="line">        vector&lt;int &gt; res;</div><div class="line">        if(array.empty())</div><div class="line">            return res;</div><div class="line">            </div><div class="line">        int i=0,j=array.size()-1;</div><div class="line">        while(i&lt;j)&#123;</div><div class="line">            int temp=array[i]+array[j];</div><div class="line">            if(temp&gt;sum)</div><div class="line">                --j;</div><div class="line">            if(temp&lt;sum)</div><div class="line">                ++i;</div><div class="line">            </div><div class="line">            if(temp==sum) </div><div class="line">            &#123;</div><div class="line">                res.push_back(array[i]);</div><div class="line">                res.push_back(array[j]);</div><div class="line">                return res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h2><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！  </p></blockquote><p>由BA=(ATBT)T计算可得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//第一次通过代码</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    string LeftRotateString(string str, int n) &#123;</div><div class="line">        int len=str.size();</div><div class="line">        if(n&gt;=len)</div><div class="line">            return str;</div><div class="line">        int i=0,j=0;</div><div class="line">        for(i=0,j=n-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</div><div class="line">        for(i=n,j=len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</div><div class="line">        for(i=0,j=len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</div><div class="line">        return str;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44.翻转单词顺序列"></a>44.翻转单词顺序列</h2><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">//以前买的</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void ReverseSentence(string &amp;str,int begin,int end)&#123;</div><div class="line">        while(begin&lt;end)&#123;</div><div class="line">            char tmp=str[begin];</div><div class="line">            str[begin]=str[end];</div><div class="line">            str[end]=tmp;</div><div class="line">            begin++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    string ReverseSentence(string str) &#123;</div><div class="line">        if(str.size()&lt;=1)</div><div class="line">            return str;</div><div class="line">        int begin=0;</div><div class="line">        int end=0;</div><div class="line">        //这里需要注意，考虑只有一个单词的情况</div><div class="line">        while(end!=str.size())&#123;</div><div class="line">            if(str[end]==&apos; &apos;)&#123;</div><div class="line">                ReverseSentence(str,0,str.size()-1);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else if(end==str.size()-1)</div><div class="line">            return str;</div><div class="line">            else</div><div class="line">                ++end;</div><div class="line">        &#125;</div><div class="line">        end=0;</div><div class="line">        //开始遍历，旋转每个单词</div><div class="line">        while(begin!=str.size())&#123;</div><div class="line">            if(str[begin]==&apos; &apos;)&#123;</div><div class="line">                ++end;</div><div class="line">                ++begin;</div><div class="line">            &#125;</div><div class="line">            else if(str[end]==&apos; &apos;||end==str.size())&#123;</div><div class="line">                ReverseSentence(str,begin,--end);</div><div class="line">                begin=++end;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                ++end;</div><div class="line">        &#125;</div><div class="line">        return str;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h2><blockquote><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    bool IsContinuous(vector&lt;int&gt; numbers)</div><div class="line">    &#123;</div><div class="line">        if (numbers.empty())</div><div class="line">            return false;</div><div class="line">        sort(numbers.begin(), numbers.end());</div><div class="line">        int sum = 0, zero_num = 0;</div><div class="line">        for (int i = 0; i &lt; numbers.size() - 1; ++i)</div><div class="line">        &#123;</div><div class="line">            if (numbers[i] == 0)</div><div class="line">            &#123;</div><div class="line">                zero_num++;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            //考虑数字重复的情况</div><div class="line">            if (numbers[i + 1] == numbers[i])</div><div class="line">                return false;</div><div class="line">            sum += numbers[i + 1] - numbers[i] - 1;</div><div class="line">        &#125;</div><div class="line">        return sum &lt;= zero_num; //注意这里要大于等于就可以，不一定等于</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="46-孩子们的游戏-圆圈中最后剩下的数"><a href="#46-孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="46.孩子们的游戏(圆圈中最后剩下的数)"></a>46.孩子们的游戏(圆圈中最后剩下的数)</h2><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)   </p></blockquote><p>此约瑟夫环的问题。<a href="https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365" target="_blank" rel="external">https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int LastRemaining_Solution(int n, int m)</div><div class="line">    &#123;</div><div class="line">        if(n&lt;=0)</div><div class="line">            return -1;</div><div class="line">        int last=0;</div><div class="line">        for(int i=2;i&lt;=n;++i)&#123;</div><div class="line">            last=(last+m)%i;</div><div class="line">        &#125;</div><div class="line">        return last;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="47-求1-2-3-…-n"><a href="#47-求1-2-3-…-n" class="headerlink" title="47.求1+2+3+…+n"></a>47.求1+2+3+…+n</h2><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。  </p></blockquote><p>这个题，可以有好几种解决办法，一个容易想到的就是递归，每次都跟自己相加，直到加到0为止，判断的条件可以采用<code>&amp;&amp;</code>的短路特性：通过&amp;&amp;判断值是否为0已经到达结尾了。<br>另一种办法，可以利用类的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Sum_Solution(int n) &#123;</div><div class="line">        int sum=n;</div><div class="line">        sum&amp;&amp;(sum+=Sum_Solution(n-1));</div><div class="line">        return sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h2><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。  </p></blockquote><p>不能用加法做加法运算，可以想到的计算机中利用的二进制的加法。通过异或两个数，也就是模2加，得到的是不考虑进位的加法的结果。通过两个数异或，左移一位得到的是进位。无进位结果加上进位，一直循环知道进位为0的时候，结果即为加法的结果。<br>计算的过程中，一定要细心。方法虽然简单，但是要写对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    int Add(int num1, int num2)</div><div class="line">    &#123;</div><div class="line">        int res = num1 ^ num2, temp = num1 &amp; num2;</div><div class="line">        while (temp != 0)</div><div class="line">        &#123;</div><div class="line">            temp = temp &lt;&lt; 1;</div><div class="line">            int t = res;  //暂存res,以避免res的值被改变</div><div class="line">            res ^= temp;</div><div class="line">            temp = temp &amp; t;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h2><blockquote><p>输入一个字符串,包括数字字母符号,可以为空.如果是合法的数值表达则返回该数字，否则返回0  </p></blockquote><p>分析：主要首先要考虑正负号，这里有一个小细节，我们把flag直接置1的话，可以直接输出flag*res得到结果，而不需要进行判断，是一种省略。另外的判断就比较简单了，按照正常的思路去判断就行。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    int StrToInt(string str)</div><div class="line">    &#123;</div><div class="line">        if (str.size() == 0)</div><div class="line">            return 0;</div><div class="line">        int flag = 1;</div><div class="line">        int size = str.size(), res = 0;</div><div class="line">        int i = 0;</div><div class="line">        if (str[0] == &apos;-&apos;)</div><div class="line">        &#123;</div><div class="line">            flag = -1;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        else if (str[0] == &apos;+&apos;)</div><div class="line">        &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        for (; i &lt; size; ++i)</div><div class="line">        &#123;</div><div class="line">            if (str[i] &lt;= &apos;0&apos; || str[i] &gt;= &apos;9&apos;)</div><div class="line">            &#123;</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                res = res * 10 + (str[i] - &apos;0&apos;);</div><div class="line">        &#125;</div><div class="line">        return flag * res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h2><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。  </p></blockquote><p>分析：由于规定了数组中的数字在范围为0–n内，所以可以利用当前数组的位置进行遍历，比如每次遍历到一个位置，就将该数字对应位置的值加n，这样，当再次遍历到该值时，发现如果该值已经大于n，说明已经重复了，返回即可。不过在遍历的时候，如果发现某一位置的值大于n，应该先减去n，得到该位置上原来的值，这里应该捋清楚。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">    // Parameters:</div><div class="line">    //        numbers:     an array of integers</div><div class="line">    //        length:      the length of array numbers</div><div class="line">    //        duplication: (Output) the duplicated number in the array number</div><div class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</div><div class="line">    //                     otherwise false</div><div class="line">    bool duplicate(int numbers[], int length, int *duplication)</div><div class="line">    &#123;</div><div class="line">        for(int i=0;i&lt;length;++i)&#123;</div><div class="line">            int index=numbers[i];</div><div class="line">            if(index&gt;=length)</div><div class="line">                index=index-length;</div><div class="line">            if(numbers[index]&gt;=length)&#123;</div><div class="line">                *duplication=index;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            numbers[index]+=length;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h2><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</div><div class="line">        vector&lt;int&gt; res(A.size());</div><div class="line">        if(A.empty())</div><div class="line">            return res;</div><div class="line">        res[0]=1;</div><div class="line">        //计算下三角</div><div class="line">        for(int i=1;i&lt;A.size();++i)&#123;</div><div class="line">            res[i]=res[i-1]*A[i-1];</div><div class="line">        &#125;</div><div class="line">        int temp=1;</div><div class="line">        for(int i=A.size()-2;i&gt;=0;--i)&#123;</div><div class="line">            temp*=A[i+1];</div><div class="line">            res[i]*=temp;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="52-正则表达式匹配"><a href="#52-正则表达式匹配" class="headerlink" title="52.正则表达式匹配"></a>52.正则表达式匹配</h2><h2 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct ListNode &#123;</div><div class="line">    int val;</div><div class="line">    struct ListNode *next;</div><div class="line">    ListNode(int x) :</div><div class="line">        val(x), next(NULL) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* deleteDuplication(ListNode* pHead)</div><div class="line">    &#123;</div><div class="line">        if(pHead==nullptr)</div><div class="line">            return pHead;</div><div class="line">        ListNode* virtualHead=new ListNode(0);</div><div class="line">        virtualHead-&gt;next=pHead;</div><div class="line">        ListNode* prev=virtualHead;</div><div class="line">        </div><div class="line">        while(pHead-&gt;next)&#123;</div><div class="line">            if(pHead-&gt;val==pHead-&gt;next-&gt;val)&#123;</div><div class="line">                if(pHead-&gt;next-&gt;next)&#123;</div><div class="line">                    pHead=pHead-&gt;next-&gt;next;</div><div class="line">                    prev-&gt;next=pHead;</div><div class="line">                &#125;</div><div class="line">                else </div><div class="line">                    return virtualHead-&gt;next;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                pHead=pHead-&gt;next;</div><div class="line">                prev=prev-&gt;next;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        return virtualHead-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>测试用例:<br>{1,1,1,1,1,1,1}</p><p>对应输出应该为:</p><h2 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h2><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。  如果当前字符流没有存在出现一次的字符，返回#字符。    </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">  //Insert one char from stringstream</div><div class="line">    void Insert(char ch)</div><div class="line">    &#123;</div><div class="line">        if(!array[ch])</div><div class="line">            ique.push(ch);</div><div class="line">        array[ch]++;</div><div class="line">    &#125;</div><div class="line">  //return the first appearence once char in current stringstream</div><div class="line">    char FirstAppearingOnce()</div><div class="line">    &#123;</div><div class="line">        while(!ique.empty() &amp;&amp; array[ique.front()]&gt;1)&#123;</div><div class="line">            ique.pop();</div><div class="line">        &#125;</div><div class="line">        if(!ique.empty())</div><div class="line">            return ique.front();</div><div class="line">        return &apos;#&apos;;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    int array[256]=&#123;0&#125;;</div><div class="line">    queue&lt;char&gt; ique;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55.链表中环的入口结点"></a>55.链表中环的入口结点</h2><blockquote><p>一个链表中包含环，请找出该链表的环的入口结点。  </p></blockquote><p>分析：<a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/" target="_blank" rel="external">http://wuchong.me/blog/2014/03/25/interview-link-questions/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* EntryNodeOfLoop(ListNode* pHead)</div><div class="line">    &#123;</div><div class="line">        if(!pHead || !pHead-&gt;next)</div><div class="line">            return nullptr;</div><div class="line">        ListNode* fast=pHead,*slow=pHead;</div><div class="line">        while(fast-&gt;next &amp;&amp; slow)&#123;</div><div class="line">            fast=fast-&gt;next-&gt;next;</div><div class="line">            slow=slow-&gt;next;</div><div class="line">            if(fast==slow)</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        if(fast!=slow)</div><div class="line">            return nullptr;</div><div class="line">        fast=pHead;</div><div class="line">        while(fast!=slow)&#123;</div><div class="line">            fast=fast-&gt;next;</div><div class="line">            slow=slow-&gt;next;</div><div class="line">        &#125;</div><div class="line">        return fast;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56.删除链表中重复的结点"></a>56.删除链表中重复的结点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">//一个不通过的代码</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* deleteDuplication(ListNode* pHead)</div><div class="line">    &#123;</div><div class="line">        if(!pHead || !pHead-&gt;next)</div><div class="line">            return pHead;</div><div class="line">        ListNode* vHead=new ListNode(0);</div><div class="line">        vHead-&gt;next=pHead;</div><div class="line">        ListNode* pre=vHead;</div><div class="line">        ListNode* cur=pHead;</div><div class="line">        int temp;</div><div class="line">        while(cur &amp;&amp; cur-&gt;next)&#123;</div><div class="line">             ListNode* next=cur-&gt;next;</div><div class="line">            if(cur-&gt;val==next-&gt;val)&#123;   //原因是这个相等的处理有问题，没有考虑一直是同一个值的处理</div><div class="line">                temp=cur-&gt;val;</div><div class="line">                cur=next-&gt;next;</div><div class="line">                pre-&gt;next=cur;</div><div class="line">            &#125;</div><div class="line">            else if(next-&gt;val==temp)&#123;</div><div class="line">                cur-&gt;next=next-&gt;next;</div><div class="line">                pre-&gt;next=cur;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                if(next-&gt;next)&#123;</div><div class="line">                    pre=cur;</div><div class="line">                    cur=next;</div><div class="line">                  //  next=next-&gt;next;</div><div class="line">                &#125;</div><div class="line">               else</div><div class="line">                    return vHead-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return vHead-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//一个通过了的代码</div><div class="line">/*</div><div class="line">struct ListNode &#123;</div><div class="line">    int val;</div><div class="line">    struct ListNode *next;</div><div class="line">    ListNode(int x) :</div><div class="line">        val(x), next(NULL) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* deleteDuplication(ListNode* pHead)</div><div class="line">    &#123;</div><div class="line">        if(!pHead || !pHead-&gt;next)</div><div class="line">            return pHead;</div><div class="line">        ListNode* vHead=new ListNode(-1);</div><div class="line">        vHead-&gt;next=pHead;</div><div class="line">        ListNode* pre=vHead;</div><div class="line">        ListNode* cur=pHead;</div><div class="line">        while(cur &amp;&amp; cur-&gt;next)&#123;</div><div class="line">            ListNode* next=cur-&gt;next;</div><div class="line">            if(cur-&gt;val==next-&gt;val)&#123;</div><div class="line">                int val=cur-&gt;val;</div><div class="line">                while(cur &amp;&amp; cur-&gt;val==val)  //一直遍历到不为当前值为止</div><div class="line">                    cur=cur-&gt;next;</div><div class="line">                pre-&gt;next=cur;</div><div class="line">                cur=pre-&gt;next;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                pre=pre-&gt;next;</div><div class="line">                cur=cur-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return vHead-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//递归解决</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* deleteDuplication(ListNode* pHead)</div><div class="line">    &#123;</div><div class="line">        if(pHead==nullptr || pHead-&gt;next==nullptr)</div><div class="line">            return pHead;</div><div class="line">        ListNode* current=pHead;</div><div class="line">        if(pHead-&gt;val==pHead-&gt;next-&gt;val)&#123;</div><div class="line">            current=pHead-&gt;next-&gt;next;</div><div class="line">            while(current!=nullptr &amp;&amp; current-&gt;val==pHead-&gt;val)</div><div class="line">                current=current-&gt;next;</div><div class="line">            return deleteDuplication(current);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        else&#123;</div><div class="line">            current=pHead-&gt;next;</div><div class="line">            pHead-&gt;next=deleteDuplication(current);</div><div class="line">            return pHead;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57.二叉树的下一个结点"></a>57.二叉树的下一个结点</h2><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。  </p></blockquote><p>分析二叉树的下一个节点，一共有以下情况：<br>1.二叉树为空，则返回空；<br>2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；<br>3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p><h2 id="58-对称的二叉树"><a href="#58-对称的二叉树" class="headerlink" title="58.对称的二叉树"></a>58.对称的二叉树</h2><h2 id="59-按之字形顺序打印二叉树"><a href="#59-按之字形顺序打印二叉树" class="headerlink" title="59.按之字形顺序打印二叉树"></a>59.按之字形顺序打印二叉树</h2><h2 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h2><h2 id="61-序列化二叉树"><a href="#61-序列化二叉树" class="headerlink" title="61.序列化二叉树"></a>61.序列化二叉树</h2><h2 id="62-二叉搜索树的第k个结点"><a href="#62-二叉搜索树的第k个结点" class="headerlink" title="62.二叉搜索树的第k个结点"></a>62.二叉搜索树的第k个结点</h2><h2 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h2><h2 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h2><h2 id="65-矩阵中的路径"><a href="#65-矩阵中的路径" class="headerlink" title="65.矩阵中的路径"></a>65.矩阵中的路径</h2><h2 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;重刷剑指offer总结  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>《redis 设计与实现》--总结</title>
    <link href="http://yoursite.com/19-Linux/redis_sum/"/>
    <id>http://yoursite.com/19-Linux/redis_sum/</id>
    <published>2018-06-19T10:50:41.000Z</published>
    <updated>2018-06-22T14:05:16.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis设计与实现，以及关于Redis使用的总结  </p></blockquote><a id="more"></a><h2 id="1-数据结构与对象"><a href="#1-数据结构与对象" class="headerlink" title="1.数据结构与对象"></a>1.数据结构与对象</h2><h3 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.简单动态字符串"></a>1.简单动态字符串</h3><p>Redis自己构建了简单动态字符串(Simple Dynamic String,SDS)来作为默认的字符串表示。<br>SDS的构造如下：<br><img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180619151556.png"><br>优势是：</p><ol><li>能够在常数时间内获取字符串的长度-通过len属性   </li><li>能够杜绝缓冲区溢出：记录了缓冲区的大小，在长度不够时，能够自动扩展空间  </li><li>减少修改字符串时带来的内存重新分配次数：采用空间预分配和惰性空间释放  <h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3>Redis自己实现了链表。拥有以下特性：双端无环、带表头指针和表尾指针、带链表长度计数器、多态(使用void* 保存节点值)<h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h3>Redis字典底层采用哈希表实现。采用MurmurHash2算法，解决键冲突的方式是：链地址法。<br>哈希表的扩展与收缩：以下条件满足时：  </li><li>服务器没有执行BGSAVE或BGREWRITEAOF命令，哈希表负载因子&gt;1  </li><li>服务器在执行BGSAVE或BGREWRITEAOF命令，哈希表负载因子&gt;5  </li></ol><h3 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.跳跃表"></a>4.跳跃表</h3><p>Redis采用跳跃表作为有序集合键的底层数据结构，另：在集群节点中用作内部数据结构<br>跳跃表：一种有序数据结构，通过在一个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。支持平均O(logN),最差O(N)复杂度的查找。<br>Redis中跳跃表的实现：</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180619154918.png"> </div><br><br>其中包括表头和表尾节点，length记录节点的数量，level用于获取跳跃表中层高最大的那个节点的层数量 （表头节点的层高不计算在内）    </p><h3 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.整数集合"></a>5.整数集合</h3><p>Redis中集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合中元素的数量不多时，就会使用整数集合作为集合键的底层实现。<br>整数集合的升级策略：能够提高整数集合的灵活性，并且能够尽可能的节约内存。升级后不支持降级  </p><h3 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.压缩列表"></a>6.压缩列表</h3><p>Redis中列表键和哈希键的底层实现之一。  </p><h3 id="7-对象"><a href="#7-对象" class="headerlink" title="7.对象"></a>7.对象</h3><p>Redis使用上述的数据结构创建了一个对象系统。包括：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。其实这就是一直说的Redis五种数据结构：字符串、列表、字典、集合、有序集合。</p><h2 id="2-单机数据库的实现"><a href="#2-单机数据库的实现" class="headerlink" title="2.单机数据库的实现"></a>2.单机数据库的实现</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Redis服务器讲所有数据库保存在一个db数组中，默认创建16个数据库。<br>切换数据库:<code>select 0 #选择0号数据库</code>  </p><h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>键空间的键也是数据库的键。每个键都是一个字符串对象。<br>键空间的值也是数据库的值，每个值可以是字符串对象、列表对象、哈希对象、集合对象，有序集合对象中的任意一个Redis对象。<br>一个键空间的例子：</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180619162843.png"> </div><br></p><h4 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h4><p>原理是：过期时间是一个UNIX时间戳，当键的过期时间来临是，服务器就会自动从数据库中删除一个键。<br>命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">expire &lt;key&gt; &lt;ttl&gt;  #key的生存时间为ttl秒</div><div class="line">pexpire &lt;key&gt; &lt;ttl&gt;  #key的生存时间为ttl毫秒</div><div class="line">expireat &lt;key&gt; &lt;timestamp&gt;  #key的生存时间直到timestamp指定的时间戳s</div><div class="line">pexpireat &lt;key&gt; &lt;timestamp&gt;  #key的生存时间直到timestamp指定的时间戳ms</div><div class="line"></div><div class="line">persist &lt;key&gt;  #移除key的过期时间</div><div class="line">ttl &lt;key&gt;   #计算key的剩余生存时间</div><div class="line">```   </div><div class="line"></div><div class="line">setex命令可以设置一个字符串键的同时为键设置过期时间。</div><div class="line">一个带有过期字典的数据库例子：（实际中，键空间的键和过期字典中的键都指向同一个键对象）</div><div class="line">&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://blog-1252063226.cosbj.myqcloud.com/network/20180619163748.png&quot; /&gt; &lt;/div&gt;&lt;br&gt;</div><div class="line"></div><div class="line">#### 过期键删除策略</div><div class="line">- 定时删除： 内存最友好，CPU时间最不友好   </div><div class="line">- 惰性删除：CPU时间友好，内存不友好  </div><div class="line">- 定期删除：折中</div><div class="line">Redis实际使用：惰性删除和定期删除配合使用。</div><div class="line"></div><div class="line">#### 过期键的处理</div><div class="line">1. RDB文件：</div><div class="line">生成RDB文件：已过期的键不会保存到新创建的RDB文件中，因此对生成新的RDB文件没有影响。</div><div class="line">载入RDB文件：主服务器模式时，过期键不会被载入。从服务器模式时，都会被载入，但同步后，从服务器数据会被清空，所以也没有影响。  </div><div class="line">2. AOF文件：</div><div class="line">AOF写入：如果某个键已经过期，但没有被删除，AOF文件不会因为这个过期键产生任何影响。如果已经删除，AOF文件会追加一条DEL命令显式记录该键已被删除。  </div><div class="line">AOF重写：已过期的键不会被保存到重写的AOF文件。  </div><div class="line">3. 复制：  </div><div class="line">主服务器删除一个过期键，会显示向所有的从服务器发送DEL命令，告知删除。  </div><div class="line">从服务器遇到过期的键也不会删除。只有接收到DEL命令后才会删除过期键。  </div><div class="line"></div><div class="line">### RDB持久化</div><div class="line">通过保存数据库中的键值对来记录数据库状态不同。  </div><div class="line">功能：将Redis在内存中的数据库状态保存到磁盘中，避免数据意外丢失。RDB文件是一个经过压缩的二进制文件，保存在硬盘中，因此Redis进程退出，只要RDB文件仍在，就可以用来还原数据库的状态。  </div><div class="line">#### RDB文件的创建和载入</div><div class="line">服务器在载入RDB文件期间，会一直阻塞。  </div><div class="line">SAVE命令由服务器进程执行保存工作，因此会阻塞服务器。BGSAVE命令由子进程执行保存工作。</div><div class="line">#### 自动间隔性保存</div><div class="line">设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</div></pre></td></tr></table></figure></p><p>save 900 1  # 900s内发生了至少一次修改<br>save 300 10<br>save 60 10000<br>满足上述一个条件，BASAVE就会执行。<br>```</p><h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><table><thead><tr><th style="text-align:center">头部</th><th style="text-align:center">数据库版本</th><th style="text-align:center">数据</th><th style="text-align:center">正文结束符</th><th style="text-align:center">校验和</th></tr></thead><tbody><tr><td style="text-align:center">REDIS</td><td style="text-align:center">db_version</td><td style="text-align:center">databases</td><td style="text-align:center">EOF</td><td style="text-align:center">check_sum</td></tr></tbody></table><h3 id="AOF持久化-Append-Only-File"><a href="#AOF持久化-Append-Only-File" class="headerlink" title="AOF持久化(Append Only File)"></a>AOF持久化(Append Only File)</h3><p>通过保存Redis服务器所执行的写命令来记录数据库状态。   </p><h4 id="AOF持久化的实现过程"><a href="#AOF持久化的实现过程" class="headerlink" title="AOF持久化的实现过程"></a>AOF持久化的实现过程</h4><p>命令追加:将内容追加到aof_buf缓冲区的末尾。<br>写入与同步：服务器每次结束一个时间循环之前，都会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区中的内容写入和保存到AOF文件中。选项值为：alwals,everysec,no<br>载入与数据还原：还原过程：创建一个不带网络连接的伪客户端；从AOF文件中分析并读取一条写命令；使用伪客户端执行被读出的写命令；循环处理。  </p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>目的：解决AOF文件体积膨胀。<br>实现原理：从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。<br>后台重写：子进程AOF重写期间，服务器进程可以继续处理命令请求。<br>后台重写问题：子进程重写期间，服务器还需要处理命令请求，可能导致服务器当前数据库状态和重写后的AOF文件所保存的数据库状态不一致。解决办法：AOF重写缓冲区。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>文件事件处理器。基于Reactor模式，使用IO多路复用程序同时监听多个套接字。</p><h2 id="3-多机数据库的实现"><a href="#3-多机数据库的实现" class="headerlink" title="3.多机数据库的实现"></a>3.多机数据库的实现</h2><h2 id="4-独立功能的实现"><a href="#4-独立功能的实现" class="headerlink" title="4.独立功能的实现"></a>4.独立功能的实现</h2><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="AOF和RDB比较"><a href="#AOF和RDB比较" class="headerlink" title="AOF和RDB比较"></a>AOF和RDB比较</h3><ul><li>两者区别：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。  </li><li>优缺点：RDB：灵活设置备份频率和周期。方便灾难恢复，可以轻松的将一个单独的文件压缩再转移到其他存储介质上。性能最大化。数据集很大时，启动效率相对AOF较高。缺点：很难保证高可用，可能数据在写入磁盘之前会丢失。数据集较大时，可能导致服务器停止服务。<br>AOF：数据持久性。对日志的写入操作采用的是append模式，写入过程即使出现宕机，也不会破坏日志文件中已经存在的内容。如果日志过大，Redis可以自动启用rewrite机制。包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。缺点：RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。根据同步策略的不同，AOF在运行效率上往往会慢于RDB。  </li></ul><h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><p>使用setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。<br>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？<br>同时把setnx和expire合成一条指令来用  </p><h3 id="寻找key"><a href="#寻找key" class="headerlink" title="寻找key"></a>寻找key</h3><p>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>用keys指令可以扫出指定模式的key列表。<br>redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。  </p><h3 id="Redis同步机制"><a href="#Redis同步机制" class="headerlink" title="Redis同步机制"></a>Redis同步机制</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h3 id="redis相比memcached有哪些优势"><a href="#redis相比memcached有哪些优势" class="headerlink" title="redis相比memcached有哪些优势"></a>redis相比memcached有哪些优势</h3><ol><li>丰富的数据类型  </li><li>速度快  </li><li>可以持久化<br>区别：  </li><li>存储方式：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。  </li><li>数据类型：Memcache对数据类型支持相对简单。Redis有复杂的数据类型,Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。  </li><li>底层模型：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。  </li><li>value大小：redis最大可以达到1GB，而memcache只有1MB。  </li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ol><h3 id="Redis的LRU算法"><a href="#Redis的LRU算法" class="headerlink" title="Redis的LRU算法"></a>Redis的LRU算法</h3><p>最近最久未用算法。当内存达到限制时，Redis 具体的回收策略是通过 maxmemory-policy 配置项配置的。<br>no-eviction：不清除数据，只是返回错误，这样会导致浪费掉更多的内存，对大多数写命令（DEL 命令和其他的少数命令例外）<br>allkeys-lru：从所有的数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，以供新数据使用<br>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰，以供新数据使用<br>allkeys-random：从所有数据集（server.db[i].dict）中任意选择数据淘汰，以供新数据使用<br>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰，以供新数据使用<br>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，以供新数据使用  </p><h3 id="Redis常见的性能问题及解决"><a href="#Redis常见的性能问题及解决" class="headerlink" title="Redis常见的性能问题及解决"></a>Redis常见的性能问题及解决</h3><ol><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件. 特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。  </li><li>尽量避免在压力很大的主库上增加从库。  </li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。  </li><li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内  </li></ol><h3 id="适合Redis的场景"><a href="#适合Redis的场景" class="headerlink" title="适合Redis的场景"></a>适合Redis的场景</h3><ol><li>会话缓存 全页缓存   队列 排行榜/计数器  发布/订阅  会话  购物车 </li></ol><h3 id="Nosql和Key-Value数据库"><a href="#Nosql和Key-Value数据库" class="headerlink" title="Nosql和Key-Value数据库"></a>Nosql和Key-Value数据库</h3><p>NoSQL，泛指非关系型的数据库，全称Not Only SQL，意即“不仅仅是SQL”。<br>NoSQL数据库的四大家族：</p><ol><li>键值（Key-Value）数据库:Redis、Memcached   </li><li>面向文档（Document-Oriented）数据库:MongoDB  适用：日志、分析</li><li>列存储（Wide Column Store/Column-Family）数据库  HBase 适用:日志、博客平台</li><li>图（Graph-Oriented）数据库 适用：关系性强，推荐引擎</li></ol><h3 id="Redis最大连接数"><a href="#Redis最大连接数" class="headerlink" title="Redis最大连接数"></a>Redis最大连接数</h3><p>默认10000</p><h3 id="redis的瓶颈"><a href="#redis的瓶颈" class="headerlink" title="redis的瓶颈"></a>redis的瓶颈</h3><h3 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h3><h4 id="Redis-复制功能"><a href="#Redis-复制功能" class="headerlink" title="Redis 复制功能"></a>Redis 复制功能</h4><h3 id="Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"><a href="#Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端" class="headerlink" title="Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"></a>Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端</h3><h3 id="Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用"><a href="#Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用" class="headerlink" title="Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用"></a>Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用</h3><h3 id="Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等"><a href="#Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等" class="headerlink" title="Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等"></a>Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等</h3><h3 id="Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"><a href="#Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的" class="headerlink" title="Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"></a>Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的</h3><h3 id="Redis和memcached的区别，Redis为什么可以组集群"><a href="#Redis和memcached的区别，Redis为什么可以组集群" class="headerlink" title="Redis和memcached的区别，Redis为什么可以组集群"></a>Redis和memcached的区别，Redis为什么可以组集群</h3><h2 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h2><p><a href="https://www.bookstack.cn/read/note-of-interview/framework-redis.md" target="_blank" rel="external">https://www.bookstack.cn/read/note-of-interview/framework-redis.md</a><br><a href="http://www.techug.com/post/nosql.html" target="_blank" rel="external">http://www.techug.com/post/nosql.html</a>   </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Redis设计与实现，以及关于Redis使用的总结  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="Nosql" scheme="http://yoursite.com/tags/Nosql/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云自媒体分享计划/邀请好友加入双方均可获得 30/100/180 元云服务器代金券</title>
    <link href="http://yoursite.com/01-Linux/tencent_cloud_plan/"/>
    <id>http://yoursite.com/01-Linux/tencent_cloud_plan/</id>
    <published>2018-06-01T09:03:08.000Z</published>
    <updated>2018-06-24T13:41:59.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="腾讯云自媒体分享计划"><a href="#腾讯云自媒体分享计划" class="headerlink" title="腾讯云自媒体分享计划"></a>腾讯云自媒体分享计划</h2><p>腾讯云自媒体分享计划是通过邀请好友加入“自媒体分享计划”，好友成功加入后你们双方都可以获得 30/100/180 元云服务器代金券。<br><img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180601170408.png"></p><p>可以通过下面我的链接申请：<br><a href="https://cloud.tencent.com/developer/support-plan?invite_code=174pin6hqb074" target="_blank" rel="external">https://cloud.tencent.com/developer/support-plan?invite_code=174pin6hqb074</a></p><p>审核通过后大家可共同分享超过百万元的资源包。腾讯云会一次性发放云服务器 CVM 30 元/ 100 元/ 180 元代金券给通过了审核的用户。代金券的发放金额是根据用户的迁入原创文章数量和质量来决定。  </p><p>参加这个活动的好处：在腾讯云发布自己的文章，对于提高你个人博客或者公众号的知名度是有很大帮助的，个人博客网站类的更可以在 SEO 方面有益处，所以如果你有个人资源还是点击上面链接参加一下活动，既增加了自媒体的权重又能拿到云服务器代金券，一举两得。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;腾讯云自媒体分享计划&quot;&gt;&lt;a href=&quot;#腾讯云自媒体分享计划&quot; class=&quot;headerlink&quot; title=&quot;腾讯云自媒体分享计划&quot;&gt;&lt;/a&gt;腾讯云自媒体分享计划&lt;/h2&gt;&lt;p&gt;腾讯云自媒体分享计划是通过邀请好友加入“自媒体分享计划”，好友成功加入后你们
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="腾讯云" scheme="http://yoursite.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu自动push到github脚本</title>
    <link href="http://yoursite.com/24-%E5%B7%A5%E5%85%B7/shell_%E8%87%AA%E5%8A%A8push/"/>
    <id>http://yoursite.com/24-工具/shell_自动push/</id>
    <published>2018-05-24T12:20:43.000Z</published>
    <updated>2018-05-31T12:15:39.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于人比较懒，总是忘了自己提交到github上，也觉得博客好不容易写了还要打开文件夹，点一下交，这个体验有点差呀。于是就写了个Linux自动提交代码的和windows自动更新博客的。</p></blockquote><a id="more"></a><h2 id="Linux编写shell脚本"><a href="#Linux编写shell脚本" class="headerlink" title="Linux编写shell脚本"></a>Linux编写shell脚本</h2><h3 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">path=~/github/</div><div class="line"></div><div class="line">git_push()&#123;</div><div class="line">    echo &quot;开始push&quot;</div><div class="line">    modify_time=`stat -c %Y $&#123;1&#125;`</div><div class="line">    this_time=`date +%s`</div><div class="line"></div><div class="line">    cd $&#123;1&#125;</div><div class="line">    echo &quot;-------切换目录------&quot;</div><div class="line">    echo `pwd`</div><div class="line">    echo &quot;---------------------&quot;</div><div class="line">    if [ $[ $&#123;modify_time&#125;-$&#123;this_time&#125; ] -gt 86400 ];</div><div class="line">    then</div><div class="line">         echo &quot;$&#123;1&#125; 文件夹 有变化，正在准备push...&quot;</div><div class="line">        date=`date &quot;+%Y-%m-%d %H:%M:%S&quot;`</div><div class="line">        git add .    </div><div class="line">        git commit -m &quot;automatic push @$(date)&quot;</div><div class="line">        echo &quot;git fetch origin master&quot;</div><div class="line">        git fetch origin master</div><div class="line"></div><div class="line">        echo &quot;git merge origin/master&quot;</div><div class="line">        git merge origin/master</div><div class="line"></div><div class="line">        echo &quot;git push origin master:master&quot;</div><div class="line">        git push origin master:master</div><div class="line">         </div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">git_push ~/github/Linux_pro</div><div class="line">git_push ~/github/miniweb</div></pre></td></tr></table></figure><h3 id="加入定时任务"><a href="#加入定时任务" class="headerlink" title="加入定时任务"></a>加入定时任务</h3><h3 id="编辑定时任务文件"><a href="#编辑定时任务文件" class="headerlink" title="编辑定时任务文件"></a>编辑定时任务文件</h3><p>(<a href="https://blog.csdn.net/xiyuan1999/article/details/8160998" target="_blank" rel="external">https://blog.csdn.net/xiyuan1999/article/details/8160998</a>)<br><code>crontab  -e</code><br>在文件的末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30 5 * * * /home/mianhk/shell/auto_push.sh  表示在每天的 5.30执行</div></pre></td></tr></table></figure></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><code>/etc/init.d/cron start</code></p><h2 id="Windows自动提交博客"><a href="#Windows自动提交博客" class="headerlink" title="Windows自动提交博客"></a>Windows自动提交博客</h2><p>其实windows的也差不多，写一个bat的脚本，然后加到系统的定时任务里面</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">title 同步博客到远端——余国聪</div><div class="line">color 16</div><div class="line"></div><div class="line">echo;</div><div class="line">echo;</div><div class="line"></div><div class="line">echo 切换目录到blog</div><div class="line">f:</div><div class="line">cd \github\mianhk</div><div class="line">cd .\blog</div><div class="line">echo clean</div><div class="line"></div><div class="line">hexo g -d</div><div class="line"></div><div class="line">echo 切换到GitHub备份目录</div><div class="line">cd ..</div><div class="line"></div><div class="line">echo 开始提交代码到本地仓库</div><div class="line">echo 当前目录是：%cd%</div><div class="line"></div><div class="line">echo 开始添加变更</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git add -A .</div><div class="line">echo 执行结束！</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 提交变更到本地仓库</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">set declation=%date:~0,4%%date:~5,2%%date:~8,2%</div><div class="line">git commit -m &quot;%declation%同步博客&quot;</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 将变更情况提交到远程git服务器</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git push origin master</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 批处理执行完毕！</div><div class="line">echo;</div><div class="line"></div><div class="line">pause</div></pre></td></tr></table></figure><h3 id="添加到自动任务"><a href="#添加到自动任务" class="headerlink" title="添加到自动任务"></a>添加到自动任务</h3><p>计算机-&gt;管理-&gt;任务计划程序-&gt;添加任务即可  </p><p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=174pin6hqb074" target="_blank" rel="external">https://cloud.tencent.com/developer/support-plan?invite_code=174pin6hqb074</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于人比较懒，总是忘了自己提交到github上，也觉得博客好不容易写了还要打开文件夹，点一下交，这个体验有点差呀。于是就写了个Linux自动提交代码的和windows自动更新博客的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jupyter-notebook安装和问题解决</title>
    <link href="http://yoursite.com/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/"/>
    <id>http://yoursite.com/26-工具/use_of_jupyter/</id>
    <published>2018-04-26T03:36:57.000Z</published>
    <updated>2018-05-13T13:39:12.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jupyter notebook折腾日记</p></blockquote><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-采用直接pip安装"><a href="#1-采用直接pip安装" class="headerlink" title="1.采用直接pip安装"></a>1.采用直接pip安装</h2><p><code>pip install jupyter</code>不过可能由于是版本自带的pip有问题，而且用的Python版本也还是2.7的，反正就出现了各种问题。中间解决的有：  </p><ul><li>重新升级pip，但是发现直接pip还是有问题，于是找到问题原因，可能名字有点对不上，找到bin目录下还有一个pip2，在Python里面运行，发现果然是这个，有点心酸，还是换了这个。  </li><li>升级之后，会出现各种的权限问题，没事，给！  </li><li>之后运行，发现没有浏览器，于是又想起服务器上没有，又加上命令试了一下，而且每次都要复制一个长长的token吗？。。</li></ul><h2 id="2-采用Anaconda安装"><a href="#2-采用Anaconda安装" class="headerlink" title="2.采用Anaconda安装"></a>2.采用Anaconda安装</h2><p>正好晚上在床上看到一个链接，说这个更方便，反正也是折腾嘛，就试试了。过程稍微写一写哈</p><ol><li>在清华镜像站找到采用Anaconda相应版本下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br> 找到后复制链接：<code>wget 链接</code> </li><li>安装Anaconda:<br> <code>sh Anaconda3-5.1.0-Linux-x86_64.sh # 一路yes就装了</code>  </li><li>服务器管理控制台开放8888端口（当然端口可以配置，也随便换了）  </li><li>运行<code>jupyter notebook --generate-config</code> 生成默认的jupyter配置文件  </li><li><p>编辑config文件：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd .jupyter</div><div class="line">vim jupyter_notebook_config.py #编辑config文件</div><div class="line">c.NotebookApp.ip = &apos;*&apos;  #允许所有的ip登录</div><div class="line">c.NotebookApp.open_browser = False #打开浏览器：关闭，因为服务器没有浏览器</div><div class="line">c.NotebookApp.port = 8888  #开放使用的端口</div></pre></td></tr></table></figure></li><li><p>保存退出。运行jupyter notebook，会得到一个带token的访问地址。复制地址，将其中的localhost替换成服务器的公网IP，访问，应该可以正常进入jupyter。  </p></li><li>每次都tocken当然有点麻烦了。设置一个密码吧：<br> <code>jupyter-notebook password</code></li><li>之后就可以公网输入登录了。</li></ol><h2 id="3-安装主题和相关插件"><a href="#3-安装主题和相关插件" class="headerlink" title="3.安装主题和相关插件"></a>3.安装主题和相关插件</h2><p><a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="external">jupyter_contrib_nbextensions</a><br>直接使用<code>conda install -c conda-forge jupyter_contrib_nbextensions</code></p><ul><li>使用注意：<br>1.关于ubuntu的环境变量设置没有对，导致conda命令不能用的问题。当然知道应该是环境变量的问题，不过还是搞了很久。才发现是加在ubuntu的home目录下的<code>.bashrc</code>后面<code>export PATH=~/anaconda3/bin:$PATH</code><br>2.由于我的conda版本没有更新，所以出现了插件也只有几个的情况，所以需要先更新。之后再重启jupyter notebook。<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><a href="http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/" target="_blank" rel="external">http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</a><br><a href="https://zhuanlan.zhihu.com/p/34289322" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34289322</a><br><a href="https://zhuanlan.zhihu.com/p/20226040?utm_source=qq&amp;utm_medium=social&amp;utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/20226040?utm_source=qq&amp;utm_medium=social&amp;utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;jupyter notebook折腾日记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="jupyter" scheme="http://yoursite.com/tags/jupyter/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日常折腾日记</title>
    <link href="http://yoursite.com/25-%E5%B7%A5%E5%85%B7/daily_zheteng/"/>
    <id>http://yoursite.com/25-工具/daily_zheteng/</id>
    <published>2018-04-25T03:49:56.000Z</published>
    <updated>2018-05-19T13:37:08.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>俗话说，生活就是不断的折腾，恰好自己是个这样的人。可能就是这样一个虽然不是很年轻了，但是心态总是年轻的，看到一些有趣的或者有意思的，总是忍不住想看看，或者试试。但是有时候又觉得自己不再年轻了，有些东西虽然当时记着了，但是后来又忘了，或者有时候记着又找起来很耽误时间。所以就在这记录一下吧。</p></blockquote><a id="more"></a><h2 id="博客相关"><a href="#博客相关" class="headerlink" title="博客相关"></a>博客相关</h2><p><a href="https://zhuanlan.zhihu.com/p/28128674" target="_blank" rel="external">hexo博客插件</a><br><a href="http://www.yuguocong.me/10-%E5%B7%A5%E5%85%B7/%E6%88%91%E7%9A%84hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">我的博客折腾</a><br><a href="http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/" target="_blank" rel="external">自动构建博客</a></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><a href="http://www.yuguocong.me/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/" target="_blank" rel="external">jupyter</a></p><ul><li><a href="https://www.cnblogs.com/kevingrace/p/6496899.html" target="_blank" rel="external">tmux的使用</a></li><li><a href="https://github.com/kxxoling/blog/blob/master/tool/tmux.md" target="_blank" rel="external">tmux的使用2</a></li></ul><h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><p>vip视频：<br><a href="https://github.com/laidefa/Flask_Web_Vip：" target="_blank" rel="external">https://github.com/laidefa/Flask_Web_Vip：</a>  <a href="http://101.37.147.236:1518/" target="_blank" rel="external">http://101.37.147.236:1518/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;俗话说，生活就是不断的折腾，恰好自己是个这样的人。可能就是这样一个虽然不是很年轻了，但是心态总是年轻的，看到一些有趣的或者有意思的，总是忍不住想看看，或者试试。但是有时候又觉得自己不再年轻了，有些东西虽然当时记着了，但是后来又忘了，或者有时候记着又找起来很耽误时间。所以就在这记录一下吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="资源" scheme="http://yoursite.com/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="收集" scheme="http://yoursite.com/tags/%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3使用总结</title>
    <link href="http://yoursite.com/24-%E5%B7%A5%E5%85%B7/use-of-sublime/"/>
    <id>http://yoursite.com/24-工具/use-of-sublime/</id>
    <published>2018-04-24T12:43:43.000Z</published>
    <updated>2018-04-24T14:49:47.092Z</updated>
    
    <content type="html"><![CDATA[<p>update:</p><ul><li>2018-04-24 首次更新:突然发现Sublime Text3也还是挺好用的，之前切出去光标总是乱跳，就有点烦，以为是这样的就没管，用了网易云，没想到发现只有我的是这样，赶紧找找问题，解决一下。顺便把很多重新折腾一下。</li></ul><p>#用好sublime</p><h3 id="为Sublime-Text3添加插入当前时间的命令"><a href="#为Sublime-Text3添加插入当前时间的命令" class="headerlink" title="为Sublime Text3添加插入当前时间的命令"></a><a href="https://www.cnblogs.com/jiafeimao-dabai/p/7238357.html" target="_blank" rel="external">为Sublime Text3添加插入当前时间的命令</a></h3><ol><li>创建插件：</li></ol><p>Tools → New Plugin:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import datetime</div><div class="line">import sublime_plugin</div><div class="line">class AddCurrentTimeCommand(sublime_plugin.TextCommand):</div><div class="line">    def run(self, edit):</div><div class="line">        self.view.run_command(&quot;insert_snippet&quot;, </div><div class="line">            &#123;</div><div class="line">                &quot;contents&quot;: &quot;%s&quot; % datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) </div><div class="line">            &#125;</div><div class="line">        )</div></pre></td></tr></table></figure></p><p>保存为Sublime Text3\Packages\User\addCurrentTime.py</p><ol><li>创建快捷键：</li></ol><p>Preference → Key Bindings - User:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;command&quot;: &quot;add_current_time&quot;,</div><div class="line">        &quot;keys&quot;: [</div><div class="line">            &quot;ctrl+shift+.&quot;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p><h3 id="添加了一个主题https-packagecontrol-io-packages-Predawn：Predawn"><a href="#添加了一个主题https-packagecontrol-io-packages-Predawn：Predawn" class="headerlink" title="添加了一个主题https://packagecontrol.io/packages/Predawn：Predawn"></a><a href="">添加了一个主题</a><a href="https://packagecontrol.io/packages/Predawn：Predawn" target="_blank" rel="external">https://packagecontrol.io/packages/Predawn：Predawn</a></h3><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><p>小土刀博客：<a href="http://wdxtub.com/2016/03/24/sublime-guide/" target="_blank" rel="external">http://wdxtub.com/2016/03/24/sublime-guide/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;update:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2018-04-24 首次更新:突然发现Sublime Text3也还是挺好用的，之前切出去光标总是乱跳，就有点烦，以为是这样的就没管，用了网易云，没想到发现只有我的是这样，赶紧找找问题，解决一下。顺便把很多重新折腾一下。&lt;/li&gt;
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="折腾" scheme="http://yoursite.com/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>阶段性生活思考</title>
    <link href="http://yoursite.com/24-%E9%9A%8F%E7%AC%94/redo-mylife/"/>
    <id>http://yoursite.com/24-随笔/redo-mylife/</id>
    <published>2018-04-24T12:40:26.000Z</published>
    <updated>2018-06-24T03:25:56.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="why-title"><a href="#why-title" class="headerlink" title="why title"></a>why title</h2><blockquote><p>生活就是要不断的思考,不是吗?</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180624112358.png"> </div><br><br><a id="more"></a></p><h3 id="update-2018-05-13-21-15-04-周日"><a href="#update-2018-05-13-21-15-04-周日" class="headerlink" title="update:2018-05-13 21:15:04 周日"></a>update:2018-05-13 21:15:04 周日</h3><p>突然觉得很久没思考自己的生活了。      </p><ul><li>1.做事情注意力不集中。最近虽然看起来学习态度要好一些，每天都是待在实验室，但是学习的效率却感觉没有以前高了。而且总是注意力不够集中，明明在该学习的时候，却看看这个看看那个。做这个的时候看看想起另外一件事，就去看看，结果就该做的事情没做好。看看论文就想玩玩手机，玩着又有点愧疚就去看看c++，总是三心二意的。  </li><li>2.不太爱思考。另一个问题就是，遇到问题不求甚解。这还是以前的老问题吧，对于以前的应试教育来说，可能里面的道理也不用太深究，毕竟能最后写在试卷上就行了，看起来还能有个差不多好看的分数。但是现在处于的阶段不一样了，不管是日常的工作学习，还是平时看到一些新闻的想法，这都会有一些问题。当然，这方面可能手机因素也比较大一点，有很多的观点唾手可得，找找资料就能看到很多东西，恰好这方面自己又比较擅长，于是就又陷入了找资料不思考的陷阱。这样虽然有时候找到了很多有价值的东西，平时看到了很多，说吧，都知道，但是具体的就是不清楚，更别谈再有所新的想法了。所以这是个重要的问题。  </li><li>3.做事情应该更有目的。就是可能现在感觉很忙，但是却没有个统一的目的，有时候花的时间是多了，但是却没有很好的效果。  </li></ul></blockquote><h3 id="update-2018-05-30-20-21-01-周三"><a href="#update-2018-05-30-20-21-01-周三" class="headerlink" title="update:2018-05-30 20:21:01 周三"></a>update:2018-05-30 20:21:01 周三</h3><ul><li>学习方面稍微集中了一点，但是还是没有太专注。  </li><li>做事情还是要抓住重点，仍然需要注意。  </li><li>多多总结。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;why-title&quot;&gt;&lt;a href=&quot;#why-title&quot; class=&quot;headerlink&quot; title=&quot;why title&quot;&gt;&lt;/a&gt;why title&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;生活就是要不断的思考,不是吗?&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://blog-1252063226.cosbj.myqcloud.com/network/20180624112358.png&quot;&gt; &lt;/div&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>更好的使用Linux</title>
    <link href="http://yoursite.com/19-Linux/easy_use_of_Linux/"/>
    <id>http://yoursite.com/19-Linux/easy_use_of_Linux/</id>
    <published>2018-04-19T06:57:16.000Z</published>
    <updated>2018-06-22T03:06:13.858Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>平时总是用Linux下进行一些开发，但是日常看看论文都是windows，有时候有一些有用的或者比较有意思的，可能当时知道了，后面就忘了，或者也有一些本身就是小东西，结果用的时候又是去查，就觉得很麻烦，觉得还不如自己整理一下。  </p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180622110604.png"> </div><br><br><a id="more"></a></p></blockquote><h1 id="代码统计软件-cloc"><a href="#代码统计软件-cloc" class="headerlink" title="代码统计软件-cloc"></a>代码统计软件-cloc</h1><p>安装：<code>sudo apt-get install cloc</code><br>使用：<code>cloc yourpath</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;平时总是用Linux下进行一些开发，但是日常看看论文都是windows，有时候有一些有用的或者比较有意思的，可能当时知道了，后面就忘了，或者也有一些本身就是小东西，结果用的时候又是去查，就觉得很麻烦，觉得还不如自己整理一下。  &lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://blog-1252063226.cosbj.myqcloud.com/network/20180622110604.png&quot;&gt; &lt;/div&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="日常" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux的fork使用</title>
    <link href="http://yoursite.com/15-Linux%E7%9A%84fork%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/15-Linux的fork使用/</id>
    <published>2018-03-15T14:48:01.000Z</published>
    <updated>2018-05-22T06:43:37.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux的fork使用"><a href="#Linux的fork使用" class="headerlink" title="Linux的fork使用"></a>Linux的fork使用</h2><blockquote><p>fork函数可以算是Linux里有点不好明白的函数了，调用一次，返回两次，虽然在平时的写法中，有基本固定的写法，但是有时候看起来还是有些让人头疼的。这里就把关于fork函数好好整理一下</p></blockquote><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><p><strong>功能</strong>：fork函数是从一个已经存在的进程中创建一个新的进程，新的进程称为子进程，原来的进程称为父进程。<br><strong>参数</strong>：无<br><strong>返回值</strong>：<br>成功：子进程中返回 0，父进程中返回子进程 ID。pid_t，为无符号整型。<br>失败：返回 -1。</p><p>失败的两个主要原因是：<br>1）当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN。<br>2）系统内存不足，这时 errno 的值被设置为 ENOMEM。</p><h3 id="测试的例子"><a href="#测试的例子" class="headerlink" title="测试的例子"></a>测试的例子</h3><p>下面是一个简单的创建子进程的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    int pid=1;</div><div class="line">    pid=fork();</div><div class="line">    if(0==pid)&#123; //pid为0，表示为子进程</div><div class="line">        cout&lt;&lt;&quot;我是子进程，我的pid是：&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    else if(pid&gt;0)&#123; //pid&gt;0表示父进程，此时返回值为子进程的pid</div><div class="line">        cout&lt;&lt;&quot;我是父进程，我的pid是&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    else &#123;  //fork 失败</div><div class="line">        cout&lt;&lt;&quot;fork失败&quot;&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面的例子可以看出，fork函数会有两个返回值，一个是在子进程中返回0,一个是在父进程中返回子进程的pid。因此在编程过程中，需要判断这个值的返回值来判断当前是父进程还是子进程。</p><h3 id="fork进程的原理"><a href="#fork进程的原理" class="headerlink" title="fork进程的原理"></a>fork进程的原理</h3><p>使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用 fork()函数的代价是很大的。<br><img src="http://blog-1252063226.cosbj.myqcloud.com/Linux/003001.jpg?raw=true" alt=""></p><h3 id="日常使用fork"><a href="#日常使用fork" class="headerlink" title="日常使用fork"></a>日常使用fork</h3><p>简单来说， 一个进程调用 fork() 函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p><p>实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在<strong>需要写入的时候才会进行，在此之前，只有以只读方式共享</strong>。</p><p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。一般来说，在 fork() 之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。</p><p>因此，在实际的使用过程中，一般都需要对fork()的返回值进行判断，看我们操作的是父进程还是子进程。</p><h4 id="一般的操作：同时创建多个子进程"><a href="#一般的操作：同时创建多个子进程" class="headerlink" title="一般的操作：同时创建多个子进程"></a>一般的操作：同时创建多个子进程</h4><p>不对的例子:父进程会生成 n(n+1)/2+1个子进程，N 为循环次数，本例中共有 7 个子进程， 但实际上只有 3 个是父进程产生的，其余都为子进程 fork（）出来的。父进程fork了3个进程，第一个子进程执行完之后又fork了2个进程，第2个子进程fork了1个进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    pid_t p1,p2;</div><div class="line">    int i;</div><div class="line">    int N=100;</div><div class="line">    for(int i=0;i&lt;=N;++i)&#123;</div><div class="line">        if((p1=fork())==0)&#123;</div><div class="line">            cout&lt;&lt;&quot;子进程1：&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">            //return 0;  //很关键的地方，为什么需要返回呢</div><div class="line">        &#125;</div><div class="line">        wait(p1,NULL,0); //父进程等待p1子进程执行后才能继续fork其他子进程</div><div class="line">        cout&lt;&lt;&quot;这是父进程: &quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>正确的使用Linux中的用fork()由一个父进程创建同时多个子进程 的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    pid_t p1,p2;</div><div class="line">    int i;</div><div class="line">    int N=100;</div><div class="line">    for(int i=0;i&lt;=N;++i)&#123;</div><div class="line">        status=fork();</div><div class="line">        if(status==0||status==1) break;//每次循环时，如果发现是子进程就直接从创建子进程的循环中跳出来，不让你进入循环，这样就保证了每次只有父进程来做循环创建子进程的工作</div><div class="line">        if (status == -1)</div><div class="line">        &#123;</div><div class="line">          //error</div><div class="line">        &#125;</div><div class="line">        else if (status == 0) //每个子进程都会执行的代码</div><div class="line"></div><div class="line">        &#123;</div><div class="line">          //sub process</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">          //parent process</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="无聊的问题"><a href="#无聊的问题" class="headerlink" title="无聊的问题"></a>无聊的问题</h3><p>1.下面的程序，不算 main这个进程自身，到底创建了多少个进程啊？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">   fork();</div><div class="line">   fork() &amp;&amp; fork() || fork();</div><div class="line">   fork();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>每fork一次就翻倍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  fork(); //2个</div><div class="line">   fork() &amp;&amp; fork() || fork();</div><div class="line">//A&amp;&amp;B||C</div><div class="line">//A为假，跳过B，判断C-----------------------2</div><div class="line">//A为真，判断B，若B为真，跳过C-----------1</div><div class="line">//若B为假，判断C ------------2</div><div class="line">   fork(); //2</div></pre></td></tr></table></figure></p><p>总共有：<br>2<em>(2+1+2)</em>2=20<br>不算自己的话有20-1=19个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux的fork使用&quot;&gt;&lt;a href=&quot;#Linux的fork使用&quot; class=&quot;headerlink&quot; title=&quot;Linux的fork使用&quot;&gt;&lt;/a&gt;Linux的fork使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;fork函数可以算是Linux里有
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-60-Permutation-Sequence</title>
    <link href="http://yoursite.com/06-%E5%88%B7%E9%A2%98/LeetCode-60-Permutation-Sequence/"/>
    <id>http://yoursite.com/06-刷题/LeetCode-60-Permutation-Sequence/</id>
    <published>2018-02-06T09:32:24.000Z</published>
    <updated>2018-04-27T02:28:48.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-60-Permutation-Sequence"><a href="#LeetCode-60-Permutation-Sequence" class="headerlink" title="LeetCode-60-Permutation-Sequence"></a>LeetCode-60-Permutation-Sequence</h3><blockquote><p>The set [1,2,3,…,n] contains a total of n! unique permutations.<br>By listing and labeling all of the permutations in order,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">We get the following sequence (ie, for n = 3):</div><div class="line"></div><div class="line">&quot;123&quot;</div><div class="line">&quot;132&quot;</div><div class="line">&quot;213&quot;</div><div class="line">&quot;231&quot;</div><div class="line">&quot;312&quot;</div><div class="line">&quot;321&quot;</div><div class="line">Given n and k, return the kth permutation sequence.</div></pre></td></tr></table></figure></p></blockquote><p>同样是排列 组合的问题，这次不需要打印所有的排列了，只需要按照排列的顺序打印出第k个，很显然，思路不会是列出所有的排列，然后找第k个打印出来是吧。</p><p>观察来看，以<code>1,2,3,4</code>为例，有<code>4*3*2*1=24</code>种排列，其中根据排列的顺序，按照第一个数字可以分为以下4种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1 * * *</div><div class="line"></div><div class="line">2 * * *</div><div class="line"></div><div class="line">3 1 2 4</div><div class="line">3 1 4 2</div><div class="line">3 2 1 4</div><div class="line">3 2 4 1</div><div class="line">3 4 1 2</div><div class="line">3 4 2 1</div><div class="line"></div><div class="line">4 * * *</div><div class="line">#### 方法一</div></pre></td></tr></table></figure></p><ul><li><p>第一个数<br>可以看出，当k=14时，第一个数字为3,这个是可以通过计算的。由于是从1开始的，取k=13；<code>index=k/(n-1)!=13/3!=2</code>，于是可以知道第一个数是3。那么第二个数字呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1+permutation(2,4)</div><div class="line">2+permutation(1,4)</div><div class="line">4+permutation(1,2)</div></pre></td></tr></table></figure></li><li><p>第二个数<br>可以根据:<code>k=k-index_pre*(n-1)!=13-2*3!=1</code>;<br><code>index=k/(n-2)!=1/(4-2)!=0</code>于是第二个数为1。</p></li><li>第三个数<br>接下来就只剩下2和4了，继续:<code>k=k-index_pre*(n-2)!=1-0*(4-2)!=1</code>,  <code>index=k/(n-3)!=1/(4-3)!=1</code>在此处表示为4.之后再确定最后一个:</li><li>第四个数<br><code>k=k-index_pre*(n-4)!=1-1*(4-4)=0</code>;<br><code>index=k/(n-4)!=0/(4-4)!=0</code> 故第四个数为2</li></ul><p>到了这里，思路就比较清晰了。我们需要做的是从第一个一直到最后一个的循环，每次选出一个数，但是还需要将该数从原来的数组中剔除掉，因为前面选过的后面就不能排列了。</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>其实原理差不多，也还是根据排列的规律。只不过算的方法不一样。</p><ol><li>j=i+k/(n-i)!;</li><li>删除s[j];</li><li>k=k%(n-i);</li><li>s[i]=s[j];<br>代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    string getPermutation(int n, int k) &#123;</div><div class="line">        if(n&lt;=0)</div><div class="line">            return &quot; &quot;;</div><div class="line">        int i,j,f=1;</div><div class="line">        string s(n,&apos;0&apos;);</div><div class="line">        for(i=1;i&lt;=n;i++)&#123;</div><div class="line">            f*=i;</div><div class="line">            s[i-1]+=i;</div><div class="line">        &#125;</div><div class="line">        for(i=0,k--;i&lt;n;++i)&#123;</div><div class="line">            f/=n-i;</div><div class="line">            j=i+k/f;</div><div class="line">            char c=s[j];</div><div class="line">            for(;j&gt;i;j--)</div><div class="line">                s[j]=s[j-1];</div><div class="line">            k%=f;</div><div class="line">            s[i]=c;</div><div class="line">        &#125;</div><div class="line">        return s;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-60-Permutation-Sequence&quot;&gt;&lt;a href=&quot;#LeetCode-60-Permutation-Sequence&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-60-Permutation-Sequ
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构技术-架构模式</title>
    <link href="http://yoursite.com/03-architecture-model-of-web-architecture/"/>
    <id>http://yoursite.com/03-architecture-model-of-web-architecture/</id>
    <published>2018-02-03T08:39:27.000Z</published>
    <updated>2018-05-13T13:47:16.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大型网站架构技术-架构模式"><a href="#大型网站架构技术-架构模式" class="headerlink" title="大型网站架构技术-架构模式"></a>大型网站架构技术-架构模式</h2><p>模式的关键在于模式的可重复性。<br><a id="more"></a></p><blockquote><p>每一个模式描述了一个在我们周围不断变化重复发生的问题及该问题解决方案的核心。这样就能一次次的使用该方案而不必做重复的工作。</p></blockquote><p>这是经过很多个实践，被很多网站重复使用而逐渐形成大型网站架构模式：</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>将系统再横向维度上切成几个部分，每个部分负责一部分相对单一的职责。就好比平时一份工作比较多的时候，团队中大家各自负责自己擅长的那一部分。大型网站中一般分为三层：</p><ul><li>应用层：负责具体业务和视图展示。</li><li>服务层：为应用层提供服务支持。</li><li>数据层：提供数据存储访问服务。如数据库、缓存、文件、搜索引擎等。<br>需要注意的是：这个分层是逻辑的，并不一定要部署在不同的服务器上，可能会根据业务调整。  </li></ul><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>对业务进行横向切分。比如应用层：分为购物、论坛、搜索等。  </p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>一台服务器解决不了的时候，就采用分布式解决一下。<br>分为：分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算。  </p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>使用分布式已经将分层和分割后的模块独立部署，但是对于用户集中访问的模块，可能还需要将独立部署的服务器集群化（多台服务器部署相同的应用构成一个集群），再通过一个负载均衡服务器对外提供服务。  </p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存是改善软件性能的第一手段。</p><ul><li>CDN：讲内容部署在离用户最近的网络服务商，用户请求的时候，可以直接访问网络服务商缓存的静态资源，所以会很快。</li><li>反向代理：用户请求到网站的数据中心时，最先访问的是反向代理服务器，这里会缓存网站的静态资源。</li><li>本地缓存：应用服务器本地缓存的热点数据，可以在本机内存中直接访问，不需要访问数据库。</li><li>分布式缓存：数据量非常庞大时，需要的内存不是单机能承受的。因此还需要分布式缓存    </li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步进行协作。<br>在单一服务器内部：采用<strong>多线程共享队列</strong>的方式实现异步。在分布式系统中：多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看做内存的分布式部署。</p><p>分布式消息队列的特性：网站扩展新功能便利，提高系统可用性，加快网站响应速度，消除并发访问高峰。  </p><h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>备份嘛，较少的机器可能坏的时间不长，但是小概率时间试验的次数过多的话就基本是必然事件了。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>主要集中在运维方面，包括：发布过程自动化、自动化代码管理、自动化测试、自动化安全监测、自动化部署。对于运行中：自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降级、自动化分配资源。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>密码和手机验证码；加密；网站验证码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大型网站架构技术-架构模式&quot;&gt;&lt;a href=&quot;#大型网站架构技术-架构模式&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构技术-架构模式&quot;&gt;&lt;/a&gt;大型网站架构技术-架构模式&lt;/h2&gt;&lt;p&gt;模式的关键在于模式的可重复性。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="大型网站技术" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构技术-演化</title>
    <link href="http://yoursite.com/03-evolution-of-webArchitecture/"/>
    <id>http://yoursite.com/03-evolution-of-webArchitecture/</id>
    <published>2018-02-03T05:43:26.000Z</published>
    <updated>2018-05-13T13:53:47.793Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="大型网站架构技术-演化"><a href="#大型网站架构技术-演化" class="headerlink" title="大型网站架构技术-演化"></a>大型网站架构技术-演化</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>高并发、大流量</li><li>高可用</li><li>海量数据</li><li>用户分布广泛、网络情况复杂</li><li>安全环境恶劣：易受攻击</li><li>需求变化快、发布频繁：为了快速适应市场</li><li>渐进式发展：逐渐进步发展</li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><h3 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h3><p>应用程序、数据库、文件等所有资源都在一台服务器上。一般是在一台廉价的服务器上采用LAMP这种免费资源。</p><h3 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h3><p>采用三台服务器分别承担自己的角色。</p><h3 id="使用缓存改善网站的性能"><a href="#使用缓存改善网站的性能" class="headerlink" title="使用缓存改善网站的性能"></a>使用缓存改善网站的性能</h3><p>二八定律：80%的业务访问集中在20%的数据上，为了减少数据库的访问压力，可以将一些数据放到缓存服务器上，这样可以提高整个网站的数据访问速度。<br>一般分为两种：</p><ul><li>缓存在应用服务器上的本地缓存：访问速度快，但缓存的数据有限；</li><li>缓存在专门的分布式缓存服务器上的远程缓存：可以采用分布式缓存。<h3 id="采用应用服务器改善网站并发处理能力"><a href="#采用应用服务器改善网站并发处理能力" class="headerlink" title="采用应用服务器改善网站并发处理能力"></a>采用应用服务器改善网站并发处理能力</h3>当应用服务器处理不了较多的并发请求时，可以增加一台服务器分担原有的服务器的访问，在前面加一个负载均衡服务器。<h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3>虽然采用了缓存，但有一些<strong>读操作和一部分写操作</strong>还是会落到数据库上。一般采用主从备份的数据库，写操作可以在主数据库中进行，读操作在从数据库中读取。<h3 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h3>加速用户的访问。基本原理都是缓存，CDN是部署在网络提供商的机房，反向代理部署在网站的中心机房。对于反向代理，用户首先访问的是反向代理服务器，如果反向代理服务器中缓存着资源，就直接返回给用户。<h3 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h3>持续增长的业务，单一的服务器满足不了要求的时候，一头牛拉不动的时候，不要企图换一头更厉害的牛，而是考虑再加一头牛一起拉。<h3 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h3>网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，需要采用一些非关系数据库技术和非数据库查询技术如搜索引擎。<h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3>分而治之<h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;大型网站架构技术-演化&quot;&gt;&lt;a href=&quot;#大型网站架构技术-演化&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构技术-演化&quot;&gt;&lt;/a&gt;大型网站架构技术-演化&lt;/h1&gt;&lt;h2 id=&quot;特点&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="大型网站技术" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-56and57-Merge-Intervals</title>
    <link href="http://yoursite.com/30-%E5%88%B7%E9%A2%98/LeetCode-56-Merge-Intervals/"/>
    <id>http://yoursite.com/30-刷题/LeetCode-56-Merge-Intervals/</id>
    <published>2018-01-30T08:00:00.000Z</published>
    <updated>2018-04-27T02:28:48.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-56-Merge-Intervals"><a href="#LeetCode-56-Merge-Intervals" class="headerlink" title="LeetCode-56-Merge-Intervals"></a>LeetCode-56-Merge-Intervals</h3><blockquote><p>Given a collection of intervals, merge all overlapping intervals.<br>For example,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Given [1,3],[2,6],[8,10],[15,18],</div><div class="line">return [1,6],[8,10],[15,18].</div></pre></td></tr></table></figure></p></blockquote><p>如例子中所示，每个数组的前后分别表示开始和结束，工作是合并有重叠的数组。例如，由于[1,3]和[2,6]有重叠，故直接改为[1,6]后输出。<br>想法还是比较简单的，因为输入的并不一定是给好的按照开始，所以需要先对输入以开始的值排序。首先在结果数组中写入第一个，只有遍历进行判断，分为两种情况：</p><ol><li>如果某一interval的开始比结果数组中的结尾要大，显然不会有重叠，直接写入到结果数组中即可；</li><li>某一interval的开始比结果数组中的结尾要大，必然有重叠，此时还需要判断结束位置的大小。</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for an interval.</div><div class="line"> * struct Interval &#123;</div><div class="line"> *     int start;</div><div class="line"> *     int end;</div><div class="line"> *     Interval() : start(0), end(0) &#123;&#125;</div><div class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</div><div class="line">        vector&lt;Interval&gt; res;</div><div class="line">        if(intervals.size()&lt;=0)</div><div class="line">            return res;</div><div class="line">        sort(intervals.begin(),intervals.end(),[](Interval a,Interval b)&#123;return a.start&lt;b.start;&#125;);</div><div class="line">        res.push_back(intervals[0]);</div><div class="line">        for(int i=1;i&lt;intervals.size();++i)&#123;</div><div class="line">            if(res.back().end&lt;intervals[i].start) res.push_back(intervals[i]);</div><div class="line">            else&#123;</div><div class="line">                res.back().end=max(res.back().end,intervals[i].end);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57-Insert-Interval"></a>57-Insert-Interval</h3><blockquote><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).<br>You may assume that the intervals were initially sorted according to their start times.</p></blockquote><p>题目改为向一个已经重叠的数组中加入新加入一个。需要做的是判断所处的位置，插入进去后还要删掉，值得注意的是这个删掉值的时候，vector的迭代器会发生变化，即有些会失效，所以最好的做法是，先插入，把需要的插入都插入之后再删除。</p><p>另外还有一个值得注意的是，排序搜索的谓语，使用的是<code>a.end&lt;b.start</code>，而不是之前的<code>a.start&lt;b.start</code> ，原因是需要找到一个范围，将newINterval夹在中间的一个范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for an interval.</div><div class="line"> * struct Interval &#123;</div><div class="line"> *     int start;</div><div class="line"> *     int end;</div><div class="line"> *     Interval() : start(0), end(0) &#123;&#125;</div><div class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</div><div class="line">        if(intervals.size()&lt;=0)&#123;</div><div class="line">            intervals.push_back(newInterval);</div><div class="line">            return intervals;</div><div class="line">        &#125;</div><div class="line">        auto range=equal_range(intervals.begin(),intervals.end(),newInterval,[](Interval a,Interval b)&#123;return a.end&lt;b.start;&#125;);</div><div class="line">        auto iter1=range.first,iter2=range.second;</div><div class="line">        if(iter1==iter2)</div><div class="line">            intervals.insert(iter1,newInterval);</div><div class="line">        else&#123;</div><div class="line">            iter2--;</div><div class="line">            iter2-&gt;start=min(newInterval.start,iter1-&gt;start);</div><div class="line">            iter2-&gt;end=max(newInterval.end,iter2-&gt;end);</div><div class="line">            intervals.erase(iter1,iter2);</div><div class="line">        &#125;</div><div class="line">        return intervals;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-56-Merge-Intervals&quot;&gt;&lt;a href=&quot;#LeetCode-56-Merge-Intervals&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-56-Merge-Intervals&quot;&gt;&lt;/a&gt;LeetC
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-55-Jump-Game</title>
    <link href="http://yoursite.com/30-%E5%88%B7%E9%A2%98/LeetCode-55-Jump-Game/"/>
    <id>http://yoursite.com/30-刷题/LeetCode-55-Jump-Game/</id>
    <published>2018-01-30T07:39:55.000Z</published>
    <updated>2018-04-27T02:28:48.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-55-Jump-Game"><a href="#LeetCode-55-Jump-Game" class="headerlink" title="LeetCode-55-Jump-Game"></a>LeetCode-55-Jump-Game</h3><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.</p></blockquote><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = [2,3,1,1,4], return true.</div><div class="line"></div><div class="line">A = [3,2,1,0,4], return false.</div></pre></td></tr></table></figure></p><p>由题可知，数组的位置表示从该位置可以像前跳的步数，看最终能否跳到结尾。乍一看，这像是一个动态规划的问题，dp数组内存储每一个位置能够走的最远的位置，但是仔细一想，又是没有必要的，因为最终的目的不是为了判断哪一个位置能走的更远，而是能否到达最后一个位置。<br>能到达最后一个位置的必要条件，显然一个就是能从某一位置继续往前走，而不会断。例如：<code>[3,2,1,0,4]</code>，我们都能走到第4个位置，但是却无法继续往前走，故到不了最后一个。所以代码可以做一个判断。<br>另一个需要考虑的问题是：在从前往后遍历的过程中，维护哪一个变量？显然这个变量记录的是我们能走的最远的距离，如果这个距离走的更远就更新，直到不能继续往前走，此时判断能否到终点。</p><p>贴上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int i=0;</div><div class="line">        for(int reach=0;i&lt;nums.size()&amp;&amp;i&lt;=reach;++i)</div><div class="line">            reach=max(reach,i+nums[i]);</div><div class="line">        return i==nums.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-55-Jump-Game&quot;&gt;&lt;a href=&quot;#LeetCode-55-Jump-Game&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-55-Jump-Game&quot;&gt;&lt;/a&gt;LeetCode-55-Jump-Game&lt;/
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-53-Maximum-Subarray</title>
    <link href="http://yoursite.com/26-%E5%88%B7%E9%A2%98/LeetCode-53-Maximum-Subarray/"/>
    <id>http://yoursite.com/26-刷题/LeetCode-53-Maximum-Subarray/</id>
    <published>2018-01-26T09:57:03.000Z</published>
    <updated>2018-04-27T02:28:48.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-53-Maximum-Subarray"><a href="#LeetCode-53-Maximum-Subarray" class="headerlink" title="LeetCode-53-Maximum-Subarray"></a>LeetCode-53-Maximum-Subarray</h2><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.<br>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p></blockquote><p>最长子序列，又是一个动态规划的问题，关于动态规划，我们最主要的是要维护DP数组，这个问题以前还有点不理解，感觉主要的还是思想，只要知道这是一个动态规划的问题，解决动态规划的一般方法掌握了，其他的就都是细节了。</p><p>最近刷算法题，不得不想到的是以前的数学，数学是逻辑性可能更强的东西，尚且需要多做练习才行，何况算法了。当然现在慢慢的感觉就是，以前看到很多题完全没有头绪，现在很多大概是能分清是想考啥了，也会想着主动去选择相应的数据结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;int&gt; dp(nums.size(),0);</div><div class="line">        dp[0]=nums[0];</div><div class="line">        int res=dp[0];</div><div class="line">        for(int i=1;i&lt;nums.size();++i)&#123;</div><div class="line">            dp[i]=nums[i]+(dp[i-1]&gt;0?dp[i-1]:0);</div><div class="line">            res=max(dp[i],res);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LeetCode-53-Maximum-Subarray&quot;&gt;&lt;a href=&quot;#LeetCode-53-Maximum-Subarray&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-53-Maximum-Subarray&quot;&gt;&lt;/a&gt;Le
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-52-N-Queens-II</title>
    <link href="http://yoursite.com/26-%E5%88%B7%E9%A2%98/LeetCode-52-N-Queens-II/"/>
    <id>http://yoursite.com/26-刷题/LeetCode-52-N-Queens-II/</id>
    <published>2018-01-26T09:00:24.000Z</published>
    <updated>2018-04-27T02:28:48.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-52-N-Queens-II"><a href="#LeetCode-52-N-Queens-II" class="headerlink" title="LeetCode-52-N-Queens-II"></a>LeetCode-52-N-Queens-II</h3><blockquote><p>Follow up for N-Queens problem.<br>Now, instead outputting board configurations, return the total number of distinct solutions.</p></blockquote><p>只返回N皇后问题结果的种数。<br>因此不需要每一个字符串置位了，只需要判断一个位置的横竖，斜45度和斜135度方向的值即可。依然采用递归的方式，这里需要注意的是，由于是对列递归，所以需要考虑的是行，斜45度，斜135度，本来是要维护一个一维数组和两个二维数组，但是想到二维数组的特征，可以改为维护三个一维数组，这两个一维数组保存的是将二维数组展开的信息。甚至是一波操作改为共维护两个一维数组也可以。<br>接下来是代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int totalNQueens(int n) &#123;</div><div class="line">        vector&lt;int&gt; rows(n),d1(2*n-1),d2(2*n-1);</div><div class="line">        return find(n,n,0,rows,d1,d2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int find(int n,int left,int i,vector&lt;int&gt;&amp; rows,vector&lt;int&gt;&amp; d1,vector&lt;int&gt;&amp; d2)&#123;</div><div class="line">        if(left==0)</div><div class="line">            return 1;</div><div class="line">        int j,sum=0;</div><div class="line">        for(j=0;j&lt;n;++j)&#123;</div><div class="line">            if(rows[j]||d1[i+j]||d2[n-1+i-j])</div><div class="line">                continue;</div><div class="line">            rows[j]=d1[i+j]=d2[n-1+i-j]=1;</div><div class="line">            sum+=find(n,left-1,i+1,rows,d1,d2);</div><div class="line">            rows[j]=d1[i+j]=d2[n-1+i-j]=0;</div><div class="line">        &#125;</div><div class="line">        return sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>看了一下别人的好像确实快一点，毕竟0ms啊，也贴一下别人的代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int totalNQueens(int n) &#123;</div><div class="line">        bool flag[5*n] = &#123;false&#125;;</div><div class="line">        int num = 0;</div><div class="line">        dfs(num,flag,0,n);</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void dfs(int&amp; num, bool* flag, int row, int n)&#123;</div><div class="line">        if(row == n)&#123;</div><div class="line">            ++num;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i = 0; i&lt;n;i++)&#123;</div><div class="line">            if(!flag[i] &amp;&amp; !flag[row+i+n] &amp;&amp; !flag[4*n + row - i])&#123;</div><div class="line">                flag[i] = 1;</div><div class="line">                flag[row+i+n] = 1;</div><div class="line">                flag[4*n + row - i] = 1;</div><div class="line">                dfs(num,flag,row+1,n);</div><div class="line">                flag[i] = 0;</div><div class="line">                flag[row+i+n] = 0;</div><div class="line">                flag[4*n + row - i] = 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h4><p><a href="https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand" target="_blank" rel="external">https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-52-N-Queens-II&quot;&gt;&lt;a href=&quot;#LeetCode-52-N-Queens-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-52-N-Queens-II&quot;&gt;&lt;/a&gt;LeetCode-52-N-Que
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-51-N-Queens</title>
    <link href="http://yoursite.com/26-%E5%88%B7%E9%A2%98/LeetCode-51-N-Queens/"/>
    <id>http://yoursite.com/26-刷题/LeetCode-51-N-Queens/</id>
    <published>2018-01-26T02:12:49.000Z</published>
    <updated>2018-04-27T02:28:48.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-51-N-Queens"><a href="#LeetCode-51-N-Queens" class="headerlink" title="LeetCode-51-N-Queens"></a>LeetCode-51-N-Queens</h3><p>经典的N皇后问题，重点是全排列的问题，但是这里由于N皇后的不重复行、列、斜的要求，在排列的过程中，比如从行开始排列，只能保证同行不重复，所以需要引入isValid函数。通过判断列，左斜、右斜是否重复。</p><p>需要注意的是：关于全排列递归的写法，要更加熟练掌握才行，并且能完全理解，能够在不同的情况中灵活运用。其基本思想还是：固定前面的某个数字，不短的对后面进行交换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isValid(vector&lt;string&gt;&amp; queen, int row,int col,int n)&#123;</div><div class="line">        for(int i=0;i&lt;row;++i)&#123;</div><div class="line">            if(queen[i][col]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;--i,--j)&#123;</div><div class="line">            if(queen[i][j]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;--i,++j)&#123;</div><div class="line">            if(queen[i][j]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    void recurse(vector&lt;string&gt;&amp; queen,vector&lt;vector&lt;string&gt;&gt;&amp; res,int row,int n)&#123;</div><div class="line">        if(row==n)&#123;</div><div class="line">            res.push_back(queen);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int col=0;col!=n;++col)&#123;</div><div class="line">            if(isValid(queen,row,col,n))&#123;</div><div class="line">                queen[row][col]=&apos;Q&apos;;</div><div class="line">                recurse(queen,res,row+1,n);</div><div class="line">                queen[row][col]=&apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">        vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">        vector&lt;string&gt; queen(n,string(n,&apos;.&apos;));</div><div class="line">        recurse(queen,res,0,n);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-51-N-Queens&quot;&gt;&lt;a href=&quot;#LeetCode-51-N-Queens&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-51-N-Queens&quot;&gt;&lt;/a&gt;LeetCode-51-N-Queens&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-49-Group-Anagrams</title>
    <link href="http://yoursite.com/25-%E5%88%B7%E9%A2%98/LeetCode-49-Group-Anagrams/"/>
    <id>http://yoursite.com/25-刷题/LeetCode-49-Group-Anagrams/</id>
    <published>2018-01-25T13:44:37.000Z</published>
    <updated>2018-04-27T02:28:48.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-49-Group-Anagrams"><a href="#LeetCode-49-Group-Anagrams" class="headerlink" title="LeetCode-49-Group-Anagrams"></a>LeetCode-49-Group-Anagrams</h3><blockquote><p>Given an array of strings, group anagrams together.<br>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],</p></blockquote><p>Return:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],</div><div class="line">  [&quot;nat&quot;,&quot;tan&quot;],</div><div class="line">  [&quot;bat&quot;]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>输入一个字符串数组，输出的是：将相同字符的字符串放在一个数组的二维数组。相同字符的处理，基本就是要对字符串排序的。然后需要考虑的就是排序好的那一个字符串怎么存的问题。用的数据结构是map，string为键，对应的值是一个set或者是一个vector，存放满足要求的string，之后再用这个初始化结果数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class="line">        unordered_map&lt;string,multiset&lt;string&gt;&gt; map_str;</div><div class="line">        for(string s:strs)&#123;</div><div class="line">            string t=s;</div><div class="line">            sort(t.begin(),t.end());</div><div class="line">            map_str[t].insert(s);</div><div class="line">        &#125;</div><div class="line">        vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">        for(auto temp:map_str)&#123;</div><div class="line">            vector&lt;string&gt; vec_str_temp(temp.second.begin(),temp.second.end());</div><div class="line">            res.push_back(vec_str_temp);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>后来发现用vector其实要好一些。只是别人这么写的，时间竟然要短一点，毕竟是用vector初始化vector？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-49-Group-Anagrams&quot;&gt;&lt;a href=&quot;#LeetCode-49-Group-Anagrams&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-49-Group-Anagrams&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
