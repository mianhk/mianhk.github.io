<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mianhk&#39;s notes</title>
  
  <subtitle>这个人很懒，动不动就不想写</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-10T13:57:38.301Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mianhk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-15-3Sum</title>
    <link href="http://yoursite.com/2018/01/10/%E5%88%B7%E9%A2%98/LeetCode-15-3Sum/"/>
    <id>http://yoursite.com/2018/01/10/刷题/LeetCode-15-3Sum/</id>
    <published>2018-01-10T13:57:08.000Z</published>
    <updated>2018-01-10T13:57:38.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h3><blockquote><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Note: The solution set must not contain duplicate triplets.</div><div class="line">For example, given array S = [-1, 0, 1, 2, -1, -4],</div><div class="line"></div><div class="line">A solution set is:</div><div class="line">[</div><div class="line">  [-1, 0, 1],</div><div class="line">  [-1, -1, 2]</div><div class="line">]</div></pre></td></tr></table></figure><p>同之前的2sum差不多，计算两个的和的方式是：为了避免重复，重新用一个set容器，解决重复的问题。但是这里的情况是，重复的一个数字是可以出现的，而且是三个数字相加的和，所以我们没法用之前的处理办法。<br>很容易想到的办法是，先让一个指针向前走，然后对之后的数字搜索，为了减少搜索的复杂度，我们可以先将数组进行排序，先排序后搜索，可以从<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">然而这里需要注意的是，需要判断数组中有相同数字的情况。虽然结果中允许有相同的数字出现，但不允许出现完全相同的两个结果，所以需要处理这种情况。</div><div class="line">具体的代码如下：</div></pre></td></tr></table></figure></p><p>class Solution {<br>public:<br>    vector<vector<int>&gt; threeSum(vector<int>&amp; nums) {<br>        vector<vector<int>&gt; res;<br>        if(nums.size()&lt;=0)<br>            return res;<br>        sort(nums.begin(),nums.end());<br>        for(int i=0;i<nums.size()&&nums[i]<=0;++i){ int="" j="i+1,k=nums.size()-1;" while(j<k){="" if(nums[i]+nums[j]+nums[k]<0)="" j++;="" else="" if(nums[i]+nums[j]+nums[k]="">0)<br>                        –k;<br>                    else if(nums[i]+nums[j]+nums[k]==0){<br>                        vector<int> temp(3,0);<br>                        temp[0]=nums[i];<br>                        temp[1]=nums[j];<br>                        temp[2]=nums[k];<br>                        res.push_back(temp);<br>                        while(k&gt;j&amp;&amp;nums[k]==temp[2]) //去除k的重复<br>                            k–;<br>                        while(k&gt;j&amp;&amp;nums[j]==temp[1]) //去除j的重复<br>                            j++;<br>                    }<br>                }<br>                while(i+1&lt;nums.size()&amp;&amp;nums[i+1]==nums[i])  //去除i的重复<br>                    i++;<br>            }<br>        return res;<br>    }<br>};<br>```</int></nums.size()&&nums[i]<=0;++i){></vector<int></int></vector<int></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;15-3Sum&quot;&gt;&lt;a href=&quot;#15-3Sum&quot; class=&quot;headerlink&quot; title=&quot;15. 3Sum&quot;&gt;&lt;/a&gt;15. 3Sum&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Given an array S of n integers, are
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-8-String to Integer (atoi)</title>
    <link href="http://yoursite.com/2018/01/09/%E5%88%B7%E9%A2%98/LeetCode-8-String-to-Integer-atoi/"/>
    <id>http://yoursite.com/2018/01/09/刷题/LeetCode-8-String-to-Integer-atoi/</id>
    <published>2018-01-09T14:24:41.000Z</published>
    <updated>2018-01-09T14:34:23.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8.String to Integer (atoi)"></a>8.String to Integer (atoi)</h3><blockquote><p>Implement atoi to convert a string to an integer.</p></blockquote><p>讲字符串转化为整型。当然过程很简单，但是需要考虑的乱七八糟的情况很多，空格和正负号之类的。提交了一百次，终于过了，但是看到别人的代码还是很气呀，还是得多写才行，但是起码写的慢慢有感觉了是吧。<br>总体思路基本都是差不多的：<br>1.循环字符串，从第一个开始不为空的字符开始判断，如果是正负号，则只能有一个正负号，进行标记，数字开始。<br>2.数字开始之后，出现空格或者字母，返回已经生成的整型。<br>3.当数字大于最大的整数或者小于最小的整数的时候，应该将其置为最大或者最小。所以这里应该将结果定义为long long int ，不然当加到INT_MAX的时候，会自动+1，置为INT_MIN，应该避免这样的情况。<br>这里贴一下自己改的乱七八糟的代码吧，实在很气呀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int myAtoi(string str) &#123;</div><div class="line">        int flag=1;</div><div class="line">        long long int res=0;</div><div class="line">        int begin=-1;</div><div class="line">        for(int i=0;i&lt;str.size();++i)&#123;</div><div class="line">            if(str[i]==&apos;-&apos;||str[i]==&apos;+&apos;)&#123;</div><div class="line">                if(begin!=-1)</div><div class="line">                    return 0;</div><div class="line">                begin=i;</div><div class="line">                flag=str[i]==&apos;-&apos;?-1:1;</div><div class="line">            &#125;</div><div class="line">            else if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123;</div><div class="line">                begin=i;</div><div class="line">                res=res*10+str[i]-48;</div><div class="line">                if(res*flag&gt;INT_MAX)</div><div class="line">                    return INT_MAX;</div><div class="line">                if(res*flag&lt;INT_MIN)</div><div class="line">                    return INT_MIN;</div><div class="line">            &#125;</div><div class="line">            else if(str[i]==&apos; &apos;)&#123;</div><div class="line">                if(begin!=-1)</div><div class="line">                    return res*flag;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                return res*flag;</div><div class="line">        &#125;</div><div class="line">        return res*flag;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>提交一看，这个时间还有点问题，就懒得自己再改了，思路都是一样的吧，就直接贴过来学习一下了，即使我觉得写的也一般呀。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int myAtoi(string str) &#123;</div><div class="line">        int i = 0;</div><div class="line">        long long res = 0;</div><div class="line">        if(str.size() == 0)</div><div class="line">            return res;</div><div class="line"></div><div class="line">        while(i &lt; str.size() &amp;&amp; str[i] == &apos; &apos;)</div><div class="line">            i++;</div><div class="line"></div><div class="line">        int flag = 1;</div><div class="line">        if(str[i] == &apos;+&apos;)</div><div class="line">            i++;</div><div class="line">        else if(str[i] == &apos;-&apos;)</div><div class="line">        &#123;</div><div class="line">            flag = -1;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        while(str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;)</div><div class="line">        &#123;</div><div class="line">            res = res * 10 + str[i] - &apos;0&apos;;</div><div class="line">            i++;</div><div class="line">        if(res * flag &gt;= INT_MAX)</div><div class="line">            return INT_MAX;</div><div class="line">        if(res * flag &lt;= INT_MIN)</div><div class="line">            return INT_MIN;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        return res * flag;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;8-String-to-Integer-atoi&quot;&gt;&lt;a href=&quot;#8-String-to-Integer-atoi&quot; class=&quot;headerlink&quot; title=&quot;8.String to Integer (atoi)&quot;&gt;&lt;/a&gt;8.String to 
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>精剪生活</title>
    <link href="http://yoursite.com/2017/12/10/cut-life/"/>
    <id>http://yoursite.com/2017/12/10/cut-life/</id>
    <published>2017-12-10T11:57:26.000Z</published>
    <updated>2017-12-10T12:49:29.976Z</updated>
    
    <content type="html"><![CDATA[<p>好像从小的时候开始，拥有各种感兴趣的事情或者不只是好好学习就像一种美德一样充斥于我们与同龄人的自己的生活中。就像小时候打的弹珠和后面看的小说乒乓球和dota一样。哦，对，应该说是合群，或者是接地气，就是所有与同龄人正常社交所需的娱乐活动吧。所以作为一个老师口中活泼开朗的学生，这些我基本都有，可能玩的不一定好，但是so what，只要不是像“那些只爱学习的同学”一样，好像都够了。</p><p>于是，也不知道什么时候就慢慢形成了广泛的娱乐活动了。直到现在，想起自己好像啥都能参与，就像篮球里能够从1打到5的那种全能型选手，不一定有机会上场，但总是差不多合格一样。<br>想一下现在自己的娱乐：</p><ul><li>打球？篮球、羽毛球、乒乓球，都可以打一些。虽然现在打篮球确实少了很多了，一个是宿舍就我一个人去，这样就很多时候懒得去了。羽毛球呢，总觉得要是四个人比较好，但是又对天气有些要求。还有乒乓球，需要有个水平不是很厉害还愿意跟我 打的了。。。</li><li>打麻将？这个简直是好约啊，四个人可以动脑或者不动脑的室内活动，主动或者三缺一的要求，都是相当的容易，这种活动还一般安排在吃饭的后边，就像你有时候也没法拒绝吃饱之后某个茶楼的茶一样，因为即使回去也还是睡觉是吧，而且自己总是告诉自己不要把生命浪费在床上。</li><li>各种吃饭？是的，忘了多少个睡到十点的周末，大家在一边互相催着起床一边讨论中午吃什么，于是由简单的黄焖鸡变成了鸡公煲，自助、火锅。。然后就是一个白天很快就过去了。</li><li>打游戏？简直是不可或缺的一部分啊。好像之前一年已经很少玩了。直到暑假开始玩的一个垃圾手游，轩辕传奇，几乎每天要花一个多小时的时间吧，想了一下，占据了我基本每天吃完午饭到睡觉之前和晚上回到宿舍到上床的一段时间。这段时间本来就不是很长，但是却被我用的看起来更紧张了。还有偶尔同学们约的王者荣耀，我基本自己都没有打过。还有最近的荒野行动，也是周末晚上或者正好十点多的上午才会有的娱乐。</li><li>看书？当然，我还是愿意把这个算进去。毕竟看的一些闲书，不能说没用，但确实是一种娱乐了吧。占据了上床到睡觉之前的不玩手机的时间，这个时间可能更短了。</li><li>然后，实验室玩手机？这个就不多说了，想想每天的手机电量吧。</li><li>乱七八糟的折腾？额，年轻的特征吗。。没意思的东西还是少弄点了吧</li></ul><p>这样看的话其实生活好像也很正常的，但是却是感觉每天，或者周末都很忙，忙了还不知道自己干了啥。有些难受。而且这好像也是自己写的第二篇这种苦恼了，上一次也是觉得这样的周末，但是两周过去了，好像还没有好多少，可能周末确实适合这么过，但是显然不是现在。<br>接下来需要做的，就是精简生活了，不是什么活动都需要参加的是吧，也不是什么都需要自己关注的是吧，也不用总是活在一个中心。<strong> 先专注做好自己现在该做的事情，或者先想想？</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好像从小的时候开始，拥有各种感兴趣的事情或者不只是好好学习就像一种美德一样充斥于我们与同龄人的自己的生活中。就像小时候打的弹珠和后面看的小说乒乓球和dota一样。哦，对，应该说是合群，或者是接地气，就是所有与同龄人正常社交所需的娱乐活动吧。所以作为一个老师口中活泼开朗的学生
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂想" scheme="http://yoursite.com/tags/%E6%9D%82%E6%83%B3/"/>
    
      <category term="记录" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-剑指offer-11</title>
    <link href="http://yoursite.com/2017/12/03/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-11/"/>
    <id>http://yoursite.com/2017/12/03/牛客网-剑指offer-11/</id>
    <published>2017-12-03T12:44:21.000Z</published>
    <updated>2017-12-03T14:00:32.524Z</updated>
    
    <content type="html"><![CDATA[<h4 id="T31：把数组排成最小的数"><a href="#T31：把数组排成最小的数" class="headerlink" title="T31：把数组排成最小的数"></a>T31：把数组排成最小的数</h4><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p></blockquote><p>这里想到的是，要对数组里面的所有数进行一个排序：不只是排长度，还要排最高位的大小。于是可以通过c++的STL的排序，通过自己定义的一个谓语比较函数。在这个比较函数里，把整数转成string进行比较，但是想到string的长度不一样的话也没法比较字符的大小了。所以分别将两个数加在一起，前后顺序不同，这样string的长度就一样了，比较的就是顺序了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</div><div class="line">        string result;</div><div class="line">        sort(numbers.begin(),numbers.end(),cmp);</div><div class="line">        for(int i=0;i!=numbers.size();++i)&#123;</div><div class="line">            result+=to_string(numbers[i]);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static bool cmp(int a,int b)&#123;</div><div class="line">        string A=to_string(a)+to_string(b);</div><div class="line">        string B=to_string(b)+to_string(a);</div><div class="line">        return A&lt;B;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T32：丑数"><a href="#T32：丑数" class="headerlink" title="T32：丑数"></a>T32：丑数</h4><blockquote><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p></blockquote><p>要求出第N个丑数，显然就要求到这N个，所以就要把所有的找出来嘛。简单的办法，就是2,3，5的倍数，但是这些倍数出来的丑数的顺序，这时候需要排序。显然不能直接对所有的都排序，那复杂度就太大了。这里一种考虑就是：比如，对于一次倍数的计算，如果2的倍数比原来的都大，那么3和5的倍数显然只会更大了。所以可以通过记录下此时分别为2,3,5倍数三个值，这样就可以减少比较的次数了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int GetUglyNumber_Solution(int index) &#123;</div><div class="line">        if(index==0)</div><div class="line">            return 0;  //解决边界条件</div><div class="line">        vector&lt;int&gt; result(index);</div><div class="line">        result[0]=1;</div><div class="line">        int x=0,y=0,z=0,i;</div><div class="line">        for(i=1;i&lt;index;i++)&#123;</div><div class="line">            result[i]=min(result[x]*2,min(result[y]*3,result[z]*5));</div><div class="line">            if(result[i]==result[x]*2)</div><div class="line">                x++;</div><div class="line">            if(result[i]==result[y]*3)</div><div class="line">                y++;</div><div class="line">            if(result[i]==result[z]*5)</div><div class="line">                z++;</div><div class="line">        &#125;</div><div class="line">        return result[index-1];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T33：第一个只出现一次的字符"><a href="#T33：第一个只出现一次的字符" class="headerlink" title="T33：第一个只出现一次的字符"></a>T33：第一个只出现一次的字符</h4><blockquote><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p></blockquote><p>很容易想到的一种复杂度为O(n)的算法是采用哈希表，遍历一次，将出现的字符放在键中，出现一次即在值中加1。第二次遍历，直接查找该键对应的值，第一个为1的输出即可。当然，这里由于是字符，所以可以直接采用数组的形式。<strong> 一定要记得对数组进行初始化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int FirstNotRepeatingChar(string str) &#123;</div><div class="line">        if(str.size()==0)</div><div class="line">            return -1;        //处理边界条件</div><div class="line">        int res[256]=&#123;0&#125;;  //局部变量，一定要初始化啊</div><div class="line">        int i=0;</div><div class="line">        for(;i!=str.size();++i)&#123;</div><div class="line">            res[(int)str[i]]++;</div><div class="line">        &#125;</div><div class="line">        for(i=0;i!=str.size();++i)&#123;</div><div class="line">            if(res[(int)str[i]]==1)</div><div class="line">                return i;</div><div class="line">        &#125;</div><div class="line">        return str.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;T31：把数组排成最小的数&quot;&gt;&lt;a href=&quot;#T31：把数组排成最小的数&quot; class=&quot;headerlink&quot; title=&quot;T31：把数组排成最小的数&quot;&gt;&lt;/a&gt;T31：把数组排成最小的数&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;输入一个正整数数组，把数组
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="牛客网" scheme="http://yoursite.com/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-剑指offer-10</title>
    <link href="http://yoursite.com/2017/12/01/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-10/"/>
    <id>http://yoursite.com/2017/12/01/牛客网-剑指offer-10/</id>
    <published>2017-12-01T13:11:56.000Z</published>
    <updated>2017-12-03T14:00:30.996Z</updated>
    
    <content type="html"><![CDATA[<h4 id="T28：最小的K个数"><a href="#T28：最小的K个数" class="headerlink" title="T28：最小的K个数"></a>T28：最小的K个数</h4><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p></blockquote><ul><li>解法一：剑指offer上给的有两种办法，一种是对数组进行排序，类似于快速排序的方式，假设基于第k个数来调整，就可以将比k小的数全放在左边，比k大的数都放在右边，于是，最后k左边的数即为最小的k个数。<br>优点：平均时间复杂度：O(n)，思路较快<br>缺点：需要修改数组</li><li>解法二：算法复杂度O(nlogk)，适合海量的数据。需要我们一个能存储k个数的容器，当容器中的数不足k个的时候，直接装进容器，当超过的时候，需要拿容器中最大的数与新的数进行比较，新数小的时候，替换已有的最大。如此，每一个新的数都需要判断，这样会增加复杂度，但是在海量数据处理的时候比较适合，因为无法一次把所有的数据都载入内存。<br>下面是解法二的代码：（没有采用multiset，直接用的vector排序的，原理一样，但是我的stl确实没有用好，下次再改吧）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</div><div class="line">        //没有考虑复杂度的情况，都是直接写的</div><div class="line">        vector&lt;int&gt; result;</div><div class="line">        //判断输入为空，或者k大于input的个数的情况</div><div class="line">        if(input.size()&lt;=0||k==0||k&gt;input.size())</div><div class="line">            return result;</div><div class="line">        vector&lt;int&gt;::iterator iter=input.begin();</div><div class="line">        for(;iter!=input.end();++iter)&#123;</div><div class="line">            sort(result.begin(),result.end());</div><div class="line">            if(result.size()&lt;k)</div><div class="line">                result.push_back(*iter);</div><div class="line">            else if(*iter&lt;*(result.end()-1))&#123;</div><div class="line">                result.pop_back();</div><div class="line">                result.push_back(*iter);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li></ul><h4 id="T29：连续子数组的最大和"><a href="#T29：连续子数组的最大和" class="headerlink" title="T29：连续子数组的最大和"></a>T29：连续子数组的最大和</h4><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><p>主要是想为什么会有最大的和，一个情况是，新加上的数比原来的数都要大，就要开始考虑需不需要原来的数了。所以我们需要两个数，一个保存最大的和，用来返回，一个 保存当前的和，可以在适当的时候丢掉。  另一种情况，加入的数都比原来的小，即都是负数的时候，可能最大和只是一个最小的数；另外，当都是正数的时候也比较好解决。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</div><div class="line">        if(array.size()==0)</div><div class="line">            return 0;</div><div class="line">        int curSum=array[0];//注意这里不能用0，因为会出现数组值全小于0的情况</div><div class="line">        int maxSum=array[0];</div><div class="line">        for(int i=1;i!=array.size();++i)&#123;</div><div class="line">            curSum+=array[i];</div><div class="line">            if(curSum&lt;array[i])</div><div class="line">                curSum=array[i];</div><div class="line">            if(maxSum&lt;curSum)</div><div class="line">                maxSum=curSum;</div><div class="line">        &#125;</div><div class="line">        return maxSum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T30-整数中1出现的个数-从1到n整数中1出现的个数"><a href="#T30-整数中1出现的个数-从1到n整数中1出现的个数" class="headerlink" title="T30:整数中1出现的个数(从1到n整数中1出现的个数)"></a>T30:整数中1出现的个数(从1到n整数中1出现的个数)</h4><blockquote><p>题目描述：求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数</p></blockquote><p>显然，最简单的思路，从1遍历到n是吧，因为要找到每个数中1的个数。先不说这个，问题的重点是，这个1的个数怎么找。<br>于是想到的是关于1存在的规律。比如很简单的就个位数而言，从0–9，只会出现一个1。由此想到，我们可以把n分成很多段进行计算。具体怎么分段，《剑指offer》上有个方法，不过确实有点难看明白了，就没有看，自己觉得可以按照从按10的倍数来分，1,10,100之类的，不过又有点问题，每个段内1的个数不一样，因为这样的话1的个数就不好算了。不过牛客网厉害的还是多啊，思路清晰，代码简洁。自己真的需要学习的有点多。不过后来又回头看了一下《剑指offer》上其实也是这样的。<br>那就直接复述一遍具体的思路吧：根据设定的整数位置，对n进行分割。这里就直接选10了，高位是a=n/10，低位是b=n%10，循环条件直接就是n*10了，这样就可以从最后一位到最高位的遍历了。<br>这里需要考虑的就是，a的最后一位，就是高位对应的最低位。</p><ul><li>当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1。</li><li>当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1。</li><li>当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）。<br>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int NumberOf1Between1AndN_Solution(int n)</div><div class="line">    &#123;</div><div class="line">        int count=0;</div><div class="line">        //n=1的情况</div><div class="line">        if(n==1)</div><div class="line">            return 1;</div><div class="line">        //考虑的边界情况，n=10,100,1000之类的，同时循环中没有考虑n=0的情况</div><div class="line">        if(n&gt;1&amp;&amp;n%10==0)</div><div class="line">            count++;</div><div class="line">        //没有考虑n=1的情况</div><div class="line">        for(int i=1;i&lt;n;i*=10)&#123;</div><div class="line">            int a=n/i,b=n%i;</div><div class="line">            //补8的效果：当百位为0，则a/10==(a+8)/10，</div><div class="line">            //当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</div><div class="line">            count+=(a+8)/10*i+(a%10==1)*(b+1);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;T28：最小的K个数&quot;&gt;&lt;a href=&quot;#T28：最小的K个数&quot; class=&quot;headerlink&quot; title=&quot;T28：最小的K个数&quot;&gt;&lt;/a&gt;T28：最小的K个数&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;输入n个整数，找出其中最小的K个数。例如输入4,5
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="牛客网" scheme="http://yoursite.com/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>一个可能很熟悉的周末</title>
    <link href="http://yoursite.com/2017/11/26/random-life-1/"/>
    <id>http://yoursite.com/2017/11/26/random-life-1/</id>
    <published>2017-11-26T13:12:29.000Z</published>
    <updated>2017-11-26T14:12:16.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2017-11-26-记录一个可能很熟悉的周末"><a href="#2017-11-26-记录一个可能很熟悉的周末" class="headerlink" title="2017-11-26 记录一个可能很熟悉的周末"></a>2017-11-26 记录一个可能很熟悉的周末</h3><p>这周又过去了，时间依旧是这么快啊，待在实验室跟上一周的感觉差不多，还是周日的下午，晚上才想起来来一下实验室，还是本来想周末搞个学习，却还是没有一不小心就休息过去了，非常单纯的尊重了一下周末。</p><p>先记个心里活动加流水吧，很无聊，但是还是想写一下，看一下自己的周末重播是怎样的。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">本来周五晚上就没有睡很晚，所以生物钟还是个好东西，一到周末就提醒我不要起的太早，于是醒</div><div class="line">来还是十点多了，躺在床上玩了一会游戏觉得有点罪过，就起床搞搞学习，嗯，十点多，算是个相</div><div class="line">对还不错的时间了，如果不是上周立了flag说是周末要学习一天的话，即使以前的我好像可以不分</div><div class="line">周末一样。</div><div class="line"></div><div class="line"></div><div class="line">没错，起床了就学习啊，还是先看一下游戏吧，刚刚打开就看到有人说，游戏现在可以电脑端挂着</div><div class="line">了，一想，这样就不用耽误我时间看平板了，直接电脑上从代码切过来很快的样子，毕竟这么多年</div><div class="line">的单身。于是开始准备下。想一下，这个流量。。赶紧查一查，还有一个多G，，算一下还有几天，</div><div class="line">今天才25，好像有点不够呀，还是不下了吧。不过仔细一想，下一个电脑端，多省事啊，毕竟我不</div><div class="line">是一个轻易被困难打倒的人，于是看了一下手机，还有3G流量，好像也有点不够用了啊。又想起来</div><div class="line">上个月月末的两个活动送的2G流量，看看能不能，于是赶紧一顿操作，我靠，竟然还有啊。只能不</div><div class="line">好意思安心开始下游戏了。</div><div class="line"></div><div class="line">哇，搞学习的时间终于开始了啊，额，这个宿舍环境，好像更适合看视频一点，打开教学视频，习</div><div class="line">惯的1.5倍速，连上云服务器，先操作一顿，看看上周用的vim的操作忘了没有。然后切到视频，额</div><div class="line">，这讲的也太慢了吧，完全不把我的基础当回事啊，这也讲。。 算了，切一下看看游戏下的怎么样</div><div class="line">了，19%，才这么点啊。切回去，切过来，25%，再切过来，咦，怎么不动了，难道热点断了，看一</div><div class="line">下手机，额，没有啊，==看，额，怎么错误了，怎么说。切回去把视频停一下，百度看看怎么回事。</div><div class="line">额，这垃圾游戏，百度都搜不到，额，这是啥啊，就是一个模拟器嘛，还下不下来。唉，算了，重试</div><div class="line">一遍吧。</div><div class="line"></div><div class="line">接下来是有点忧心忡忡的看着视频，一边心疼着流量啊，一边看。忍不了，切回去看看，2%,5%。。。</div><div class="line">额，40%，又不动了，又出错了。垃圾游戏，删掉。重新网上找一个。看一下手机，我靠，1G流量已经</div><div class="line">没了啊。算了，我去找个别的模拟器吧，还得搞学习呢，耽误我时间，分分钟搜到一个，赶紧下。 额</div><div class="line">，这次好像很顺利的样子，（百次切换后的十分钟。。）额，这个怎么有点不对的样子啊，头上怎么一</div><div class="line">个安卓的机器人啊，难道是只有安卓的才能用吗？这波就傻逼了。还先装的引擎，再下的游戏，额，这</div><div class="line">游戏都下了一半了，现在我是停不停啊，不会坑我吧。算了，中国有句古话说的好，来都来了是吧。。</div><div class="line">等等下完吧。</div><div class="line"></div><div class="line">终于下完了，我手机也提示2G的流量也没了。赶紧隆重的停一下视屏，装上看一看，额，怎么一个不是</div><div class="line">很熟悉的模拟器一样，上面就装了一个游戏，有点虚呀，兄弟。还是试试吧，擦，果然不可以啊，这下</div><div class="line">傻逼了。怎么说，哎，难道我老了，连这点都解决不了了。关机重启重下吧。</div><div class="line"></div><div class="line">重启！可是我的校园网没流量了啊，管他呢，先下了再说吧，出去吃饭了。。。。。。回来，赶紧看一</div><div class="line">下，哇，竟然下完了，看来西电的校园网还是有一点靠谱的嘛，装上试试，等等，这好像有点卡啊，这</div><div class="line">个，半天进不去啊。怎么他们说的可以啊，赶紧微信私聊一个人问一下，靠，他也很卡，刚刚自己还说</div><div class="line">可以的，擦。</div><div class="line"></div><div class="line">嗯，游戏总是很坑，但生活还得继续啊，周末的好天气也不忍心待在室内，难得在这个时间没有雾霾，</div><div class="line">已经快一点了，约的羽毛球和洗澡吃饭一条龙还没确定呢。赶紧找人啊，随便问一个，怎么不去？这也</div><div class="line">不去，只剩下我和这个破峰了？两个人怎么玩到四点去洗澡啊。额，再想想，于是看到师兄约篮球，要</div><div class="line">不怂恿看看？可是破峰竟然抛弃我准备先去洗澡了，但是这么好的天气，作为有点欠太阳的我是必须要</div><div class="line">出去运动一下的，那就去打篮球吧。。</div><div class="line"></div><div class="line">。。。</div><div class="line"></div><div class="line">打完球四点多，打的有点累啊，回来休息一波，也没啥事干，要不休息一下带这个破峰玩一局吧，结果</div><div class="line">洗澡就是五点多了，自己去洗个澡，买点吃的，回来还是用平板玩会游戏，吃个饭，给家里打个电话，</div><div class="line">已经七点多了，想起游戏有活动啊，上来看看，顺便看看视频，额，完全看不进去啊，还有点累啊。算</div><div class="line">了，随便看看视频之类的吧，反正不想学习。额，我的校园网没了，要不用免费网下个游戏吧，试试看</div><div class="line">怎么样，就荒野行动吧，反正最近这么火是吧，这个速度有点快啊，确定是我自己的网吗？看一下，是</div><div class="line">我的，放心不是书记的。下完了，再更新，额，怎么一兆多啊，不对啊，再看一下，果然是书记的，我</div><div class="line">靠，这就尴尬了 。。于是结果就是半个小时陪着这个破书记去搞了吃的额</div><div class="line"></div><div class="line">回来已经十点多了，游戏终于下好了，怂恿破峰下一个吧。我先去床上玩一把。于是玩到了12点了。该</div><div class="line">睡觉了，好困啊，睡吧。</div><div class="line"></div><div class="line">星期天到了，看来睡的早还是可以啊，八点多就醒了，简直是像上帝多要了两个多小时的生命啊，赶紧</div><div class="line">玩会游戏浪费一下，玩到九点，额，怎么有点困啊，算了，睡吧，昨天打球确实有点累啊，年纪大了，</div><div class="line">不能拉杆了啊。休息休息。。。已经11点了啊，赶紧起来看看，随便一收拾，又要吃饭了，唉，赶紧收</div><div class="line">拾一下衣服扔下去，然后吃个饭，去个超市回来正好收衣服，我真会过日子啊，哈哈。</div><div class="line"></div><div class="line">回来又是一点，挂好衣服，干啥了，听听歌，洗洗东西。额，快两点了啊，赶紧休息一下，三点了，想</div><div class="line">起来周末好像完全没学习啊，关键是还是入党的东西很多没填啊，还是去一下实验室吧。。</div></pre></td></tr></table></figure></p><p>终于差不多记完了，真的有点无聊，但是确实好像又好像拜托不了的周末啊，除了周内每天按时上班让人周末不想好好起床以外，还有一些确实需要做的事情，比如锻炼和洗刷，时间好像也就那些。或者再稍微加点娱乐，再加点别的赖床，晚上再睡晚一点，时间就更短了啊。</p><p>显然，时间当然没法安排的这么满，但是确实也不是一点留给该做事的时间都没有的。为什么别人都有了，而我只是看似想着学习却实际上啥都没干呢？<br>分析一下周末的时间：</p><ul><li><strong> 晚上的晚睡</strong>：没有理由的晚睡当然是透支了第二天的白天的时间，晚睡的一两个小时，直接一个上午几乎没了，然后下午再随便一玩，就觉得一天啥都没干。</li><li><strong> 无聊的折腾</strong>：有的时候很多的爱好并不是一件很好的事情，看看比赛的情况，刷个新闻，刷个朋友圈，看看游戏，再玩会游戏，直接学习时间就没了，直接体现就是在进度上。还会觉得很烦躁</li><li><strong> 当然还是有点懒啊</strong>： 谁都有不想做啥的时候，但是生活就是这样，这就不多说了。</li></ul><p>直到晚上写个人自传的时候，才想起来很多没得啥写，生活就像游戏一样，你玩的多爽杀了多少人，能给你带来的快乐，除了当时的快乐，还有之后你回头看过来，自己有多少收获，有的时候不功利是一种美德，但有时候那只能证明你太年轻了，换句话说就是傻逼了，快乐的生活还是要建立在将来看起来也仍然是快乐的不是吗。</p><h3 id="希望以后换种方式的周末吧"><a href="#希望以后换种方式的周末吧" class="headerlink" title="希望以后换种方式的周末吧"></a>希望以后换种方式的周末吧</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2017-11-26-记录一个可能很熟悉的周末&quot;&gt;&lt;a href=&quot;#2017-11-26-记录一个可能很熟悉的周末&quot; class=&quot;headerlink&quot; title=&quot;2017-11-26 记录一个可能很熟悉的周末&quot;&gt;&lt;/a&gt;2017-11-26 记录一个可能
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂想" scheme="http://yoursite.com/tags/%E6%9D%82%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-剑指offer-3</title>
    <link href="http://yoursite.com/2017/11/17/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-3/"/>
    <id>http://yoursite.com/2017/11/17/刷题/牛客网-剑指offer-3/</id>
    <published>2017-11-17T11:50:52.000Z</published>
    <updated>2017-11-19T13:41:05.964Z</updated>
    
    <content type="html"><![CDATA[<h4 id="T7：斐波那契数列"><a href="#T7：斐波那契数列" class="headerlink" title="T7：斐波那契数列"></a>T7：斐波那契数列</h4><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39</p></blockquote><p>斐波那契数列是很常用的数列，也是很简单的递归能够解决的，但是当n稍微大一点的时候，复杂度都让人无法接受。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">long long Fi(int n)&#123;</div><div class="line">    if(n==0)</div><div class="line">        return 0;</div><div class="line">    if(n==1)</div><div class="line">        return 1;</div><div class="line">    return Fi(n-1)+Fi(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样出现的问题主要是在递归的过程中会出现很多重复的计算，比如我们每次计算第n个的时候，都需要重新计算前面的n-1和n-2，这样每个值其实都会被计算两遍。简单的处理是：从下往上开始算，从第0个一直算到第n个。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Fibonacci(int n) &#123;</div><div class="line">        if(n&lt;=0)</div><div class="line">            return 0;</div><div class="line">        if(n==1||n==2)</div><div class="line">            return 1;</div><div class="line">        int newNum=1;</div><div class="line">        int oneNum=1,twoNum=1;</div><div class="line">        for(int i=3;i&lt;=n;++i)&#123;</div><div class="line">            newNum=oneNum+twoNum;</div><div class="line">            oneNum=twoNum;</div><div class="line">            twoNum=newNum;</div><div class="line">        &#125;</div><div class="line">        return newNum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T8：跳台阶"><a href="#T8：跳台阶" class="headerlink" title="T8：跳台阶"></a>T8：跳台阶</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>该类问题其实就是斐波那契数列的应用：考虑第一次跳的情况，如果第一跳1级，那么后面就是n种情况，如果第一次跳2级，后面就是n-2种，于是：<code>f(n)=f(n-1)+f(n-2)</code>；同理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int jumpFloor(int number) &#123;</div><div class="line">        if(number&lt;=0)</div><div class="line">            return 0;</div><div class="line">        int result=0;</div><div class="line">        if(number==1)</div><div class="line">            return 1;</div><div class="line">        int first_step=1;</div><div class="line">        int second_step=1;</div><div class="line">        while(number&gt;=2)&#123;</div><div class="line">            --number;</div><div class="line">            result=first_step+second_step;</div><div class="line">            first_step=second_step;</div><div class="line">            second_step=result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T9：变态跳台阶"><a href="#T9：变态跳台阶" class="headerlink" title="T9：变态跳台阶"></a>T9：变态跳台阶</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>同样的分析：1.把第n级和第n-1级看成一级，则有：f(n-1)种；2.把第n级和第n-1级分开，则到n-1级有：f(n-1)，n-1级到第n级只有一种，所以加起来是：2*f(n-1)<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int jumpFloorII(int number) &#123;</div><div class="line">        if(number&lt;=0)</div><div class="line">            return 0;</div><div class="line">        int result=1;</div><div class="line">        if(number==1)</div><div class="line">            return 1;</div><div class="line">        for(int i=1;i&lt;=number-1;++i)&#123;</div><div class="line">            result*=2;</div><div class="line">            &#125;</div><div class="line">        return result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;T7：斐波那契数列&quot;&gt;&lt;a href=&quot;#T7：斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;T7：斐波那契数列&quot;&gt;&lt;/a&gt;T7：斐波那契数列&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++ 剑指offer 牛客网" scheme="http://yoursite.com/tags/C-%E5%89%91%E6%8C%87offer-%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>我的专业书阅读</title>
    <link href="http://yoursite.com/2017/11/12/%E7%94%9F%E6%B4%BB/%E6%88%91%E7%9A%84%E4%B8%93%E4%B8%9A%E4%B9%A6/"/>
    <id>http://yoursite.com/2017/11/12/生活/我的专业书/</id>
    <published>2017-11-12T12:47:37.000Z</published>
    <updated>2017-11-14T12:07:24.668Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>《Python核心编程》 ed2</li><li>《C++　Primer 》ed5</li><li>《STL 源码剖析》</li><li>《Effective C++》</li><li>《Unix 网络编程》卷一</li><li>《Unix 网络编程》卷二</li><li>《Unix 环境高级编程》</li><li>《Linux多线程服务端编程》陈硕</li><li>《TCP/IP详解》卷一</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;《Python核心编程》 ed2&lt;/li&gt;
&lt;li&gt;《C++　Primer 》ed5&lt;/li&gt;
&lt;li&gt;《STL 源码剖析》&lt;/li&gt;
&lt;li&gt;《Effective C++》&lt;/li&gt;
&lt;li&gt;《Unix 网络编程》卷一&lt;/l
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我看的电影</title>
    <link href="http://yoursite.com/2017/11/12/%E7%94%9F%E6%B4%BB/%E6%88%91%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/"/>
    <id>http://yoursite.com/2017/11/12/生活/我看的电影/</id>
    <published>2017-11-12T12:27:30.000Z</published>
    <updated>2018-01-03T12:33:34.782Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="记录我看的电影"><a href="#记录我看的电影" class="headerlink" title="记录我看的电影"></a>记录我看的电影</h2><h3 id="羞羞的铁拳"><a href="#羞羞的铁拳" class="headerlink" title="羞羞的铁拳"></a>羞羞的铁拳</h3><p>真的，啥玩意？</p><h3 id="嘉年华"><a href="#嘉年华" class="headerlink" title="嘉年华"></a>嘉年华</h3><p>值得一看的电影。</p><h3 id="机器之血"><a href="#机器之血" class="headerlink" title="机器之血"></a>机器之血</h3><p>估计可能是成龙演的吧，毕竟61岁了，还这么拼，总让人觉得有点厉害了。但是电影从剧情到演员到画面，真的没有一点合格的吧，浪费时间了啊。</p><h3 id="无证之罪（1957）"><a href="#无证之罪（1957）" class="headerlink" title="无证之罪（1957）"></a>无证之罪（1957）</h3><h3 id="缝纫机乐队（2017）"><a href="#缝纫机乐队（2017）" class="headerlink" title="缝纫机乐队（2017）"></a>缝纫机乐队（2017）</h3><p>毕竟睿思一周热门啊，还是忍不住下下来看了一下。记得之前大鹏各种微博之类的请大家去看看，不过评分依然很低。所以看的时候本来也没有那么期待。看完之后觉得也没有那么烂吧，想起之前看的大鹏的煎饼侠，也不知道除了搞笑之外还记起来什么了。不过这个好像好了很多，因为我想以后可能不会记得这个有多搞笑，但应该会记得讲了个什么故事。<br>虽然电影对于大鹏来说可能有着特别的意义或者怎样，但是我看的时候还是觉得一如很多的国产电影，剧情不够瞎搞笑凑，然后就为了搞笑又加了很多无聊的东西，让剧情更烂了。所以这个也是这样，但是在最后强催的泪点环节，还是能够感觉到大鹏想告诉大家的东西，或者说是他对生活，对他自己的生活的一个理解？但是不重要是吗？电影可以就像一个人，但应该是我们发自肺腑的感叹，而不是要你用电影之外的话来告诉我们。就好像你做了一道菜，一定要在我们吃的时候加上旁白告诉我们现在吃的是什么，那可能不一定难吃，但一定不优秀。</p><h3 id="寻梦环游记（2017）-date：2017-12-2"><a href="#寻梦环游记（2017）-date：2017-12-2" class="headerlink" title="寻梦环游记（2017） date：2017-12-2"></a>寻梦环游记（2017） date：2017-12-2</h3><p>额，要不是评分实在太高了，我也不会去看个说是动画片的电影吧，很少见出来一周的电影还9.5分的，但是确实值得高分。</p><p>不愧是迪士尼啊，效果非常棒不说了。整个剧情，跟一些非常优秀的电影一样，塑造了一个存在于人们想象中有可能很合理的新世界，在那里，有很多匪夷所思却又言之合理的事情。然后在这个世界里出现了与现实有联系的矛盾。当然最后问题的解决，又给人现实很简单纯粹的思考。比如在这里，塑造了亡灵的世界，如果死了的人真的被人遗忘，就会真的死亡。你在现实里追逐梦想最终被人记住的，在亡灵的世界也可以活的风光，就像梦想可能不被理解，但是实现了一定很值得一样。最后的大反转又让人回归，家人是最重要的，即使你有梦想，也没必要去牺牲这些。简单的道理，但是如果像我这么说就很没意思了，所以，这就是我们为什么会喜欢优秀的电影了吧。</p><h3 id="天才枪手-2017"><a href="#天才枪手-2017" class="headerlink" title="天才枪手(2017)"></a>天才枪手(2017)</h3><p><a href="http://www.imdb.com/title/tt6788942/" target="_blank" rel="external">IMDI 8.2分</a> <strong> /</strong><a href="https://movie.douban.com/subject/27024903/" target="_blank" rel="external">豆瓣 8.3分</a><br>好吧，8分多纯粹就是看了个热闹啊。简直就像告诉你，优秀的人作弊都比人优秀啊，即使感觉满屏幕的bug也依然很没文化的wokaowokao了。。</p><h3 id="东方快车谋杀案-1974"><a href="#东方快车谋杀案-1974" class="headerlink" title="东方快车谋杀案(1974)"></a>东方快车谋杀案(1974)</h3><p><a href="http://www.imdb.com/title/tt0071877/" target="_blank" rel="external">IMDI 7.3分</a> <strong> /</strong><a href="https://movie.douban.com/subject/1292699/" target="_blank" rel="external">豆瓣 8.3分</a><br>能拿奥斯卡的一般特性，就像一般艺术到最后所反映的，除了一个完整的故事，精彩的剧情，还有整个电影对人物、风情、地域以及社会环境等的刻画，传达人性或这个世界我们需要的思考。这种深度，国产电影离别人几十年前的电影都相差甚远。想起冯小刚说的，中国电影拍不好，是因为中国的观众不行，我觉得观众始终是很少的一部分，因为更多的时候、其实观众不知道他们喜欢的究竟是什么，因为更好看的永远在后面，这就是电影行业的责任了。<br>再说这个电影吧，剧情的丰富就不必说了，从开头的各种铺垫，让我们在看到各种人物性格，国家的特点等，产生各种怀疑的时候，案件就开始了，于是现在看起来有点搞笑的主人公就开始了表演，整个审问和查找线索的过程让人敬佩，直到慢慢开始跟着他产生新的怀疑。。<br>在主人公宣布结果之前，我也似乎猜到了一点，他最后给了大家选择，这是大家都希望的，看到大家开始香槟庆祝的时候，我不禁在想，这样的结果，究竟是应该的吗？如果这样的谋杀也可以，法律又怎么会进步。<br>说到这里，又不禁想起来最近的江歌的事件，我只是在新闻上看到了，对此也表示很遗憾。不过在网上却各种签名投票之类的沸沸扬扬，诚然，在这种时候我们需要帮助受害者的家人，也想让罪人得到应有的报应，但这样可能真的不是最好的办法。就像规则可能有时候会有缺陷，但是如果每次都因为特殊事件让它临时违背，那跟没有也没区别。</p><h3 id="幸福终点站-2004"><a href="#幸福终点站-2004" class="headerlink" title="幸福终点站(2004)"></a>幸福终点站(2004)</h3><p><a href="http://www.imdb.com/title/tt0362227/" target="_blank" rel="external">IMDI 7.3分</a> <strong> /</strong><a href="https://movie.douban.com/subject/1292274/" target="_blank" rel="external">豆瓣 8.6分</a></p><h3 id="加勒比海盗5：死无对证"><a href="#加勒比海盗5：死无对证" class="headerlink" title="加勒比海盗5：死无对证"></a>加勒比海盗5：死无对证</h3><p><a href="http://www.imdb.com/title/tt1790809/" target="_blank" rel="external">IMDI 6.7分</a> <strong> /</strong><a href="https://movie.douban.com/subject/6311303/" target="_blank" rel="external">豆瓣 7.2分</a></p><h3 id="速度与激情8"><a href="#速度与激情8" class="headerlink" title="速度与激情8"></a>速度与激情8</h3><p><a href="http://www.imdb.com/title/tt0362227/" target="_blank" rel="external">IMDI 6.8分</a> <strong> /</strong><a href="https://movie.douban.com/subject/26260853/" target="_blank" rel="external">豆瓣 7.1分</a></p><h3 id="百万美元宝贝-Million-Dollor-baby"><a href="#百万美元宝贝-Million-Dollor-baby" class="headerlink" title="百万美元宝贝( Million Dollor baby)"></a>百万美元宝贝( Million Dollor baby)</h3><h3 id="陪安东尼度过漫长岁月"><a href="#陪安东尼度过漫长岁月" class="headerlink" title="陪安东尼度过漫长岁月"></a>陪安东尼度过漫长岁月</h3><h3 id="看不见的客人"><a href="#看不见的客人" class="headerlink" title="看不见的客人"></a>看不见的客人</h3><p><a href="http://www.imdb.com/title/tt4857264/" target="_blank" rel="external">IMDI 8.1分</a> <strong> /</strong><a href="https://movie.douban.com/subject/26580232/" target="_blank" rel="external">豆瓣 8.7分</a></p><h3 id="致命ID"><a href="#致命ID" class="headerlink" title="致命ID"></a>致命ID</h3><h3 id="雷神3"><a href="#雷神3" class="headerlink" title="雷神3"></a>雷神3</h3><h3 id="罗生门（日本）"><a href="#罗生门（日本）" class="headerlink" title="罗生门（日本）"></a>罗生门（日本）</h3><h3 id="心迷宫"><a href="#心迷宫" class="headerlink" title="心迷宫"></a>心迷宫</h3><h3 id="情遇曼哈顿"><a href="#情遇曼哈顿" class="headerlink" title="情遇曼哈顿"></a>情遇曼哈顿</h3><h3 id="复仇者联盟"><a href="#复仇者联盟" class="headerlink" title="复仇者联盟"></a>复仇者联盟</h3><h2 id="记录看的电视剧"><a href="#记录看的电视剧" class="headerlink" title="记录看的电视剧"></a>记录看的电视剧</h2><blockquote><p>电视剧看的不多，但是一看就要看完啊。等不了啊</p></blockquote><h3 id="权力的游戏s7"><a href="#权力的游戏s7" class="headerlink" title="权力的游戏s7"></a>权力的游戏s7<a href=""></a></h3><h3 id="白夜追凶"><a href="#白夜追凶" class="headerlink" title="白夜追凶"></a>白夜追凶<a href=""></a></h3><h3 id="无证之罪"><a href="#无证之罪" class="headerlink" title="无证之罪"></a>无证之罪<a href=""></a></h3><h3 id="激战玄武门（纪录片）"><a href="#激战玄武门（纪录片）" class="headerlink" title="激战玄武门（纪录片）"></a>激战玄武门（纪录片）<a href=""></a></h3><h3 id="Justice（公开课）"><a href="#Justice（公开课）" class="headerlink" title="Justice（公开课）"></a>Justice（公开课）<a href=""></a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;记录我看的电影&quot;&gt;&lt;a href=&quot;#记录我看的电影&quot; class=&quot;headerlink&quot; title=&quot;记录我看的电影&quot;&gt;&lt;/a&gt;记录我看的电影&lt;/h2&gt;&lt;h3 id=&quot;羞羞的铁拳&quot;&gt;&lt;a href=&quot;#羞羞的铁拳&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="记录" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="娱乐" scheme="http://yoursite.com/tags/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习1-Linux的基本命令（1）</title>
    <link href="http://yoursite.com/2017/11/12/Linux/linux-learn-1/"/>
    <id>http://yoursite.com/2017/11/12/Linux/linux-learn-1/</id>
    <published>2017-11-12T11:33:00.000Z</published>
    <updated>2017-11-13T03:49:07.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux的命令比较多，而且后台开发的时候基本操作服务器的时候都是采用命令行，当然不需要所有的都一次掌握，但是很多重要的用的多的还是需要掌握，不需要直接去记，还是需要多用才会熟练</p></blockquote><h5 id="shell相关"><a href="#shell相关" class="headerlink" title="shell相关"></a>shell相关</h5><h6 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h6><p><code>cat /etc/shells   //查看当前系统有那些shell</code><br><code>cat $SHELL</code></p><h6 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h6><p><code>cd ~    //切换路径到家目录</code></p><h6 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h6><p><code>history  //显示最近使用的命令</code><br><code>cd -  //在上下两个目录之间切换</code><br>``<br>主键盘快捷键：<br><img src="https://github.com/mianhk/image-save/blob/master/mingling1.jpg?raw=true" alt=""></p><h5 id="目录和文件"><a href="#目录和文件" class="headerlink" title="目录和文件"></a>目录和文件</h5><h6 id="类Unix系统目录结构"><a href="#类Unix系统目录结构" class="headerlink" title="类Unix系统目录结构"></a>类Unix系统目录结构</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/ 根目录</div><div class="line">    bin //系统可执行程序，如命令</div><div class="line">    boot //内核和启动程序，所有和启动相关的文件都保存在这里</div><div class="line">    grub //引导器相关文件</div><div class="line">    dev //设备文件</div><div class="line">    etc //系统软件的启动和配置文件，系统在启动过程中需要读取的文件都在这个目录。如LILO参数、用</div><div class="line">户账户和密码。</div><div class="line">    home //用户的主目录。下面是自己定义的用户名的文件夹</div><div class="line">    lib //系统程序库文件,这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32</div><div class="line">目录，几乎所有的应用程序都需要用到这些共享库。</div><div class="line">    media //挂载媒体设备，如光驱、U盘等</div><div class="line">    mnt //目录是让用户临时挂载别的文件系统，如挂载Windows下的某个分区，ubuntu默认还是挂载在/media</div><div class="line">目录。</div><div class="line">    opt //可选的应用软件包（很少使用）</div><div class="line">    proc //这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录</div><div class="line">的内容不在硬盘上而是在内存里。</div><div class="line">    sbin //管理员系统程序</div><div class="line">    selinux</div><div class="line">    srv</div><div class="line">    sys //udev用到的设备目录树，/sys反映你机器当前所接的设备</div><div class="line">    tmp //临时文件夹</div><div class="line">    usr //这是个最庞大的目录，我们要用到的很多应用程序和文件几乎都存放在这个目录下。]</div><div class="line">    bin // 应用程序</div><div class="line">    game //游戏程序</div><div class="line">    include</div><div class="line">    lib //应用程序的库文件</div><div class="line">    lib64</div><div class="line">    local //包含用户程序等</div><div class="line">    sbin //管理员应用程序</div></pre></td></tr></table></figure><h6 id="ls（列出文件夹中的文件）"><a href="#ls（列出文件夹中的文件）" class="headerlink" title="ls（列出文件夹中的文件）"></a>ls（列出文件夹中的文件）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-a 列出隐藏文件，文件中以“.”开头的均为隐藏文件，如：~/.bashrc</div><div class="line">-l 列出文件的详细信息</div><div class="line">-R 连同子目录中的内容一起列出</div></pre></td></tr></table></figure><p>ls -l开头显示的10个字符串，第一个表示的是文件类型，后面的9个分别表示：分为3组，每组3位。第一组表示文件属主的权<br>限，第二组表示同组用户的权限，第三组表示其他用户的权限。每一组的三个字符分别表示对文件的读、写和执行权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">首位表示：</div><div class="line">- 普通文件</div><div class="line">d 目录</div><div class="line">l 符号链接</div><div class="line">b 块设备文件</div><div class="line">c 字符设备文件</div><div class="line">s socket文件，网络套接字</div><div class="line">p 管道</div></pre></td></tr></table></figure></p><p>后九位对应的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">r 读</div><div class="line">w 写</div><div class="line">x 可执行。对于目录，表示进入权限。</div><div class="line">s 当文件被执行时，把该文件的UID或GID赋予执行进程的UID（用户ID）或GID（组 ID）。</div><div class="line">t 设置标志位（sticky bit）。如果是有sticky bit的目录，在该目录下任何用户只要有适当的权限即可创建文</div><div class="line">件，但文件只能被超级用户、目录拥有者或文件属主删除。如果是有sticky bit的可执行文件，在该文件执行后，</div><div class="line">指向其正文段的指针仍留在内存。这样再次执行它时，系统就能更快地装入该文件。</div><div class="line">- 没有相应位置的权限。</div></pre></td></tr></table></figure></p><h6 id="which-查看命令所在的位置"><a href="#which-查看命令所在的位置" class="headerlink" title="which(查看命令所在的位置)"></a>which(查看命令所在的位置)</h6><p><code>which ls    //查看ls命令所在的位置</code></p><h6 id="mv（移动）和cp（复制）"><a href="#mv（移动）和cp（复制）" class="headerlink" title="mv（移动）和cp（复制）"></a>mv（移动）和cp（复制）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv file1 file2  //文件重命名，file1和file2分别是原文件名和重命名的文件名</div><div class="line">mv file /dir     //移动文件</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//拷贝文件</div><div class="line">cp file1 file2</div><div class="line">cp file1 dir/</div><div class="line"></div><div class="line">//拷贝目录</div><div class="line">cp dir1 dir2 -r  //-r 选项在文件夹操作中，一般表示对文件夹中的文件递归操作</div><div class="line">cp dir1 ~/ -r</div></pre></td></tr></table></figure><h6 id="cat-查看文件里内容，输出到终端"><a href="#cat-查看文件里内容，输出到终端" class="headerlink" title="cat(查看文件里内容，输出到终端)"></a>cat(查看文件里内容，输出到终端)</h6><p>如果cat后面没有文件名，则读取标准输入</p><h6 id="ln-链接"><a href="#ln-链接" class="headerlink" title="ln(链接)"></a>ln(链接)</h6><p>链接分为两种，一种是硬链接（hard link），另一种是符号链接（Symbolic link）。建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。如果给ln命令加上-s选项，则建立符号链接。</p><h6 id="tree（显示目录的结构树）"><a href="#tree（显示目录的结构树）" class="headerlink" title="tree（显示目录的结构树）"></a>tree（显示目录的结构树）</h6><h6 id="wc-word-count"><a href="#wc-word-count" class="headerlink" title="wc(word count)"></a>wc(word count)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wc -l file //或–lines 只显示列数</div><div class="line">wc -w file //或–words 只显示字数</div><div class="line">wc -c file //或–bytes 或–chars 只显示 Bytes 数</div></pre></td></tr></table></figure><h6 id="od-显示数据"><a href="#od-显示数据" class="headerlink" title="od(显示数据)"></a>od(显示数据)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">od -tcx file1 //-t 指定数据的显示格式</div></pre></td></tr></table></figure><h6 id="du-显示目录的大小"><a href="#du-显示目录的大小" class="headerlink" title="du(显示目录的大小)"></a>du(显示目录的大小)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">du -hm /dir //以M为单位显示</div><div class="line">du -hb /dir //以B为单位</div><div class="line">du -hk /dir //以K为单位</div></pre></td></tr></table></figure><h6 id="df-查看磁盘的使用状况"><a href="#df-查看磁盘的使用状况" class="headerlink" title="df(查看磁盘的使用状况)"></a>df(查看磁盘的使用状况)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df --block-size=GB //以GB为单位显示</div><div class="line">df --block-size=MB //以MB为单位显示</div></pre></td></tr></table></figure><h5 id="文件属性和用户、用户组"><a href="#文件属性和用户、用户组" class="headerlink" title="文件属性和用户、用户组"></a>文件属性和用户、用户组</h5><h6 id="chmod（改变权限）"><a href="#chmod（改变权限）" class="headerlink" title="chmod（改变权限）"></a>chmod（改变权限）</h6><p>一种数字表示法一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0表示没有权限，</div><div class="line">1表示可执行权限，</div><div class="line">2表示可写权限，</div><div class="line">4表示可读权限，</div></pre></td></tr></table></figure></p><h6 id="whoami（显示当前用户名）"><a href="#whoami（显示当前用户名）" class="headerlink" title="whoami（显示当前用户名）"></a>whoami（显示当前用户名）</h6><h6 id="chown（更改某个文件或目录的属主和属组）"><a href="#chown（更改某个文件或目录的属主和属组）" class="headerlink" title="chown（更改某个文件或目录的属主和属组）"></a>chown（更改某个文件或目录的属主和属组）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown itcast:nogroup file1 //把一个文件改为itcast用户和nogroup用户组所有</div></pre></td></tr></table></figure><h6 id="chgrp-改变指定文件所属的用户组"><a href="#chgrp-改变指定文件所属的用户组" class="headerlink" title="chgrp(改变指定文件所属的用户组)"></a>chgrp(改变指定文件所属的用户组)</h6><h5 id="查找与检索"><a href="#查找与检索" class="headerlink" title="查找与检索"></a>查找与检索</h5><h6 id="find（在目录中搜索）"><a href="#find（在目录中搜索）" class="headerlink" title="find（在目录中搜索）"></a>find（在目录中搜索）</h6><p><code>find . -name &#39;file*&#39;  //在当前目录中搜索以file开头的文件</code></p><h6 id="grep-根据内容检索"><a href="#grep-根据内容检索" class="headerlink" title="grep(根据内容检索)"></a>grep(根据内容检索)</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Linux的命令比较多，而且后台开发的时候基本操作服务器的时候都是采用命令行，当然不需要所有的都一次掌握，但是很多重要的用的多的还是需要掌握，不需要直接去记，还是需要多用才会熟练&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;shell相关&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux 后台开发" scheme="http://yoursite.com/tags/Linux-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习-文件I/O</title>
    <link href="http://yoursite.com/2017/11/12/Linux/linux-learn-2-file-IO/"/>
    <id>http://yoursite.com/2017/11/12/Linux/linux-learn-2-file-IO/</id>
    <published>2017-11-12T11:33:00.000Z</published>
    <updated>2018-01-03T12:47:15.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>一个进程默认打开三个文件描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">STDIN_FILENO 0</div><div class="line">STDOUT_FILENO 1</div><div class="line">STDERR_FILENO 2</div></pre></td></tr></table></figure></p><p>新打开文件返回文件描述符表中未使用的最小文件描述符。<br><strong>open函数 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">int open(const char *pathname, int flags);</div><div class="line">int open(const char *pathname, int flags, mode_t mode);</div><div class="line">返回值：成功返回新分配的文件描述符，出错返回-1并设置errno</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h3&gt;&lt;h4 id=&quot;文件描述符&quot;&gt;&lt;a href=&quot;#文件描述符&quot; class=&quot;headerlink&quot; title=&quot;文件描述符&quot;&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux 后台开发" scheme="http://yoursite.com/tags/Linux-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习0-开始</title>
    <link href="http://yoursite.com/2017/11/12/Linux/linux-learn-0/"/>
    <id>http://yoursite.com/2017/11/12/Linux/linux-learn-0/</id>
    <published>2017-11-12T10:59:12.000Z</published>
    <updated>2017-11-14T12:55:00.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong> 写在前面：</strong>关于Linux，是从大学的时候就开始用的，记得最开始的时候还是大二的暑假，那时候拿着一块嵌入式的开发板，还记得开发板的名字，友善之臂6440，cpu还是arm11的，第一次看到板子的时候是觉得这么大一块名字应该很吊了。于是拷了两个光盘的视频，在那个寒假就基本一直在家看那个视频。从像单片机一样点亮上面的二极管，基本上差不多的步骤，在没有系统的时候，觉得也还好。直到后来把整个系统写到板子上，便开始接触Linux了。</p></blockquote><a id="more"></a><blockquote><p>于是开始在虚拟机上抛弃了ubuntu，开始知道nat和桥接，开始ifconfig，开始折腾在vim的退出上。直到后面的一个课程设计上，做了一个嵌入式的小车，自己去找了很多开源的东西，越来越觉得Linux的神（ma）奇（fan）。后来考研了，然后来到了一个以为会搞嵌入式的老师。。。</p><p>好吧，反正中间陆陆续续看了看，其实真正拿来当找工作的成分还是少的，自己知道的也都是皮毛。于是现在开始了新的系统化的学习。希望这是另一个有趣且有用的过程。</p></blockquote><h4 id="学习大纲"><a href="#学习大纲" class="headerlink" title="学习大纲"></a>学习大纲</h4><h5 id="Linux的基本使用"><a href="#Linux的基本使用" class="headerlink" title="Linux的基本使用"></a>Linux的基本使用</h5><ul><li><a href="./linux-learn-0.md">Linux的基本命令</a></li><li><a href="ch3/README.md">vim编辑器</a></li><li><a href="ch4/README.md">GNU工具链</a></li></ul><h5 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h5><ul><li><a href="ch2/README.md">文件I/O</a></li><li><a href="ch3/README.md">文件系统</a></li><li><a href="ch4/README.md">进程</a></li><li><a href="ch2/README.md">信号</a></li><li><a href="ch3/README.md">线程</a></li><li><a href="ch4/README.md">网络编程</a><h5 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h5><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; 写在前面：&lt;/strong&gt;关于Linux，是从大学的时候就开始用的，记得最开始的时候还是大二的暑假，那时候拿着一块嵌入式的开发板，还记得开发板的名字，友善之臂6440，cpu还是arm11的，第一次看到板子的时候是觉得这么大一块名字应该很吊了。于是拷了两个光盘的视频，在那个寒假就基本一直在家看那个视频。从像单片机一样点亮上面的二极管，基本上差不多的步骤，在没有系统的时候，觉得也还好。直到后来把整个系统写到板子上，便开始接触Linux了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux 后台开发" scheme="http://yoursite.com/tags/Linux-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch6 函数</title>
    <link href="http://yoursite.com/2017/11/12/cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/11/12/cpp/cpp-primer/《cpp primer》ch6函数/</id>
    <published>2017-11-12T10:56:56.438Z</published>
    <updated>2017-11-14T12:33:53.446Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。</p></blockquote><a id="more"></a><h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><h2 id="形参和实参："><a href="#形参和实参：" class="headerlink" title="形参和实参："></a>形参和实参：</h2><p>实参是形参的初始值，函数的形参列表可以为空。<br>局部静态对象，定义成static类型，在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><p>如果形参是引用类型，它将绑定到对应的实参上，称为引用传递；否则，将实参的值拷贝后赋给形参，称为值传递。</p><h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2><p>将实参的值拷贝给形参。当是指针形参时，指针的行为和其他非引用类型一样，执行指针拷贝类型时，拷贝的是指针的值。拷贝之后是不同的指针，但是指向的是相同的值，我们可以在函数中修改指针所指对象的值。在C++中，建议使用引用类型的形参替代指针。</p><h2 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h2><p><strong> 1.使用引用避免拷贝。 </strong>因为有的类类型是不能拷贝的，或者在拷贝一些大的类类型对象或者容器对象比较低效。<br>如果函数不需要改变引用参数的值，最好将其声明为常量引用。<br><strong> 2.使用引用形参返回额外信息。</strong>由于函数不能有多个返回值，在我们需要返回多个值的时候，可以额外传一个引用参数。<br><strong> 3.可以直接操作引用形参所引的对象。 </strong></p><h2 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h2><p>和其它初始化一样，当用实参初始化形参时会忽略掉顶层const。也就是，形参的顶层const会被忽略掉。（这个可以思考一下，我们可以通过形参的const在参数中控制是否需要改变形参，以及对应的实参，这样更方便我们传参数。当然有了这个我们就不能重载有无const的两个函数了，因为会被编译器相同对待。）<br>尽量使用常量引用，除了在使用的时候，无法把常量引用初始化为引用（很简单的道理），另外，也会给调用者一种误导。</p><h2 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h2><p>无法以值传递的方式使用数组参数。数组的特点：不允许拷贝、使用数组会将其转化为指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void print(const int*);</div><div class="line">void print(const int[]);</div><div class="line">void print(const int[10]);  //这里的维度表示我们期望数组含有多少个元素，实际不一定</div></pre></td></tr></table></figure></p><h3 id="关于数组长度"><a href="#关于数组长度" class="headerlink" title="关于数组长度"></a>关于数组长度</h3><p>由于传递数组引用的时候，只是数组的首元素指针，所以有时候我们需要在形参定义的时候，就将数组大小传递给形参。这里有几种方式。</p><h2 id="6-2-5-mian处理命令行选项"><a href="#6-2-5-mian处理命令行选项" class="headerlink" title="6.2.5 mian处理命令行选项"></a>6.2.5 mian处理命令行选项</h2><p>当使用argv[]中的实参时，第一个实参保存的是程序名，所以应该从第二个开始。</p><h2 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h2><p>有时候我们预先不知道向函数传递几个实参。1.如果所有的实参类型相同，可以传递名为initializee_list的标准库类型；2.如果实参类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。</p><h1 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h1><p>return语句终止当前执行的函数，并将控制权返回到调用该函数的地方。<br>return语句不要返回局部对象的引用或引用（因为局部对象会在函数调用完成后删除，会产生未定义的结果）。<br>c++11新标准中函数可以返回花括号包围的值列表，主函数main的返回值，非0的返回值由机器决定。</p><h1 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h1><p>拥有顶层const不影响传入函数的对象。另外，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。<br>不能仅仅通过函数的返回值区分两个同名的函数</p><h2 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h2><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。在不同的作用域中无法重载函数名。<br>在c++中，名字查找发生在类型检查之前。</p><h1 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h1><p>大多数程序都有用的特性：默认实参、内联函数、constexpr函数。</p><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>一旦某个形参赋予了默认值，后面的所有形参必须有默认值。函数调用时，实参按其位置进行解析，只能省略尾部的实参。<br>一个函数被声明多次的时候，在给定的作用域中一个形参只能被赋予一次默认实参，也就是函数的后续声明。</p><h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>将它在每个调用点上“内联的”展开，一般来说用于优化规模较小、流程直接、频繁调用的函数。</p><h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>constexpr函数指能用于常量表达式的函数。函数的返回值及所有形参的类型都得是字面值类型，并且函数体中必须有且只有一条return语句。<br>编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式的指定 为内联函数.<br>内联函数和constexpr函数通常定义在头文件中.</p><h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>assert预处理宏,以一个表达式作为条件.<br>我们可以使用一个#define 语句定义NDEBUG，关闭调试状态</p><h1 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h1><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换得来时。</p><h2 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h2><p>函数匹配第一步：选定本次调用对应的重载函数集。<br>候选函数的两个特征：与被调用的函数同名，其声明在调用点可见。<br>第二步考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数。</p><h2 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h2><p>确定最佳匹配的排序：</p><ul><li>1.精确匹配：实参形参类型相同，实参从数组或函数类型转化为对应的指针类型，实参添加顶层const或者从实参中删除顶层const。</li><li>2.通过const转换实现的匹配。</li><li>3.通过类型提升实现的匹配。</li><li>4.通过算术类型转换或指针转换实现的匹配。</li><li>5.通过类类型转换实现的匹配。</li></ul><h1 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h1><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p><h2 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h2><p>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。</p><h2 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h2><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上是被当成指针使用。<br>可以直接把函数当成实参使用，会自动转换成指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-剑指offer-2</title>
    <link href="http://yoursite.com/2017/10/27/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-2/"/>
    <id>http://yoursite.com/2017/10/27/刷题/牛客网-剑指offer-2/</id>
    <published>2017-10-27T11:50:52.000Z</published>
    <updated>2017-11-19T13:11:31.212Z</updated>
    
    <content type="html"><![CDATA[<h4 id="T4：重建二叉树"><a href="#T4：重建二叉树" class="headerlink" title="T4：重建二叉树"></a>T4：重建二叉树</h4><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><p>二叉树是觉得很烦的东西了，比链表复杂很多，看着头都有点疼啊，但是没办法，生活就是这样，只有把不会的会了才会进步，怕的变得不怕才能越来越厉害。<br>常规的理解一下：二叉树的遍历序列分为三种：前序遍历、中序遍历和后序遍历。这样叫是根据根节点相对于其左右子节点而言的。所以很容易知道三种遍历序列的特点，比如对于前序遍历而言，第一个就是根节点，对于中序遍历，根节点的左边必然是左子树，右边为右子树。所以首先可以根据两个序列确定根节点，然后把两个序列都分别分为两个序列，两个左右子树的前序遍历和两个左右子树的后序遍历。于是便可以采用递归的方式分别对左右子树进行处理了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for binary tree</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</div><div class="line">        if(pre.size()==0||vin.size()==0||pre.size()!=vin.size())</div><div class="line">            return nullptr;</div><div class="line">        TreeNode *root=new TreeNode(pre[0]);</div><div class="line">        vector&lt;int&gt; pre1,pre2,vin1,vin2;</div><div class="line">        int i=0;</div><div class="line">        for(;i!=vin.size();++i)&#123;</div><div class="line">            if(root-&gt;val==vin[i])&#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //if(i==0)</div><div class="line">            //root-&gt;left=nullptr;</div><div class="line">        //else if(i==vin.size()-1)</div><div class="line">            //root-&gt;right=nullptr;</div><div class="line">        //else&#123;</div><div class="line">        for(int j=0;j&lt;i;++j)&#123;</div><div class="line">            pre1.push_back(pre[1+j]);</div><div class="line">            vin1.push_back(vin[j]);</div><div class="line">            &#125;</div><div class="line">        for(int j=i+1;j&lt;vin.size();++j)&#123;</div><div class="line">            pre2.push_back(pre[j]);</div><div class="line">            vin2.push_back(vin[j]);</div><div class="line">            &#125;</div><div class="line">        root-&gt;left=reConstructBinaryTree(pre1,vin1);</div><div class="line">        root-&gt;right=reConstructBinaryTree(pre2,vin2);</div><div class="line">        //&#125;</div><div class="line"></div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T5-用两个栈实现队列"><a href="#T5-用两个栈实现队列" class="headerlink" title="T5:用两个栈实现队列"></a>T5:用两个栈实现队列</h4><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote><p>对于这种简单的结构，实现起来可能还是比较简单一点，主要还是思考的过程，通过队列和栈的特点进行分析。队列是一个先进先出的结构，而栈是一个先进后出的结构。显然当我们把数据push到第一个栈，每次数据pop都把第一个栈的全部数据先放到第二个栈当中，然后再pop，肯定就达到了先入先出的目的了。<br>另外需要的是代码的编写。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int pop() &#123;</div><div class="line">        if(stack2.size()&lt;=0)&#123;</div><div class="line">            while(stack1.size()&gt;0)&#123;</div><div class="line">                int temp=stack1.top();</div><div class="line">                stack1.pop();</div><div class="line">                stack2.push(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int result=stack2.top();</div><div class="line">        stack2.pop();</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    stack&lt;int&gt; stack1;</div><div class="line">    stack&lt;int&gt; stack2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T6：旋转数组的最小数字"><a href="#T6：旋转数组的最小数字" class="headerlink" title="T6：旋转数组的最小数字"></a>T6：旋转数组的最小数字</h4><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p>对于数组或者双链表的问题，很多时候我们都可以采用<strong> 双指针</strong>的方法来解决，这通常能减小难度，就像这题，首先我们需要注意的是，旋转数组的特点，旋转之前是一个非递减排序，所以旋转之后必然是前面一个非递减排序加上后半部分的一个非递增排序。很容易想到的是，采用前后两个指针，根据两个指针中间的点的值，可以确定这个数组中最小的值在前半部分还是后半部分，然后移动某一指针到中间节点，知道两个指针之间相差1，就可以确定最小值。<br>然而，看题目还存在一个问题，就是题目所说的是一个非递减排序，而并非递增序列。（这就需要我们认真审题了），可以想到，如果出现了特殊的情况，例如存在几个相等值，导致左右两个指针和中间值都相同的时候，我们只能通过最原始的办法一个个进行判断了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</div><div class="line">        if(rotateArray.size()&lt;=0)</div><div class="line">            return 0;</div><div class="line">        int index1=0;</div><div class="line">        int index2=rotateArray.size()-1;</div><div class="line">        int indexMid=index1;</div><div class="line">        while(rotateArray[index1]&gt;=rotateArray[index2])&#123;</div><div class="line">            if(index2-index1==1)&#123;</div><div class="line">                indexMid=index2;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            indexMid=index1+(index2-index1)/2;</div><div class="line">            if(rotateArray[index1]==rotateArray[indexMid]&amp;&amp;</div><div class="line">               rotateArray[indexMid]==rotateArray[index2])</div><div class="line">                return MinInorder(rotateArray);</div><div class="line">            if(rotateArray[indexMid]&gt;=rotateArray[index1])</div><div class="line">                index1=indexMid;</div><div class="line">            else if(rotateArray[indexMid]&lt;=rotateArray[index2])</div><div class="line">                index2=indexMid;</div><div class="line">        &#125;</div><div class="line">        return rotateArray[indexMid];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int MinInorder(vector&lt;int&gt; rotateArray)&#123;</div><div class="line">        int result=rotateArray[0];</div><div class="line">        int index2=rotateArray[1];</div><div class="line">        while(index2!=rotateArray.size())&#123;</div><div class="line">            if(result&gt;rotateArray[index2])</div><div class="line">                result=rotateArray[index2++];</div><div class="line">            else</div><div class="line">               ++index2;</div><div class="line">               &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;T4：重建二叉树&quot;&gt;&lt;a href=&quot;#T4：重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;T4：重建二叉树&quot;&gt;&lt;/a&gt;T4：重建二叉树&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++ 剑指offer 牛客网" scheme="http://yoursite.com/tags/C-%E5%89%91%E6%8C%87offer-%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>win7下安装Ubuntu双系统</title>
    <link href="http://yoursite.com/2017/10/22/%E5%B7%A5%E5%85%B7/win7%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/10/22/工具/win7下安装Ubuntu双系统/</id>
    <published>2017-10-22T14:37:21.000Z</published>
    <updated>2017-11-14T12:56:09.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学(xian)习(de)所(dan)需(teng)，觉得一个虚拟机确实装的Ubuntu确实有点烦了，除了没有一个系统那样直接用起来爽以外，总觉得感受不到一个纯正的系统。而且虚拟机有时候懒得开了就算了。但是又舍不得直接把我换了固态之后就没有换过的系统直接换掉，毕竟我已经不是那个年轻的爱折腾的22岁的小伙子了，我23了。。于是就看着教程和xjbg装了双系统。同时的难度是，我的固态硬盘里放的系统，但是又不想把系统直接放在固态硬盘，只是希望通过固态启动一下，然后把其他的目录放在机械硬盘中</p></blockquote><h5 id="Win7准备"><a href="#Win7准备" class="headerlink" title="Win7准备"></a>Win7准备</h5><p>双系统的准备主要就是硬盘了，毕竟这么多学习资料是吧。。总还是要谨慎一点的。因为win7和linux系统的磁盘格式不一样，所以我们不能直接在win7里面分好磁盘。这里的工作是：将固态硬盘压缩300MB空间，作为Ubuntu的<code>/boot</code>分区，以供系统启动用。另外在机械硬盘中分出80GB空间，作为其他的<code>/</code>和<code>swap</code>分区。</p><h5 id="通过U盘做系统盘"><a href="#通过U盘做系统盘" class="headerlink" title="通过U盘做系统盘"></a>通过U盘做系统盘</h5><p>使用工具UtralISO，将下载好的Ubuntu系统，通过正常的模式写入到U盘中(这个随便百度一下就有了，经常装系统的这个就差不多知道了)</p><h5 id="重启装系统"><a href="#重启装系统" class="headerlink" title="重启装系统"></a>重启装系统</h5><p>首先还是熟悉的修改bios，按一下各种类似<code>F2</code>之类的键，进入BIOS设置，将启动项第一位改成U盘，然后重启。。<br>之后就是进去装系统了，主要是选磁盘的时候，把 固态硬盘中的未分配空间格式化为<code>/boot</code>，然后其他的机械硬盘中的，按照需要格式化为<code>/</code>和<code>/swap</code>,之后等着装完就好了。</p><h5 id="修改启动选项"><a href="#修改启动选项" class="headerlink" title="修改启动选项"></a>修改启动选项</h5><p>系统装完之后就要重启进入新系统了，这是惊喜而又刺激的发现，Ubuntu真好看，但是我的Win7去哪儿了。不过装了一百遍系统的我知道肯定还是个引导的问题，在网上找到了解决办法。在Ubuntu中输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo gedit /etc/default/grub</div><div class="line">#修改</div><div class="line">GRUB_DEFAULT=0 为：GRUB_DEFAULT=4</div><div class="line">#更新grub</div><div class="line">sudo update-grub</div><div class="line">在终端中找到：</div><div class="line">found win7...</div><div class="line">就说明win7引导被找到了，重启可以开始愉快的用了</div></pre></td></tr></table></figure></p><h6 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h6><p><a href="http://m.jb51.net/article/110288.htm" target="_blank" rel="external">http://m.jb51.net/article/110288.htm</a><br><a href="https://jingyan.baidu.com/article/e4d08ffdace06e0fd2f60d39.html" target="_blank" rel="external">https://jingyan.baidu.com/article/e4d08ffdace06e0fd2f60d39.html</a><br><a href="http://www.jianshu.com/p/c6750e459a94" target="_blank" rel="external">http://www.jianshu.com/p/c6750e459a94</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学(xian)习(de)所(dan)需(teng)，觉得一个虚拟机确实装的Ubuntu确实有点烦了，除了没有一个系统那样直接用起来爽以外，总觉得感受不到一个纯正的系统。而且虚拟机有时候懒得开了就算了。但是又舍不得直接把我换了固态之后就没有换过的系统
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>牛客网刷题总结-剑指offer(1)</title>
    <link href="http://yoursite.com/2017/10/15/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-1/"/>
    <id>http://yoursite.com/2017/10/15/刷题/牛客网-剑指offer-1/</id>
    <published>2017-10-15T13:26:46.000Z</published>
    <updated>2017-10-15T13:54:34.891Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说在前面：刷题真的是一件残酷的事情，就好比以前大学的时候只剩两天就考试了，刚刚看了一遍就开始先做题一样的感觉，面对无数的套路，幸运的时候还能庆幸自己能发现他们的套路。。<br>刷题的开始总是艰难的，希望有一天我能以上帝视角看清这些芸芸众生的时候，还能想起来当年我不止一次的一道题怼了一晚上照样白怼。</p></blockquote><h4 id="T1：二维数组的查找"><a href="#T1：二维数组的查找" class="headerlink" title="T1：二维数组的查找"></a>T1：二维数组的查找</h4><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>这里一般的思路肯定是，从行或者列开始找，根据递增的顺序，找到行或者列之后再判断列或者行，知道找到为止。最好的方法是，从左下角或者右上角开始找。原因是：这样的一行和一列的顺序是不一样的，这样我们找一行的时候没有就可以直接找下一行，充分利用递增的顺序，减少循环的次数。<br>其他的就是循环的写法了，关于数组，一定注意的是不要越界，这真的是我的痛啊，日常越界一百遍。<em>^</em>^_<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</div><div class="line">        bool found=false;</div><div class="line">        if(array.size()==0 ||array[0].size()==0)</div><div class="line">            return found;</div><div class="line">        for(int i=array[0].size()-1;i&gt;=0;--i)&#123;</div><div class="line">            if(target&gt;=array[0][i])&#123;</div><div class="line">                for(int j=0;j!=array.size();++j)&#123;</div><div class="line">                    if(target==array[j][i])</div><div class="line">                        found=true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                continue;</div><div class="line">        &#125;</div><div class="line">        return found;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T2：替换空格"><a href="#T2：替换空格" class="headerlink" title="T2：替换空格"></a>T2：替换空格</h4><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>替换的过程是，先找到这个空格，正常想法是，从前往后找，然后遇到就开始替换。但是注意到<em>对于一般题目，最直观的解法总不是最好的</em>，都是需要多从<strong>时间复杂度和空间复杂度想一想</strong>。就这个题目而言，直接从前往后替换，因为替换后的字符比原来多2个，所以每次替换我们都需要将后面的字符串向后移2个，这无疑会增加复杂度。一个很好的办法是：先统计空格的个数，计算出替换后的字符串长度，然后从后往前开始替换，这样就减少了移动的复杂度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void replaceSpace(char *str,int length) &#123;</div><div class="line">        if(length&lt;=0)</div><div class="line">            return;</div><div class="line">        int move_length=0;</div><div class="line">        int original_length=0;</div><div class="line">        for(int i=0;str[i]!=&apos;\0&apos;;++i)&#123;</div><div class="line">            ++original_length;</div><div class="line">            if(str[i]==&apos; &apos;)</div><div class="line">                ++move_length;</div><div class="line">        &#125;</div><div class="line">        int new_length=original_length+2*move_length;</div><div class="line">        if(new_length&gt;length)</div><div class="line">            return;</div><div class="line">        str[new_length]=&apos;\0&apos;;</div><div class="line">        while(original_length&gt;0)&#123;</div><div class="line">            --original_length;</div><div class="line">            if(str[original_length]==&apos; &apos;)&#123;</div><div class="line">                str[--new_length]=&apos;0&apos;;</div><div class="line">                str[--new_length]=&apos;2&apos;;</div><div class="line">                str[--new_length]=&apos;%&apos;;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                str[--new_length]=str[original_length];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T3-从尾到头打印链表"><a href="#T3-从尾到头打印链表" class="headerlink" title="T3:从尾到头打印链表"></a>T3:从尾到头打印链表</h4><blockquote><p>输入一个链表，从尾到头打印链表每个节点的值。</p></blockquote><p>链表我们一般都是从头到尾处理的，要从尾到头打印，这里想到一个数据结构：<strong>栈</strong>，后入先出的特点。从头到尾遍历链表，并把节点的值存入栈中，再从栈一一弹出即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  struct ListNode &#123;</div><div class="line">*        int val;</div><div class="line">*        struct ListNode *next;</div><div class="line">*        ListNode(int x) :</div><div class="line">*              val(x), next(NULL) &#123;</div><div class="line">*        &#125;</div><div class="line">*  &#125;;</div><div class="line">*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</div><div class="line">        stack&lt;int&gt; stack;</div><div class="line">        vector&lt;int&gt; result;</div><div class="line">        while(head!=nullptr)&#123;</div><div class="line">            stack.push(head-&gt;val);</div><div class="line">            head=head-&gt;next;</div><div class="line">        &#125;</div><div class="line">        while(stack.size()!=0)&#123;</div><div class="line">            result.push_back(stack.top());</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;说在前面：刷题真的是一件残酷的事情，就好比以前大学的时候只剩两天就考试了，刚刚看了一遍就开始先做题一样的感觉，面对无数的套路，幸运的时候还能庆幸自己能发现他们的套路。。&lt;br&gt;刷题的开始总是艰难的，希望有一天我能以上帝视角看清这些芸芸众生的时候，还
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++ 剑指offer 牛客网" scheme="http://yoursite.com/tags/C-%E5%89%91%E6%8C%87offer-%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>《effective C++》from line 1 to line 12</title>
    <link href="http://yoursite.com/2017/10/09/cpp/effective-cpp-1/"/>
    <id>http://yoursite.com/2017/10/09/cpp/effective-cpp-1/</id>
    <published>2017-10-09T11:16:31.000Z</published>
    <updated>2017-11-14T12:34:49.605Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面两章的内容主要是习惯使用c++，大部分都是《C++ primer》中的需要注意的一些东西，由于刚刚看完前面一本，所以有些还是有些印象的。这里大体总结一下。</p></blockquote><h4 id="L1-C-是一个语言联邦。"><a href="#L1-C-是一个语言联邦。" class="headerlink" title="L1:C++是一个语言联邦。"></a>L1:C++是一个语言联邦。</h4><p>包含着最初的以c语言为基础的C，面向对象的C++，C++的泛型编程，以及STL。在我们使用的过程中，可能会穿插，但是我们需要根据不同的情况使用不同的策略。</p><h4 id="L2：代替-define"><a href="#L2：代替-define" class="headerlink" title="L2：代替#define"></a>L2：代替#define</h4><p><code>#define</code>是在编译之前，也就是预处理的阶段就会被替换，这样我们在调试程序的时候看到的就是被替换的数字，会给别人甚至是之后调试的我们自己带来理解上的困难。另外，预处理器的工作是，直接把define的内容进行替换，当我们在define中写的表达式，并且在接下来使用的时候，可能产生无法理解的结果。所以当我们使用不想改变的常量时，使用<code>const</code>代替<code>#define</code>。<br>我们还可以使用<code>enum</code>来代替<code>#define</code>。这样显得会更接近一些，因为<code>enum</code>和<code>#define</code>一样，同时也不会被pointer或reference指向。<br>使用<code>inline</code>函数。</p><h4 id="L3-尽量使用const"><a href="#L3-尽量使用const" class="headerlink" title="L3:尽量使用const"></a>L3:尽量使用const</h4><p>这是一个很好理解的问题，就像你把东西给别人用，不想让别人动的地方就加一个<code>const</code>不让别人动一样。。。<br>具体的体现为：指针，不想被改变的变量，迭代器，成员函数等等。<br>我们可能还会为一个函数定义<code>const</code>和<code>非const</code>版本。</p><h4 id="L4：在使用对象前先初始化"><a href="#L4：在使用对象前先初始化" class="headerlink" title="L4：在使用对象前先初始化"></a>L4：在使用对象前先初始化</h4><p>嗯，记住。</p><h4 id="L5：了解c-会默认编写并调用哪些函数"><a href="#L5：了解c-会默认编写并调用哪些函数" class="headerlink" title="L5：了解c++会默认编写并调用哪些函数"></a>L5：了解c++会默认编写并调用哪些函数</h4><p>在面向对象编程时，记住三五法则。构造函数、拷贝构造函数、拷贝赋值运算符、移动赋值运算符、析构函数。记住这几个函数的作用，其在什么时候会被使用，如果没有的时候，系统会不会为我们生成。我们需不需要系统为我们生成。</p><h4 id="L6：不想编译器默认生成的函数，应该明确拒绝"><a href="#L6：不想编译器默认生成的函数，应该明确拒绝" class="headerlink" title="L6：不想编译器默认生成的函数，应该明确拒绝"></a>L6：不想编译器默认生成的函数，应该明确拒绝</h4><p>比如我们不希望编译器为我们生成默认的函数，我们应该将其定义为删除的或者定义为<code>private</code>的，也可以定义类似于uncopyable类似的base class。</p><h4 id="L7：为多态的基类声明virtual析构函数"><a href="#L7：为多态的基类声明virtual析构函数" class="headerlink" title="L7：为多态的基类声明virtual析构函数"></a>L7：为多态的基类声明virtual析构函数</h4><p>通常我们希望派生类覆盖或重写的函数，定义为virtual函数。析构函数作为对象被销毁时调用的函数，如果不是虚函数，那么可能在销毁的时候只会销毁基类的部分，局部销毁，造成资源泄露。</p><h4 id="L8：不要让异常逃离析构函数"><a href="#L8：不要让异常逃离析构函数" class="headerlink" title="L8：不要让异常逃离析构函数"></a>L8：不要让异常逃离析构函数</h4><p>析构函数绝对不要吐出异常，当遇到异常的时候应该捕捉任何异常，然后吞下或结束程序。<br>如果需要对某个操作函数运行期间抛出的异常做出反应，应该提供一个普通的函数执行操作，而不是在析构函数中。</p><h4 id="L9：绝不在构造和析构过程中调用virtual函数"><a href="#L9：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="L9：绝不在构造和析构过程中调用virtual函数"></a>L9：绝不在构造和析构过程中调用virtual函数</h4><p>构造和析构过程中，调用virtual函数的对象可能还没有产生，也就是派生类的对象，此时会产生未定义的行为。</p><h4 id="L10：另operator-返回一个reference-to-this"><a href="#L10：另operator-返回一个reference-to-this" class="headerlink" title="L10：另operator=返回一个reference to *this"></a>L10：另operator=返回一个reference to *this</h4><p>并不强制，只是为了防止一些调皮的调用者使用：<code>x=y=z=15</code>这样的操作。</p><h4 id="L11：在operator-中处理自赋值的情况"><a href="#L11：在operator-中处理自赋值的情况" class="headerlink" title="L11：在operator=中处理自赋值的情况"></a>L11：在operator=中处理自赋值的情况</h4><p>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，行为仍然正确。</p><h4 id="L12：复制对象时不忘每一个成分"><a href="#L12：复制对象时不忘每一个成分" class="headerlink" title="L12：复制对象时不忘每一个成分"></a>L12：复制对象时不忘每一个成分</h4><p>Copying函数应该确保复制对象内的所有成员变量和所有base class成分。<br>不要使用一个copying函数实现另一个copying函数，而是创建一个新的函数避免代码重复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前面两章的内容主要是习惯使用c++，大部分都是《C++ primer》中的需要注意的一些东西，由于刚刚看完前面一本，所以有些还是有些印象的。这里大体总结一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;L1-C-是一个语言联邦。&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>不知道怎么开的船？</title>
    <link href="http://yoursite.com/2017/09/25/%E7%94%9F%E6%B4%BB/%E4%B8%8D%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E5%BC%80%E7%9A%84%E8%88%B9/"/>
    <id>http://yoursite.com/2017/09/25/生活/不知道怎么开的船/</id>
    <published>2017-09-25T15:36:13.000Z</published>
    <updated>2017-11-12T12:54:26.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2017-9-25-记录学习"><a href="#2017-9-25-记录学习" class="headerlink" title="2017-9-25 记录学习"></a>2017-9-25 记录学习</h3><h4 id="额，打开sublime，打出来第一个-号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。"><a href="#额，打开sublime，打出来第一个-号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。" class="headerlink" title="额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。"></a>额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。</h4><p>最近开始再一次准备看数据结构和算法，再一次，是不能再跟闹着玩的一次了。看着实验室最近找工作的师兄师姐，一边心疼他们，一边更心疼明年的自己。所以我也想到了也许很好的办法，不如抓紧时间现在先好好学习，头疼起来了，心就不疼了吧。<br>断断续续看完了c++ primer，加上之前看过一些数据结构，但是当我打开牛客网第一题的时候还是觉得自己像个傻逼，于是按照我通常的习惯，换了第二题，觉得更傻逼了。于是还是先打开书看看了。。<br>看看书啊，又刷刷题啊，自己还是经常在骂自己和夸自己和强行夸自己这几种有限状态中跳来跳去。<br>晚上，刷到那个链表翻转的题目，又是好久没搞出来，各种数组越界。明明只是就那么几个指针而已，反复看了好几遍。当方法论出了问题的时候，有的时候会忍不住怀疑世界观。作为一个还是对这个世界充满疑惑和兴趣的青年，我好奇地又在网上搜了一遍：C++学什么，C++怎么学，C++学习路线。。于是一晚上又没了，留下一份写有听过好多遍名字的书的TXT文档，一如一个多月前的某一个晚上。。<br>可能距离我们找工作也有快一年吧，时间说长不长，说短不短吧。其实我觉得能担心的可能一直不是时间，而是利用时间。<br>先写一下接下来一段时间的任务吧，不要又乱跑了：</p><ul><li>《Effictive C++》认真看，主线</li><li>有空看数据结构，刷题，不随便放弃题目。搞懂会写，写好了为止</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2017-9-25-记录学习&quot;&gt;&lt;a href=&quot;#2017-9-25-记录学习&quot; class=&quot;headerlink&quot; title=&quot;2017-9-25 记录学习&quot;&gt;&lt;/a&gt;2017-9-25 记录学习&lt;/h3&gt;&lt;h4 id=&quot;额，打开sublime，打出来第一
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂想" scheme="http://yoursite.com/tags/%E6%9D%82%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch16 模板与泛型编程</title>
    <link href="http://yoursite.com/2017/09/19/cpp/cpp-primer/ch16-notes/"/>
    <id>http://yoursite.com/2017/09/19/cpp/cpp-primer/ch16-notes/</id>
    <published>2017-09-19T04:47:04.000Z</published>
    <updated>2017-11-14T12:36:54.894Z</updated>
    
    <content type="html"><![CDATA[<p>泛型编程与面向对象编程的区别是：面向对象编程能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。</p><h4 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h4><p>模板程序应该尽量减少对实参类型的要求。<br>模板的头文件通常包括声明和定义。<br>模板直到实例化时才生成代码。<br>泛型编程的一个目标就是另算法是“通用的”-适合于不同类型。所有标准库容器都定义了<code>==</code>和<code>!=</code>，但只有少数定义了<code>&lt;</code>运算符。因此尽量使用<code>!=</code>而不是<code>&lt;</code>。<br><strong> 类模板</strong>用来生成类的蓝图，一个类模板的每个实例都形成一个独立的类。默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。在类模板的作用域类，我们可以直接使用模板名而不必指定模板实参。<br>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给 所有友元模板实例，也可以只授权给特定实例。<br>当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。<br><strong> 成员模板</strong>：一个类（不管是模板类还是普通类）可以包含本身是模板的成员函数。这些成员函数被称为成员模板。成员模板不能是虚函数。<br>控制实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extern template class Blob&lt;string&gt;;  //声明，遇到extern模板声明时，编译器不会在本文件中生成实例化代码。，对于一个给定的实例化版本，可以有多个extern声明，但只能有一个定义。</div><div class="line">template int compare(const int&amp;,const int&amp;); //定义</div></pre></td></tr></table></figure></p><h4 id="16-2-模板实参推断"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断</h4><p>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。<br>一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。<br>如果函数参数类型不是模板参数，则可以进行正常的类型转换。<br><strong> 显式模板实参</strong>按由左至右的顺序与对应的模板参数匹配。</p><h4 id="16-3-重载与模板"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板</h4><h4 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h4><h4 id="16-5-模板特例化"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;泛型编程与面向对象编程的区别是：面向对象编程能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。&lt;/p&gt;
&lt;h4 id=&quot;16-1-定义模板&quot;&gt;&lt;a href=&quot;#16-1-定义模板&quot; class=&quot;headerlink&quot; title=&quot;16.1 
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《c++primer》ch15-面向对象程序设计</title>
    <link href="http://yoursite.com/2017/09/19/cpp/cpp-primer/ch15-notes/"/>
    <id>http://yoursite.com/2017/09/19/cpp/cpp-primer/ch15-notes/</id>
    <published>2017-09-19T04:44:24.000Z</published>
    <updated>2017-11-14T12:36:35.325Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面向对象三个基本概念：数据抽象、继承和动态绑定（java里说的多态）。这章主要内容是继承和动态绑定。</p></blockquote><h4 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h4><h4 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h4><p>基类希望派生类进行覆盖的函数，通常将其定义为<strong> 虚函数</strong>，另一种是基类希望派生类继承但不要改变的函数。<br><code>protected</code>访问运算符：派生类可以访问，但是其他用户无法访问。<br>定义派生类：通过访问说明符控制派生类从基类继承而来的成员是否对派生类可见。<br>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为跟其他类一样，派生类会直接继承其在基类中的版本。<br>派生类到基类的转换。这可以让我们把派生类对象或者派生类对象的引用用在需要基类引用的地方，也可以把派生类指针用在需要基类指针的地方。但是，这里会出现一个问题，当我们使用基类的指针或者引用时，就不知道这个所绑定的对象到底是基类还是派生类了。<br>派生类构造函数。必须使用基类的构造函数初始化。（每个类控制自己的初始化过程。）<br>每个类定义各自的接口，派生类要遵循基类的接口。<br>如果基类中定义了静态成员，则在整个继承体系中只存在唯一的定义，不管定义了多少遍，都只存在唯一的实例。<br>对派生类的声明，不需要包含派生列表。<br>当我们不想让类被继承的时候，可以使用<code>final</code>关键字，跟在类名之后。<br>表达式的<strong> 静态类型</strong>在编译时是已知的，是变量声明时或者表达式生成式生成的类型。<strong> 动态类型</strong>则是变量或表达式表示的内存中的对象的类型。因此，基类的指针或引用的静态类型可能与动态类型不一致。<br>派生类向基类的自动类型转换只对指针和引用有效，在类型之间不存在这样的转换。当我们用一个派生类对象初始化或给一个基类对象赋值时，只有该派生类的对象中的基类部分会被拷贝、移动或赋值，派生类部分则会被忽略掉。</p><h4 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h4><p>我们必须为每一个虚函数提供定义，因为连编译器也无法确定到底使用的是哪一个虚函数。<br>如果我们在派生类中覆盖了某个虚函数时，可以再次使用<code>virtual</code>指出该函数的性质，但实际上并不一定要这么做。因为某个函数被声明成虚函数，则在所有的派生类中都是虚函数。</p><h4 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h4><p>在函数体声明的语句的分号前使用<code>=0</code>可以将一个函数声明为纯虚函数。<br>含有纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类负责覆盖该接口。我们不能直接创建一个抽象基类的对象。GCC的编译器中可能前面还是要加上<code>virtual</code><br><strong> 重构</strong>：重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。</p><h4 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h4><p>protected:对于类的用户来说是不可访问的，对于派生类的成员和友元来说是可访问的。但是只能通过<strong> 派生类对象</strong>来访问，<strong> 派生类</strong>对于一个基类中受保护的成员是无法访问的。<br>派生类向基类的转换：只有当D公有的继承B时，<strong> 用户代码</strong>才能使用基类向派生类的转换。无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换。如果D继承B的方式是公有的或受保护的，则D的派生类可以使用D向B的类型转换。<br>友元关系不能继承。基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员。<br>派生类可以使用<code>using</code>为那些可以访问的名字提供声明，以改变这些名字在它的派生类中的可访问性。</p><h4 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h4><p>每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。<br>当名字相同时，派生类的成员将隐藏基类的成员。基类可以通过<strong> 作用域运算符</strong>来使用隐藏的成员。一般情况下，我们应该不会这么使用，所以，平时继承类尽量不要覆盖继承而来的虚函数以外的基类的名字。<br><strong> 名字查找先于类型检查</strong>：如果派生类的成员与基类中的某个成员同名，则派生类将在其作用域内隐藏该基类成员。一旦编译器查找到名字后，不管形参列表是否相同，都不会再继续查找，这也是我们需要在覆盖虚函数时，保证形参列表是相同的。<br><code>using</code>声明语句指定一个名字而不是形参列表，所以我们在基类中使用一个<code>using</code>就可以把该函数的所有重载实例添加到派生类作用域中，派生类只需要定义特有的函数即可。</p><h4 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h4><p>位于继承体系中的类也需要控制当其对象执行一系列操作时发生怎样的行为：包括创建、移动、拷贝、赋值和销毁。<br>一般讲基类中的析构函数定义为虚函数，这样，继承体系中的派生类都会是虚析构函数，否则，若基类中的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。<br>虚析构函数将组织合成移动操作。<br>和普通成员的using声明不同，构造函数的using声明不会改变该构造函数的访问级别。<br>using声明语句不能指定explicit或constexpr。<br>当一个基类构造函数含有默认实参时，这些实参并不会被继承。派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p><h4 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8 容器与继承"></a>15.8 容器与继承</h4><p>容器不能直接存放继承体系中的对象，通常采用间接存储的方式。因为当我们把基类存储到一个容器中，当存入派生类对象，实际存入的只是派生类中基类的部分，显然不符合我们的需要。所以我们希望在具有继承关系的对象时，实际上存储的是基类的指针。（最好使用智能指针）</p><h4 id="15-9-文本查询程序再探"><a href="#15-9-文本查询程序再探" class="headerlink" title="15.9 文本查询程序再探"></a>15.9 文本查询程序再探</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;面向对象三个基本概念：数据抽象、继承和动态绑定（java里说的多态）。这章主要内容是继承和动态绑定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;15-1-OOP：概述&quot;&gt;&lt;a href=&quot;#15-1-OOP：概述&quot; class=&quot;head
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
