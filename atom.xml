<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mianhk&#39;s notes</title>
  
  <subtitle>这个人很懒，动不动就不想写</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-27T02:52:09.656Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mianhk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ubuntu自动push到github脚本</title>
    <link href="http://yoursite.com/24-%E5%B7%A5%E5%85%B7/shell_%E8%87%AA%E5%8A%A8push/"/>
    <id>http://yoursite.com/24-工具/shell_自动push/</id>
    <published>2018-05-24T12:20:43.000Z</published>
    <updated>2018-05-27T02:52:09.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于人比较懒，总是忘了自己提交到github上，也觉得博客好不容易写了还要打开文件夹，点一下交，这个体验有点差呀。于是就写了个Linux自动提交代码的和windows自动更新博客的。</p></blockquote><a id="more"></a><h2 id="Linux编写shell脚本"><a href="#Linux编写shell脚本" class="headerlink" title="Linux编写shell脚本"></a>Linux编写shell脚本</h2><h3 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">path=~/github/</div><div class="line"></div><div class="line">git_push()&#123;</div><div class="line">    echo &quot;开始push&quot;</div><div class="line">    modify_time=`stat -c %Y $&#123;1&#125;`</div><div class="line">    this_time=`date +%s`</div><div class="line"></div><div class="line">    cd $&#123;1&#125;</div><div class="line">    echo &quot;-------切换目录------&quot;</div><div class="line">    echo `pwd`</div><div class="line">    echo &quot;---------------------&quot;</div><div class="line">    if [ $[ $&#123;modify_time&#125;-$&#123;this_time&#125; ] -gt 86400 ];</div><div class="line">    then</div><div class="line">         echo &quot;$&#123;1&#125; 文件夹 有变化，正在准备push...&quot;</div><div class="line">        date=`date &quot;+%Y-%m-%d %H:%M:%S&quot;`</div><div class="line">        git add .    </div><div class="line">        git commit -m &quot;automatic push @$(date)&quot;</div><div class="line">        echo &quot;git fetch origin master&quot;</div><div class="line">        git fetch origin master</div><div class="line"></div><div class="line">        echo &quot;git merge origin/master&quot;</div><div class="line">        git merge origin/master</div><div class="line"></div><div class="line">        echo &quot;git push origin master:master&quot;</div><div class="line">        git push origin master:master</div><div class="line">         </div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">git_push ~/github/Linux_pro</div><div class="line">git_push ~/github/miniweb</div></pre></td></tr></table></figure><h3 id="加入定时任务"><a href="#加入定时任务" class="headerlink" title="加入定时任务"></a>加入定时任务</h3><h3 id="编辑定时任务文件"><a href="#编辑定时任务文件" class="headerlink" title="编辑定时任务文件"></a>编辑定时任务文件</h3><p>(<a href="https://blog.csdn.net/xiyuan1999/article/details/8160998" target="_blank" rel="external">https://blog.csdn.net/xiyuan1999/article/details/8160998</a>)<br><code>crontab  -e</code><br>在文件的末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30 5 * * * /home/mianhk/shell/auto_push.sh  表示在每天的 5.30执行</div></pre></td></tr></table></figure></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><code>/etc/init.d/cron start</code></p><h2 id="Windows自动提交博客"><a href="#Windows自动提交博客" class="headerlink" title="Windows自动提交博客"></a>Windows自动提交博客</h2><p>其实windows的也差不多，写一个bat的脚本，然后加到系统的定时任务里面</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">title 同步博客到远端——余国聪</div><div class="line">color 16</div><div class="line"></div><div class="line">echo;</div><div class="line">echo;</div><div class="line"></div><div class="line">echo 切换目录到blog</div><div class="line">f:</div><div class="line">cd \github\mianhk</div><div class="line">cd .\blog</div><div class="line">echo clean</div><div class="line"></div><div class="line">hexo g -d</div><div class="line"></div><div class="line">echo 切换到GitHub备份目录</div><div class="line">cd ..</div><div class="line"></div><div class="line">echo 开始提交代码到本地仓库</div><div class="line">echo 当前目录是：%cd%</div><div class="line"></div><div class="line">echo 开始添加变更</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git add -A .</div><div class="line">echo 执行结束！</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 提交变更到本地仓库</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">set declation=%date:~0,4%%date:~5,2%%date:~8,2%</div><div class="line">git commit -m &quot;%declation%同步博客&quot;</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 将变更情况提交到远程git服务器</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git push origin master</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 批处理执行完毕！</div><div class="line">echo;</div><div class="line"></div><div class="line">pause</div></pre></td></tr></table></figure><h3 id="添加到自动任务"><a href="#添加到自动任务" class="headerlink" title="添加到自动任务"></a>添加到自动任务</h3><p>计算机-&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于人比较懒，总是忘了自己提交到github上，也觉得博客好不容易写了还要打开文件夹，点一下交，这个体验有点差呀。于是就写了个Linux自动提交代码的和windows自动更新博客的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jupyter-notebook安装和问题解决</title>
    <link href="http://yoursite.com/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/"/>
    <id>http://yoursite.com/26-工具/use_of_jupyter/</id>
    <published>2018-04-26T03:36:57.000Z</published>
    <updated>2018-05-13T13:39:12.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jupyter notebook折腾日记</p></blockquote><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-采用直接pip安装"><a href="#1-采用直接pip安装" class="headerlink" title="1.采用直接pip安装"></a>1.采用直接pip安装</h2><p><code>pip install jupyter</code>不过可能由于是版本自带的pip有问题，而且用的Python版本也还是2.7的，反正就出现了各种问题。中间解决的有：  </p><ul><li>重新升级pip，但是发现直接pip还是有问题，于是找到问题原因，可能名字有点对不上，找到bin目录下还有一个pip2，在Python里面运行，发现果然是这个，有点心酸，还是换了这个。  </li><li>升级之后，会出现各种的权限问题，没事，给！  </li><li>之后运行，发现没有浏览器，于是又想起服务器上没有，又加上命令试了一下，而且每次都要复制一个长长的token吗？。。</li></ul><h2 id="2-采用Anaconda安装"><a href="#2-采用Anaconda安装" class="headerlink" title="2.采用Anaconda安装"></a>2.采用Anaconda安装</h2><p>正好晚上在床上看到一个链接，说这个更方便，反正也是折腾嘛，就试试了。过程稍微写一写哈</p><ol><li>在清华镜像站找到采用Anaconda相应版本下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br> 找到后复制链接：<code>wget 链接</code> </li><li>安装Anaconda:<br> <code>sh Anaconda3-5.1.0-Linux-x86_64.sh # 一路yes就装了</code>  </li><li>服务器管理控制台开放8888端口（当然端口可以配置，也随便换了）  </li><li>运行<code>jupyter notebook --generate-config</code> 生成默认的jupyter配置文件  </li><li><p>编辑config文件：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd .jupyter</div><div class="line">vim jupyter_notebook_config.py #编辑config文件</div><div class="line">c.NotebookApp.ip = &apos;*&apos;  #允许所有的ip登录</div><div class="line">c.NotebookApp.open_browser = False #打开浏览器：关闭，因为服务器没有浏览器</div><div class="line">c.NotebookApp.port = 8888  #开放使用的端口</div></pre></td></tr></table></figure></li><li><p>保存退出。运行jupyter notebook，会得到一个带token的访问地址。复制地址，将其中的localhost替换成服务器的公网IP，访问，应该可以正常进入jupyter。  </p></li><li>每次都tocken当然有点麻烦了。设置一个密码吧：<br> <code>jupyter-notebook password</code></li><li>之后就可以公网输入登录了。</li></ol><h2 id="3-安装主题和相关插件"><a href="#3-安装主题和相关插件" class="headerlink" title="3.安装主题和相关插件"></a>3.安装主题和相关插件</h2><p><a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="external">jupyter_contrib_nbextensions</a><br>直接使用<code>conda install -c conda-forge jupyter_contrib_nbextensions</code></p><ul><li>使用注意：<br>1.关于ubuntu的环境变量设置没有对，导致conda命令不能用的问题。当然知道应该是环境变量的问题，不过还是搞了很久。才发现是加在ubuntu的home目录下的<code>.bashrc</code>后面<code>export PATH=~/anaconda3/bin:$PATH</code><br>2.由于我的conda版本没有更新，所以出现了插件也只有几个的情况，所以需要先更新。之后再重启jupyter notebook。<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><a href="http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/" target="_blank" rel="external">http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</a><br><a href="https://zhuanlan.zhihu.com/p/34289322" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34289322</a><br><a href="https://zhuanlan.zhihu.com/p/20226040?utm_source=qq&amp;utm_medium=social&amp;utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/20226040?utm_source=qq&amp;utm_medium=social&amp;utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;jupyter notebook折腾日记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="jupyter" scheme="http://yoursite.com/tags/jupyter/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日常折腾日记</title>
    <link href="http://yoursite.com/25-%E5%B7%A5%E5%85%B7/daily_zheteng/"/>
    <id>http://yoursite.com/25-工具/daily_zheteng/</id>
    <published>2018-04-25T03:49:56.000Z</published>
    <updated>2018-05-19T13:37:08.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>俗话说，生活就是不断的折腾，恰好自己是个这样的人。可能就是这样一个虽然不是很年轻了，但是心态总是年轻的，看到一些有趣的或者有意思的，总是忍不住想看看，或者试试。但是有时候又觉得自己不再年轻了，有些东西虽然当时记着了，但是后来又忘了，或者有时候记着又找起来很耽误时间。所以就在这记录一下吧。</p></blockquote><a id="more"></a><h2 id="博客相关"><a href="#博客相关" class="headerlink" title="博客相关"></a>博客相关</h2><p><a href="https://zhuanlan.zhihu.com/p/28128674" target="_blank" rel="external">hexo博客插件</a><br><a href="http://www.yuguocong.me/10-%E5%B7%A5%E5%85%B7/%E6%88%91%E7%9A%84hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">我的博客折腾</a><br><a href="http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/" target="_blank" rel="external">自动构建博客</a></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><a href="http://www.yuguocong.me/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/" target="_blank" rel="external">jupyter</a></p><ul><li><a href="https://www.cnblogs.com/kevingrace/p/6496899.html" target="_blank" rel="external">tmux的使用</a></li><li><a href="https://github.com/kxxoling/blog/blob/master/tool/tmux.md" target="_blank" rel="external">tmux的使用2</a></li></ul><h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><p>vip视频：<br><a href="https://github.com/laidefa/Flask_Web_Vip：" target="_blank" rel="external">https://github.com/laidefa/Flask_Web_Vip：</a>  <a href="http://101.37.147.236:1518/" target="_blank" rel="external">http://101.37.147.236:1518/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;俗话说，生活就是不断的折腾，恰好自己是个这样的人。可能就是这样一个虽然不是很年轻了，但是心态总是年轻的，看到一些有趣的或者有意思的，总是忍不住想看看，或者试试。但是有时候又觉得自己不再年轻了，有些东西虽然当时记着了，但是后来又忘了，或者有时候记着又找起来很耽误时间。所以就在这记录一下吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="资源" scheme="http://yoursite.com/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="收集" scheme="http://yoursite.com/tags/%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3使用总结</title>
    <link href="http://yoursite.com/24-%E5%B7%A5%E5%85%B7/use-of-sublime/"/>
    <id>http://yoursite.com/24-工具/use-of-sublime/</id>
    <published>2018-04-24T12:43:43.000Z</published>
    <updated>2018-04-24T14:49:47.092Z</updated>
    
    <content type="html"><![CDATA[<p>update:</p><ul><li>2018-04-24 首次更新:突然发现Sublime Text3也还是挺好用的，之前切出去光标总是乱跳，就有点烦，以为是这样的就没管，用了网易云，没想到发现只有我的是这样，赶紧找找问题，解决一下。顺便把很多重新折腾一下。</li></ul><p>#用好sublime</p><h3 id="为Sublime-Text3添加插入当前时间的命令"><a href="#为Sublime-Text3添加插入当前时间的命令" class="headerlink" title="为Sublime Text3添加插入当前时间的命令"></a><a href="https://www.cnblogs.com/jiafeimao-dabai/p/7238357.html" target="_blank" rel="external">为Sublime Text3添加插入当前时间的命令</a></h3><ol><li>创建插件：</li></ol><p>Tools → New Plugin:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import datetime</div><div class="line">import sublime_plugin</div><div class="line">class AddCurrentTimeCommand(sublime_plugin.TextCommand):</div><div class="line">    def run(self, edit):</div><div class="line">        self.view.run_command(&quot;insert_snippet&quot;, </div><div class="line">            &#123;</div><div class="line">                &quot;contents&quot;: &quot;%s&quot; % datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) </div><div class="line">            &#125;</div><div class="line">        )</div></pre></td></tr></table></figure></p><p>保存为Sublime Text3\Packages\User\addCurrentTime.py</p><ol><li>创建快捷键：</li></ol><p>Preference → Key Bindings - User:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;command&quot;: &quot;add_current_time&quot;,</div><div class="line">        &quot;keys&quot;: [</div><div class="line">            &quot;ctrl+shift+.&quot;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p><h3 id="添加了一个主题https-packagecontrol-io-packages-Predawn：Predawn"><a href="#添加了一个主题https-packagecontrol-io-packages-Predawn：Predawn" class="headerlink" title="添加了一个主题https://packagecontrol.io/packages/Predawn：Predawn"></a><a href="">添加了一个主题</a><a href="https://packagecontrol.io/packages/Predawn：Predawn" target="_blank" rel="external">https://packagecontrol.io/packages/Predawn：Predawn</a></h3><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><p>小土刀博客：<a href="http://wdxtub.com/2016/03/24/sublime-guide/" target="_blank" rel="external">http://wdxtub.com/2016/03/24/sublime-guide/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;update:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2018-04-24 首次更新:突然发现Sublime Text3也还是挺好用的，之前切出去光标总是乱跳，就有点烦，以为是这样的就没管，用了网易云，没想到发现只有我的是这样，赶紧找找问题，解决一下。顺便把很多重新折腾一下。&lt;/li&gt;
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="折腾" scheme="http://yoursite.com/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>阶段性生活思考</title>
    <link href="http://yoursite.com/24-%E9%9A%8F%E7%AC%94/redo-mylife/"/>
    <id>http://yoursite.com/24-随笔/redo-mylife/</id>
    <published>2018-04-24T12:40:26.000Z</published>
    <updated>2018-05-30T12:22:38.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="why-title"><a href="#why-title" class="headerlink" title="why title"></a>why title</h2><blockquote><p>生活就是要不断的思考,不是吗?</p></blockquote><a id="more"></a><h3 id="update-2018-05-13-21-15-04-周日"><a href="#update-2018-05-13-21-15-04-周日" class="headerlink" title="update:2018-05-13 21:15:04 周日"></a>update:2018-05-13 21:15:04 周日</h3><p>突然觉得很久没思考自己的生活了。      </p><ul><li>1.做事情注意力不集中。最近虽然看起来学习态度要好一些，每天都是待在实验室，但是学习的效率却感觉没有以前高了。而且总是注意力不够集中，明明在该学习的时候，却看看这个看看那个。做这个的时候看看想起另外一件事，就去看看，结果就该做的事情没做好。看看论文就想玩玩手机，玩着又有点愧疚就去看看c++，总是三心二意的。  </li><li>2.不太爱思考。另一个问题就是，遇到问题不求甚解。这还是以前的老问题吧，对于以前的应试教育来说，可能里面的道理也不用太深究，毕竟能最后写在试卷上就行了，看起来还能有个差不多好看的分数。但是现在处于的阶段不一样了，不管是日常的工作学习，还是平时看到一些新闻的想法，这都会有一些问题。当然，这方面可能手机因素也比较大一点，有很多的观点唾手可得，找找资料就能看到很多东西，恰好这方面自己又比较擅长，于是就又陷入了找资料不思考的陷阱。这样虽然有时候找到了很多有价值的东西，平时看到了很多，说吧，都知道，但是具体的就是不清楚，更别谈再有所新的想法了。所以这是个重要的问题。  </li><li>3.做事情应该更有目的。就是可能现在感觉很忙，但是却没有个统一的目的，有时候花的时间是多了，但是却没有很好的效果。  </li></ul><h3 id="update-2018-05-30-20-21-01-周三"><a href="#update-2018-05-30-20-21-01-周三" class="headerlink" title="update:2018-05-30 20:21:01 周三"></a>update:2018-05-30 20:21:01 周三</h3><ul><li>学习方面稍微集中了一点，但是还是没有太专注。  </li><li>做事情还是要抓住重点，仍然需要注意。  </li><li>多多总结。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;why-title&quot;&gt;&lt;a href=&quot;#why-title&quot; class=&quot;headerlink&quot; title=&quot;why title&quot;&gt;&lt;/a&gt;why title&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;生活就是要不断的思考,不是吗?&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>一文总结计算机网络</title>
    <link href="http://yoursite.com/10-network/network/"/>
    <id>http://yoursite.com/10-network/network/</id>
    <published>2018-04-10T12:24:59.000Z</published>
    <updated>2018-05-31T04:00:58.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近一直在看网络编程的东西，不管是看书、还是一些博客，或者是自己的一些编程，都觉得写的有点乱，有点杂。虽然这也比较符合网络方面的特点，零碎的知识点，有些人觉得重要就写上了，另一些就没有写。想到将来可能跟网络编程接触很多，也觉得最近的学习就是缺少一些总结。就在这里站在大佬的肩膀上整理一下吧。<br><a id="more"></a></p><h1 id="计算机网络体系结构（TCP-IP四层模型）"><a href="#计算机网络体系结构（TCP-IP四层模型）" class="headerlink" title="计算机网络体系结构（TCP/IP四层模型）"></a>计算机网络体系结构（TCP/IP四层模型）</h1><p>一般所说的计算机体系结构分为三种，其中TCP/IP体系结构是实际应用较多的。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/001.png" width="500"> </div><br></p><h2 id="各层的作用以及协议"><a href="#各层的作用以及协议" class="headerlink" title="各层的作用以及协议"></a>各层的作用以及协议</h2><h3 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h3><p>表示层和会话层用途如下：</p><ol><li>表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩；</li><li>会话层：不同机器上的用户之间建立及管理会话。</li></ol><h3 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h3><ol><li>应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li>网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</li><li>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。</li><li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ol><h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。<br>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/010.png" width="400"> </div><br><br>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/011.png" width="400"> </div><br></p><h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。<br>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/012.jpg" width="600"> </div><br></p><h1 id="网络接口层（TCP-IP）"><a href="#网络接口层（TCP-IP）" class="headerlink" title="网络接口层（TCP/IP）"></a>网络接口层（TCP/IP）</h1><p>对应OSI七层协议的数据链路层和物理层。在实际的编程中，一般对底层关注的更少，作为长期从事物理层和数据链路层相关工作的通信工程本来觉得可以稍微发挥一下的，咳咳。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li>传输数据的单位–比特</li><li>数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点）</li></ul><p>通道：</p><ul><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li><li>双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul><p>通道复用技术：</p><ul><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="主要信道："><a href="#主要信道：" class="headerlink" title="主要信道："></a>主要信道：</h3><ul><li>点对点信道</li><li>广播信道</li></ul><h4 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h4><ul><li>数据单元 ———— 帧</li></ul><p>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</p><h4 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h4><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/013.jpg" width="400"> </div><br></p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>透明表示一个实际存在的事物看起来好像不存在一样。<br>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符，如果出现转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/014.jpg" width="400"> </div><br></p><h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。网络层协议有：</p><ul><li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li><li>ARP（Address Resolution Protocol，地址解析协议）</li><li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li></ul><h2 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP 网际协议"></a>IP 网际协议</h2><h3 id="IP-地址分类："><a href="#IP-地址分类：" class="headerlink" title="IP 地址分类："></a>IP 地址分类：</h3><ul><li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li></ul><table><thead><tr><th>IP 地址类别</th><th>网络号</th><th>网络范围</th><th>主机号</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A 类</td><td>8bit，第一位固定为 0</td><td>0 —— 127</td><td>24bit</td><td>1.0.0.0 —— 127.255.255.255</td></tr><tr><td>B 类</td><td>16bit，前两位固定为  10</td><td>128.0 —— 191.255</td><td>16bit</td><td>128.0.0.0 —— 191.255.255.255</td></tr><tr><td>C  类</td><td>24bit，前三位固定为  110</td><td>192.0.0 —— 223.255.255</td><td>8bit</td><td>192.0.0.0 —— 223.255.255.255</td></tr><tr><td>D  类</td><td>前四位固定为 1110，后面为多播地址</td></tr><tr><td>E  类</td><td>前五位固定为 11110，后面保留为今后所用</td></tr></tbody></table><h3 id="IP-数据报格式："><a href="#IP-数据报格式：" class="headerlink" title="IP 数据报格式："></a>IP 数据报格式：</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/015.jpg" width="500"> </div><br></p><ul><li><strong>版本</strong>  : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong>  : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong>  : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong>  : 包括首部长度和数据部分长度。</li><li><strong>标识</strong>  : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong>  : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。<br><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/016.jpg" width="500"> </div><br></li><li><strong>生存时间</strong>  ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li></ul><h3 id="ARP-RARP-地址解析协议-反向地址转化协议"><a href="#ARP-RARP-地址解析协议-反向地址转化协议" class="headerlink" title="ARP/RARP 地址解析协议/反向地址转化协议"></a>ARP/RARP 地址解析协议/反向地址转化协议</h3><h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议:"></a>地址解析协议:</h4><ul><li>在数据报向下一个站点传递时，负责将IP地址转换为物理地址。</li><li>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接受返回消息，以此确定目标的物理地址；<br>接收的返回消息后将该IP地址和物理地址存入本机并保留一段时间，下次请求时直接查询ARP缓存以节约时间。<br>（地址解析协议是IPV4中广泛使用的协议；但在IPV6中不存在该协议，使用NDP（邻居发现协议））</li><li>工作流程：<br>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址解析为主机B的MAC（物理）地址。<br>ARP缓存是一个用来存储IP地址和MAC地址的一个缓冲区，其本质是一个IP地址对应一个MAC地址。当地址解析协议在查询IP时，首先在ARP缓存中查看，若存在则返回，否则发送ARP请求；<br>地址解析协议是通过报文工作的。报文包括如下字段：硬件类型，协议类型，硬件地址长度，协议长度，操作类型。</li><li>APR缓存包含一个或多个表，他们用于存储IP地址及经过地址解析的MAC地址。ARP命令用于查询本机的ARP缓存中的IP到MAC地址的对应关系、添加或删除静态对应关系等。如果再没有参数的情况下ARP命令将显示帮助信息。</li><li>ARP-a 查看缓存中的所有项目，在Linux中命令式ARP-g;</li></ul><h4 id="反向地址转化协议"><a href="#反向地址转化协议" class="headerlink" title="反向地址转化协议:"></a>反向地址转化协议:</h4><ul><li>作用于ARP相反，负责将物理层地址转换为IP地址</li><li>反向地址转化协议，作用于ARP相反，负责将物理层地址转换为IP地址；<br>允许局域网物理机器从网关服务器的ARP表或缓存上请求主机的IP地址；当设置一台新机器时，其RARP客户机程序需要向路由器上的RARP服务器请求相应的IP地址。</li><li>ARP是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议，假设知道自己的物理地址但不知道自己的IP地址，这种情况就该使用RARP协议。<br>RARP工作方式与ARP相反，RARP发出需要反向解析的MAC地址，并且希望返回其对应的IP地址，应答包括由能提供信息的RARP服务器发出的IP地址。</li><li>工作流程：<br>从网卡读取自己的MAC地址—&gt;发送RARP请求的广播数据包—&gt;RARP服务器收到请求，为其分配IP地址，并将RARP回应发送给该机器—&gt;该机器收到IP地址后，使用IP地址进行通信</li></ul><h3 id="ICMP-网际控制报文协议"><a href="#ICMP-网际控制报文协议" class="headerlink" title="ICMP 网际控制报文协议"></a>ICMP 网际控制报文协议</h3><p>由于IP协议提供的是一种不可靠的和无连接的数据报服务，为了对IP数据报的传送进行差错控制，对未能完成传送的数据报给出出错的原因，TCP/IP协议簇在网络连层提供了一个用于传递控制报文的ICMP协议，即网际控制报文协议。<br>ICMP 报文格式：</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/017.jpg" width="400"> </div><br><br>应用：</p><ul><li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性<ul><li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li></ul></li><li>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</li></ul><h3 id="IGMP-网际组管理协议"><a href="#IGMP-网际组管理协议" class="headerlink" title="IGMP 网际组管理协议"></a>IGMP 网际组管理协议</h3><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。</p><h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/018.jpg" width="500"> </div><br></p><ul><li><strong>Source Port和Destination Port</strong>:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接</li><li><strong>Sequence Number</strong>:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401；</li><li><strong>Acknowledgment Number</strong>:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。主要用来解决不丢包的问题。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701；</li><li><strong>Offset</strong>:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；</li><li><strong>TCP Flags</strong>:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：<ul><li>URG：此标志表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</li><li><strong>确认ACK</strong>：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1；</li><li>PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li><li>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li><li><strong>同步SYN</strong>：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</li><li><strong>终止FIN</strong>： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN=1标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</li></ul></li><li><strong>窗口</strong>  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/002.jpg" width="500"> </div><br></p><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li></ul><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的。那对于TCP的断开连接，就是通常说的“四次挥手”。</p><ul><li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，主机1也关闭连接。</li></ul><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接，解决网络中存在延迟的分组，防止了服务器端的一直等待而浪费资源。</p><blockquote><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”<br>失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。</p></blockquote><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。<br>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p><h4 id="TCP的十一种状态"><a href="#TCP的十一种状态" class="headerlink" title="TCP的十一种状态"></a>TCP的十一种状态</h4><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/008.png" width="500"> </div><br></p><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li><li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li><li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li><li>FIN_WAIT_1: 其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</li><li>FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li><li>CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</li><li>LAST_ACK: 被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li><li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li></ul><h4 id="TCP长连接和短连接"><a href="#TCP长连接和短连接" class="headerlink" title="TCP长连接和短连接"></a>TCP长连接和短连接</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul><li>长连接，也叫持久连接，在TCP层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息（包括心跳）交互，直至连接的任意一方（客户端OR服务端）主动断开连接，此过程称为一次完整的长连接。HTTP 1.1相对于1.0最重要的新特性就是引入了长连接。  </li><li>短连接，与长连接的区别就是，客户端收到服务端的响应后，立刻发送FIN消息，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互（发请求-收响应）之后立刻断开连接的情况都称为短连接。  </li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>1、需要频繁交互的场景使用长连接，如即时通信工具（微信/QQ，QQ也有UDP），相反则使用短连接，比如普通的web网站，只有当浏览器发起请求时才会建立连接，服务器返回响应后，连接立即断开。<br>2、维持长连接会有一定的系统开销，用户量少不容易看出系统瓶颈，一旦用户量上去了，就很有可能把服务器资源（内存/CPU/网卡）耗尽，所以使用需谨慎。  </p><h5 id="快速区分使用的是长连接还是短连接"><a href="#快速区分使用的是长连接还是短连接" class="headerlink" title="快速区分使用的是长连接还是短连接"></a>快速区分使用的是长连接还是短连接</h5><p>1、凡是在一次完整的消息交互（发请求-收响应）之后，立刻断开连接（有一方发送FIN消息）的情况都称为短连接；<br>2、长连接的一个明显特征是会有心跳消息（也有没有心跳的情况），且一般心跳间隔都在30S或者1MIN左右，用wireshark抓包可以看到有规律的心跳消息交互（可能会存在毫秒级别的误差）。  </p><h4 id="TCP实现可靠传输"><a href="#TCP实现可靠传输" class="headerlink" title="TCP实现可靠传输"></a>TCP实现可靠传输</h4><ul><li>建立连接（标志位）：通信前确认通信实体存在。</li><li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li><li>数据校验（校验和）：CRC校验全部数据。</li><li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li><li>窗口机制（窗口）：提供流量控制，避免过量发送。</li><li>拥塞控制：同上。</li></ul><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>超时重传机制：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<br>发送的数据没能到达接收端，所以对方没有响应。<br>接收端接收到数据，但是ACK报文在返回过程中丢失。<br>接收端拒绝或丢弃数据。</p><ul><li>重传间隔(RTO)：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。<ul><li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li><li>重传次数到达上限之后停止重传。</li></ul></li><li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li></ul><h5 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a><a href="https://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="external">TCP流量控制</a></h5><h6 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h6><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/007.jpg" width="500"> </div><br><br>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><h6 id="考虑传输速率"><a href="#考虑传输速率" class="headerlink" title="考虑传输速率"></a>考虑传输速率</h6><p>可以用不同的机制来控制TCP报文段的发送时机。如：</p><ol><li>TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即TCP支持的推送( push )操作。</li><li>发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</li></ol><p>Nagle算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定：当到达的数据已达到 发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p><p>糊涂窗口综合证：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><p>拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。<br>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。<br>流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。<br>拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。<br>控制办法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><h6 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h6><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。<br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。<br>慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/004.jpg" width="500"> </div><br><br>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。<br>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：<br>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p><p>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。<br>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/005.jpg" width="500"> </div><br></p><ol><li>当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</li><li>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。</li><li>假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。</li></ol><p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。<br>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/006.jpg" width="500"> </div><br><br>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。<br>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ol><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</li><li>由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ol><h5 id="区分流量控制和拥塞控制"><a href="#区分流量控制和拥塞控制" class="headerlink" title="区分流量控制和拥塞控制"></a>区分流量控制和拥塞控制</h5><ul><li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li><li>实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</li></ul><h4 id="TCP黏包问题"><a href="#TCP黏包问题" class="headerlink" title="TCP黏包问题"></a>TCP黏包问题</h4><ul><li>原因：<br>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</li><li>解决：</li></ul><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li><li>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。</li><li>使用更加复杂的应用层协议。</li></ul><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>面向无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），对于一些控制需要在应用层解决。</p><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/009.png" width="500"> </div><br></p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ol><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li><li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ol><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><h3 id="socket原理"><a href="#socket原理" class="headerlink" title="socket原理"></a>socket原理</h3><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。<br>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h3 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><ul><li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>*连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ul><h3 id="创建TCP的socket流程"><a href="#创建TCP的socket流程" class="headerlink" title="创建TCP的socket流程"></a>创建TCP的socket流程</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul><li>创建socket： <code>int socket(int domain, int type, int protocol)</code>;</li><li>将socket绑定地址和端口号：<code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</code>;</li><li>监听：<code>int listen(int sockfd, int backlog)</code>;</li><li>接受连接：<code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)</code>;</li><li>读取数据：<code>ssize_t read(int fd, void *buf, size_t count)</code>;</li><li>关闭socket:<code>int close(int fd)</code>;</li></ul><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li>创建socket： <code>int socket(int domain, int type, int protocol)</code>;</li><li>连接：<code>int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen)</code>;</li><li>输入数据: <code>ssize_t write(int fd, const void *buf, size_t count)</code>;</li><li>关闭socket:<code>int close(int fd)</code>;</li></ul><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><p>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</p><h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h2><p>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。<br>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</p><h2 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。<br>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><h2 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h2><p>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：</p><ol><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ol><h2 id="超文本传送协议-HTTP"><a href="#超文本传送协议-HTTP" class="headerlink" title="超文本传送协议 HTTP"></a>超文本传送协议 HTTP</h2><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://github.com/huihut/interview#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" target="_blank" rel="external">https://github.com/huihut/interview#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C</a><br><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82" target="_blank" rel="external">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82</a><br><a href="https://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="external">https://blog.csdn.net/yechaodechuntian/article/details/25429143</a><br><a href="http://www.cnblogs.com/maybe2030/p/4781555.html#_label3" target="_blank" rel="external">http://www.cnblogs.com/maybe2030/p/4781555.html#_label3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近一直在看网络编程的东西，不管是看书、还是一些博客，或者是自己的一些编程，都觉得写的有点乱，有点杂。虽然这也比较符合网络方面的特点，零碎的知识点，有些人觉得重要就写上了，另一些就没有写。想到将来可能跟网络编程接触很多，也觉得最近的学习就是缺少一些总结。就在这里站在大佬的肩膀上整理一下吧。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux的fork使用</title>
    <link href="http://yoursite.com/15-Linux%E7%9A%84fork%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/15-Linux的fork使用/</id>
    <published>2018-03-15T14:48:01.000Z</published>
    <updated>2018-05-22T06:43:37.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux的fork使用"><a href="#Linux的fork使用" class="headerlink" title="Linux的fork使用"></a>Linux的fork使用</h2><blockquote><p>fork函数可以算是Linux里有点不好明白的函数了，调用一次，返回两次，虽然在平时的写法中，有基本固定的写法，但是有时候看起来还是有些让人头疼的。这里就把关于fork函数好好整理一下</p></blockquote><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><p><strong>功能</strong>：fork函数是从一个已经存在的进程中创建一个新的进程，新的进程称为子进程，原来的进程称为父进程。<br><strong>参数</strong>：无<br><strong>返回值</strong>：<br>成功：子进程中返回 0，父进程中返回子进程 ID。pid_t，为无符号整型。<br>失败：返回 -1。</p><p>失败的两个主要原因是：<br>1）当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN。<br>2）系统内存不足，这时 errno 的值被设置为 ENOMEM。</p><h3 id="测试的例子"><a href="#测试的例子" class="headerlink" title="测试的例子"></a>测试的例子</h3><p>下面是一个简单的创建子进程的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    int pid=1;</div><div class="line">    pid=fork();</div><div class="line">    if(0==pid)&#123; //pid为0，表示为子进程</div><div class="line">        cout&lt;&lt;&quot;我是子进程，我的pid是：&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    else if(pid&gt;0)&#123; //pid&gt;0表示父进程，此时返回值为子进程的pid</div><div class="line">        cout&lt;&lt;&quot;我是父进程，我的pid是&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    else &#123;  //fork 失败</div><div class="line">        cout&lt;&lt;&quot;fork失败&quot;&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面的例子可以看出，fork函数会有两个返回值，一个是在子进程中返回0,一个是在父进程中返回子进程的pid。因此在编程过程中，需要判断这个值的返回值来判断当前是父进程还是子进程。</p><h3 id="fork进程的原理"><a href="#fork进程的原理" class="headerlink" title="fork进程的原理"></a>fork进程的原理</h3><p>使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用 fork()函数的代价是很大的。<br><img src="http://blog-1252063226.cosbj.myqcloud.com/Linux/003001.jpg?raw=true" alt=""></p><h3 id="日常使用fork"><a href="#日常使用fork" class="headerlink" title="日常使用fork"></a>日常使用fork</h3><p>简单来说， 一个进程调用 fork() 函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p><p>实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在<strong>需要写入的时候才会进行，在此之前，只有以只读方式共享</strong>。</p><p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。一般来说，在 fork() 之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。</p><p>因此，在实际的使用过程中，一般都需要对fork()的返回值进行判断，看我们操作的是父进程还是子进程。</p><h4 id="一般的操作：同时创建多个子进程"><a href="#一般的操作：同时创建多个子进程" class="headerlink" title="一般的操作：同时创建多个子进程"></a>一般的操作：同时创建多个子进程</h4><p>不对的例子:父进程会生成 n(n+1)/2+1个子进程，N 为循环次数，本例中共有 7 个子进程， 但实际上只有 3 个是父进程产生的，其余都为子进程 fork（）出来的。父进程fork了3个进程，第一个子进程执行完之后又fork了2个进程，第2个子进程fork了1个进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    pid_t p1,p2;</div><div class="line">    int i;</div><div class="line">    int N=100;</div><div class="line">    for(int i=0;i&lt;=N;++i)&#123;</div><div class="line">        if((p1=fork())==0)&#123;</div><div class="line">            cout&lt;&lt;&quot;子进程1：&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">            //return 0;  //很关键的地方，为什么需要返回呢</div><div class="line">        &#125;</div><div class="line">        wait(p1,NULL,0); //父进程等待p1子进程执行后才能继续fork其他子进程</div><div class="line">        cout&lt;&lt;&quot;这是父进程: &quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>正确的使用Linux中的用fork()由一个父进程创建同时多个子进程 的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    pid_t p1,p2;</div><div class="line">    int i;</div><div class="line">    int N=100;</div><div class="line">    for(int i=0;i&lt;=N;++i)&#123;</div><div class="line">        status=fork();</div><div class="line">        if(status==0||status==1) break;//每次循环时，如果发现是子进程就直接从创建子进程的循环中跳出来，不让你进入循环，这样就保证了每次只有父进程来做循环创建子进程的工作</div><div class="line">        if (status == -1)</div><div class="line">        &#123;</div><div class="line">          //error</div><div class="line">        &#125;</div><div class="line">        else if (status == 0) //每个子进程都会执行的代码</div><div class="line"></div><div class="line">        &#123;</div><div class="line">          //sub process</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">          //parent process</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="无聊的问题"><a href="#无聊的问题" class="headerlink" title="无聊的问题"></a>无聊的问题</h3><p>1.下面的程序，不算 main这个进程自身，到底创建了多少个进程啊？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">   fork();</div><div class="line">   fork() &amp;&amp; fork() || fork();</div><div class="line">   fork();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>每fork一次就翻倍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  fork(); //2个</div><div class="line">   fork() &amp;&amp; fork() || fork();</div><div class="line">//A&amp;&amp;B||C</div><div class="line">//A为假，跳过B，判断C-----------------------2</div><div class="line">//A为真，判断B，若B为真，跳过C-----------1</div><div class="line">//若B为假，判断C ------------2</div><div class="line">   fork(); //2</div></pre></td></tr></table></figure></p><p>总共有：<br>2<em>(2+1+2)</em>2=20<br>不算自己的话有20-1=19个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux的fork使用&quot;&gt;&lt;a href=&quot;#Linux的fork使用&quot; class=&quot;headerlink&quot; title=&quot;Linux的fork使用&quot;&gt;&lt;/a&gt;Linux的fork使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;fork函数可以算是Linux里有
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-60-Permutation-Sequence</title>
    <link href="http://yoursite.com/06-%E5%88%B7%E9%A2%98/LeetCode-60-Permutation-Sequence/"/>
    <id>http://yoursite.com/06-刷题/LeetCode-60-Permutation-Sequence/</id>
    <published>2018-02-06T09:32:24.000Z</published>
    <updated>2018-04-27T02:28:48.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-60-Permutation-Sequence"><a href="#LeetCode-60-Permutation-Sequence" class="headerlink" title="LeetCode-60-Permutation-Sequence"></a>LeetCode-60-Permutation-Sequence</h3><blockquote><p>The set [1,2,3,…,n] contains a total of n! unique permutations.<br>By listing and labeling all of the permutations in order,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">We get the following sequence (ie, for n = 3):</div><div class="line"></div><div class="line">&quot;123&quot;</div><div class="line">&quot;132&quot;</div><div class="line">&quot;213&quot;</div><div class="line">&quot;231&quot;</div><div class="line">&quot;312&quot;</div><div class="line">&quot;321&quot;</div><div class="line">Given n and k, return the kth permutation sequence.</div></pre></td></tr></table></figure></p></blockquote><p>同样是排列 组合的问题，这次不需要打印所有的排列了，只需要按照排列的顺序打印出第k个，很显然，思路不会是列出所有的排列，然后找第k个打印出来是吧。</p><p>观察来看，以<code>1,2,3,4</code>为例，有<code>4*3*2*1=24</code>种排列，其中根据排列的顺序，按照第一个数字可以分为以下4种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1 * * *</div><div class="line"></div><div class="line">2 * * *</div><div class="line"></div><div class="line">3 1 2 4</div><div class="line">3 1 4 2</div><div class="line">3 2 1 4</div><div class="line">3 2 4 1</div><div class="line">3 4 1 2</div><div class="line">3 4 2 1</div><div class="line"></div><div class="line">4 * * *</div><div class="line">#### 方法一</div></pre></td></tr></table></figure></p><ul><li><p>第一个数<br>可以看出，当k=14时，第一个数字为3,这个是可以通过计算的。由于是从1开始的，取k=13；<code>index=k/(n-1)!=13/3!=2</code>，于是可以知道第一个数是3。那么第二个数字呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1+permutation(2,4)</div><div class="line">2+permutation(1,4)</div><div class="line">4+permutation(1,2)</div></pre></td></tr></table></figure></li><li><p>第二个数<br>可以根据:<code>k=k-index_pre*(n-1)!=13-2*3!=1</code>;<br><code>index=k/(n-2)!=1/(4-2)!=0</code>于是第二个数为1。</p></li><li>第三个数<br>接下来就只剩下2和4了，继续:<code>k=k-index_pre*(n-2)!=1-0*(4-2)!=1</code>,  <code>index=k/(n-3)!=1/(4-3)!=1</code>在此处表示为4.之后再确定最后一个:</li><li>第四个数<br><code>k=k-index_pre*(n-4)!=1-1*(4-4)=0</code>;<br><code>index=k/(n-4)!=0/(4-4)!=0</code> 故第四个数为2</li></ul><p>到了这里，思路就比较清晰了。我们需要做的是从第一个一直到最后一个的循环，每次选出一个数，但是还需要将该数从原来的数组中剔除掉，因为前面选过的后面就不能排列了。</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>其实原理差不多，也还是根据排列的规律。只不过算的方法不一样。</p><ol><li>j=i+k/(n-i)!;</li><li>删除s[j];</li><li>k=k%(n-i);</li><li>s[i]=s[j];<br>代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    string getPermutation(int n, int k) &#123;</div><div class="line">        if(n&lt;=0)</div><div class="line">            return &quot; &quot;;</div><div class="line">        int i,j,f=1;</div><div class="line">        string s(n,&apos;0&apos;);</div><div class="line">        for(i=1;i&lt;=n;i++)&#123;</div><div class="line">            f*=i;</div><div class="line">            s[i-1]+=i;</div><div class="line">        &#125;</div><div class="line">        for(i=0,k--;i&lt;n;++i)&#123;</div><div class="line">            f/=n-i;</div><div class="line">            j=i+k/f;</div><div class="line">            char c=s[j];</div><div class="line">            for(;j&gt;i;j--)</div><div class="line">                s[j]=s[j-1];</div><div class="line">            k%=f;</div><div class="line">            s[i]=c;</div><div class="line">        &#125;</div><div class="line">        return s;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-60-Permutation-Sequence&quot;&gt;&lt;a href=&quot;#LeetCode-60-Permutation-Sequence&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-60-Permutation-Sequ
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构技术-架构模式</title>
    <link href="http://yoursite.com/03-architecture-model-of-web-architecture/"/>
    <id>http://yoursite.com/03-architecture-model-of-web-architecture/</id>
    <published>2018-02-03T08:39:27.000Z</published>
    <updated>2018-05-13T13:47:16.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大型网站架构技术-架构模式"><a href="#大型网站架构技术-架构模式" class="headerlink" title="大型网站架构技术-架构模式"></a>大型网站架构技术-架构模式</h2><p>模式的关键在于模式的可重复性。<br><a id="more"></a></p><blockquote><p>每一个模式描述了一个在我们周围不断变化重复发生的问题及该问题解决方案的核心。这样就能一次次的使用该方案而不必做重复的工作。</p></blockquote><p>这是经过很多个实践，被很多网站重复使用而逐渐形成大型网站架构模式：</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>将系统再横向维度上切成几个部分，每个部分负责一部分相对单一的职责。就好比平时一份工作比较多的时候，团队中大家各自负责自己擅长的那一部分。大型网站中一般分为三层：</p><ul><li>应用层：负责具体业务和视图展示。</li><li>服务层：为应用层提供服务支持。</li><li>数据层：提供数据存储访问服务。如数据库、缓存、文件、搜索引擎等。<br>需要注意的是：这个分层是逻辑的，并不一定要部署在不同的服务器上，可能会根据业务调整。  </li></ul><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>对业务进行横向切分。比如应用层：分为购物、论坛、搜索等。  </p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>一台服务器解决不了的时候，就采用分布式解决一下。<br>分为：分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算。  </p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>使用分布式已经将分层和分割后的模块独立部署，但是对于用户集中访问的模块，可能还需要将独立部署的服务器集群化（多台服务器部署相同的应用构成一个集群），再通过一个负载均衡服务器对外提供服务。  </p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存是改善软件性能的第一手段。</p><ul><li>CDN：讲内容部署在离用户最近的网络服务商，用户请求的时候，可以直接访问网络服务商缓存的静态资源，所以会很快。</li><li>反向代理：用户请求到网站的数据中心时，最先访问的是反向代理服务器，这里会缓存网站的静态资源。</li><li>本地缓存：应用服务器本地缓存的热点数据，可以在本机内存中直接访问，不需要访问数据库。</li><li>分布式缓存：数据量非常庞大时，需要的内存不是单机能承受的。因此还需要分布式缓存    </li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步进行协作。<br>在单一服务器内部：采用<strong>多线程共享队列</strong>的方式实现异步。在分布式系统中：多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看做内存的分布式部署。</p><p>分布式消息队列的特性：网站扩展新功能便利，提高系统可用性，加快网站响应速度，消除并发访问高峰。  </p><h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>备份嘛，较少的机器可能坏的时间不长，但是小概率时间试验的次数过多的话就基本是必然事件了。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>主要集中在运维方面，包括：发布过程自动化、自动化代码管理、自动化测试、自动化安全监测、自动化部署。对于运行中：自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降级、自动化分配资源。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>密码和手机验证码；加密；网站验证码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大型网站架构技术-架构模式&quot;&gt;&lt;a href=&quot;#大型网站架构技术-架构模式&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构技术-架构模式&quot;&gt;&lt;/a&gt;大型网站架构技术-架构模式&lt;/h2&gt;&lt;p&gt;模式的关键在于模式的可重复性。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="大型网站技术" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构技术-演化</title>
    <link href="http://yoursite.com/03-evolution-of-webArchitecture/"/>
    <id>http://yoursite.com/03-evolution-of-webArchitecture/</id>
    <published>2018-02-03T05:43:26.000Z</published>
    <updated>2018-05-13T13:53:47.793Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="大型网站架构技术-演化"><a href="#大型网站架构技术-演化" class="headerlink" title="大型网站架构技术-演化"></a>大型网站架构技术-演化</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>高并发、大流量</li><li>高可用</li><li>海量数据</li><li>用户分布广泛、网络情况复杂</li><li>安全环境恶劣：易受攻击</li><li>需求变化快、发布频繁：为了快速适应市场</li><li>渐进式发展：逐渐进步发展</li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><h3 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h3><p>应用程序、数据库、文件等所有资源都在一台服务器上。一般是在一台廉价的服务器上采用LAMP这种免费资源。</p><h3 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h3><p>采用三台服务器分别承担自己的角色。</p><h3 id="使用缓存改善网站的性能"><a href="#使用缓存改善网站的性能" class="headerlink" title="使用缓存改善网站的性能"></a>使用缓存改善网站的性能</h3><p>二八定律：80%的业务访问集中在20%的数据上，为了减少数据库的访问压力，可以将一些数据放到缓存服务器上，这样可以提高整个网站的数据访问速度。<br>一般分为两种：</p><ul><li>缓存在应用服务器上的本地缓存：访问速度快，但缓存的数据有限；</li><li>缓存在专门的分布式缓存服务器上的远程缓存：可以采用分布式缓存。<h3 id="采用应用服务器改善网站并发处理能力"><a href="#采用应用服务器改善网站并发处理能力" class="headerlink" title="采用应用服务器改善网站并发处理能力"></a>采用应用服务器改善网站并发处理能力</h3>当应用服务器处理不了较多的并发请求时，可以增加一台服务器分担原有的服务器的访问，在前面加一个负载均衡服务器。<h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3>虽然采用了缓存，但有一些<strong>读操作和一部分写操作</strong>还是会落到数据库上。一般采用主从备份的数据库，写操作可以在主数据库中进行，读操作在从数据库中读取。<h3 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h3>加速用户的访问。基本原理都是缓存，CDN是部署在网络提供商的机房，反向代理部署在网站的中心机房。对于反向代理，用户首先访问的是反向代理服务器，如果反向代理服务器中缓存着资源，就直接返回给用户。<h3 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h3>持续增长的业务，单一的服务器满足不了要求的时候，一头牛拉不动的时候，不要企图换一头更厉害的牛，而是考虑再加一头牛一起拉。<h3 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h3>网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，需要采用一些非关系数据库技术和非数据库查询技术如搜索引擎。<h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3>分而治之<h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;大型网站架构技术-演化&quot;&gt;&lt;a href=&quot;#大型网站架构技术-演化&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构技术-演化&quot;&gt;&lt;/a&gt;大型网站架构技术-演化&lt;/h1&gt;&lt;h2 id=&quot;特点&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="大型网站技术" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-56and57-Merge-Intervals</title>
    <link href="http://yoursite.com/30-%E5%88%B7%E9%A2%98/LeetCode-56-Merge-Intervals/"/>
    <id>http://yoursite.com/30-刷题/LeetCode-56-Merge-Intervals/</id>
    <published>2018-01-30T08:00:00.000Z</published>
    <updated>2018-04-27T02:28:48.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-56-Merge-Intervals"><a href="#LeetCode-56-Merge-Intervals" class="headerlink" title="LeetCode-56-Merge-Intervals"></a>LeetCode-56-Merge-Intervals</h3><blockquote><p>Given a collection of intervals, merge all overlapping intervals.<br>For example,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Given [1,3],[2,6],[8,10],[15,18],</div><div class="line">return [1,6],[8,10],[15,18].</div></pre></td></tr></table></figure></p></blockquote><p>如例子中所示，每个数组的前后分别表示开始和结束，工作是合并有重叠的数组。例如，由于[1,3]和[2,6]有重叠，故直接改为[1,6]后输出。<br>想法还是比较简单的，因为输入的并不一定是给好的按照开始，所以需要先对输入以开始的值排序。首先在结果数组中写入第一个，只有遍历进行判断，分为两种情况：</p><ol><li>如果某一interval的开始比结果数组中的结尾要大，显然不会有重叠，直接写入到结果数组中即可；</li><li>某一interval的开始比结果数组中的结尾要大，必然有重叠，此时还需要判断结束位置的大小。</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for an interval.</div><div class="line"> * struct Interval &#123;</div><div class="line"> *     int start;</div><div class="line"> *     int end;</div><div class="line"> *     Interval() : start(0), end(0) &#123;&#125;</div><div class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</div><div class="line">        vector&lt;Interval&gt; res;</div><div class="line">        if(intervals.size()&lt;=0)</div><div class="line">            return res;</div><div class="line">        sort(intervals.begin(),intervals.end(),[](Interval a,Interval b)&#123;return a.start&lt;b.start;&#125;);</div><div class="line">        res.push_back(intervals[0]);</div><div class="line">        for(int i=1;i&lt;intervals.size();++i)&#123;</div><div class="line">            if(res.back().end&lt;intervals[i].start) res.push_back(intervals[i]);</div><div class="line">            else&#123;</div><div class="line">                res.back().end=max(res.back().end,intervals[i].end);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57-Insert-Interval"></a>57-Insert-Interval</h3><blockquote><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).<br>You may assume that the intervals were initially sorted according to their start times.</p></blockquote><p>题目改为向一个已经重叠的数组中加入新加入一个。需要做的是判断所处的位置，插入进去后还要删掉，值得注意的是这个删掉值的时候，vector的迭代器会发生变化，即有些会失效，所以最好的做法是，先插入，把需要的插入都插入之后再删除。</p><p>另外还有一个值得注意的是，排序搜索的谓语，使用的是<code>a.end&lt;b.start</code>，而不是之前的<code>a.start&lt;b.start</code> ，原因是需要找到一个范围，将newINterval夹在中间的一个范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for an interval.</div><div class="line"> * struct Interval &#123;</div><div class="line"> *     int start;</div><div class="line"> *     int end;</div><div class="line"> *     Interval() : start(0), end(0) &#123;&#125;</div><div class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</div><div class="line">        if(intervals.size()&lt;=0)&#123;</div><div class="line">            intervals.push_back(newInterval);</div><div class="line">            return intervals;</div><div class="line">        &#125;</div><div class="line">        auto range=equal_range(intervals.begin(),intervals.end(),newInterval,[](Interval a,Interval b)&#123;return a.end&lt;b.start;&#125;);</div><div class="line">        auto iter1=range.first,iter2=range.second;</div><div class="line">        if(iter1==iter2)</div><div class="line">            intervals.insert(iter1,newInterval);</div><div class="line">        else&#123;</div><div class="line">            iter2--;</div><div class="line">            iter2-&gt;start=min(newInterval.start,iter1-&gt;start);</div><div class="line">            iter2-&gt;end=max(newInterval.end,iter2-&gt;end);</div><div class="line">            intervals.erase(iter1,iter2);</div><div class="line">        &#125;</div><div class="line">        return intervals;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-56-Merge-Intervals&quot;&gt;&lt;a href=&quot;#LeetCode-56-Merge-Intervals&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-56-Merge-Intervals&quot;&gt;&lt;/a&gt;LeetC
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-55-Jump-Game</title>
    <link href="http://yoursite.com/30-%E5%88%B7%E9%A2%98/LeetCode-55-Jump-Game/"/>
    <id>http://yoursite.com/30-刷题/LeetCode-55-Jump-Game/</id>
    <published>2018-01-30T07:39:55.000Z</published>
    <updated>2018-04-27T02:28:48.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-55-Jump-Game"><a href="#LeetCode-55-Jump-Game" class="headerlink" title="LeetCode-55-Jump-Game"></a>LeetCode-55-Jump-Game</h3><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.</p></blockquote><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = [2,3,1,1,4], return true.</div><div class="line"></div><div class="line">A = [3,2,1,0,4], return false.</div></pre></td></tr></table></figure></p><p>由题可知，数组的位置表示从该位置可以像前跳的步数，看最终能否跳到结尾。乍一看，这像是一个动态规划的问题，dp数组内存储每一个位置能够走的最远的位置，但是仔细一想，又是没有必要的，因为最终的目的不是为了判断哪一个位置能走的更远，而是能否到达最后一个位置。<br>能到达最后一个位置的必要条件，显然一个就是能从某一位置继续往前走，而不会断。例如：<code>[3,2,1,0,4]</code>，我们都能走到第4个位置，但是却无法继续往前走，故到不了最后一个。所以代码可以做一个判断。<br>另一个需要考虑的问题是：在从前往后遍历的过程中，维护哪一个变量？显然这个变量记录的是我们能走的最远的距离，如果这个距离走的更远就更新，直到不能继续往前走，此时判断能否到终点。</p><p>贴上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int i=0;</div><div class="line">        for(int reach=0;i&lt;nums.size()&amp;&amp;i&lt;=reach;++i)</div><div class="line">            reach=max(reach,i+nums[i]);</div><div class="line">        return i==nums.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-55-Jump-Game&quot;&gt;&lt;a href=&quot;#LeetCode-55-Jump-Game&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-55-Jump-Game&quot;&gt;&lt;/a&gt;LeetCode-55-Jump-Game&lt;/
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-53-Maximum-Subarray</title>
    <link href="http://yoursite.com/26-%E5%88%B7%E9%A2%98/LeetCode-53-Maximum-Subarray/"/>
    <id>http://yoursite.com/26-刷题/LeetCode-53-Maximum-Subarray/</id>
    <published>2018-01-26T09:57:03.000Z</published>
    <updated>2018-04-27T02:28:48.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-53-Maximum-Subarray"><a href="#LeetCode-53-Maximum-Subarray" class="headerlink" title="LeetCode-53-Maximum-Subarray"></a>LeetCode-53-Maximum-Subarray</h2><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.<br>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p></blockquote><p>最长子序列，又是一个动态规划的问题，关于动态规划，我们最主要的是要维护DP数组，这个问题以前还有点不理解，感觉主要的还是思想，只要知道这是一个动态规划的问题，解决动态规划的一般方法掌握了，其他的就都是细节了。</p><p>最近刷算法题，不得不想到的是以前的数学，数学是逻辑性可能更强的东西，尚且需要多做练习才行，何况算法了。当然现在慢慢的感觉就是，以前看到很多题完全没有头绪，现在很多大概是能分清是想考啥了，也会想着主动去选择相应的数据结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;int&gt; dp(nums.size(),0);</div><div class="line">        dp[0]=nums[0];</div><div class="line">        int res=dp[0];</div><div class="line">        for(int i=1;i&lt;nums.size();++i)&#123;</div><div class="line">            dp[i]=nums[i]+(dp[i-1]&gt;0?dp[i-1]:0);</div><div class="line">            res=max(dp[i],res);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LeetCode-53-Maximum-Subarray&quot;&gt;&lt;a href=&quot;#LeetCode-53-Maximum-Subarray&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-53-Maximum-Subarray&quot;&gt;&lt;/a&gt;Le
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-52-N-Queens-II</title>
    <link href="http://yoursite.com/26-%E5%88%B7%E9%A2%98/LeetCode-52-N-Queens-II/"/>
    <id>http://yoursite.com/26-刷题/LeetCode-52-N-Queens-II/</id>
    <published>2018-01-26T09:00:24.000Z</published>
    <updated>2018-04-27T02:28:48.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-52-N-Queens-II"><a href="#LeetCode-52-N-Queens-II" class="headerlink" title="LeetCode-52-N-Queens-II"></a>LeetCode-52-N-Queens-II</h3><blockquote><p>Follow up for N-Queens problem.<br>Now, instead outputting board configurations, return the total number of distinct solutions.</p></blockquote><p>只返回N皇后问题结果的种数。<br>因此不需要每一个字符串置位了，只需要判断一个位置的横竖，斜45度和斜135度方向的值即可。依然采用递归的方式，这里需要注意的是，由于是对列递归，所以需要考虑的是行，斜45度，斜135度，本来是要维护一个一维数组和两个二维数组，但是想到二维数组的特征，可以改为维护三个一维数组，这两个一维数组保存的是将二维数组展开的信息。甚至是一波操作改为共维护两个一维数组也可以。<br>接下来是代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int totalNQueens(int n) &#123;</div><div class="line">        vector&lt;int&gt; rows(n),d1(2*n-1),d2(2*n-1);</div><div class="line">        return find(n,n,0,rows,d1,d2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int find(int n,int left,int i,vector&lt;int&gt;&amp; rows,vector&lt;int&gt;&amp; d1,vector&lt;int&gt;&amp; d2)&#123;</div><div class="line">        if(left==0)</div><div class="line">            return 1;</div><div class="line">        int j,sum=0;</div><div class="line">        for(j=0;j&lt;n;++j)&#123;</div><div class="line">            if(rows[j]||d1[i+j]||d2[n-1+i-j])</div><div class="line">                continue;</div><div class="line">            rows[j]=d1[i+j]=d2[n-1+i-j]=1;</div><div class="line">            sum+=find(n,left-1,i+1,rows,d1,d2);</div><div class="line">            rows[j]=d1[i+j]=d2[n-1+i-j]=0;</div><div class="line">        &#125;</div><div class="line">        return sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>看了一下别人的好像确实快一点，毕竟0ms啊，也贴一下别人的代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int totalNQueens(int n) &#123;</div><div class="line">        bool flag[5*n] = &#123;false&#125;;</div><div class="line">        int num = 0;</div><div class="line">        dfs(num,flag,0,n);</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void dfs(int&amp; num, bool* flag, int row, int n)&#123;</div><div class="line">        if(row == n)&#123;</div><div class="line">            ++num;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i = 0; i&lt;n;i++)&#123;</div><div class="line">            if(!flag[i] &amp;&amp; !flag[row+i+n] &amp;&amp; !flag[4*n + row - i])&#123;</div><div class="line">                flag[i] = 1;</div><div class="line">                flag[row+i+n] = 1;</div><div class="line">                flag[4*n + row - i] = 1;</div><div class="line">                dfs(num,flag,row+1,n);</div><div class="line">                flag[i] = 0;</div><div class="line">                flag[row+i+n] = 0;</div><div class="line">                flag[4*n + row - i] = 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h4><p><a href="https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand" target="_blank" rel="external">https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-52-N-Queens-II&quot;&gt;&lt;a href=&quot;#LeetCode-52-N-Queens-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-52-N-Queens-II&quot;&gt;&lt;/a&gt;LeetCode-52-N-Que
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-51-N-Queens</title>
    <link href="http://yoursite.com/26-%E5%88%B7%E9%A2%98/LeetCode-51-N-Queens/"/>
    <id>http://yoursite.com/26-刷题/LeetCode-51-N-Queens/</id>
    <published>2018-01-26T02:12:49.000Z</published>
    <updated>2018-04-27T02:28:48.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-51-N-Queens"><a href="#LeetCode-51-N-Queens" class="headerlink" title="LeetCode-51-N-Queens"></a>LeetCode-51-N-Queens</h3><p>经典的N皇后问题，重点是全排列的问题，但是这里由于N皇后的不重复行、列、斜的要求，在排列的过程中，比如从行开始排列，只能保证同行不重复，所以需要引入isValid函数。通过判断列，左斜、右斜是否重复。</p><p>需要注意的是：关于全排列递归的写法，要更加熟练掌握才行，并且能完全理解，能够在不同的情况中灵活运用。其基本思想还是：固定前面的某个数字，不短的对后面进行交换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isValid(vector&lt;string&gt;&amp; queen, int row,int col,int n)&#123;</div><div class="line">        for(int i=0;i&lt;row;++i)&#123;</div><div class="line">            if(queen[i][col]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;--i,--j)&#123;</div><div class="line">            if(queen[i][j]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;--i,++j)&#123;</div><div class="line">            if(queen[i][j]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    void recurse(vector&lt;string&gt;&amp; queen,vector&lt;vector&lt;string&gt;&gt;&amp; res,int row,int n)&#123;</div><div class="line">        if(row==n)&#123;</div><div class="line">            res.push_back(queen);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int col=0;col!=n;++col)&#123;</div><div class="line">            if(isValid(queen,row,col,n))&#123;</div><div class="line">                queen[row][col]=&apos;Q&apos;;</div><div class="line">                recurse(queen,res,row+1,n);</div><div class="line">                queen[row][col]=&apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">        vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">        vector&lt;string&gt; queen(n,string(n,&apos;.&apos;));</div><div class="line">        recurse(queen,res,0,n);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-51-N-Queens&quot;&gt;&lt;a href=&quot;#LeetCode-51-N-Queens&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-51-N-Queens&quot;&gt;&lt;/a&gt;LeetCode-51-N-Queens&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-49-Group-Anagrams</title>
    <link href="http://yoursite.com/25-%E5%88%B7%E9%A2%98/LeetCode-49-Group-Anagrams/"/>
    <id>http://yoursite.com/25-刷题/LeetCode-49-Group-Anagrams/</id>
    <published>2018-01-25T13:44:37.000Z</published>
    <updated>2018-04-27T02:28:48.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-49-Group-Anagrams"><a href="#LeetCode-49-Group-Anagrams" class="headerlink" title="LeetCode-49-Group-Anagrams"></a>LeetCode-49-Group-Anagrams</h3><blockquote><p>Given an array of strings, group anagrams together.<br>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],</p></blockquote><p>Return:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],</div><div class="line">  [&quot;nat&quot;,&quot;tan&quot;],</div><div class="line">  [&quot;bat&quot;]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>输入一个字符串数组，输出的是：将相同字符的字符串放在一个数组的二维数组。相同字符的处理，基本就是要对字符串排序的。然后需要考虑的就是排序好的那一个字符串怎么存的问题。用的数据结构是map，string为键，对应的值是一个set或者是一个vector，存放满足要求的string，之后再用这个初始化结果数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class="line">        unordered_map&lt;string,multiset&lt;string&gt;&gt; map_str;</div><div class="line">        for(string s:strs)&#123;</div><div class="line">            string t=s;</div><div class="line">            sort(t.begin(),t.end());</div><div class="line">            map_str[t].insert(s);</div><div class="line">        &#125;</div><div class="line">        vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">        for(auto temp:map_str)&#123;</div><div class="line">            vector&lt;string&gt; vec_str_temp(temp.second.begin(),temp.second.end());</div><div class="line">            res.push_back(vec_str_temp);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>后来发现用vector其实要好一些。只是别人这么写的，时间竟然要短一点，毕竟是用vector初始化vector？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeetCode-49-Group-Anagrams&quot;&gt;&lt;a href=&quot;#LeetCode-49-Group-Anagrams&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-49-Group-Anagrams&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-48-Rotate-Image</title>
    <link href="http://yoursite.com/25-%E5%88%B7%E9%A2%98/Leetcode-48-Rotate-Image/"/>
    <id>http://yoursite.com/25-刷题/Leetcode-48-Rotate-Image/</id>
    <published>2018-01-25T12:44:32.000Z</published>
    <updated>2018-04-27T02:28:47.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Leetcode-48-Rotate-Image"><a href="#Leetcode-48-Rotate-Image" class="headerlink" title="Leetcode-48-Rotate-Image"></a>Leetcode-48-Rotate-Image</h3><blockquote><p>ou are given an n x n 2D matrix representing an image.<br>Rotate the image by 90 degrees (clockwise).<br>Note:<br>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p></blockquote><p>Example :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [4,5,6],</div><div class="line">  [7,8,9]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [7,4,1],</div><div class="line">  [8,5,2],</div><div class="line">  [9,6,3]</div><div class="line">]</div><div class="line"></div><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [ 5, 1, 9,11],</div><div class="line">  [ 2, 4, 8,10],</div><div class="line">  [13, 3, 6, 7],</div><div class="line">  [15,14,12,16]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [15,13, 2, 5],</div><div class="line">  [14, 3, 4, 1],</div><div class="line">  [12, 6, 8, 9],</div><div class="line">  [16, 7,10,11]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>这个乍一看觉得不难，但是写的时候又不知道怎么回事，其实旋转，对于我们写程序来说，其实就是不停的调换位置，但是怎么调换是个问题。</p><p>观察发现，第一个矩阵，最角上的四个1,3,7,9。转完之后，还是这四个数字，只不过是位置变了，接下来这样的四个是：2,4,6,8.最后一个5.再看一下4x4的其实也差不多。</p><p>所以想法就是直接每次四个数字进行换，换三次，就能换回来，然后进行下一次调换。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class="line">        if(matrix.size()&lt;=0)</div><div class="line">            return;</div><div class="line">        int a=0,b=matrix.size()-1;</div><div class="line">        while(a&lt;b)&#123;</div><div class="line">            for(int i=0;i&lt;b-a;++i)&#123;</div><div class="line">                swap(matrix[a][a+i],matrix[a+i][b]);</div><div class="line">                swap(matrix[a][a+i],matrix[b][b-i]);</div><div class="line">                swap(matrix[a][a+i],matrix[b-i][a]);</div><div class="line">            &#125;</div><div class="line">            ++a;</div><div class="line">            --b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Leetcode-48-Rotate-Image&quot;&gt;&lt;a href=&quot;#Leetcode-48-Rotate-Image&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-48-Rotate-Image&quot;&gt;&lt;/a&gt;Leetcode-48-Ro
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-48-Rotate-Image</title>
    <link href="http://yoursite.com/25-Leetcode-48-Rotate-Image/"/>
    <id>http://yoursite.com/25-Leetcode-48-Rotate-Image/</id>
    <published>2018-01-25T12:44:32.000Z</published>
    <updated>2018-04-27T02:28:46.905Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Leetcode-48-Rotate-Image"><a href="#Leetcode-48-Rotate-Image" class="headerlink" title="Leetcode-48-Rotate-Image"></a>Leetcode-48-Rotate-Image</h3><blockquote><p>ou are given an n x n 2D matrix representing an image.<br>Rotate the image by 90 degrees (clockwise).<br>Note:<br>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p></blockquote><p>Example :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [4,5,6],</div><div class="line">  [7,8,9]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [7,4,1],</div><div class="line">  [8,5,2],</div><div class="line">  [9,6,3]</div><div class="line">]</div><div class="line"></div><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [ 5, 1, 9,11],</div><div class="line">  [ 2, 4, 8,10],</div><div class="line">  [13, 3, 6, 7],</div><div class="line">  [15,14,12,16]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [15,13, 2, 5],</div><div class="line">  [14, 3, 4, 1],</div><div class="line">  [12, 6, 8, 9],</div><div class="line">  [16, 7,10,11]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>这个乍一看觉得不难，但是写的时候又不知道怎么回事，其实旋转，对于我们写程序来说，其实就是不停的调换位置，但是怎么调换是个问题。</p><p>观察发现，第一个矩阵，最角上的四个1,3,7,9。转完之后，还是这四个数字，只不过是位置变了，接下来这样的四个是：2,4,6,8.最后一个5.再看一下4x4的其实也差不多。</p><p>所以想法就是直接每次四个数字进行换，换三次，就能换回来，然后进行下一次调换。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class="line">        if(matrix.size()&lt;=0)</div><div class="line">            return;</div><div class="line">        int a=0,b=matrix.size()-1;</div><div class="line">        while(a&lt;b)&#123;</div><div class="line">            for(int i=0;i&lt;b-a;++i)&#123;</div><div class="line">                swap(matrix[a][a+i],matrix[a+i][b]);</div><div class="line">                swap(matrix[a][a+i],matrix[b][b-i]);</div><div class="line">                swap(matrix[a][a+i],matrix[b-i][a]);</div><div class="line">            &#125;</div><div class="line">            ++a;</div><div class="line">            --b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Leetcode-48-Rotate-Image&quot;&gt;&lt;a href=&quot;#Leetcode-48-Rotate-Image&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-48-Rotate-Image&quot;&gt;&lt;/a&gt;Leetcode-48-Ro
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>服务器-Nginx设计架构</title>
    <link href="http://yoursite.com/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/25-服务器/服务器-Nginx设计架构/</id>
    <published>2018-01-25T08:37:48.000Z</published>
    <updated>2018-05-27T02:52:22.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务器-Nginx设计架构"><a href="#服务器-Nginx设计架构" class="headerlink" title="服务器-Nginx设计架构"></a>服务器-Nginx设计架构</h3><h4 id="Nginx服务器架构"><a href="#Nginx服务器架构" class="headerlink" title="Nginx服务器架构"></a>Nginx服务器架构</h4><p>Nginx服务器启动后，产生一个主进程，主进程执行一系列工作后产生一个或多个工作进程。</p><p>如下图所示：Nginx服务器的结构大致分为主进程、工作进程、后端服务器和缓存。<br><img src="http://blog-1252063226.cosbj.myqcloud.com/server/003/001.png?raw=true" alt=""></p><ul><li>主进程主要进行：Nginx配置文件解析、数据结构初始化、模块配置和注册、信号处理、网络监听生成、工作进程生成和管理。</li><li>工作进程主要进行：进程初始化、模块调用和请求处理等。</li><li>缓存索引重建及管理进程：cache模块，主要由缓存索引重建和缓存索引管理两类进程完成。缓存索引重建是在Nginx服务启动一段时间后由主进程生成，在缓存元数据重建完成后自动退出。主要工作是：根据本地磁盘上的缓存文件在内存中建立索引元数据库，启动后对本地磁盘上存放缓存文件的目录结构进行扫描，检查内存中已有的缓存你数据元是否正确，并更新索引元数据库；缓存索引管理进程一般存在于主进程的整个生命周期，负责对缓存索引进行管理。主要负责对元数据是否过期做出判断。</li></ul><h4 id="进程交互"><a href="#进程交互" class="headerlink" title="进程交互"></a>进程交互</h4><h5 id="Master-worker交互"><a href="#Master-worker交互" class="headerlink" title="Master-worker交互"></a>Master-worker交互</h5><p>主进程会建立一张工作进程表，存放所有未退出的，主进程通过一个单向管道向工作进程发送指令等信息。</p><h5 id="Worker-Worker交互"><a href="#Worker-Worker交互" class="headerlink" title="Worker-Worker交互"></a>Worker-Worker交互</h5><p>工作进程之间的交互，首先要得到彼此的信息，建立管道通信。当工作进程w1需要向w2发送指令时，首先在主进程给它的其他工作进程信息中找到w2的进程ID，然后将正确的指令写入指向w2的通道。w2捕捉到管道中的时间后，解析指令并采取相应的措施。完成worker之间的交互</p><h4 id="Run-Loops时间处理循环模型"><a href="#Run-Loops时间处理循环模型" class="headerlink" title="Run Loops时间处理循环模型"></a>Run Loops时间处理循环模型</h4><p>Run Loops指的是进程内部用来不停的调配工作，对事件进行循环处理的一种模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务器-Nginx设计架构&quot;&gt;&lt;a href=&quot;#服务器-Nginx设计架构&quot; class=&quot;headerlink&quot; title=&quot;服务器-Nginx设计架构&quot;&gt;&lt;/a&gt;服务器-Nginx设计架构&lt;/h3&gt;&lt;h4 id=&quot;Nginx服务器架构&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>服务器-Nginx的事件驱动模型</title>
    <link href="http://yoursite.com/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/25-服务器/服务器-Nginx的事件驱动模型/</id>
    <published>2018-01-25T07:49:39.000Z</published>
    <updated>2018-04-27T02:28:47.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器-Nginx的事件驱动模型"><a href="#服务器-Nginx的事件驱动模型" class="headerlink" title="服务器-Nginx的事件驱动模型"></a>服务器-Nginx的事件驱动模型</h2><h3 id="什么是事件驱动模型"><a href="#什么是事件驱动模型" class="headerlink" title="什么是事件驱动模型"></a>什么是事件驱动模型</h3><p>事件驱动概念：在持续的事物管理过程中，由当前时间节点上出现的事件引起的调用可用资源执行相关任务，解决问题，防止事物堆积的一种策略。<br>一般由：事件收集器、事件发送器和事件处理器组成。</p><h3 id="事件驱动处理库"><a href="#事件驱动处理库" class="headerlink" title="事件驱动处理库"></a>事件驱动处理库</h3><p>又称为多路IO复用方法：主要包括以下几种：</p><h4 id="select库"><a href="#select库" class="headerlink" title="select库"></a>select库</h4><ol><li>创建所关注事件的描述符集合，每个描述符，可以关注读事件、写事件以及异常发生事件。</li><li>调用底层的select函数，等待事件发生。</li><li>轮询所有事件描述符集合中的每一个事件描述符，检查是否有相应的事件发生，如果有，就进行处理。<h4 id="poll库"><a href="#poll库" class="headerlink" title="poll库"></a>poll库</h4>Linux下平台的基本事件驱动模型。基本工作方式与select库相同。<br>区别在于：select库需要为读事件、写事件和异常事件分别创建一个描述符集合，因此在最后轮询的时候，需要分别轮询三个集合。而poll库只需要创建一个集合。轮询的时候同时检查三种事件是否发生。<h4 id="epoll库"><a href="#epoll库" class="headerlink" title="epoll库"></a>epoll库</h4>Nginx服务器支持的高性能事件驱动库。主要的改动是：把描述符列表的管理交由内核负责，一旦有某种事件发生，内核把发生的事件的描述列表通知给进程，这样就避免了轮询整个描述符列表。</li><li>epoll库通过相关调用通知内核创建一个有N个描述符的事件列表。然后给这些描述符设置关注的事件，并添加到内核的事件列表中去。</li><li>完成设置之后，epoll库就开始等待内核通知事件发生。一旦发生，内核将发生事件的描述符上报给epoll库。<h4 id="rtsig模型"><a href="#rtsig模型" class="headerlink" title="rtsig模型"></a>rtsig模型</h4>Real-time signal，实时信号。使用rtsig时，工作进程会通过系统内核建立一个rtsig队列用于存放标记事件发生的信号。每个事件发生时，系统内核就会产生一个信号存放在rtsig队列中等待工作进程的处理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务器-Nginx的事件驱动模型&quot;&gt;&lt;a href=&quot;#服务器-Nginx的事件驱动模型&quot; class=&quot;headerlink&quot; title=&quot;服务器-Nginx的事件驱动模型&quot;&gt;&lt;/a&gt;服务器-Nginx的事件驱动模型&lt;/h2&gt;&lt;h3 id=&quot;什么是事件驱动模型
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
</feed>
