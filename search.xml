<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>jupyter-notebook安装和问题解决</title>
      <link href="/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/"/>
      <url>/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/</url>
      <content type="html"><![CDATA[<blockquote><p>jupyter notebook折腾日记</p></blockquote><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-采用直接pip安装"><a href="#1-采用直接pip安装" class="headerlink" title="1.采用直接pip安装"></a>1.采用直接pip安装</h2><p><code>pip install jupyter</code>不过可能由于是版本自带的pip有问题，而且用的Python版本也还是2.7的，反正就出现了各种问题。中间解决的有：  </p><ul><li>重新升级pip，但是发现直接pip还是有问题，于是找到问题原因，可能名字有点对不上，找到bin目录下还有一个pip2，在Python里面运行，发现果然是这个，有点心酸，还是换了这个。  </li><li>升级之后，会出现各种的权限问题，没事，给！  </li><li>之后运行，发现没有浏览器，于是又想起服务器上没有，又加上命令试了一下，而且每次都要复制一个长长的token吗？。。</li></ul><h2 id="2-采用Anaconda安装"><a href="#2-采用Anaconda安装" class="headerlink" title="2.采用Anaconda安装"></a>2.采用Anaconda安装</h2><p>正好晚上在床上看到一个链接，说这个更方便，反正也是折腾嘛，就试试了。过程稍微写一写哈</p><ol><li>在清华镜像站找到采用Anaconda相应版本下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br> 找到后复制链接：<code>wget 链接</code> </li><li>安装Anaconda:<br> <code>sh Anaconda3-5.1.0-Linux-x86_64.sh # 一路yes就装了</code>  </li><li>服务器管理控制台开放8888端口（当然端口可以配置，也随便换了）  </li><li>运行<code>jupyter notebook --generate-config</code> 生成默认的jupyter配置文件  </li><li><p>编辑config文件：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd .jupyter</div><div class="line">vim jupyter_notebook_config.py #编辑config文件</div><div class="line">c.NotebookApp.ip = &apos;*&apos;  #允许所有的ip登录</div><div class="line">c.NotebookApp.open_browser = False #打开浏览器：关闭，因为服务器没有浏览器</div><div class="line">c.NotebookApp.port = 8888  #开放使用的端口</div></pre></td></tr></table></figure></li><li><p>保存退出。运行jupyter notebook，会得到一个带token的访问地址。复制地址，将其中的localhost替换成服务器的公网IP，访问，应该可以正常进入jupyter。  </p></li><li>每次都tocken当然有点麻烦了。设置一个密码吧：<br> <code>jupyter-notebook password</code></li><li>之后就可以公网输入登录了。</li></ol><h2 id="3-安装主题和相关插件"><a href="#3-安装主题和相关插件" class="headerlink" title="3.安装主题和相关插件"></a>3.安装主题和相关插件</h2><p><a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="external">jupyter_contrib_nbextensions</a><br>直接使用<code>conda install -c conda-forge jupyter_contrib_nbextensions</code></p><ul><li>使用注意：<br>1.关于ubuntu的环境变量设置没有对，导致conda命令不能用的问题。当然知道应该是环境变量的问题，不过还是搞了很久。才发现是加在ubuntu的home目录下的<code>.bashrc</code>后面<code>export PATH=~/anaconda3/bin:$PATH</code><br>2.由于我的conda版本没有更新，所以出现了插件也只有几个的情况，所以需要先更新。之后再重启jupyter notebook。<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><a href="http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/" target="_blank" rel="external">http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</a><br><a href="https://zhuanlan.zhihu.com/p/34289322" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34289322</a><br><a href="https://zhuanlan.zhihu.com/p/20226040?utm_source=qq&amp;utm_medium=social&amp;utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/20226040?utm_source=qq&amp;utm_medium=social&amp;utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A</a></li></ul>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 工具 </tag>
            
            <tag> jupyter </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日常折腾日记</title>
      <link href="/25-%E5%B7%A5%E5%85%B7/daily_zheteng/"/>
      <url>/25-%E5%B7%A5%E5%85%B7/daily_zheteng/</url>
      <content type="html"><![CDATA[<blockquote><p>俗话说，生活就是不断的折腾，恰好自己是个这样的人。可能就是这样一个虽然不是很年轻了，但是心态总是年轻的，看到一些有趣的或者有意思的，总是忍不住想看看，或者试试。但是有时候又觉得自己不再年轻了，有些东西虽然当时记着了，但是后来又忘了，或者有时候记着又找起来很耽误时间。所以就在这记录一下吧。</p></blockquote><a id="more"></a><h2 id="博客相关"><a href="#博客相关" class="headerlink" title="博客相关"></a>博客相关</h2><p><a href="https://zhuanlan.zhihu.com/p/28128674" target="_blank" rel="external">hexo博客插件</a><br><a href="http://www.yuguocong.me/10-%E5%B7%A5%E5%85%B7/%E6%88%91%E7%9A%84hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">我的博客折腾</a><br><a href="http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/" target="_blank" rel="external">自动构建博客</a></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><a href="http://www.yuguocong.me/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/" target="_blank" rel="external">jupyter</a></p><ul><li><a href="https://www.cnblogs.com/kevingrace/p/6496899.html" target="_blank" rel="external">tmux的使用</a></li><li><a href="https://github.com/kxxoling/blog/blob/master/tool/tmux.md" target="_blank" rel="external">tmux的使用2</a></li></ul><h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><p>vip视频：<br><a href="https://github.com/laidefa/Flask_Web_Vip：" target="_blank" rel="external">https://github.com/laidefa/Flask_Web_Vip：</a>  <a href="http://101.37.147.236:1518/" target="_blank" rel="external">http://101.37.147.236:1518/</a></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 收集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sublime Text3使用总结</title>
      <link href="/24-%E5%B7%A5%E5%85%B7/use-of-sublime/"/>
      <url>/24-%E5%B7%A5%E5%85%B7/use-of-sublime/</url>
      <content type="html"><![CDATA[<p>update:</p><ul><li>2018-04-24 首次更新:突然发现Sublime Text3也还是挺好用的，之前切出去光标总是乱跳，就有点烦，以为是这样的就没管，用了网易云，没想到发现只有我的是这样，赶紧找找问题，解决一下。顺便把很多重新折腾一下。</li></ul><p>#用好sublime</p><h3 id="为Sublime-Text3添加插入当前时间的命令"><a href="#为Sublime-Text3添加插入当前时间的命令" class="headerlink" title="为Sublime Text3添加插入当前时间的命令"></a><a href="https://www.cnblogs.com/jiafeimao-dabai/p/7238357.html" target="_blank" rel="external">为Sublime Text3添加插入当前时间的命令</a></h3><ol><li>创建插件：</li></ol><p>Tools → New Plugin:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import datetime</div><div class="line">import sublime_plugin</div><div class="line">class AddCurrentTimeCommand(sublime_plugin.TextCommand):</div><div class="line">    def run(self, edit):</div><div class="line">        self.view.run_command(&quot;insert_snippet&quot;, </div><div class="line">            &#123;</div><div class="line">                &quot;contents&quot;: &quot;%s&quot; % datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) </div><div class="line">            &#125;</div><div class="line">        )</div></pre></td></tr></table></figure></p><p>保存为Sublime Text3\Packages\User\addCurrentTime.py</p><ol><li>创建快捷键：</li></ol><p>Preference → Key Bindings - User:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;command&quot;: &quot;add_current_time&quot;,</div><div class="line">        &quot;keys&quot;: [</div><div class="line">            &quot;ctrl+shift+.&quot;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p><h3 id="添加了一个主题https-packagecontrol-io-packages-Predawn：Predawn"><a href="#添加了一个主题https-packagecontrol-io-packages-Predawn：Predawn" class="headerlink" title="添加了一个主题https://packagecontrol.io/packages/Predawn：Predawn"></a><a href="">添加了一个主题</a><a href="https://packagecontrol.io/packages/Predawn：Predawn" target="_blank" rel="external">https://packagecontrol.io/packages/Predawn：Predawn</a></h3><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><p>小土刀博客：<a href="http://wdxtub.com/2016/03/24/sublime-guide/" target="_blank" rel="external">http://wdxtub.com/2016/03/24/sublime-guide/</a></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 折腾 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阶段性生活思考</title>
      <link href="/24-%E9%9A%8F%E7%AC%94/redo-mylife/"/>
      <url>/24-%E9%9A%8F%E7%AC%94/redo-mylife/</url>
      <content type="html"><![CDATA[<h2 id="why-title"><a href="#why-title" class="headerlink" title="why title"></a>why title</h2><blockquote><p>生活就是要不断的思考,不是吗?</p></blockquote><a id="more"></a><h3 id="update-2018-05-13-21-15-04-周日"><a href="#update-2018-05-13-21-15-04-周日" class="headerlink" title="update:2018-05-13 21:15:04 周日"></a>update:2018-05-13 21:15:04 周日</h3><p>突然觉得很久没思考自己的生活了。      </p><ul><li>1.做事情注意力不集中。最近虽然看起来学习态度要好一些，每天都是待在实验室，但是学习的效率却感觉没有以前高了。而且总是注意力不够集中，明明在该学习的时候，却看看这个看看那个。做这个的时候看看想起另外一件事，就去看看，结果就该做的事情没做好。看看论文就想玩玩手机，玩着又有点愧疚就去看看c++，总是三心二意的。  </li><li>2.不太爱思考。另一个问题就是，遇到问题不求甚解。这还是以前的老问题吧，对于以前的应试教育来说，可能里面的道理也不用太深究，毕竟能最后写在试卷上就行了，看起来还能有个差不多好看的分数。但是现在处于的阶段不一样了，不管是日常的工作学习，还是平时看到一些新闻的想法，这都会有一些问题。当然，这方面可能手机因素也比较大一点，有很多的观点唾手可得，找找资料就能看到很多东西，恰好这方面自己又比较擅长，于是就又陷入了找资料不思考的陷阱。这样虽然有时候找到了很多有价值的东西，平时看到了很多，说吧，都知道，但是具体的就是不清楚，更别谈再有所新的想法了。所以这是个重要的问题。  </li><li>3.做事情应该更有目的。就是可能现在感觉很忙，但是却没有个统一的目的，有时候花的时间是多了，但是却没有很好的效果。  </li></ul>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu自动push到github脚本</title>
      <link href="/10-%E5%B7%A5%E5%85%B7/shell_%E8%87%AA%E5%8A%A8push/"/>
      <url>/10-%E5%B7%A5%E5%85%B7/shell_%E8%87%AA%E5%8A%A8push/</url>
      <content type="html"><![CDATA[<h2 id="编写shell脚本"><a href="#编写shell脚本" class="headerlink" title="编写shell脚本"></a>编写shell脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">path=~/github/</div><div class="line"></div><div class="line">git_push()&#123;</div><div class="line">    echo &quot;开始push&quot;</div><div class="line">    modify_time=`stat -c %Y $&#123;1&#125;`</div><div class="line">    this_time=`date +%s`</div><div class="line"></div><div class="line">    cd $&#123;1&#125;</div><div class="line">    echo &quot;-------切换目录------&quot;</div><div class="line">    echo `pwd`</div><div class="line">    echo &quot;---------------------&quot;</div><div class="line">    if [ $[ $&#123;modify_time&#125;-$&#123;this_time&#125; ] -gt 86400 ];</div><div class="line">    then</div><div class="line">         echo &quot;$&#123;1&#125; 文件夹 有变化，正在准备push...&quot;</div><div class="line">        date=`date &quot;+%Y-%m-%d %H:%M:%S&quot;`</div><div class="line">        git add .    </div><div class="line">        git commit -m &quot;automatic push @$(date)&quot;</div><div class="line">        echo &quot;git fetch origin master&quot;</div><div class="line">        git fetch origin master</div><div class="line"></div><div class="line">        echo &quot;git merge origin/master&quot;</div><div class="line">        git merge origin/master</div><div class="line"></div><div class="line">        echo &quot;git push origin master:master&quot;</div><div class="line">        git push origin master:master</div><div class="line">         </div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">git_push ~/github/Linux_pro</div><div class="line">git_push ~/github/miniweb</div></pre></td></tr></table></figure><h2 id="加入定时任务"><a href="#加入定时任务" class="headerlink" title="加入定时任务"></a>加入定时任务</h2><h3 id="编辑定时任务文件"><a href="#编辑定时任务文件" class="headerlink" title="编辑定时任务文件"></a>编辑定时任务文件</h3><p>(<a href="https://blog.csdn.net/xiyuan1999/article/details/8160998" target="_blank" rel="external">https://blog.csdn.net/xiyuan1999/article/details/8160998</a>)<br><code>crontab  -e</code><br>在文件的末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30 5 * * * /home/mianhk/shell/auto_push.sh  表示在每天的 5.30执行</div></pre></td></tr></table></figure></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><code>/etc/init.d/cron start</code></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一文总结计算机网络</title>
      <link href="/10-network/network/"/>
      <url>/10-network/network/</url>
      <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近一直在看网络编程的东西，不管是看书、还是一些博客，或者是自己的一些编程，都觉得写的有点乱，有点杂。虽然这也比较符合网络方面的特点，零碎的知识点，有些人觉得重要就写上了，另一些就没有写。想到将来可能跟网络编程接触很多，也觉得最近的学习就是缺少一些总结。就在这里站在大佬的肩膀上整理一下吧。<br><a id="more"></a></p><h1 id="计算机网络体系结构（TCP-IP四层模型）"><a href="#计算机网络体系结构（TCP-IP四层模型）" class="headerlink" title="计算机网络体系结构（TCP/IP四层模型）"></a>计算机网络体系结构（TCP/IP四层模型）</h1><p>一般所说的计算机体系结构分为三种，其中TCP/IP体系结构是实际应用较多的。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/001.png" width="500"> </div><br></p><h2 id="各层的作用以及协议"><a href="#各层的作用以及协议" class="headerlink" title="各层的作用以及协议"></a>各层的作用以及协议</h2><h3 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h3><p>表示层和会话层用途如下：</p><ol><li>表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩；</li><li>会话层：不同机器上的用户之间建立及管理会话。</li></ol><h3 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h3><ol><li>应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li>网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</li><li>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。</li><li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ol><h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。<br>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/010.png" width="400"> </div><br><br>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/011.png" width="400"> </div><br></p><h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。<br>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/012.jpg" width="600"> </div><br></p><h1 id="网络接口层（TCP-IP）"><a href="#网络接口层（TCP-IP）" class="headerlink" title="网络接口层（TCP/IP）"></a>网络接口层（TCP/IP）</h1><p>对应OSI七层协议的数据链路层和物理层。在实际的编程中，一般对底层关注的更少，作为长期从事物理层和数据链路层相关工作的通信工程本来觉得可以稍微发挥一下的，咳咳。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li>传输数据的单位–比特</li><li>数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点）</li></ul><p>通道：</p><ul><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li><li>双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul><p>通道复用技术：</p><ul><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="主要信道："><a href="#主要信道：" class="headerlink" title="主要信道："></a>主要信道：</h3><ul><li>点对点信道</li><li>广播信道</li></ul><h4 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h4><ul><li>数据单元 ———— 帧</li></ul><p>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</p><h4 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h4><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/013.jpg" width="400"> </div><br></p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>透明表示一个实际存在的事物看起来好像不存在一样。<br>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符，如果出现转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/014.jpg" width="400"> </div><br></p><h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。网络层协议有：</p><ul><li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li><li>ARP（Address Resolution Protocol，地址解析协议）</li><li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li></ul><h2 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP 网际协议"></a>IP 网际协议</h2><h3 id="IP-地址分类："><a href="#IP-地址分类：" class="headerlink" title="IP 地址分类："></a>IP 地址分类：</h3><ul><li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li></ul><table><thead><tr><th>IP 地址类别</th><th>网络号</th><th>网络范围</th><th>主机号</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A 类</td><td>8bit，第一位固定为 0</td><td>0 —— 127</td><td>24bit</td><td>1.0.0.0 —— 127.255.255.255</td></tr><tr><td>B 类</td><td>16bit，前两位固定为  10</td><td>128.0 —— 191.255</td><td>16bit</td><td>128.0.0.0 —— 191.255.255.255</td></tr><tr><td>C  类</td><td>24bit，前三位固定为  110</td><td>192.0.0 —— 223.255.255</td><td>8bit</td><td>192.0.0.0 —— 223.255.255.255</td></tr><tr><td>D  类</td><td>前四位固定为 1110，后面为多播地址</td></tr><tr><td>E  类</td><td>前五位固定为 11110，后面保留为今后所用</td></tr></tbody></table><h3 id="IP-数据报格式："><a href="#IP-数据报格式：" class="headerlink" title="IP 数据报格式："></a>IP 数据报格式：</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/015.jpg" width="500"> </div><br></p><ul><li><strong>版本</strong>  : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong>  : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong>  : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong>  : 包括首部长度和数据部分长度。</li><li><strong>标识</strong>  : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong>  : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。<br><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/016.jpg" width="500"> </div><br></li><li><strong>生存时间</strong>  ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li></ul><h3 id="ARP-RARP-地址解析协议-反向地址转化协议"><a href="#ARP-RARP-地址解析协议-反向地址转化协议" class="headerlink" title="ARP/RARP 地址解析协议/反向地址转化协议"></a>ARP/RARP 地址解析协议/反向地址转化协议</h3><h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议:"></a>地址解析协议:</h4><ul><li>在数据报向下一个站点传递时，负责将IP地址转换为物理地址。</li><li>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接受返回消息，以此确定目标的物理地址；<br>接收的返回消息后将该IP地址和物理地址存入本机并保留一段时间，下次请求时直接查询ARP缓存以节约时间。<br>（地址解析协议是IPV4中广泛使用的协议；但在IPV6中不存在该协议，使用NDP（邻居发现协议））</li><li>工作流程：<br>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址解析为主机B的MAC（物理）地址。<br>ARP缓存是一个用来存储IP地址和MAC地址的一个缓冲区，其本质是一个IP地址对应一个MAC地址。当地址解析协议在查询IP时，首先在哎ARP缓存中查看，若存在则返回，否则发送ARP请求；<br>地址解析协议是通过报文工作的。报文包括如下字段：硬件类型，协议类型，硬件地址长度，协议长度，操作类型。</li><li>APR缓存包含一个或多个表，他们用于存储IP地址及经过地址解析的MAC地址。ARP命令用于查询本机的ARP缓存中的IP到MAC地址的对应关系、添加或删除静态对应关系等。如果再没有参数的情况下ARP命令将显示帮助信息。</li><li>ARP-a 查看缓存中的所有项目，在Linux中命令式ARP-g;</li></ul><h4 id="反向地址转化协议"><a href="#反向地址转化协议" class="headerlink" title="反向地址转化协议:"></a>反向地址转化协议:</h4><ul><li>作用于ARP相反，负责将物理层地址转换为IP地址</li><li>反向地址转化协议，作用于ARP相反，负责将物理层地址转换为IP地址；<br>允许局域网物理机器从网关服务器的ARP表或缓存上请求主机的IP地址；当设置一台新机器时，其RARP客户机程序需要向路由器上的RARP服务器请求相应的IP地址。</li><li>ARP是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议，假设知道自己的物理地址但不知道自己的IP地址，这种情况就该使用RARP协议。<br>RARP工作方式与ARP相反，RARP发出需要反向解析的MAC地址，并且希望返回其对应的IP地址，应答包括由能提供信息的RARP服务器发出的IP地址。</li><li>工作流程：<br>从网卡读取自己的MAC地址—&gt;发送RARP请求的广播数据包—&gt;RARP服务器收到请求，为其分配IP地址，并将RARP回应发送给该机器—&gt;该机器收到IP地址后，使用IP地址进行通信</li></ul><h3 id="ICMP-网际控制报文协议"><a href="#ICMP-网际控制报文协议" class="headerlink" title="ICMP 网际控制报文协议"></a>ICMP 网际控制报文协议</h3><p>由于IP协议提供的是一种不可靠的和无连接的数据报服务，为了对IP数据报的传送进行差错控制，对未能完成传送的数据报给出出错的原因，TCP/IP协议簇在网络连层提供了一个用于传递控制报文的ICMP协议，即网际控制报文协议。<br>ICMP 报文格式：</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/017.jpg" width="400"> </div><br><br>应用：</p><ul><li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性<ul><li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li></ul></li><li>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</li></ul><h3 id="IGMP-网际组管理协议"><a href="#IGMP-网际组管理协议" class="headerlink" title="IGMP 网际组管理协议"></a>IGMP 网际组管理协议</h3><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。</p><h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/018.jpg" width="500"> </div><br></p><ul><li><strong>Source Port和Destination Port</strong>:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接</li><li><strong>Sequence Number</strong>:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401；</li><li><strong>Acknowledgment Number</strong>:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701；</li><li><strong>Offset</strong>:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；</li><li><strong>TCP Flags</strong>:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：<ul><li>URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</li><li><strong>确认ACK</strong>：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0.TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1；</li><li>PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li><li>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li><li><strong>同步SYN</strong>：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</li><li><strong>终止FIN</strong>： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN=1标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</li></ul></li><li><strong>窗口</strong>  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/002.jpg" width="500"> </div><br></p><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li></ul><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的。那对于TCP的断开连接，就是通常说的“四次挥手”。</p><ul><li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ul><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接，解决网络中存在延迟的分组，防止了服务器端的一直等待而浪费资源。</p><blockquote><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”<br>失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。</p></blockquote><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。<br>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p><h4 id="TCP的十一种状态"><a href="#TCP的十一种状态" class="headerlink" title="TCP的十一种状态"></a>TCP的十一种状态</h4><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/008.png" width="500"> </div><br></p><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li><li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li><li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li><li>FIN_WAIT_1: 其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</li><li>FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li><li>CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</li><li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li><li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li></ul><h4 id="TCP长连接和短连接"><a href="#TCP长连接和短连接" class="headerlink" title="TCP长连接和短连接"></a>TCP长连接和短连接</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul><li>长连接，也叫持久连接，在TCP层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息（包括心跳）交互，直至连接的任意一方（客户端OR服务端）主动断开连接，此过程称为一次完整的长连接。HTTP 1.1相对于1.0最重要的新特性就是引入了长连接。  </li><li>短连接，与长连接的区别就是，客户端收到服务端的响应后，立刻发送FIN消息，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互（发请求-收响应）之后立刻断开连接的情况都称为短连接。  </li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>1、需要频繁交互的场景使用长连接，如即时通信工具（微信/QQ，QQ也有UDP），相反则使用短连接，比如普通的web网站，只有当浏览器发起请求时才会建立连接，服务器返回响应后，连接立即断开。<br>2、维持长连接会有一定的系统开销，用户量少不容易看出系统瓶颈，一旦用户量上去了，就很有可能把服务器资源（内存/CPU/网卡）耗尽，所以使用需谨慎。  </p><h5 id="快速区分使用的是长连接还是短连接"><a href="#快速区分使用的是长连接还是短连接" class="headerlink" title="快速区分使用的是长连接还是短连接"></a>快速区分使用的是长连接还是短连接</h5><p>1、凡是在一次完整的消息交互（发请求-收响应）之后，立刻断开连接（有一方发送FIN消息）的情况都称为短连接；<br>2、长连接的一个明显特征是会有心跳消息（也有没有心跳的情况），且一般心跳间隔都在30S或者1MIN左右，用wireshark抓包可以看到有规律的心跳消息交互（可能会存在毫秒级别的误差）。  </p><h4 id="TCP实现可靠传输"><a href="#TCP实现可靠传输" class="headerlink" title="TCP实现可靠传输"></a>TCP实现可靠传输</h4><ul><li>建立连接（标志位）：通信前确认通信实体存在。</li><li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li><li>数据校验（校验和）：CRC校验全部数据。</li><li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li><li>窗口机制（窗口）：提供流量控制，避免过量发送。</li><li>拥塞控制：同上。</li></ul><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>超时重传机制：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<br>发送的数据没能到达接收端，所以对方没有响应。<br>接收端接收到数据，但是ACK报文在返回过程中丢失。<br>接收端拒绝或丢弃数据。</p><ul><li>重传间隔(RTO)：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。<ul><li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li><li>重传次数到达上限之后停止重传。</li></ul></li><li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li></ul><h5 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a><a href="https://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="external">TCP流量控制</a></h5><h6 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h6><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/007.jpg" width="500"> </div><br><br>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><h6 id="考虑传输速率"><a href="#考虑传输速率" class="headerlink" title="考虑传输速率"></a>考虑传输速率</h6><p>可以用不同的机制来控制TCP报文段的发送时机。如：</p><ol><li>TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即TCP支持的推送( push )操作。</li><li>发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</li></ol><p>Nagle算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定：当到达的数据已达到 发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p><p>糊涂窗口综合证：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><p>拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。<br>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。<br>流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。<br>拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。<br>控制办法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><h6 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h6><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。<br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。<br>慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/004.jpg" width="500"> </div><br><br>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。<br>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：<br>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p><p>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。<br>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/005.jpg" width="500"> </div><br></p><ol><li>当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</li><li>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。</li><li>假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。</li></ol><p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。<br>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/006.jpg" width="500"> </div><br><br>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。<br>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ol><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</li><li>由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ol><h5 id="区分流量控制和拥塞控制"><a href="#区分流量控制和拥塞控制" class="headerlink" title="区分流量控制和拥塞控制"></a>区分流量控制和拥塞控制</h5><ul><li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li><li>实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</li></ul><h4 id="TCP黏包问题"><a href="#TCP黏包问题" class="headerlink" title="TCP黏包问题"></a>TCP黏包问题</h4><ul><li>原因：<br>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</li><li>解决：</li></ul><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li><li>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。</li><li>使用更加复杂的应用层协议。</li></ul><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>面向无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），对于一些控制需要在应用层解决。</p><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/009.png" width="500"> </div><br></p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ol><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li><li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ol><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><h3 id="socket原理"><a href="#socket原理" class="headerlink" title="socket原理"></a>socket原理</h3><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。<br>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h3 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><ul><li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>*连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ul><h3 id="创建TCP的socket流程"><a href="#创建TCP的socket流程" class="headerlink" title="创建TCP的socket流程"></a>创建TCP的socket流程</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul><li>创建socket： int socket(int domain, int type, int protocol);</li><li>将socket绑定地址和端口号：int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</li><li>监听：int listen(int sockfd, int backlog);</li><li>接受连接：int accept(int sockfd, struct sockaddr <em>addr, socklen_t </em>addrlen);</li><li>读取数据：ssize_t read(int fd, void *buf, size_t count);</li><li>关闭socket:int close(int fd);</li></ul><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li>创建socket： int socket(int domain, int type, int protocol);</li><li>连接：int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);</li><li>输入数据: ssize_t write(int fd, const void *buf, size_t count);</li><li>关闭socket:int close(int fd);</li></ul><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><p>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</p><h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h2><p>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。<br>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</p><h2 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。<br>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><h2 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h2><p>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：</p><ol><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ol><h2 id="超文本传送协议-HTTP"><a href="#超文本传送协议-HTTP" class="headerlink" title="超文本传送协议 HTTP"></a>超文本传送协议 HTTP</h2><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://github.com/huihut/interview#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" target="_blank" rel="external">https://github.com/huihut/interview#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C</a><br><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82" target="_blank" rel="external">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82</a><br><a href="https://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="external">https://blog.csdn.net/yechaodechuntian/article/details/25429143</a><br><a href="http://www.cnblogs.com/maybe2030/p/4781555.html#_label3" target="_blank" rel="external">http://www.cnblogs.com/maybe2030/p/4781555.html#_label3</a></p>]]></content>
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux的fork使用</title>
      <link href="/15-Linux%E7%9A%84fork%E4%BD%BF%E7%94%A8/"/>
      <url>/15-Linux%E7%9A%84fork%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="Linux的fork使用"><a href="#Linux的fork使用" class="headerlink" title="Linux的fork使用"></a>Linux的fork使用</h2><blockquote><p>fork函数可以算是Linux里有点不好明白的函数了，调用一次，返回两次，虽然在平时的写法中，有基本固定的写法，但是有时候看起来还是有些让人头疼的。这里就把关于fork函数好好整理一下</p></blockquote><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><p><strong>功能</strong>：fork函数是从一个已经存在的进程中创建一个新的进程，新的进程称为子进程，原来的进程称为父进程。<br><strong>参数</strong>：无<br><strong>返回值</strong>：<br>成功：子进程中返回 0，父进程中返回子进程 ID。pid_t，为无符号整型。<br>失败：返回 -1。</p><p>失败的两个主要原因是：<br>1）当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN。<br>2）系统内存不足，这时 errno 的值被设置为 ENOMEM。</p><h3 id="测试的例子"><a href="#测试的例子" class="headerlink" title="测试的例子"></a>测试的例子</h3><p>下面是一个简单的创建子进程的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    int pid=1;</div><div class="line">    pid=fork();</div><div class="line">    if(0==pid)&#123; //pid为0，表示为子进程</div><div class="line">        cout&lt;&lt;&quot;我是子进程，我的pid是：&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    else if(pid&gt;0)&#123; //pid&gt;0表示父进程，此时返回值为子进程的pid</div><div class="line">        cout&lt;&lt;&quot;我是父进程，我的pid是&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    else &#123;  //fork 失败</div><div class="line">        cout&lt;&lt;&quot;fork失败&quot;&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面的例子可以看出，fork函数会有两个返回值，一个是在子进程中返回0,一个是在父进程中返回子进程的pid。因此在编程过程中，需要判断这个值的返回值来判断当前是父进程还是子进程。</p><h3 id="fork进程的原理"><a href="#fork进程的原理" class="headerlink" title="fork进程的原理"></a>fork进程的原理</h3><p>使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用 fork()函数的代价是很大的。<br><img src="http://blog-1252063226.cosbj.myqcloud.com/Linux/003001.jpg?raw=true" alt=""></p><h3 id="日常使用fork"><a href="#日常使用fork" class="headerlink" title="日常使用fork"></a>日常使用fork</h3><p>简单来说， 一个进程调用 fork() 函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p><p>实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在<strong>需要写入的时候才会进行，在此之前，只有以只读方式共享</strong>。</p><p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。一般来说，在 fork() 之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。</p><p>因此，在实际的使用过程中，一般都需要对fork()的返回值进行判断，看我们操作的是父进程还是子进程。</p><h4 id="一般的操作：同时创建多个子进程"><a href="#一般的操作：同时创建多个子进程" class="headerlink" title="一般的操作：同时创建多个子进程"></a>一般的操作：同时创建多个子进程</h4><p>不对的例子:父进程会生成 n(n+1)/2+1个子进程，N 为循环次数，本例中共有 7 个子进程， 但实际上只有 3 个是父进程产生的，其余都为子进程 fork（）出来的。父进程fork了3个进程，第一个子进程执行完之后又fork了2个进程，第2个子进程fork了1个进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    pid_t p1,p2;</div><div class="line">    int i;</div><div class="line">    int N=100;</div><div class="line">    for(int i=0;i&lt;=N;++i)&#123;</div><div class="line">        if((p1=fork())==0)&#123;</div><div class="line">            cout&lt;&lt;&quot;子进程1：&quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">            //return 0;  //很关键的地方，为什么需要返回呢</div><div class="line">        &#125;</div><div class="line">        wait(p1,NULL,0); //父进程等待p1子进程执行后才能继续fork其他子进程</div><div class="line">        cout&lt;&lt;&quot;这是父进程: &quot;&lt;&lt;getpid()&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>正确的使用Linux中的用fork()由一个父进程创建同时多个子进程 的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    pid_t p1,p2;</div><div class="line">    int i;</div><div class="line">    int N=100;</div><div class="line">    for(int i=0;i&lt;=N;++i)&#123;</div><div class="line">        status=fork();</div><div class="line">        if(status==0||status==1) break;//每次循环时，如果发现是子进程就直接从创建子进程的循环中跳出来，不让你进入循环，这样就保证了每次只有父进程来做循环创建子进程的工作</div><div class="line">        if (status == -1)</div><div class="line">        &#123;</div><div class="line">          //error</div><div class="line">        &#125;</div><div class="line">        else if (status == 0) //每个子进程都会执行的代码</div><div class="line"></div><div class="line">        &#123;</div><div class="line">          //sub process</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">          //parent process</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="无聊的问题"><a href="#无聊的问题" class="headerlink" title="无聊的问题"></a>无聊的问题</h3><p>1.下面的程序，不算 main这个进程自身，到底创建了多少个进程啊？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">   fork();</div><div class="line">   fork() &amp;&amp; fork() || fork();</div><div class="line">   fork();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>每fork一次就翻倍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  fork(); //2个</div><div class="line">   fork() &amp;&amp; fork() || fork();</div><div class="line">//A&amp;&amp;B||C</div><div class="line">//A为假，跳过B，判断C-----------------------2</div><div class="line">//A为真，判断B，若B为真，跳过C-----------1</div><div class="line">//若B为假，判断C ------------2</div><div class="line">   fork(); //2</div></pre></td></tr></table></figure></p><p>总共有：<br>2<em>(2+1+2)</em>2=20<br>不算自己的话有20-1=19个</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-60-Permutation-Sequence</title>
      <link href="/06-%E5%88%B7%E9%A2%98/LeetCode-60-Permutation-Sequence/"/>
      <url>/06-%E5%88%B7%E9%A2%98/LeetCode-60-Permutation-Sequence/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-60-Permutation-Sequence"><a href="#LeetCode-60-Permutation-Sequence" class="headerlink" title="LeetCode-60-Permutation-Sequence"></a>LeetCode-60-Permutation-Sequence</h3><blockquote><p>The set [1,2,3,…,n] contains a total of n! unique permutations.<br>By listing and labeling all of the permutations in order,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">We get the following sequence (ie, for n = 3):</div><div class="line"></div><div class="line">&quot;123&quot;</div><div class="line">&quot;132&quot;</div><div class="line">&quot;213&quot;</div><div class="line">&quot;231&quot;</div><div class="line">&quot;312&quot;</div><div class="line">&quot;321&quot;</div><div class="line">Given n and k, return the kth permutation sequence.</div></pre></td></tr></table></figure></p></blockquote><p>同样是排列 组合的问题，这次不需要打印所有的排列了，只需要按照排列的顺序打印出第k个，很显然，思路不会是列出所有的排列，然后找第k个打印出来是吧。</p><p>观察来看，以<code>1,2,3,4</code>为例，有<code>4*3*2*1=24</code>种排列，其中根据排列的顺序，按照第一个数字可以分为以下4种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1 * * *</div><div class="line"></div><div class="line">2 * * *</div><div class="line"></div><div class="line">3 1 2 4</div><div class="line">3 1 4 2</div><div class="line">3 2 1 4</div><div class="line">3 2 4 1</div><div class="line">3 4 1 2</div><div class="line">3 4 2 1</div><div class="line"></div><div class="line">4 * * *</div><div class="line">#### 方法一</div></pre></td></tr></table></figure></p><ul><li><p>第一个数<br>可以看出，当k=14时，第一个数字为3,这个是可以通过计算的。由于是从1开始的，取k=13；<code>index=k/(n-1)!=13/3!=2</code>，于是可以知道第一个数是3。那么第二个数字呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1+permutation(2,4)</div><div class="line">2+permutation(1,4)</div><div class="line">4+permutation(1,2)</div></pre></td></tr></table></figure></li><li><p>第二个数<br>可以根据:<code>k=k-index_pre*(n-1)!=13-2*3!=1</code>;<br><code>index=k/(n-2)!=1/(4-2)!=0</code>于是第二个数为1。</p></li><li>第三个数<br>接下来就只剩下2和4了，继续:<code>k=k-index_pre*(n-2)!=1-0*(4-2)!=1</code>,  <code>index=k/(n-3)!=1/(4-3)!=1</code>在此处表示为4.之后再确定最后一个:</li><li>第四个数<br><code>k=k-index_pre*(n-4)!=1-1*(4-4)=0</code>;<br><code>index=k/(n-4)!=0/(4-4)!=0</code> 故第四个数为2</li></ul><p>到了这里，思路就比较清晰了。我们需要做的是从第一个一直到最后一个的循环，每次选出一个数，但是还需要将该数从原来的数组中剔除掉，因为前面选过的后面就不能排列了。</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>其实原理差不多，也还是根据排列的规律。只不过算的方法不一样。</p><ol><li>j=i+k/(n-i)!;</li><li>删除s[j];</li><li>k=k%(n-i);</li><li>s[i]=s[j];<br>代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    string getPermutation(int n, int k) &#123;</div><div class="line">        if(n&lt;=0)</div><div class="line">            return &quot; &quot;;</div><div class="line">        int i,j,f=1;</div><div class="line">        string s(n,&apos;0&apos;);</div><div class="line">        for(i=1;i&lt;=n;i++)&#123;</div><div class="line">            f*=i;</div><div class="line">            s[i-1]+=i;</div><div class="line">        &#125;</div><div class="line">        for(i=0,k--;i&lt;n;++i)&#123;</div><div class="line">            f/=n-i;</div><div class="line">            j=i+k/f;</div><div class="line">            char c=s[j];</div><div class="line">            for(;j&gt;i;j--)</div><div class="line">                s[j]=s[j-1];</div><div class="line">            k%=f;</div><div class="line">            s[i]=c;</div><div class="line">        &#125;</div><div class="line">        return s;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大型网站架构技术-架构模式</title>
      <link href="/03-architecture-model-of-web-architecture/"/>
      <url>/03-architecture-model-of-web-architecture/</url>
      <content type="html"><![CDATA[<h2 id="大型网站架构技术-架构模式"><a href="#大型网站架构技术-架构模式" class="headerlink" title="大型网站架构技术-架构模式"></a>大型网站架构技术-架构模式</h2><p>模式的关键在于模式的可重复性。<br><a id="more"></a></p><blockquote><p>每一个模式描述了一个在我们周围不断变化重复发生的问题及该问题解决方案的核心。这样就能一次次的使用该方案而不必做重复的工作。</p></blockquote><p>这是经过很多个实践，被很多网站重复使用而逐渐形成大型网站架构模式：</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>将系统再横向维度上切成几个部分，每个部分负责一部分相对单一的职责。就好比平时一份工作比较多的时候，团队中大家各自负责自己擅长的那一部分。大型网站中一般分为三层：</p><ul><li>应用层：负责具体业务和视图展示。</li><li>服务层：为应用层提供服务支持。</li><li>数据层：提供数据存储访问服务。如数据库、缓存、文件、搜索引擎等。<br>需要注意的是：这个分层是逻辑的，并不一定要部署在不同的服务器上，可能会根据业务调整。  </li></ul><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>对业务进行横向切分。比如应用层：分为购物、论坛、搜索等。  </p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>一台服务器解决不了的时候，就采用分布式解决一下。<br>分为：分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算。  </p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>使用分布式已经将分层和分割后的模块独立部署，但是对于用户集中访问的模块，可能还需要将独立部署的服务器集群化（多台服务器部署相同的应用构成一个集群），再通过一个负载均衡服务器对外提供服务。  </p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存是改善软件性能的第一手段。</p><ul><li>CDN：讲内容部署在离用户最近的网络服务商，用户请求的时候，可以直接访问网络服务商缓存的静态资源，所以会很快。</li><li>反向代理：用户请求到网站的数据中心时，最先访问的是反向代理服务器，这里会缓存网站的静态资源。</li><li>本地缓存：应用服务器本地缓存的热点数据，可以在本机内存中直接访问，不需要访问数据库。</li><li>分布式缓存：数据量非常庞大时，需要的内存不是单机能承受的。因此还需要分布式缓存    </li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步进行协作。<br>在单一服务器内部：采用<strong>多线程共享队列</strong>的方式实现异步。在分布式系统中：多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看做内存的分布式部署。</p><p>分布式消息队列的特性：网站扩展新功能便利，提高系统可用性，加快网站响应速度，消除并发访问高峰。  </p><h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>备份嘛，较少的机器可能坏的时间不长，但是小概率时间试验的次数过多的话就基本是必然事件了。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>主要集中在运维方面，包括：发布过程自动化、自动化代码管理、自动化测试、自动化安全监测、自动化部署。对于运行中：自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降级、自动化分配资源。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>密码和手机验证码；加密；网站验证码。</p>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发 </tag>
            
            <tag> 大型网站技术 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大型网站架构技术-演化</title>
      <link href="/03-evolution-of-webArchitecture/"/>
      <url>/03-evolution-of-webArchitecture/</url>
      <content type="html"><![CDATA[<a id="more"></a><h1 id="大型网站架构技术-演化"><a href="#大型网站架构技术-演化" class="headerlink" title="大型网站架构技术-演化"></a>大型网站架构技术-演化</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>高并发、大流量</li><li>高可用</li><li>海量数据</li><li>用户分布广泛、网络情况复杂</li><li>安全环境恶劣：易受攻击</li><li>需求变化快、发布频繁：为了快速适应市场</li><li>渐进式发展：逐渐进步发展</li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><h3 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h3><p>应用程序、数据库、文件等所有资源都在一台服务器上。一般是在一台廉价的服务器上采用LAMP这种免费资源。</p><h3 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h3><p>采用三台服务器分别承担自己的角色。</p><h3 id="使用缓存改善网站的性能"><a href="#使用缓存改善网站的性能" class="headerlink" title="使用缓存改善网站的性能"></a>使用缓存改善网站的性能</h3><p>二八定律：80%的业务访问集中在20%的数据上，为了减少数据库的访问压力，可以将一些数据放到缓存服务器上，这样可以提高整个网站的数据访问速度。<br>一般分为两种：</p><ul><li>缓存在应用服务器上的本地缓存：访问速度快，但缓存的数据有限；</li><li>缓存在专门的分布式缓存服务器上的远程缓存：可以采用分布式缓存。<h3 id="采用应用服务器改善网站并发处理能力"><a href="#采用应用服务器改善网站并发处理能力" class="headerlink" title="采用应用服务器改善网站并发处理能力"></a>采用应用服务器改善网站并发处理能力</h3>当应用服务器处理不了较多的并发请求时，可以增加一台服务器分担原有的服务器的访问，在前面加一个负载均衡服务器。<h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3>虽然采用了缓存，但有一些<strong>读操作和一部分写操作</strong>还是会落到数据库上。一般采用主从备份的数据库，写操作可以在主数据库中进行，读操作在从数据库中读取。<h3 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h3>加速用户的访问。基本原理都是缓存，CDN是部署在网络提供商的机房，反向代理部署在网站的中心机房。对于反向代理，用户首先访问的是反向代理服务器，如果反向代理服务器中缓存着资源，就直接返回给用户。<h3 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h3>持续增长的业务，单一的服务器满足不了要求的时候，一头牛拉不动的时候，不要企图换一头更厉害的牛，而是考虑再加一头牛一起拉。<h3 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h3>网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，需要采用一些非关系数据库技术和非数据库查询技术如搜索引擎。<h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3>分而治之<h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3></li></ul>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发 </tag>
            
            <tag> 大型网站技术 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-56and57-Merge-Intervals</title>
      <link href="/30-%E5%88%B7%E9%A2%98/LeetCode-56-Merge-Intervals/"/>
      <url>/30-%E5%88%B7%E9%A2%98/LeetCode-56-Merge-Intervals/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-56-Merge-Intervals"><a href="#LeetCode-56-Merge-Intervals" class="headerlink" title="LeetCode-56-Merge-Intervals"></a>LeetCode-56-Merge-Intervals</h3><blockquote><p>Given a collection of intervals, merge all overlapping intervals.<br>For example,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Given [1,3],[2,6],[8,10],[15,18],</div><div class="line">return [1,6],[8,10],[15,18].</div></pre></td></tr></table></figure></p></blockquote><p>如例子中所示，每个数组的前后分别表示开始和结束，工作是合并有重叠的数组。例如，由于[1,3]和[2,6]有重叠，故直接改为[1,6]后输出。<br>想法还是比较简单的，因为输入的并不一定是给好的按照开始，所以需要先对输入以开始的值排序。首先在结果数组中写入第一个，只有遍历进行判断，分为两种情况：</p><ol><li>如果某一interval的开始比结果数组中的结尾要大，显然不会有重叠，直接写入到结果数组中即可；</li><li>某一interval的开始比结果数组中的结尾要大，必然有重叠，此时还需要判断结束位置的大小。</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for an interval.</div><div class="line"> * struct Interval &#123;</div><div class="line"> *     int start;</div><div class="line"> *     int end;</div><div class="line"> *     Interval() : start(0), end(0) &#123;&#125;</div><div class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</div><div class="line">        vector&lt;Interval&gt; res;</div><div class="line">        if(intervals.size()&lt;=0)</div><div class="line">            return res;</div><div class="line">        sort(intervals.begin(),intervals.end(),[](Interval a,Interval b)&#123;return a.start&lt;b.start;&#125;);</div><div class="line">        res.push_back(intervals[0]);</div><div class="line">        for(int i=1;i&lt;intervals.size();++i)&#123;</div><div class="line">            if(res.back().end&lt;intervals[i].start) res.push_back(intervals[i]);</div><div class="line">            else&#123;</div><div class="line">                res.back().end=max(res.back().end,intervals[i].end);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57-Insert-Interval"></a>57-Insert-Interval</h3><blockquote><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).<br>You may assume that the intervals were initially sorted according to their start times.</p></blockquote><p>题目改为向一个已经重叠的数组中加入新加入一个。需要做的是判断所处的位置，插入进去后还要删掉，值得注意的是这个删掉值的时候，vector的迭代器会发生变化，即有些会失效，所以最好的做法是，先插入，把需要的插入都插入之后再删除。</p><p>另外还有一个值得注意的是，排序搜索的谓语，使用的是<code>a.end&lt;b.start</code>，而不是之前的<code>a.start&lt;b.start</code> ，原因是需要找到一个范围，将newINterval夹在中间的一个范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for an interval.</div><div class="line"> * struct Interval &#123;</div><div class="line"> *     int start;</div><div class="line"> *     int end;</div><div class="line"> *     Interval() : start(0), end(0) &#123;&#125;</div><div class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</div><div class="line">        if(intervals.size()&lt;=0)&#123;</div><div class="line">            intervals.push_back(newInterval);</div><div class="line">            return intervals;</div><div class="line">        &#125;</div><div class="line">        auto range=equal_range(intervals.begin(),intervals.end(),newInterval,[](Interval a,Interval b)&#123;return a.end&lt;b.start;&#125;);</div><div class="line">        auto iter1=range.first,iter2=range.second;</div><div class="line">        if(iter1==iter2)</div><div class="line">            intervals.insert(iter1,newInterval);</div><div class="line">        else&#123;</div><div class="line">            iter2--;</div><div class="line">            iter2-&gt;start=min(newInterval.start,iter1-&gt;start);</div><div class="line">            iter2-&gt;end=max(newInterval.end,iter2-&gt;end);</div><div class="line">            intervals.erase(iter1,iter2);</div><div class="line">        &#125;</div><div class="line">        return intervals;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-55-Jump-Game</title>
      <link href="/30-%E5%88%B7%E9%A2%98/LeetCode-55-Jump-Game/"/>
      <url>/30-%E5%88%B7%E9%A2%98/LeetCode-55-Jump-Game/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-55-Jump-Game"><a href="#LeetCode-55-Jump-Game" class="headerlink" title="LeetCode-55-Jump-Game"></a>LeetCode-55-Jump-Game</h3><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.</p></blockquote><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = [2,3,1,1,4], return true.</div><div class="line"></div><div class="line">A = [3,2,1,0,4], return false.</div></pre></td></tr></table></figure></p><p>由题可知，数组的位置表示从该位置可以像前跳的步数，看最终能否跳到结尾。乍一看，这像是一个动态规划的问题，dp数组内存储每一个位置能够走的最远的位置，但是仔细一想，又是没有必要的，因为最终的目的不是为了判断哪一个位置能走的更远，而是能否到达最后一个位置。<br>能到达最后一个位置的必要条件，显然一个就是能从某一位置继续往前走，而不会断。例如：<code>[3,2,1,0,4]</code>，我们都能走到第4个位置，但是却无法继续往前走，故到不了最后一个。所以代码可以做一个判断。<br>另一个需要考虑的问题是：在从前往后遍历的过程中，维护哪一个变量？显然这个变量记录的是我们能走的最远的距离，如果这个距离走的更远就更新，直到不能继续往前走，此时判断能否到终点。</p><p>贴上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int i=0;</div><div class="line">        for(int reach=0;i&lt;nums.size()&amp;&amp;i&lt;=reach;++i)</div><div class="line">            reach=max(reach,i+nums[i]);</div><div class="line">        return i==nums.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-53-Maximum-Subarray</title>
      <link href="/26-%E5%88%B7%E9%A2%98/LeetCode-53-Maximum-Subarray/"/>
      <url>/26-%E5%88%B7%E9%A2%98/LeetCode-53-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<h2 id="LeetCode-53-Maximum-Subarray"><a href="#LeetCode-53-Maximum-Subarray" class="headerlink" title="LeetCode-53-Maximum-Subarray"></a>LeetCode-53-Maximum-Subarray</h2><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.<br>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p></blockquote><p>最长子序列，又是一个动态规划的问题，关于动态规划，我们最主要的是要维护DP数组，这个问题以前还有点不理解，感觉主要的还是思想，只要知道这是一个动态规划的问题，解决动态规划的一般方法掌握了，其他的就都是细节了。</p><p>最近刷算法题，不得不想到的是以前的数学，数学是逻辑性可能更强的东西，尚且需要多做练习才行，何况算法了。当然现在慢慢的感觉就是，以前看到很多题完全没有头绪，现在很多大概是能分清是想考啥了，也会想着主动去选择相应的数据结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;int&gt; dp(nums.size(),0);</div><div class="line">        dp[0]=nums[0];</div><div class="line">        int res=dp[0];</div><div class="line">        for(int i=1;i&lt;nums.size();++i)&#123;</div><div class="line">            dp[i]=nums[i]+(dp[i-1]&gt;0?dp[i-1]:0);</div><div class="line">            res=max(dp[i],res);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-52-N-Queens-II</title>
      <link href="/26-%E5%88%B7%E9%A2%98/LeetCode-52-N-Queens-II/"/>
      <url>/26-%E5%88%B7%E9%A2%98/LeetCode-52-N-Queens-II/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-52-N-Queens-II"><a href="#LeetCode-52-N-Queens-II" class="headerlink" title="LeetCode-52-N-Queens-II"></a>LeetCode-52-N-Queens-II</h3><blockquote><p>Follow up for N-Queens problem.<br>Now, instead outputting board configurations, return the total number of distinct solutions.</p></blockquote><p>只返回N皇后问题结果的种数。<br>因此不需要每一个字符串置位了，只需要判断一个位置的横竖，斜45度和斜135度方向的值即可。依然采用递归的方式，这里需要注意的是，由于是对列递归，所以需要考虑的是行，斜45度，斜135度，本来是要维护一个一维数组和两个二维数组，但是想到二维数组的特征，可以改为维护三个一维数组，这两个一维数组保存的是将二维数组展开的信息。甚至是一波操作改为共维护两个一维数组也可以。<br>接下来是代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int totalNQueens(int n) &#123;</div><div class="line">        vector&lt;int&gt; rows(n),d1(2*n-1),d2(2*n-1);</div><div class="line">        return find(n,n,0,rows,d1,d2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int find(int n,int left,int i,vector&lt;int&gt;&amp; rows,vector&lt;int&gt;&amp; d1,vector&lt;int&gt;&amp; d2)&#123;</div><div class="line">        if(left==0)</div><div class="line">            return 1;</div><div class="line">        int j,sum=0;</div><div class="line">        for(j=0;j&lt;n;++j)&#123;</div><div class="line">            if(rows[j]||d1[i+j]||d2[n-1+i-j])</div><div class="line">                continue;</div><div class="line">            rows[j]=d1[i+j]=d2[n-1+i-j]=1;</div><div class="line">            sum+=find(n,left-1,i+1,rows,d1,d2);</div><div class="line">            rows[j]=d1[i+j]=d2[n-1+i-j]=0;</div><div class="line">        &#125;</div><div class="line">        return sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>看了一下别人的好像确实快一点，毕竟0ms啊，也贴一下别人的代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int totalNQueens(int n) &#123;</div><div class="line">        bool flag[5*n] = &#123;false&#125;;</div><div class="line">        int num = 0;</div><div class="line">        dfs(num,flag,0,n);</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void dfs(int&amp; num, bool* flag, int row, int n)&#123;</div><div class="line">        if(row == n)&#123;</div><div class="line">            ++num;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i = 0; i&lt;n;i++)&#123;</div><div class="line">            if(!flag[i] &amp;&amp; !flag[row+i+n] &amp;&amp; !flag[4*n + row - i])&#123;</div><div class="line">                flag[i] = 1;</div><div class="line">                flag[row+i+n] = 1;</div><div class="line">                flag[4*n + row - i] = 1;</div><div class="line">                dfs(num,flag,row+1,n);</div><div class="line">                flag[i] = 0;</div><div class="line">                flag[row+i+n] = 0;</div><div class="line">                flag[4*n + row - i] = 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h4><p><a href="https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand" target="_blank" rel="external">https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand</a></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-51-N-Queens</title>
      <link href="/26-%E5%88%B7%E9%A2%98/LeetCode-51-N-Queens/"/>
      <url>/26-%E5%88%B7%E9%A2%98/LeetCode-51-N-Queens/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-51-N-Queens"><a href="#LeetCode-51-N-Queens" class="headerlink" title="LeetCode-51-N-Queens"></a>LeetCode-51-N-Queens</h3><p>经典的N皇后问题，重点是全排列的问题，但是这里由于N皇后的不重复行、列、斜的要求，在排列的过程中，比如从行开始排列，只能保证同行不重复，所以需要引入isValid函数。通过判断列，左斜、右斜是否重复。</p><p>需要注意的是：关于全排列递归的写法，要更加熟练掌握才行，并且能完全理解，能够在不同的情况中灵活运用。其基本思想还是：固定前面的某个数字，不短的对后面进行交换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isValid(vector&lt;string&gt;&amp; queen, int row,int col,int n)&#123;</div><div class="line">        for(int i=0;i&lt;row;++i)&#123;</div><div class="line">            if(queen[i][col]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;--i,--j)&#123;</div><div class="line">            if(queen[i][j]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;--i,++j)&#123;</div><div class="line">            if(queen[i][j]==&apos;Q&apos;)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    void recurse(vector&lt;string&gt;&amp; queen,vector&lt;vector&lt;string&gt;&gt;&amp; res,int row,int n)&#123;</div><div class="line">        if(row==n)&#123;</div><div class="line">            res.push_back(queen);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int col=0;col!=n;++col)&#123;</div><div class="line">            if(isValid(queen,row,col,n))&#123;</div><div class="line">                queen[row][col]=&apos;Q&apos;;</div><div class="line">                recurse(queen,res,row+1,n);</div><div class="line">                queen[row][col]=&apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">        vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">        vector&lt;string&gt; queen(n,string(n,&apos;.&apos;));</div><div class="line">        recurse(queen,res,0,n);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-49-Group-Anagrams</title>
      <link href="/25-%E5%88%B7%E9%A2%98/LeetCode-49-Group-Anagrams/"/>
      <url>/25-%E5%88%B7%E9%A2%98/LeetCode-49-Group-Anagrams/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-49-Group-Anagrams"><a href="#LeetCode-49-Group-Anagrams" class="headerlink" title="LeetCode-49-Group-Anagrams"></a>LeetCode-49-Group-Anagrams</h3><blockquote><p>Given an array of strings, group anagrams together.<br>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],</p></blockquote><p>Return:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],</div><div class="line">  [&quot;nat&quot;,&quot;tan&quot;],</div><div class="line">  [&quot;bat&quot;]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>输入一个字符串数组，输出的是：将相同字符的字符串放在一个数组的二维数组。相同字符的处理，基本就是要对字符串排序的。然后需要考虑的就是排序好的那一个字符串怎么存的问题。用的数据结构是map，string为键，对应的值是一个set或者是一个vector，存放满足要求的string，之后再用这个初始化结果数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class="line">        unordered_map&lt;string,multiset&lt;string&gt;&gt; map_str;</div><div class="line">        for(string s:strs)&#123;</div><div class="line">            string t=s;</div><div class="line">            sort(t.begin(),t.end());</div><div class="line">            map_str[t].insert(s);</div><div class="line">        &#125;</div><div class="line">        vector&lt;vector&lt;string&gt;&gt; res;</div><div class="line">        for(auto temp:map_str)&#123;</div><div class="line">            vector&lt;string&gt; vec_str_temp(temp.second.begin(),temp.second.end());</div><div class="line">            res.push_back(vec_str_temp);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>后来发现用vector其实要好一些。只是别人这么写的，时间竟然要短一点，毕竟是用vector初始化vector？</p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode-48-Rotate-Image</title>
      <link href="/25-%E5%88%B7%E9%A2%98/Leetcode-48-Rotate-Image/"/>
      <url>/25-%E5%88%B7%E9%A2%98/Leetcode-48-Rotate-Image/</url>
      <content type="html"><![CDATA[<h3 id="Leetcode-48-Rotate-Image"><a href="#Leetcode-48-Rotate-Image" class="headerlink" title="Leetcode-48-Rotate-Image"></a>Leetcode-48-Rotate-Image</h3><blockquote><p>ou are given an n x n 2D matrix representing an image.<br>Rotate the image by 90 degrees (clockwise).<br>Note:<br>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p></blockquote><p>Example :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [4,5,6],</div><div class="line">  [7,8,9]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [7,4,1],</div><div class="line">  [8,5,2],</div><div class="line">  [9,6,3]</div><div class="line">]</div><div class="line"></div><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [ 5, 1, 9,11],</div><div class="line">  [ 2, 4, 8,10],</div><div class="line">  [13, 3, 6, 7],</div><div class="line">  [15,14,12,16]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [15,13, 2, 5],</div><div class="line">  [14, 3, 4, 1],</div><div class="line">  [12, 6, 8, 9],</div><div class="line">  [16, 7,10,11]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>这个乍一看觉得不难，但是写的时候又不知道怎么回事，其实旋转，对于我们写程序来说，其实就是不停的调换位置，但是怎么调换是个问题。</p><p>观察发现，第一个矩阵，最角上的四个1,3,7,9。转完之后，还是这四个数字，只不过是位置变了，接下来这样的四个是：2,4,6,8.最后一个5.再看一下4x4的其实也差不多。</p><p>所以想法就是直接每次四个数字进行换，换三次，就能换回来，然后进行下一次调换。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class="line">        if(matrix.size()&lt;=0)</div><div class="line">            return;</div><div class="line">        int a=0,b=matrix.size()-1;</div><div class="line">        while(a&lt;b)&#123;</div><div class="line">            for(int i=0;i&lt;b-a;++i)&#123;</div><div class="line">                swap(matrix[a][a+i],matrix[a+i][b]);</div><div class="line">                swap(matrix[a][a+i],matrix[b][b-i]);</div><div class="line">                swap(matrix[a][a+i],matrix[b-i][a]);</div><div class="line">            &#125;</div><div class="line">            ++a;</div><div class="line">            --b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Leetcode-48-Rotate-Image</title>
      <link href="/25-Leetcode-48-Rotate-Image/"/>
      <url>/25-Leetcode-48-Rotate-Image/</url>
      <content type="html"><![CDATA[<h3 id="Leetcode-48-Rotate-Image"><a href="#Leetcode-48-Rotate-Image" class="headerlink" title="Leetcode-48-Rotate-Image"></a>Leetcode-48-Rotate-Image</h3><blockquote><p>ou are given an n x n 2D matrix representing an image.<br>Rotate the image by 90 degrees (clockwise).<br>Note:<br>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p></blockquote><p>Example :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [4,5,6],</div><div class="line">  [7,8,9]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [7,4,1],</div><div class="line">  [8,5,2],</div><div class="line">  [9,6,3]</div><div class="line">]</div><div class="line"></div><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [ 5, 1, 9,11],</div><div class="line">  [ 2, 4, 8,10],</div><div class="line">  [13, 3, 6, 7],</div><div class="line">  [15,14,12,16]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [15,13, 2, 5],</div><div class="line">  [14, 3, 4, 1],</div><div class="line">  [12, 6, 8, 9],</div><div class="line">  [16, 7,10,11]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>这个乍一看觉得不难，但是写的时候又不知道怎么回事，其实旋转，对于我们写程序来说，其实就是不停的调换位置，但是怎么调换是个问题。</p><p>观察发现，第一个矩阵，最角上的四个1,3,7,9。转完之后，还是这四个数字，只不过是位置变了，接下来这样的四个是：2,4,6,8.最后一个5.再看一下4x4的其实也差不多。</p><p>所以想法就是直接每次四个数字进行换，换三次，就能换回来，然后进行下一次调换。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class="line">        if(matrix.size()&lt;=0)</div><div class="line">            return;</div><div class="line">        int a=0,b=matrix.size()-1;</div><div class="line">        while(a&lt;b)&#123;</div><div class="line">            for(int i=0;i&lt;b-a;++i)&#123;</div><div class="line">                swap(matrix[a][a+i],matrix[a+i][b]);</div><div class="line">                swap(matrix[a][a+i],matrix[b][b-i]);</div><div class="line">                swap(matrix[a][a+i],matrix[b-i][a]);</div><div class="line">            &#125;</div><div class="line">            ++a;</div><div class="line">            --b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器-Nginx设计架构</title>
      <link href="/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/"/>
      <url>/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="服务器-Nginx设计架构"><a href="#服务器-Nginx设计架构" class="headerlink" title="服务器-Nginx设计架构"></a>服务器-Nginx设计架构</h3><h4 id="Nginx服务器架构"><a href="#Nginx服务器架构" class="headerlink" title="Nginx服务器架构"></a>Nginx服务器架构</h4><p>Nginx服务器启动后，产生一个主进程，主进程执行一系列工作后产生一个或多个工作进程。</p><p>如下图所示：Nginx服务器的结构大致分为主进程、工作进程、后端服务器和缓存。<br><img src="https://github.com/mianhk/image-save/blob/master/server/003/001.png?raw=true" alt=""></p><ul><li>主进程主要进行：Nginx配置文件解析、数据结构初始化、模块配置和注册、信号处理、网络监听生成、工作进程生成和管理。</li><li>工作进程主要进行：进程初始化、模块调用和请求处理等。</li><li>缓存索引重建及管理进程：cache模块，主要由缓存索引重建和缓存索引管理两类进程完成。缓存索引重建是在Nginx服务启动一段时间后由主进程生成，在缓存元数据重建完成后自动退出。主要工作是：根据本地磁盘上的缓存文件在内存中建立索引元数据库，启动后对本地磁盘上存放缓存文件的目录结构进行扫描，检查内存中已有的缓存你数据元是否正确，并更新索引元数据库；缓存索引管理进程一般存在于主进程的整个生命周期，负责对缓存索引进行管理。主要负责对元数据是否过期做出判断。</li></ul><h4 id="进程交互"><a href="#进程交互" class="headerlink" title="进程交互"></a>进程交互</h4><h5 id="Master-worker交互"><a href="#Master-worker交互" class="headerlink" title="Master-worker交互"></a>Master-worker交互</h5><p>主进程会建立一张工作进程表，存放所有未退出的，主进程通过一个单向管道向工作进程发送指令等信息。</p><h5 id="Worker-Worker交互"><a href="#Worker-Worker交互" class="headerlink" title="Worker-Worker交互"></a>Worker-Worker交互</h5><p>工作进程之间的交互，首先要得到彼此的信息，建立管道通信。当工作进程w1需要向w2发送指令时，首先在主进程给它的其他工作进程信息中找到w2的进程ID，然后将正确的指令写入指向w2的通道。w2捕捉到管道中的时间后，解析指令并采取相应的措施。完成worker之间的交互</p><h4 id="Run-Loops时间处理循环模型"><a href="#Run-Loops时间处理循环模型" class="headerlink" title="Run Loops时间处理循环模型"></a>Run Loops时间处理循环模型</h4><p>Run Loops指的是进程内部用来不停的调配工作，对事件进行循环处理的一种模型。</p>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器-Nginx的事件驱动模型</title>
      <link href="/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"/>
      <url>/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="服务器-Nginx的事件驱动模型"><a href="#服务器-Nginx的事件驱动模型" class="headerlink" title="服务器-Nginx的事件驱动模型"></a>服务器-Nginx的事件驱动模型</h2><h3 id="什么是事件驱动模型"><a href="#什么是事件驱动模型" class="headerlink" title="什么是事件驱动模型"></a>什么是事件驱动模型</h3><p>事件驱动概念：在持续的事物管理过程中，由当前时间节点上出现的事件引起的调用可用资源执行相关任务，解决问题，防止事物堆积的一种策略。<br>一般由：事件收集器、事件发送器和事件处理器组成。</p><h3 id="事件驱动处理库"><a href="#事件驱动处理库" class="headerlink" title="事件驱动处理库"></a>事件驱动处理库</h3><p>又称为多路IO复用方法：主要包括以下几种：</p><h4 id="select库"><a href="#select库" class="headerlink" title="select库"></a>select库</h4><ol><li>创建所关注事件的描述符集合，每个描述符，可以关注读事件、写事件以及异常发生事件。</li><li>调用底层的select函数，等待事件发生。</li><li>轮询所有事件描述符集合中的每一个事件描述符，检查是否有相应的事件发生，如果有，就进行处理。<h4 id="poll库"><a href="#poll库" class="headerlink" title="poll库"></a>poll库</h4>Linux下平台的基本事件驱动模型。基本工作方式与select库相同。<br>区别在于：select库需要为读事件、写事件和异常事件分别创建一个描述符集合，因此在最后轮询的时候，需要分别轮询三个集合。而poll库只需要创建一个集合。轮询的时候同时检查三种事件是否发生。<h4 id="epoll库"><a href="#epoll库" class="headerlink" title="epoll库"></a>epoll库</h4>Nginx服务器支持的高性能事件驱动库。主要的改动是：把描述符列表的管理交由内核负责，一旦有某种事件发生，内核把发生的事件的描述列表通知给进程，这样就避免了轮询整个描述符列表。</li><li>epoll库通过相关调用通知内核创建一个有N个描述符的事件列表。然后给这些描述符设置关注的事件，并添加到内核的事件列表中去。</li><li>完成设置之后，epoll库就开始等待内核通知事件发生。一旦发生，内核将发生事件的描述符上报给epoll库。<h4 id="rtsig模型"><a href="#rtsig模型" class="headerlink" title="rtsig模型"></a>rtsig模型</h4>Real-time signal，实时信号。使用rtsig时，工作进程会通过系统内核建立一个rtsig队列用于存放标记事件发生的信号。每个事件发生时，系统内核就会产生一个信号存放在rtsig队列中等待工作进程的处理。</li></ol>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器-Nginx的Web请求处理机制</title>
      <link href="/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E7%9A%84Web%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E7%9A%84Web%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="服务器-Nginx的Web请求处理机制"><a href="#服务器-Nginx的Web请求处理机制" class="headerlink" title="服务器-Nginx的Web请求处理机制"></a>服务器-Nginx的Web请求处理机制</h2><h3 id="并行处理请求的三种方式"><a href="#并行处理请求的三种方式" class="headerlink" title="并行处理请求的三种方式"></a>并行处理请求的三种方式</h3><p>web服务器和客户端是一对多的关系，所以web服务器要能同时为多个客户端提供服务。一般有三种方式：多进程方式、多线程方式和异步方式。</p><h4 id="多进程方式"><a href="#多进程方式" class="headerlink" title="多进程方式"></a>多进程方式</h4><p>服务器每接收到一个客户端时，就由服务器主进程生成一个子进程与该客户端交互 ，直到连接断开，子进程结束。</p><ul><li>优点：设计和实现相对简单、子进程之间相互独立，处理客户端请求的过程彼此不干扰，一个有问题不会影响其他的。保证了稳定性。子进程退出时，资源会被系统回收，不会留下垃圾。</li><li>缺点：每生成一个子进程，都要进行内存复制的操作，在资源和时间上会有额外的开销。<br>Apache采用的“预生成进程”可以稍微解决大并发请求，但是本质是多进程，无法解决多并发的问题。<h5 id="多线程方式"><a href="#多线程方式" class="headerlink" title="多线程方式"></a>多线程方式</h5>服务器每接收到一个客户端时，会由服务器主进程派生一个线程出来和该客户端进行交互。</li><li>优点：产生一个线程的开销要小于一个进程，比较规范，利于协作。</li><li>缺点：多个线程在一个内存空间中，彼此互相影响，对内存的管理增加了出错的风险。<h4 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h4><h5 id="同步、异步与阻塞、非阻塞"><a href="#同步、异步与阻塞、非阻塞" class="headerlink" title="同步、异步与阻塞、非阻塞"></a>同步、异步与阻塞、非阻塞</h5><strong>同步和异步描述的是通信模式的概念</strong><br>同步：发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求。所有的请求在服务器端得到同步，发送方和接收方对请求的处理步调是一致的。<br>异步：发送方发送请求后，不等待接收方响应这个请求，就继续发送下一个请求。所有来自发送方的请求形成一个队列，接收方处理完后通知发送方。</li></ul><p><strong>阻塞和非阻塞描述的是进程处理调用的方式，在网络通信中，主要指的是网络套接字socket的阻塞和非阻塞方式，socket实质上就是IO操作</strong><br>阻塞：调用结果返回之前，当前的线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU继续执行。<br>非阻塞：调用结果返回之前，线程不会被挂起，而是立即返回执行下一个周期。</p><p>所以共有四种方式：</p><ul><li>同步阻塞：发送方发送请求后，一直等待响应；接收方处理请求时不能立即等到结果的时候，就会一直等待返回结果，才响应发送方，期间不能执行任何其他工作。</li><li>同步非阻塞：发送方发送请求后，一直等待响应；接收方处理请求时不能立即等到结果的时候，就会立即返回，去做别的事情，但是由于没有得到结果，也不响应发送方，发送方一直等待。</li><li>异步阻塞：发送方发送请求后，不等待响应；接收方处理请求时不能立即等到结果的时候，就会一直等待返回结果，才响应发送方，期间不能执行任何其他工作。</li><li>异步非阻塞：发送方发送请求后，不等待响应；接收方处理请求时不能立即等到结果的时候，就会立即返回，去做别的事情，但是由于没有得到结果，也不响应发送方，发送方一直等待。</li></ul><h5 id="Nginx如何处理请求"><a href="#Nginx如何处理请求" class="headerlink" title="Nginx如何处理请求"></a>Nginx如何处理请求</h5><p>Nginx采用的是异步非阻塞的方式。采用Master-work模型（其实实际也有single的单进程模式，但是性能较差，很少使用）。每个工作进程采用异步非阻塞的方式。<br>Nginx服务器的工作进程调用IO后，就去进行其他工作，当IO调用返回，会通知工作进程。接下来就是怎么通知给工作进程了。</p>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器-Nginx模块化结构</title>
      <link href="/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%93%E6%9E%84/"/>
      <url>/25-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="服务器-Nginx模块化结构"><a href="#服务器-Nginx模块化结构" class="headerlink" title="服务器-Nginx模块化结构"></a>服务器-Nginx模块化结构</h3><p>习惯上将Nginx分为：核心模块、标准模块、可选HTTP模块、邮件服务模块和第三方模块五大类。</p><h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>包含对两部分功能的支持：</p><ul><li>主体功能：进程管理、权限控制、错误日志记录、配置解析等</li><li>用于响应请求必需的功能：事件驱动机制、正则表达式解析等    </li></ul><h4 id="标准HTTP模块"><a href="#标准HTTP模块" class="headerlink" title="标准HTTP模块"></a>标准HTTP模块</h4><p>对应基本的HTTP服务  </p><h4 id="可选HTTP模块"><a href="#可选HTTP模块" class="headerlink" title="可选HTTP模块"></a>可选HTTP模块</h4><p>快速编译中默认不编译，需要使用的话需要自己加上–with-XXX的参数声明。</p><h4 id="邮件服务模块"><a href="#邮件服务模块" class="headerlink" title="邮件服务模块"></a>邮件服务模块</h4><p>Nginx的主要服务之一，快速编译时也不会编译</p><h4 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h4>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器-Nginx-一个简单的例子</title>
      <link href="/24-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
      <url>/24-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
      <content type="html"><![CDATA[<h3 id="服务器-Nginx-一个简单的例子"><a href="#服务器-Nginx-一个简单的例子" class="headerlink" title="服务器-Nginx-一个简单的例子"></a>服务器-Nginx-一个简单的例子</h3><p>直接贴一个几经磨难的简单的例子吧，虽然简单，但是有些不理解的地方，就出了很多错，但是因为这些错误，在对nginx理解稍微深刻了那么一点点的同时，对Linux的操作好像也有了一点进步啊。才知道为什么大家的命令都那么长，而我总是一步步慢慢的来了，一方面不熟，另一方面确实操作的不够多啊。</p><h4 id="配置细节"><a href="#配置细节" class="headerlink" title="配置细节"></a>配置细节</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">user mianhk;</div><div class="line">worker_processes 3;</div><div class="line">pid /run/nginx.pid;</div><div class="line"></div><div class="line">events &#123;</div><div class="line">    use epoll;</div><div class="line">    #worker_connections 768;</div><div class="line">    worker_connections 768;</div><div class="line">    # multi_accept on;</div><div class="line">&#125;</div><div class="line"></div><div class="line">http &#123;</div><div class="line"></div><div class="line">    ##</div><div class="line">    # Basic Settings</div><div class="line">    ##</div><div class="line"></div><div class="line">    sendfile on;</div><div class="line">    #tcp_nopush on;</div><div class="line">    #tcp_nodelay on;</div><div class="line">    keepalive_timeout 65;</div><div class="line">    types_hash_max_size 2048;</div><div class="line">    # server_tokens off;</div><div class="line"></div><div class="line">    # server_names_hash_bucket_size 64;</div><div class="line">    # server_name_in_redirect off;</div><div class="line"></div><div class="line">    include /etc/nginx/mime.types;</div><div class="line">    default_type application/octet-stream;</div><div class="line"></div><div class="line">    ##</div><div class="line">    # SSL Settings</div><div class="line">    ##</div><div class="line"></div><div class="line">    #ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</div><div class="line">    #ssl_prefer_server_ciphers on;</div><div class="line"></div><div class="line">    ##</div><div class="line">    # Logging Settings</div><div class="line">    ##</div><div class="line"></div><div class="line">    access_log /var/log/nginx/access.log;</div><div class="line">    error_log /var/log/nginx/error.log;</div><div class="line"></div><div class="line">    ##</div><div class="line">    # Gzip Settings</div><div class="line">    ##</div><div class="line"></div><div class="line">    gzip on;</div><div class="line">    gzip_disable &quot;msie6&quot;;</div><div class="line"></div><div class="line">    # gzip_vary on;</div><div class="line">    # gzip_proxied any;</div><div class="line">    # gzip_comp_level 6;</div><div class="line">    # gzip_buffers 16 8k;</div><div class="line">    # gzip_http_version 1.1;</div><div class="line">    # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</div><div class="line"></div><div class="line">    ##</div><div class="line">    # Virtual Host Configs</div><div class="line">    ##</div><div class="line">    ## 配置虚拟主机1</div><div class="line">    server &#123;</div><div class="line">        listen        8081;   #监听端口</div><div class="line">        server_name   myServer1;</div><div class="line">        access_log  var/myweb/server1/log/access_log;  #配置日志存放路径</div><div class="line">        error_page 404 /404.thml;   # 错误界面</div><div class="line"></div><div class="line">        location /server1/location1 &#123; #配置/server1/location1请求的location</div><div class="line">            root /var/myweb;</div><div class="line">            index index.svr1-loc1.htm;</div><div class="line">        &#125;</div><div class="line">        location /server1/location2 &#123;  #配置/server1/location2请求的location</div><div class="line">            root /var/myweb;</div><div class="line">            index index.svr1-locl2.htm;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;   #配置虚拟主机myServer2</div><div class="line">        listen     8082;</div><div class="line">        server_name 192.168.1.31;</div><div class="line">        access_log var/myweb/server2/log/access_log;</div><div class="line">        error_page 404 /404.thml;  #对错误页面定向</div><div class="line"></div><div class="line">        location /server2/location1 &#123;</div><div class="line">            root /var/myweb;</div><div class="line">            index index.svr2-loc1.htm;</div><div class="line">        &#125;</div><div class="line">        location /svr2/loc2 &#123;</div><div class="line">            alias /myweb/server2/location2/;  #对location的URI进行更改</div><div class="line">            index index.svr2-locl2.htm;</div><div class="line">        &#125;</div><div class="line">        location = /404.html &#123;  #配置错误页面转向</div><div class="line">            root /var/myweb;</div><div class="line">            index 404.html;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    #include /etc/nginx/conf.d/*.conf;</div><div class="line">    #include /etc/nginx/sites-enabled/*;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>在浏览器中输入：<code>http://111.230.231.95:8081/server1/location1/</code><img src="http://blog-1252063226.cosbj.myqcloud.com/server/002001.jpg?raw=true" alt=""><br>输入<code>http://111.230.231.95:8082/server2/location1/</code>显示：<br><img src="http://blog-1252063226.cosbj.myqcloud.com/server/002002.jpg?raw=true" alt=""></p><h4 id="出现的问题分析"><a href="#出现的问题分析" class="headerlink" title="出现的问题分析"></a>出现的问题分析</h4><ul><li><p>root目录的位置：<br>原来root的目录虽然写的是/var/myweb，但是实际发现位置是 在<code>/usr/share/nginx</code>下面，所以需要拷过去，具体这个位置是在哪里设置的，因为已经把所有其他的include都关掉了，所以可能是ubuntu下安装之后的默认目录，就像默认监听的80端口的页面其实在<code>var/www/html</code>下面一样。 导致出了各种莫名其妙的错误啊:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">root@VM-95-58-ubuntu:/etc/nginx# systemctl status nginx.service</div><div class="line">● nginx.service - A high performance web server and a reverse proxy server</div><div class="line">   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)</div><div class="line">   Active: failed (Result: exit-code) since Wed 2018-01-24 22:05:09 CST; 1s ago</div><div class="line">  Process: 32576 ExecStop=/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid (code</div><div class="line">  Process: 21311 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)</div><div class="line">  Process: 3307 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=1/FAI</div><div class="line"> Main PID: 21314 (code=exited, status=0/SUCCESS)</div><div class="line"></div><div class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: Starting A high performance web server and a reverse proxy server.</div><div class="line">Jan 24 22:05:09 VM-95-58-ubuntu nginx[3307]: nginx: [emerg] open() &quot;/usr/share/nginx/var/myweb/server1/log/acc</div><div class="line">Jan 24 22:05:09 VM-95-58-ubuntu nginx[3307]: nginx: configuration file /etc/nginx/nginx.conf test failed</div><div class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: nginx.service: Control process exited, code=exited status=1</div><div class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: Failed to start A high performance web server and a reverse proxy</div><div class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: nginx.service: Unit entered failed state.</div><div class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: nginx.service: Failed with result &apos;exit-code&apos;.</div></pre></td></tr></table></figure></li><li><p>另一个就是关于config文件的格式，一定要仔细写，需要加分号，然后就是最后的<code>/</code>，对于nginx的配置来说，是意义重大的，后面可能会说到这个问题，但是现在还是要写上。</p></li><li>刚刚测试，好像发现这里还有其他的问题，比如我的location2好像打不开啊，尴尬，明天再看看出了什么问题。。</li></ul>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器-Nginx基础配置</title>
      <link href="/24-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
      <url>/24-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="服务器-Nginx基础配置"><a href="#服务器-Nginx基础配置" class="headerlink" title="服务器-Nginx基础配置"></a>服务器-Nginx基础配置</h3><h4 id="nginx-conf文件结构"><a href="#nginx-conf文件结构" class="headerlink" title="nginx.conf文件结构"></a>nginx.conf文件结构</h4><p>Nginx的默认配置文件为：<code>nginx.conf</code>，文件一共由三个部分组成，分别为：<code>全局块、events块、http块</code>在<code>http块</code>中，包含http全局块，多个server块。在每个<code>server块</code>中，可以包含多个server块和location块。</p><p>同一模块中嵌套的配置块。各个之间不存在次序关系，也就是是同时生效的。另外，在高一等级的配置可能会被更内层括号内的设置覆盖，这个其实跟我们的继承或者函数中差不多。</p><ul><li>全局块：（从配置文件开始到events的一部分）主要影响Nginx服务器整体运行的配置指令 ，顾名思义，能够作用于全局。</li><li>evevts块：主要影响Nginx服务器与用户的网络连接。这部分对Nginx服务器性能影响较大。</li><li>http块：代理、缓存和日志定义等绝大部分功能和第三方模块的配置都在这部分。由于http块包括server块，这里用http全局块表示不包含server块的部分。</li><li>server块：和“虚拟主机”密切联系。利用虚拟主机技术可以避免为每一个要用运行的网站提供单独的Nginx服务器，也不需要为每个网站对应一组nginx进程。一个http块中可以包含多个server块，每个server块相当于一个虚拟主机，它内部可以有多台主机联合提供服务，一起对外提供在逻辑上的一组服务（或网站）。server全局块一般配置的是：虚拟主机的监听配置和本虚拟主机的名称和IP配置。</li><li>location块：location块其实是server块的一个指令，主要作用是：基于Nginx服务器接收到的字符串，对除虚拟主机名称外的字符串进行匹配，对特定的请求进行处理、地址定向、数据缓存和应答控制等功能。</li></ul><h4 id="详细配置分析"><a href="#详细配置分析" class="headerlink" title="详细配置分析"></a>详细配置分析</h4><p>接下来是一个详细解释的配置的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">                                     #全局块开始</div><div class="line">user user [group];                       #可以开启nginx服务的用户名user和所对应的group（可选）</div><div class="line">#user nobody nobody;         #注释或者nobody可以表示任何人都能启动</div><div class="line">worker_processes number|auto;               #开启的工作进程的数量，auto则会根据系统自动</div><div class="line">pid /run/nginx.pid;                  #存储进程pid的文件，记得不止要加上路径，还要加上文件名，并且开启服务的用户需要对该文件有权限</div><div class="line"></div><div class="line">events &#123;                             #events块</div><div class="line">    worker_connections 768;          #每一个工作进程能开启的最大连接个数：总的连接个数total=worker_processes*worker_connections</div><div class="line">    # accept_mutex on;     #设置网络连接的序列化，解决“惊群”的问题（当一个网络连接到来时，多个睡眠进程被唤醒，影响系统性能）</div><div class="line">    # multi_accept on;  #允许接受多个网络连接</div><div class="line">    #use method;  #时间驱动模型的选择:select|poll|kqueue|epoll|rtsig|/dev/poll|eventport</div><div class="line">&#125;</div><div class="line"></div><div class="line">http &#123;                               #http块</div><div class="line"></div><div class="line">    ##</div><div class="line">    # Basic Settings</div><div class="line">    ##</div><div class="line"></div><div class="line">    sendfile on;</div><div class="line">    tcp_nopush on;</div><div class="line">    tcp_nodelay on;</div><div class="line">    keepalive_timeout 65;   #连接超时时间</div><div class="line">    #keepalive_requests number; #单连接请求数上限</div><div class="line">    types_hash_max_size 2048;</div><div class="line">    # server_tokens off;</div><div class="line"></div><div class="line">    # server_names_hash_bucket_size 64;</div><div class="line">    # server_name_in_redirect off;</div><div class="line"></div><div class="line">    include /etc/nginx/mime.types;   #MIME-types存储了媒体资源的类型</div><div class="line">    default_type application/octet-stream; #处理前端请求的MIME类型，可在http、server、location中定义</div><div class="line"></div><div class="line">    ##</div><div class="line">    # SSL Settings</div><div class="line">    ##</div><div class="line"></div><div class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</div><div class="line">    ssl_prefer_server_ciphers on;</div><div class="line"></div><div class="line">    ##</div><div class="line">    # Logging Settings</div><div class="line">    ##</div><div class="line"></div><div class="line">    access_log /var/log/nginx/access.log;  # 日志存放文件名，该指令可以在全局块、http块和server块中，作用域不同</div><div class="line">    error_log /var/log/nginx/error.log;</div><div class="line"></div><div class="line">    ##</div><div class="line">    # Gzip Settings</div><div class="line">    ##</div><div class="line"></div><div class="line">    gzip on;</div><div class="line">    gzip_disable &quot;msie6&quot;;</div><div class="line"></div><div class="line">    # gzip_vary on;</div><div class="line">    # gzip_proxied any;</div><div class="line">    # gzip_comp_level 6;</div><div class="line">    # gzip_buffers 16 8k;</div><div class="line">    # gzip_http_version 1.1;</div><div class="line">    # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</div><div class="line"></div><div class="line">    ##</div><div class="line">    # Virtual Host Configs</div><div class="line">    ##</div><div class="line"></div><div class="line">    include /etc/nginx/conf.d/*.conf;   # include 引入配置文件，支持相对路径</div><div class="line">    include /etc/nginx/sites-enabled/*;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器-Nginx安装和基本配置</title>
      <link href="/23-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>/23-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="服务器-Nginx安装和基本配置"><a href="#服务器-Nginx安装和基本配置" class="headerlink" title="服务器-Nginx安装和基本配置"></a>服务器-Nginx安装和基本配置</h3><h4 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h4><p>没有看书上，直接在ubuntu输了一个nginx，大概是ubuntu的支持比较好，直接提醒可以安装，于是就毫不客气的装了一下就启动了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div><div class="line">sudo /etc/init.d/nginx start</div></pre></td></tr></table></figure></p><p>接下来直接在浏览器里面打开，就能看到hello,Nginx这样欣慰 的界面了。</p><p>之后能够在文件夹<code>/etc</code>中看到我们的配置的文件：<br><img src="http://blog-1252063226.cosbj.myqcloud.com/server/001001.jpg?raw=true" alt=""><br>在<code>var/www/html</code>文件夹中能看到<code>index.html</code>文件，即是我们的主页文件。<br><strong>这里没有采用源码的方式安装，其实是觉得没有必要了。 </strong></p><h4 id="Nginx的启停"><a href="#Nginx的启停" class="headerlink" title="Nginx的启停"></a>Nginx的启停</h4><p>刚刚已经直接开启了Nginx了，其实关就更简单了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/nginx stop  #停止nginx</div><div class="line">sudo /etc/init.d/nginx restart # 重启nginx</div></pre></td></tr></table></figure></p><p>这里需要注意的是nginx的平滑重启：Nginx服务进程接受到信号后，首先读取新的Nginx的配置文件，如果新的配置文件语法正确，则启动新的Nginx服务，然后平缓的关闭旧的服务进程。否则，仍然使用旧的Nginx进程提供服务。</p><h4 id="Nginx服务器的升级"><a href="#Nginx服务器的升级" class="headerlink" title="Nginx服务器的升级"></a>Nginx服务器的升级</h4><p>平滑升级：Nginx服务接收到USR2信号后，首先将旧的nginx.pid文件（如果配置文件中更改过名字，也是相同的过程）添加后缀<code>.oldbin</code>，变为nginx.pid.oldbin文件；之后执行新版本Nginx服务器的二进制文件启动服务。如果新的服务启动成功，系统中将有新旧两个Nginx服务共同提供Web服务。之后，需要像旧的Nginx服务进程发送WINCH信号，使旧的Nginx服务平滑停止，并删除nginx.pid.oldbin文件。在发送WINCH信号之前，可以随时停止新的Nginx服务。</p>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器-初识Nginx</title>
      <link href="/23-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%88%9D%E8%AF%86Nginx/"/>
      <url>/23-%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%88%9D%E8%AF%86Nginx/</url>
      <content type="html"><![CDATA[<h3 id="初识Nginx"><a href="#初识Nginx" class="headerlink" title="初识Nginx"></a>初识Nginx</h3><h4 id="Nginx的历史"><a href="#Nginx的历史" class="headerlink" title="Nginx的历史"></a>Nginx的历史</h4><p>Netcraft公司，1994年在英国成立。</p><h4 id="常见服务器"><a href="#常见服务器" class="headerlink" title="常见服务器"></a>常见服务器</h4><ul><li>Apache服务器：目前最广泛使用的web服务器，由于使用了以“进程”为基础的结构，会消耗更多的系统开支。因此通常对Apache web进行扩容的时候，是增加服务器或者扩充集群节点而不是增加处理器。</li><li>Microsoft IIS：微软的，付费软件，部署成本较高。</li><li>Tomcat服务器：最初Sun公司开发，是官方推荐的Servlet和JSP容器，在中小型系统和并发访问用户不是很多的时候，可以作为轻量级应用服务器。一般应用中，通常作为Apache服务器的扩展部分，为运行JSP页面和Servlet提供服务，提供的Servlet容器是Tomcat的默认模式。Tomcat也具有处理HTML页面的功能，只是处理静态页面的能力不如Apache服务器。</li><li>Lighttpd服务器：德国开源的一个轻量级web服务器，它专门针对高性能网站，提供一种安全、快速、兼容性良好并且灵活的Web Server的环境。同时有非常低的内存开销、CPU占用率低、模块丰富。  但是最为轻量服务器，与Apache这种大型服务器相比还有差距。</li><li>Nginx</li></ul><h4 id="Nginx的功能特性"><a href="#Nginx的功能特性" class="headerlink" title="Nginx的功能特性"></a>Nginx的功能特性</h4><h5 id="基本的HTTP服务："><a href="#基本的HTTP服务：" class="headerlink" title="基本的HTTP服务："></a>基本的HTTP服务：</h5><ul><li>作为HTTP代理服务器和反向代理服务器</li><li>支持通过缓存加速访问</li><li>完成简单的负载均衡和容错</li><li>支持包过滤</li><li>支持SSL<h5 id="高级HTTP服务："><a href="#高级HTTP服务：" class="headerlink" title="高级HTTP服务："></a>高级HTTP服务：</h5></li><li>进行自定义配置</li><li>支持虚拟主机</li><li>支持URL重定向</li><li>支持网络监控</li><li>支持流媒体传输<h5 id="邮件服务："><a href="#邮件服务：" class="headerlink" title="邮件服务："></a>邮件服务：</h5></li><li>支持IMAP/POP3代理服务</li><li>支持内部SMTP代理服务</li></ul><h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h4><h5 id="HTTP代理和反向代理"><a href="#HTTP代理和反向代理" class="headerlink" title="HTTP代理和反向代理"></a>HTTP代理和反向代理</h5><p>在反向代理服务方面，Nginx服务器转发前端请求性能稳定，并且后端转发与业务配置相互分离，配置相当灵活。</p><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>负载均衡：一是将单一的重负载分担到多个网络节点做并行处理，每个节点处理结束后将结果汇总返回给用户；二是讲大量的前端并发访问或数据流量分担到多个后端网络节点上分别处理，有效减少前端用户等待响应的时间。Nginx服务器的负载均衡主要是对大量的前端访问和流量进行分流，以保证前端用户的访问效率。</p><p>Nginx服务器的负载均衡策略可以划分为两类：</p><ul><li>内置策略：轮询、加权轮询和IP hash</li><li>扩展策略：通过第三方模块实现，常见：url hash、fair</li></ul><h5 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h5>]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux用户管理</title>
      <link href="/23-Linux/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/23-Linux/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="Linux账户管理"><a href="#Linux账户管理" class="headerlink" title="Linux账户管理"></a>Linux账户管理</h3><h4 id="新建账户（ubuntu）"><a href="#新建账户（ubuntu）" class="headerlink" title="新建账户（ubuntu）"></a>新建账户（ubuntu）</h4><p>新建账户比较简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd mianhk1  #mianhk1为账户名</div></pre></td></tr></table></figure></p><p>之后可以在三个文件夹看到新账户的信息：<br><img src="https://github.com/mianhk/image-save/blob/master/Linux/002/001.jpg?raw=true" alt=""><br>此时可以看到，shadow文件中，第二个存密码的位置是一个!,此时新建的账户还没有密码，当然也可以看到home目录下没有mianhk1的文件夹，此时需要先改密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd mianhk1 #修改密码</div></pre></td></tr></table></figure><p><img src="https://github.com/mianhk/image-save/blob/master/Linux/002/002.jpg?raw=true" alt=""><br>这时候就能看到shadow文件中保存的密码了，同时，也能在home目录下看到miahk1的文件夹了。但是此时切换到mianhk1账户时，看到的仍然是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mianhk1@VM-95-58-ubuntu:/home$ ls</div><div class="line">mianhk  mianhk1</div><div class="line">bash: history: /home/mianhk1/.bash_history: cannot create: Permission denied</div><div class="line">bash: history: /home/mianhk1/.bash_history: cannot create: Permission denied</div><div class="line">bash: history: /home/mianhk1/.bash_history: cannot create: Permission denied</div></pre></td></tr></table></figure></p><p>这个原因其实是无法建立bash的一些文件，原因在上图中可以看到，因为我们没有指定系统的默认bash。通过修改之后，添加默认的bash还是出现了下列的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[sudo] password for mianhk1:</div><div class="line">mianhk1 is not in the sudoers file.  This incident will be reported.</div><div class="line">bash: history: /home/mianhk1/.bash_history: cannot create: Permission denied</div><div class="line">bash: history: /home/mianhk1/.bash_history: cannot create: Permission denied</div><div class="line">bash: history: /home/mianhk1/.bash_history: cannot create: Permission denied</div><div class="line">bash: history: /home/mianhk1/.bash_history: cannot create: Permission denied</div><div class="line">bash: history: /home/mianhk1/.bash_history: cannot create: Permission denied</div></pre></td></tr></table></figure></p><p>原因还没有权限，用root用户看了一下，发现原来mianhk1的所有者原来是root用户，直接修改拥有者和用户权限吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chown mianhk1 mianhk1  #修改拥有者用户</div><div class="line">chgrp mianhk1 mianhk1  #修改拥有组</div><div class="line">chmod +040 mianhk1     #修改文件夹权限</div></pre></td></tr></table></figure></p><p>之后可以通过命令查看生成的账户的信息了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@VM-95-58-ubuntu:/home# useradd -D</div><div class="line">GROUP=100           #用户组</div><div class="line">HOME=/home          #用户家目录的位置</div><div class="line">INACTIVE=-1         #密码失效日，在 shadow 内的第 7 栏</div><div class="line">EXPIRE=             #账号失效日，在 shadow 内的第 8 栏</div><div class="line">SHELL=/bin/sh       #预设的shell</div><div class="line">SKEL=/etc/skel      #用户家目录的内容数据参考目录</div><div class="line">CREATE_MAIL_SPOOL=no#是否主动帮使用者建立邮件信箱(mailbox)</div></pre></td></tr></table></figure></p><p>之后看了一下centos的，发现根本直接新建就好使了啊，<strong>^_^</strong>尴尬</p><p>中间还出了个很尴尬的事情，一不小心删了/etc/passwd 文件。。<br>没事，想想这么重要的文件肯定会有备份的，果然是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp /etc/passwd- /etc/passwd</div></pre></td></tr></table></figure></p><h4 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">deluser mianhk1  #mianhk1 为账户的名字</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>腾讯云服务器Linux挖比特币</title>
      <link href="/19-%E9%9A%8F%E7%AC%94/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8Linux%E6%8C%96%E6%AF%94%E7%89%B9%E5%B8%81/"/>
      <url>/19-%E9%9A%8F%E7%AC%94/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8Linux%E6%8C%96%E6%AF%94%E7%89%B9%E5%B8%81/</url>
      <content type="html"><![CDATA[<h3 id="腾讯云服务器Linux挖比特币"><a href="#腾讯云服务器Linux挖比特币" class="headerlink" title="腾讯云服务器Linux挖比特币"></a>腾讯云服务器Linux挖比特币</h3><p>毕竟又是一个周五的下午，有点等着放假，就想起来现在的挖矿，虽然现在挖矿都是专门的矿机或者是显卡之类的。但是经过计算，好像自己挖的话连电费都不够，就想试试云服务器可不可以，虽然CPU做这种傻瓜的计算问题可能不如专门的器件是吧。<br><a id="more"></a><br>这是我的ubuntu服务器的。</p><ul><li>注册一个矿池账号，推荐<a href="https://www.f2pool.com/" target="_blank" rel="external">https://www.f2pool.com/</a></li><li>通过ssh连接远程服务器</li><li><p>下载挖矿工具<br>这里别人推荐的地址可能有问题，或者我这个之后也会升级，所以可以直接去官网下载最新的推荐的版本就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://downloads.sourceforge.net/project/cpuminer/pooler-cpuminer-2.5.0-linux-x86_64.tar.gz</div></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar xvzf ooler-cpuminer-2.5.0-linux-x86_64.tar.gz</div></pre></td></tr></table></figure></li><li><p>nohup命令后台一直运行<br>注意：不同的端口对应不同的币，一个用户名可以在后面例如：mianhk.001，mianhk.002代表不同的矿机。userpass后面是账户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 以下不同的地址对应的是不同的矿</div><div class="line">nohup ./minerd -a scrypt -o stratum+tcp://stratum.f2pool.com:3333 --userpass=账号:密码 &amp;</div><div class="line"></div><div class="line">nohup ./minerd -a scrypt -o stratum+tcp://xmr.f2pool.com:13531 --userpass=账号:密码 &amp;</div><div class="line"></div><div class="line">nohup ./minerd -a scrypt -o stratum+tcp://zec.f2pool.com:3357 --userpass=账号:密码 &amp;</div></pre></td></tr></table></figure></li></ul><p>之后，就可以打开日志文件看到在挖矿了。我们还需要在网站填上自己的比特币钱包地址。但是这个挖的数目确实有点小啊<br>  <img src="http://blog-1252063226.cosbj.myqcloud.com/tools/001001.png?raw=true" alt=""></p><p>之后打开腾讯云服务器可以看到CPU已经跑满了啊。<br><img src="http://blog-1252063226.cosbj.myqcloud.com/tools/001002.png?raw=true" alt=""></p><p>然后之后就看到网上说云服务器跑的太满的话，会被封的，那就把CPU限制一下吧。<br>步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install cpulimit</div><div class="line">top  # 查看pid</div><div class="line">cpulimit -p pid -l n  # n是限制的值</div></pre></td></tr></table></figure></p><p><strong>下面是centos的，因为有两台服务器，但是centos放的是vpn，平时还没装过软件呢</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yum install epel-release</div><div class="line">yum install cpulimit</div><div class="line">top  # 查看pid</div><div class="line">cpulimit -p pid -l n  # n是限制的值</div></pre></td></tr></table></figure></p><p>限制之后，就能明显的看到CPU占用没有满了：<br><img src="http://blog-1252063226.cosbj.myqcloud.com/tools/001003.jpg?raw=true" alt=""><br><img src="http://blog-1252063226.cosbj.myqcloud.com/tools/001004.jpg?raw=true" alt=""></p><p>哈哈，就当玩玩吧，多了解一下区块链，总得跟上节奏吧，虽然已经有点晚了的样子</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux修改用户名和所属组</title>
      <link href="/17-Linux/Linux%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E6%89%80%E5%B1%9E%E7%BB%84/"/>
      <url>/17-Linux/Linux%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E6%89%80%E5%B1%9E%E7%BB%84/</url>
      <content type="html"><![CDATA[<h3 id="Linux修改用户名和所属组"><a href="#Linux修改用户名和所属组" class="headerlink" title="Linux修改用户名和所属组"></a>Linux修改用户名和所属组</h3><p>腾讯云的云服务器的，初始的用户名和主机名都是分配的。主机名其实还好了，用户名总是一个ubuntu有点看的不爽，正好看到了用户管理，就在这准备改一下，mianhk显然是一个更好一点的选择是吧。_<em>^ </em> ^_</p><h4 id="更改用户名"><a href="#更改用户名" class="headerlink" title="更改用户名"></a>更改用户名</h4><h5 id="修改sudoers文件"><a href="#修改sudoers文件" class="headerlink" title="修改sudoers文件"></a>修改sudoers文件</h5><p>因为之后的操作，直接进入root用户操作。<br>将要改的名字提前赋予较高的权限，防止修改下面文件的过程中出现权限不足的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sudoers</div></pre></td></tr></table></figure></p><p><img src="https://github.com/mianhk/image-save/blob/master/Linux/001/001.jpg?raw=true" alt=""></p><h5 id="修改shadow文件"><a href="#修改shadow文件" class="headerlink" title="修改shadow文件"></a>修改shadow文件</h5><p>shadow文件存储与登陆有关的内容，格式如下：<br>username: passwd: lastchg: min: max: warn: inactive: expire: flag<br>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:<br>警告时间:不活动时间:失效时间:标志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/shadow</div></pre></td></tr></table></figure></p><p><img src="https://github.com/mianhk/image-save/blob/master/Linux/001/002.jpg?raw=true" alt=""></p><h5 id="修改开始目录"><a href="#修改开始目录" class="headerlink" title="修改开始目录"></a>修改开始目录</h5><p>每个用户都有一个家目录，远程登录的时候就会进入家目录。包含用户相关配置信息,例如：<img src="https://github.com/mianhk/image-save/blob/master/Linux/001/003.jpg?raw=true" alt=""><br>现在直接将这个家目录修改就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv ubuntu mianhk  # ubuntu 原来的目录</div></pre></td></tr></table></figure></p><h5 id="修改passwd文件"><a href="#修改passwd文件" class="headerlink" title="修改passwd文件"></a>修改passwd文件</h5><p>passwd的文件格式是：<br>用户名: 密码 : uid  : gid :用户描述：主目录：登陆shell<br>需要将用户描述和主目录都改成新的，不然无法读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/passwd</div></pre></td></tr></table></figure></p><p><img src="https://github.com/mianhk/image-save/blob/master/Linux/001/004.jpg?raw=true" alt=""></p><h5 id="修改所属组"><a href="#修改所属组" class="headerlink" title="修改所属组"></a>修改所属组</h5><p>其实这里的修改，只需要将所有原来的ubuntu所属的组替换为mianhk即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/group</div></pre></td></tr></table></figure></p><p><img src="https://github.com/mianhk/image-save/blob/master/Linux/001/005.jpg?raw=true" alt=""></p><h5 id="删除ubuntu"><a href="#删除ubuntu" class="headerlink" title="删除ubuntu"></a>删除ubuntu</h5><p>再次进入/etc/sudoers 中，讲ubuntu删除</p><h5 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h5><p>　</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-36-Valid-Sudoku</title>
      <link href="/14-%E5%88%B7%E9%A2%98/LeetCode-36-Valid-Sudoku/"/>
      <url>/14-%E5%88%B7%E9%A2%98/LeetCode-36-Valid-Sudoku/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-36-Valid-Sudoku"><a href="#LeetCode-36-Valid-Sudoku" class="headerlink" title="LeetCode-36-Valid-Sudoku"></a>LeetCode-36-Valid-Sudoku</h3><blockquote><p>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.<br>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.<br><img src="https://github.com/mianhk/image-save/blob/master/exams/001/001.jpg?raw=true" alt=""></p></blockquote><p>判断一个二维数组是不是数独数组。要求是：同行同列，斜对角不能有相同的数组，这里需要定义三个数组，当然参考了一下讨论区一个大神的代码。采用行列，竖列和斜列。其中比较惊艳的是k=i/3*3+j/3;这里可以直接得到斜对角的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</div><div class="line">        int used1[9][9]=&#123;0&#125;,used2[9][9]=&#123;0&#125;,used3[9][9]=&#123;0&#125;;</div><div class="line">        for(int i=0;i&lt;board.size();++i)&#123;</div><div class="line">            for(int j=0;j&lt;board[i].size();++j)&#123;</div><div class="line">                if(board[i][j]!=&apos;.&apos;)&#123;</div><div class="line">                    int num=board[i][j]-&apos;0&apos;-1,k=i/3*3+j/3;</div><div class="line">                    if(used1[i][num]||used2[j][num]||used3[k][num])</div><div class="line">                        return false;</div><div class="line">                    used1[i][num]=used2[j][num]=used3[k][num]=1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h4><p><a href="http://blog.csdn.net/u012050154/article/details/51541380" target="_blank" rel="external">http://blog.csdn.net/u012050154/article/details/51541380</a></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-34-Search-for-a-Range</title>
      <link href="/14-%E5%88%B7%E9%A2%98/LeetCode-34-Search-for-a-Range/"/>
      <url>/14-%E5%88%B7%E9%A2%98/LeetCode-34-Search-for-a-Range/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-34-Search-for-a-Range"><a href="#LeetCode-34-Search-for-a-Range" class="headerlink" title="LeetCode-34-Search-for-a-Range"></a>LeetCode-34-Search-for-a-Range</h3><blockquote><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.<br>Your algorithm’s runtime complexity must be in the order of O(log n).<br>  If the target is not found in the array, return [-1, -1].</p></blockquote><p>在一个排序的数组中找到出现这个值的起点和重点。很容易想到的是二分查找了。复杂度为<code>nlog(n)</code>。思路如下，先二分查找，找到下界，如果下界lo的值不等于target时，直接返回{-1，-1}，否则，直接将下界添加到res中。之后重置上界，同样的方法搜索上界。注意到，<strong>由于每次循环中，我们只考虑了一个界，所以只有一个界能mid+1，否则就会出现相等的也被else处理了。写的时候就是这个问题没有考虑好，折腾了很久。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        vector&lt;int&gt; res=&#123;-1,-1&#125;;</div><div class="line">        if(nums.size()&lt;=0)</div><div class="line">            return res;</div><div class="line">        int lo=0,hi=nums.size()-1;</div><div class="line">        while(lo&lt;hi)&#123;  //找下界</div><div class="line">            int mid=(lo+hi)/2;</div><div class="line">            if(nums[mid]&lt;target)</div><div class="line">                lo=mid+1;</div><div class="line">            else</div><div class="line">                hi=mid;</div><div class="line">        &#125;</div><div class="line">        if((nums[lo]!=target))&#123;</div><div class="line">            return res;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            res[0]=lo;</div><div class="line">        hi=nums.size()-1;</div><div class="line">        while(lo&lt;hi)&#123;  //找上界</div><div class="line">            int mid=(lo+hi)/2+1;</div><div class="line">            if(nums[mid]&gt;target)</div><div class="line">                hi=mid-1;</div><div class="line">            else</div><div class="line">                lo=mid;</div><div class="line">        &#125;</div><div class="line">        res[1]=hi;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>当然还看到有用stl的方法的，直接用lower_bound()和upper_bound()函数，速度要快一些。虽然觉得stl应该也是一样的原理写的吧。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        if (nums.empty()) return&#123; -1, -1 &#125;;</div><div class="line"></div><div class="line">    auto iter1 = lower_bound(nums.begin(), nums.end(), target);</div><div class="line">    auto iter2 = upper_bound(nums.begin(), nums.end(), target);</div><div class="line"></div><div class="line">    if (iter1 == nums.end()) return&#123; -1, -1 &#125;;</div><div class="line"></div><div class="line">    if ((*iter1) != target) return&#123; -1, -1 &#125;;</div><div class="line">    vector&lt;int&gt; tmp(2, 0);</div><div class="line">    tmp[0] = iter1 - nums.begin();</div><div class="line"></div><div class="line">    --iter2;</div><div class="line">    tmp[1] = iter2 - nums.begin();</div><div class="line">    return tmp;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-32-Longest-Valid-Parentheses</title>
      <link href="/12-%E5%88%B7%E9%A2%98/LeetCode-32-Longest-Valid-Parentheses/"/>
      <url>/12-%E5%88%B7%E9%A2%98/LeetCode-32-Longest-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-32-Longest-Valid-Parentheses"><a href="#LeetCode-32-Longest-Valid-Parentheses" class="headerlink" title="LeetCode-32-Longest-Valid-Parentheses"></a>LeetCode-32-Longest-Valid-Parentheses</h3><blockquote><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.<br>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.<br>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p></blockquote><p>表示这是一道没有看懂题目的题，看到题目的难度是hard，但是自己的想法很简答，以为直接一个栈就可以了。。 too young啊</p><p>提交之后才知道，原来还要解决类似<code>()((()))</code>这类问题，所以这是一个动态规划的问题啊。<br>昨天看了一下动态规划，我们首先要构建D数组，如下所示的<code>vector longest</code>，负责存下当前第i个的长度。需要考虑的情况如下。<br>只有当s[i]为<code>)</code>时，才需要判断，如果它的左边是<code>(</code>或者<code>)</code>的情况。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int longestValidParentheses(string s) &#123;</div><div class="line">        if(s.length()&lt;=1)</div><div class="line">            return 0;</div><div class="line">        vector&lt;int &gt; longest(s.size(),0);</div><div class="line">        int curMax=0;</div><div class="line">        for(int i=1;i&lt;s.length();++i)&#123;</div><div class="line">            if(s[i]==&apos;)&apos;)&#123;</div><div class="line">                if(s[i-1]==&apos;(&apos;)&#123;</div><div class="line">                    longest[i]=(i-2&gt;=0?(longest[i-2]+2):2);</div><div class="line">                    curMax=curMax&gt;longest[i]?curMax:longest[i];</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    if(i-longest[i-1]-1&gt;=0&amp;&amp;s[i-longest[i-1]-1]==&apos;(&apos;)&#123;</div><div class="line">                        longest[i]=longest[i-1]+2+((i-longest[i-1]-2&gt;=0)?longest[i-longest[i-1]-2]:0);</div><div class="line">                        curMax=curMax&gt;longest[i]?curMax:longest[i];</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return curMax;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-31-Next-Permutation</title>
      <link href="/12-%E5%88%B7%E9%A2%98/LeetCode-31-Next-Permutation/"/>
      <url>/12-%E5%88%B7%E9%A2%98/LeetCode-31-Next-Permutation/</url>
      <content type="html"><![CDATA[<h3 id="LeetCode-31-Next-Permutation"><a href="#LeetCode-31-Next-Permutation" class="headerlink" title="LeetCode-31-Next-Permutation"></a>LeetCode-31-Next-Permutation</h3><blockquote><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.<br>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).<br>The replacement must be in-place, do not allocate extra memory.</p></blockquote><p>这个排序主要是有两种情况，一个是类似于<code>3 1 2</code>这样的情况，直接从后往前找到第一个<code>nums[i]&lt;nums[i-1]</code>的，然后把<code>i</code>记下来，再与后面第一个小于<code>i</code>的<code>k</code>调换顺序之后，对<code>i</code>后面的进行反转排序就好了。<br>另一种情况是：已经反转成功了，类似<code>3 2 1</code>，需要直接置为最开始的状态，处理方式是，依旧从后往前找<code>i</code>,如果没有找到的话，就可以直接将序列反转即可。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int k=-1;</div><div class="line">        for(int i=nums.size()-2;i&gt;=0;--i)&#123;</div><div class="line">            if(nums[i]&lt;nums[i+1])&#123;</div><div class="line">                k=i;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(k==-1)&#123;</div><div class="line">            reverse(nums.begin(),nums.end());</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        int l=0;</div><div class="line">        for(int i=nums.size()-1;i&gt;k;--i)&#123;</div><div class="line">            if(nums[i]&gt;nums[k])&#123;</div><div class="line">                l=i;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        swap(nums[l],nums[k]);</div><div class="line">        reverse(nums.begin()+k+1,nums.end());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-19-Remove-Nth-Node-From-End-of-List</title>
      <link href="/12-%E5%88%B7%E9%A2%98/LeetCode-19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/12-%E5%88%B7%E9%A2%98/LeetCode-19-Remove-Nth-Node-From-End-of-List/</url>
      <content type="html"><![CDATA[<blockquote><p>Given a linked list, remove the nth node from the end of list and return its head.<br>For example,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</div><div class="line"></div><div class="line">   After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</div></pre></td></tr></table></figure></p></blockquote><p>这个题目之前在剑指offer上就有，记得当时的方法是：采用两个指针，首先判断n的大小是否比链表的长度要大，大的话直接返回。否则采用一前一后两个指针，两个指针相差n，当前面的指针到链表末尾时，后面的指针所在的位置就是要删除的位置了。</p><p>当然，这是个很好的方法，不过看了一下后面的答案，以及前天看到的一个有点不是很明白的一个答案，才知道大家都用的是二级指针，二级指针的好处是，可以直接记住链表的头节点，而不至于总是去判断。这样显得对指针的理解就不一样了。可以看看下面的这篇文章。</p><p><a href="http://blogread.cn/it/article/6243?f=wb" target="_blank" rel="external">Linus：利用二级指针删除单向链表</a></p><p>下面是代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</div><div class="line">        ListNode **t1=&amp;head,*t2=head; //这样head一直指向的是头节点</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            t2=t2-&gt;next;</div><div class="line">        &#125;</div><div class="line">        while(t2!=nullptr)&#123;</div><div class="line">            t1=&amp;((*t1)-&gt;next);</div><div class="line">            t2=t2-&gt;next;</div><div class="line">        &#125;</div><div class="line">        *t1=(*t1)-&gt;next; //删除找到的节点</div><div class="line">        return head;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>无奈每次提交总是有群禽兽比我的快那么多啊，我的12ms，别人的6ms。。</p><p>不过别人的代码一看好像也还好，思路都是差不多的，就是一些细节的地方注意的比较好，看来还得好好弄啊。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</div><div class="line">        int counter = 0;</div><div class="line">        if(!head || !n) &#123;</div><div class="line">            return head;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        ListNode *p = head;</div><div class="line">        ListNode **pp = &amp;head;</div><div class="line">        while(p &amp;&amp; n) &#123;</div><div class="line">            p = p-&gt;next;</div><div class="line">            n--;</div><div class="line">        &#125;</div><div class="line">        while(p) &#123;</div><div class="line">            p = p-&gt;next;</div><div class="line">            pp = &amp;((*pp)-&gt;next);</div><div class="line">        &#125;</div><div class="line">        ListNode *temp = *pp;</div><div class="line">        *pp = temp-&gt;next;</div><div class="line">        delete(temp);</div><div class="line">        return head;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-23-Merge-k-Sorted-Lists</title>
      <link href="/11-%E5%88%B7%E9%A2%98/LeetCode-23-Merge-k-Sorted-Lists/"/>
      <url>/11-%E5%88%B7%E9%A2%98/LeetCode-23-Merge-k-Sorted-Lists/</url>
      <content type="html"><![CDATA[<h3 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h3><blockquote><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p></blockquote><p>这个题乍一看只是对链表的一个排序，因为是很多个链表，所以很简单的想法就是将整个数组里面的两个链表分别进行排序。两个两个互相排序之后就能排好。这里用的是递归。当vector中的元素大于1说明还没有排完。<br>直接一下就AC了，但是一看detail，果然时间有点长。运行时间内93ms，看到别人的只需要20+。。<br>还是先记一下自己的代码 吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* merge2List(ListNode* lList,ListNode* rList)&#123;</div><div class="line">        if(lList==nullptr)</div><div class="line">            return rList;</div><div class="line">        if(rList==nullptr)</div><div class="line">            return lList;</div><div class="line">        if(lList-&gt;val&lt;rList-&gt;val)&#123;</div><div class="line">            lList-&gt;next=merge2List(lList-&gt;next,rList);</div><div class="line">            return lList;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            rList-&gt;next=merge2List(lList,rList-&gt;next);</div><div class="line">            return rList;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</div><div class="line">        if(lists.size()==0)</div><div class="line">            return nullptr;</div><div class="line">        while(lists.size()&gt;1)&#123;</div><div class="line">            lists.push_back(merge2List(lists[0],lists[1]));</div><div class="line">            lists.erase(lists.begin());</div><div class="line">            lists.erase(lists.begin());</div><div class="line">        &#125;</div><div class="line">        return lists[0];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p> 看了一下别人的代码，用了优先队列，进行排序，没有重新写了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    class Cmp</div><div class="line">    &#123;</div><div class="line">    public:</div><div class="line">        bool operator() (ListNode *a, ListNode *b) const</div><div class="line">        &#123;</div><div class="line">            return a-&gt;val &gt; b-&gt;val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">public:</div><div class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</div><div class="line">        priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, Cmp&gt; pq;</div><div class="line">        ListNode *head = NULL;</div><div class="line">        ListNode *cur = NULL;</div><div class="line">        int k = lists.size();</div><div class="line">        if(k == 0)</div><div class="line">        &#123;</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        for(ListNode *list: lists)</div><div class="line">        &#123;</div><div class="line">            if(list != NULL)</div><div class="line">            &#123;</div><div class="line">                pq.push(list);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        while( !pq.empty() )</div><div class="line">        &#123;</div><div class="line">            ListNode *next = pq.top();</div><div class="line">            pq.pop();</div><div class="line">            if(next-&gt;next != NULL)</div><div class="line">            &#123;</div><div class="line">                pq.push(next-&gt;next);</div><div class="line">            &#125;</div><div class="line">            next-&gt;next = NULL;</div><div class="line">            if(head == NULL)</div><div class="line">            &#123;</div><div class="line">                head = next;</div><div class="line">                cur = head;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                cur-&gt;next = next;</div><div class="line">                cur = cur-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return head;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-15-3Sum&amp;&amp;4Sum</title>
      <link href="/10-%E5%88%B7%E9%A2%98/LeetCode-15-3Sum/"/>
      <url>/10-%E5%88%B7%E9%A2%98/LeetCode-15-3Sum/</url>
      <content type="html"><![CDATA[<h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h3><blockquote><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Note: The solution set must not contain duplicate triplets.</div><div class="line">For example, given array S = [-1, 0, 1, 2, -1, -4],</div><div class="line"></div><div class="line">A solution set is:</div><div class="line">[</div><div class="line">  [-1, 0, 1],</div><div class="line">  [-1, -1, 2]</div><div class="line">]</div></pre></td></tr></table></figure><p>同之前的2sum差不多，计算两个的和的方式是：为了避免重复，重新用一个set容器，解决重复的问题。但是这里的情况是，重复的一个数字是可以出现的，而且是三个数字相加的和，所以我们没法用之前的处理办法。</p><p>很容易想到的办法是，先让一个指针向前走，然后对之后的数字搜索，为了减少搜索的复杂度，我们可以先将数组进行排序，先排序后搜索，可以从O(n^2)的复杂度减小到nlog(n)，所以采用先排序。</p><p>然而这里需要注意的是，需要判断数组中有相同数字的情况。虽然结果中允许有相同的数字出现，但不允许出现完全相同的两个结果，所以需要处理这种情况。<br>具体的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">        if(nums.size()&lt;=0)</div><div class="line">            return res;</div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        for(int i=0;i&lt;nums.size()&amp;&amp;nums[i]&lt;=0;++i)&#123;</div><div class="line">            int j=i+1,k=nums.size()-1;</div><div class="line">            while(j&lt;k)&#123;</div><div class="line">                    if(nums[i]+nums[j]+nums[k]&lt;0)</div><div class="line">                        j++;</div><div class="line">                    else if(nums[i]+nums[j]+nums[k]&gt;0)</div><div class="line">                        --k;</div><div class="line">                    else if(nums[i]+nums[j]+nums[k]==0)&#123;</div><div class="line">                        vector&lt;int&gt; temp(3,0);</div><div class="line">                        temp[0]=nums[i];</div><div class="line">                        temp[1]=nums[j];</div><div class="line">                        temp[2]=nums[k];</div><div class="line">                        res.push_back(temp);</div><div class="line">                        while(k&gt;j&amp;&amp;nums[k]==temp[2]) //去除k的重复</div><div class="line">                            k--;</div><div class="line">                        while(k&gt;j&amp;&amp;nums[j]==temp[1]) //去除j的重复</div><div class="line">                            j++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                while(i+1&lt;nums.size()&amp;&amp;nums[i+1]==nums[i])  //去除i的重复</div><div class="line">                    i++;</div><div class="line">            &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h3><blockquote><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p></blockquote><p><strong>Note </strong>: The solution set must not contain duplicate quadruplets.</p><p>其实跟前面的3sum解决的办法是一样的，无非这里为了减少一点复杂度，借用了一下大家使用的方法。，在每次遍历的时候进行一点判断，以减少循环的次数。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">        int n=nums.size();</div><div class="line">        if(n&lt;4)</div><div class="line">            return res;</div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        for(int i=0;i&lt;n-3;++i)&#123;</div><div class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue;</div><div class="line">            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break;</div><div class="line">            if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3]&lt;target) continue;</div><div class="line">            for(int j=i+1;j&lt;nums.size()-2;++j)&#123;</div><div class="line">                if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue;</div><div class="line">                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break;</div><div class="line">                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue;</div><div class="line">                int begin=j+1,end=n-1;</div><div class="line">                while(begin&lt;end)&#123;</div><div class="line">                    int sum=nums[i]+nums[j]+nums[begin]+nums[end];</div><div class="line">                    if(sum&gt;target)</div><div class="line">                        --end;</div><div class="line">                    else if(sum&lt;target)</div><div class="line">                        ++begin;</div><div class="line">                    if(sum==target)&#123;</div><div class="line">                        vector&lt;int&gt; temp(4,0);</div><div class="line">                        temp[0]=nums[i];</div><div class="line">                        temp[1]=nums[j];</div><div class="line">                        temp[2]=nums[begin];</div><div class="line">                        temp[3]=nums[end];</div><div class="line">                        res.push_back(temp);</div><div class="line">                        while(begin&lt;end&amp;&amp;temp[2]==nums[begin])</div><div class="line">                            ++begin;</div><div class="line">                        while(begin&lt;end&amp;&amp;temp[3]==nums[end])</div><div class="line">                            --end;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-8-String to Integer (atoi)</title>
      <link href="/09-%E5%88%B7%E9%A2%98/LeetCode-8-String-to-Integer-atoi/"/>
      <url>/09-%E5%88%B7%E9%A2%98/LeetCode-8-String-to-Integer-atoi/</url>
      <content type="html"><![CDATA[<h3 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8.String to Integer (atoi)"></a>8.String to Integer (atoi)</h3><blockquote><p>Implement atoi to convert a string to an integer.</p></blockquote><p>讲字符串转化为整型。当然过程很简单，但是需要考虑的乱七八糟的情况很多，空格和正负号之类的。提交了一百次，终于过了，但是看到别人的代码还是很气呀，还是得多写才行，但是起码写的慢慢有感觉了是吧。<br>总体思路基本都是差不多的：<br>1.循环字符串，从第一个开始不为空的字符开始判断，如果是正负号，则只能有一个正负号，进行标记，数字开始。<br>2.数字开始之后，出现空格或者字母，返回已经生成的整型。<br>3.当数字大于最大的整数或者小于最小的整数的时候，应该将其置为最大或者最小。所以这里应该将结果定义为long long int ，不然当加到INT_MAX的时候，会自动+1，置为INT_MIN，应该避免这样的情况。<br>这里贴一下自己改的乱七八糟的代码吧，实在很气呀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int myAtoi(string str) &#123;</div><div class="line">        int flag=1;</div><div class="line">        long long int res=0;</div><div class="line">        int begin=-1;</div><div class="line">        for(int i=0;i&lt;str.size();++i)&#123;</div><div class="line">            if(str[i]==&apos;-&apos;||str[i]==&apos;+&apos;)&#123;</div><div class="line">                if(begin!=-1)</div><div class="line">                    return 0;</div><div class="line">                begin=i;</div><div class="line">                flag=str[i]==&apos;-&apos;?-1:1;</div><div class="line">            &#125;</div><div class="line">            else if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)&#123;</div><div class="line">                begin=i;</div><div class="line">                res=res*10+str[i]-48;</div><div class="line">                if(res*flag&gt;INT_MAX)</div><div class="line">                    return INT_MAX;</div><div class="line">                if(res*flag&lt;INT_MIN)</div><div class="line">                    return INT_MIN;</div><div class="line">            &#125;</div><div class="line">            else if(str[i]==&apos; &apos;)&#123;</div><div class="line">                if(begin!=-1)</div><div class="line">                    return res*flag;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                return res*flag;</div><div class="line">        &#125;</div><div class="line">        return res*flag;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>提交一看，这个时间还有点问题，就懒得自己再改了，思路都是一样的吧，就直接贴过来学习一下了，即使我觉得写的也一般呀。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int myAtoi(string str) &#123;</div><div class="line">        int i = 0;</div><div class="line">        long long res = 0;</div><div class="line">        if(str.size() == 0)</div><div class="line">            return res;</div><div class="line"></div><div class="line">        while(i &lt; str.size() &amp;&amp; str[i] == &apos; &apos;)</div><div class="line">            i++;</div><div class="line"></div><div class="line">        int flag = 1;</div><div class="line">        if(str[i] == &apos;+&apos;)</div><div class="line">            i++;</div><div class="line">        else if(str[i] == &apos;-&apos;)</div><div class="line">        &#123;</div><div class="line">            flag = -1;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        while(str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;)</div><div class="line">        &#123;</div><div class="line">            res = res * 10 + str[i] - &apos;0&apos;;</div><div class="line">            i++;</div><div class="line">        if(res * flag &gt;= INT_MAX)</div><div class="line">            return INT_MAX;</div><div class="line">        if(res * flag &lt;= INT_MIN)</div><div class="line">            return INT_MIN;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        return res * flag;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>精剪生活</title>
      <link href="/10-cut-life/"/>
      <url>/10-cut-life/</url>
      <content type="html"><![CDATA[<p>好像从小的时候开始，拥有各种感兴趣的事情或者不只是好好学习就像一种美德一样充斥于我们与同龄人的自己的生活中。就像小时候打的弹珠和后面看的小说乒乓球和dota一样。哦，对，应该说是合群，或者是接地气，就是所有与同龄人正常社交所需的娱乐活动吧。所以作为一个老师口中活泼开朗的学生，这些我基本都有，可能玩的不一定好，但是so what，只要不是像“那些只爱学习的同学”一样，好像都够了。</p><a id="more"></a><p>于是，也不知道什么时候就慢慢形成了广泛的娱乐活动了。直到现在，想起自己好像啥都能参与，就像篮球里能够从1打到5的那种全能型选手，不一定有机会上场，但总是差不多合格一样。<br>想一下现在自己的娱乐：</p><ul><li>打球？篮球、羽毛球、乒乓球，都可以打一些。虽然现在打篮球确实少了很多了，一个是宿舍就我一个人去，这样就很多时候懒得去了。羽毛球呢，总觉得要是四个人比较好，但是又对天气有些要求。还有乒乓球，需要有个水平不是很厉害还愿意跟我 打的了。。。</li><li>打麻将？这个简直是好约啊，四个人可以动脑或者不动脑的室内活动，主动或者三缺一的要求，都是相当的容易，这种活动还一般安排在吃饭的后边，就像你有时候也没法拒绝吃饱之后某个茶楼的茶一样，因为即使回去也还是睡觉是吧，而且自己总是告诉自己不要把生命浪费在床上。</li><li>各种吃饭？是的，忘了多少个睡到十点的周末，大家在一边互相催着起床一边讨论中午吃什么，于是由简单的黄焖鸡变成了鸡公煲，自助、火锅。。然后就是一个白天很快就过去了。</li><li>打游戏？简直是不可或缺的一部分啊。好像之前一年已经很少玩了。直到暑假开始玩的一个垃圾手游，轩辕传奇，几乎每天要花一个多小时的时间吧，想了一下，占据了我基本每天吃完午饭到睡觉之前和晚上回到宿舍到上床的一段时间。这段时间本来就不是很长，但是却被我用的看起来更紧张了。还有偶尔同学们约的王者荣耀，我基本自己都没有打过。还有最近的荒野行动，也是周末晚上或者正好十点多的上午才会有的娱乐。</li><li>看书？当然，我还是愿意把这个算进去。毕竟看的一些闲书，不能说没用，但确实是一种娱乐了吧。占据了上床到睡觉之前的不玩手机的时间，这个时间可能更短了。</li><li>然后，实验室玩手机？这个就不多说了，想想每天的手机电量吧。</li><li>乱七八糟的折腾？额，年轻的特征吗。。没意思的东西还是少弄点了吧</li></ul><p>这样看的话其实生活好像也很正常的，但是却是感觉每天，或者周末都很忙，忙了还不知道自己干了啥。有些难受。而且这好像也是自己写的第二篇这种苦恼了，上一次也是觉得这样的周末，但是两周过去了，好像还没有好多少，可能周末确实适合这么过，但是显然不是现在。<br>接下来需要做的，就是精简生活了，不是什么活动都需要参加的是吧，也不是什么都需要自己关注的是吧，也不用总是活在一个中心。<strong> 先专注做好自己现在该做的事情，或者先想想？</strong></p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂想 </tag>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网-剑指offer-11</title>
      <link href="/03-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-11/"/>
      <url>/03-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-11/</url>
      <content type="html"><![CDATA[<h4 id="T31：把数组排成最小的数"><a href="#T31：把数组排成最小的数" class="headerlink" title="T31：把数组排成最小的数"></a>T31：把数组排成最小的数</h4><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p></blockquote><p>这里想到的是，要对数组里面的所有数进行一个排序：不只是排长度，还要排最高位的大小。于是可以通过c++的STL的排序，通过自己定义的一个谓语比较函数。在这个比较函数里，把整数转成string进行比较，但是想到string的长度不一样的话也没法比较字符的大小了。所以分别将两个数加在一起，前后顺序不同，这样string的长度就一样了，比较的就是顺序了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</div><div class="line">        string result;</div><div class="line">        sort(numbers.begin(),numbers.end(),cmp);</div><div class="line">        for(int i=0;i!=numbers.size();++i)&#123;</div><div class="line">            result+=to_string(numbers[i]);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static bool cmp(int a,int b)&#123;</div><div class="line">        string A=to_string(a)+to_string(b);</div><div class="line">        string B=to_string(b)+to_string(a);</div><div class="line">        return A&lt;B;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T32：丑数"><a href="#T32：丑数" class="headerlink" title="T32：丑数"></a>T32：丑数</h4><blockquote><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p></blockquote><p>要求出第N个丑数，显然就要求到这N个，所以就要把所有的找出来嘛。简单的办法，就是2,3，5的倍数，但是这些倍数出来的丑数的顺序，这时候需要排序。显然不能直接对所有的都排序，那复杂度就太大了。这里一种考虑就是：比如，对于一次倍数的计算，如果2的倍数比原来的都大，那么3和5的倍数显然只会更大了。所以可以通过记录下此时分别为2,3,5倍数三个值，这样就可以减少比较的次数了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int GetUglyNumber_Solution(int index) &#123;</div><div class="line">        if(index==0)</div><div class="line">            return 0;  //解决边界条件</div><div class="line">        vector&lt;int&gt; result(index);</div><div class="line">        result[0]=1;</div><div class="line">        int x=0,y=0,z=0,i;</div><div class="line">        for(i=1;i&lt;index;i++)&#123;</div><div class="line">            result[i]=min(result[x]*2,min(result[y]*3,result[z]*5));</div><div class="line">            if(result[i]==result[x]*2)</div><div class="line">                x++;</div><div class="line">            if(result[i]==result[y]*3)</div><div class="line">                y++;</div><div class="line">            if(result[i]==result[z]*5)</div><div class="line">                z++;</div><div class="line">        &#125;</div><div class="line">        return result[index-1];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T33：第一个只出现一次的字符"><a href="#T33：第一个只出现一次的字符" class="headerlink" title="T33：第一个只出现一次的字符"></a>T33：第一个只出现一次的字符</h4><blockquote><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p></blockquote><p>很容易想到的一种复杂度为O(n)的算法是采用哈希表，遍历一次，将出现的字符放在键中，出现一次即在值中加1。第二次遍历，直接查找该键对应的值，第一个为1的输出即可。当然，这里由于是字符，所以可以直接采用数组的形式。<strong> 一定要记得对数组进行初始化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int FirstNotRepeatingChar(string str) &#123;</div><div class="line">        if(str.size()==0)</div><div class="line">            return -1;        //处理边界条件</div><div class="line">        int res[256]=&#123;0&#125;;  //局部变量，一定要初始化啊</div><div class="line">        int i=0;</div><div class="line">        for(;i!=str.size();++i)&#123;</div><div class="line">            res[(int)str[i]]++;</div><div class="line">        &#125;</div><div class="line">        for(i=0;i!=str.size();++i)&#123;</div><div class="line">            if(res[(int)str[i]]==1)</div><div class="line">                return i;</div><div class="line">        &#125;</div><div class="line">        return str.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网-剑指offer-10</title>
      <link href="/01-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-10/"/>
      <url>/01-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-10/</url>
      <content type="html"><![CDATA[<h4 id="T28：最小的K个数"><a href="#T28：最小的K个数" class="headerlink" title="T28：最小的K个数"></a>T28：最小的K个数</h4><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p></blockquote><ul><li>解法一：剑指offer上给的有两种办法，一种是对数组进行排序，类似于快速排序的方式，假设基于第k个数来调整，就可以将比k小的数全放在左边，比k大的数都放在右边，于是，最后k左边的数即为最小的k个数。<br>优点：平均时间复杂度：O(n)，思路较快<br>缺点：需要修改数组</li><li>解法二：算法复杂度O(nlogk)，适合海量的数据。需要我们一个能存储k个数的容器，当容器中的数不足k个的时候，直接装进容器，当超过的时候，需要拿容器中最大的数与新的数进行比较，新数小的时候，替换已有的最大。如此，每一个新的数都需要判断，这样会增加复杂度，但是在海量数据处理的时候比较适合，因为无法一次把所有的数据都载入内存。<br>下面是解法二的代码：（没有采用multiset，直接用的vector排序的，原理一样，但是我的stl确实没有用好，下次再改吧）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</div><div class="line">        //没有考虑复杂度的情况，都是直接写的</div><div class="line">        vector&lt;int&gt; result;</div><div class="line">        //判断输入为空，或者k大于input的个数的情况</div><div class="line">        if(input.size()&lt;=0||k==0||k&gt;input.size())</div><div class="line">            return result;</div><div class="line">        vector&lt;int&gt;::iterator iter=input.begin();</div><div class="line">        for(;iter!=input.end();++iter)&#123;</div><div class="line">            sort(result.begin(),result.end());</div><div class="line">            if(result.size()&lt;k)</div><div class="line">                result.push_back(*iter);</div><div class="line">            else if(*iter&lt;*(result.end()-1))&#123;</div><div class="line">                result.pop_back();</div><div class="line">                result.push_back(*iter);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li></ul><h4 id="T29：连续子数组的最大和"><a href="#T29：连续子数组的最大和" class="headerlink" title="T29：连续子数组的最大和"></a>T29：连续子数组的最大和</h4><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><p>主要是想为什么会有最大的和，一个情况是，新加上的数比原来的数都要大，就要开始考虑需不需要原来的数了。所以我们需要两个数，一个保存最大的和，用来返回，一个 保存当前的和，可以在适当的时候丢掉。  另一种情况，加入的数都比原来的小，即都是负数的时候，可能最大和只是一个最小的数；另外，当都是正数的时候也比较好解决。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</div><div class="line">        if(array.size()==0)</div><div class="line">            return 0;</div><div class="line">        int curSum=array[0];//注意这里不能用0，因为会出现数组值全小于0的情况</div><div class="line">        int maxSum=array[0];</div><div class="line">        for(int i=1;i!=array.size();++i)&#123;</div><div class="line">            curSum+=array[i];</div><div class="line">            if(curSum&lt;array[i])</div><div class="line">                curSum=array[i];</div><div class="line">            if(maxSum&lt;curSum)</div><div class="line">                maxSum=curSum;</div><div class="line">        &#125;</div><div class="line">        return maxSum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T30-整数中1出现的个数-从1到n整数中1出现的个数"><a href="#T30-整数中1出现的个数-从1到n整数中1出现的个数" class="headerlink" title="T30:整数中1出现的个数(从1到n整数中1出现的个数)"></a>T30:整数中1出现的个数(从1到n整数中1出现的个数)</h4><blockquote><p>题目描述：求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数</p></blockquote><p>显然，最简单的思路，从1遍历到n是吧，因为要找到每个数中1的个数。先不说这个，问题的重点是，这个1的个数怎么找。<br>于是想到的是关于1存在的规律。比如很简单的就个位数而言，从0–9，只会出现一个1。由此想到，我们可以把n分成很多段进行计算。具体怎么分段，《剑指offer》上有个方法，不过确实有点难看明白了，就没有看，自己觉得可以按照从按10的倍数来分，1,10,100之类的，不过又有点问题，每个段内1的个数不一样，因为这样的话1的个数就不好算了。不过牛客网厉害的还是多啊，思路清晰，代码简洁。自己真的需要学习的有点多。不过后来又回头看了一下《剑指offer》上其实也是这样的。<br>那就直接复述一遍具体的思路吧：根据设定的整数位置，对n进行分割。这里就直接选10了，高位是a=n/10，低位是b=n%10，循环条件直接就是n*10了，这样就可以从最后一位到最高位的遍历了。<br>这里需要考虑的就是，a的最后一位，就是高位对应的最低位。</p><ul><li>当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1。</li><li>当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1。</li><li>当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）。<br>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int NumberOf1Between1AndN_Solution(int n)</div><div class="line">    &#123;</div><div class="line">        int count=0;</div><div class="line">        //n=1的情况</div><div class="line">        if(n==1)</div><div class="line">            return 1;</div><div class="line">        //考虑的边界情况，n=10,100,1000之类的，同时循环中没有考虑n=0的情况</div><div class="line">        if(n&gt;1&amp;&amp;n%10==0)</div><div class="line">            count++;</div><div class="line">        //没有考虑n=1的情况</div><div class="line">        for(int i=1;i&lt;n;i*=10)&#123;</div><div class="line">            int a=n/i,b=n%i;</div><div class="line">            //补8的效果：当百位为0，则a/10==(a+8)/10，</div><div class="line">            //当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</div><div class="line">            count+=(a+8)/10*i+(a%10==1)*(b+1);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个可能很熟悉的周末</title>
      <link href="/26-random-life-1/"/>
      <url>/26-random-life-1/</url>
      <content type="html"><![CDATA[<h3 id="2017-11-26-记录一个可能很熟悉的周末"><a href="#2017-11-26-记录一个可能很熟悉的周末" class="headerlink" title="2017-11-26 记录一个可能很熟悉的周末"></a>2017-11-26 记录一个可能很熟悉的周末</h3><p>这周又过去了，时间依旧是这么快啊，待在实验室跟上一周的感觉差不多，还是周日的下午，晚上才想起来来一下实验室，还是本来想周末搞个学习，却还是没有一不小心就休息过去了，非常单纯的尊重了一下周末。</p><a id="more"></a><p>先记个心里活动加流水吧，很无聊，但是还是想写一下，看一下自己的周末重播是怎样的。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">本来周五晚上就没有睡很晚，所以生物钟还是个好东西，一到周末就提醒我不要起的太早，于是醒</div><div class="line">来还是十点多了，躺在床上玩了一会游戏觉得有点罪过，就起床搞搞学习，嗯，十点多，算是个相</div><div class="line">对还不错的时间了，如果不是上周立了flag说是周末要学习一天的话，即使以前的我好像可以不分</div><div class="line">周末一样。</div><div class="line"></div><div class="line"></div><div class="line">没错，起床了就学习啊，还是先看一下游戏吧，刚刚打开就看到有人说，游戏现在可以电脑端挂着</div><div class="line">了，一想，这样就不用耽误我时间看平板了，直接电脑上从代码切过来很快的样子，毕竟这么多年</div><div class="line">的单身。于是开始准备下。想一下，这个流量。。赶紧查一查，还有一个多G，，算一下还有几天，</div><div class="line">今天才25，好像有点不够呀，还是不下了吧。不过仔细一想，下一个电脑端，多省事啊，毕竟我不</div><div class="line">是一个轻易被困难打倒的人，于是看了一下手机，还有3G流量，好像也有点不够用了啊。又想起来</div><div class="line">上个月月末的两个活动送的2G流量，看看能不能，于是赶紧一顿操作，我靠，竟然还有啊。只能不</div><div class="line">好意思安心开始下游戏了。</div><div class="line"></div><div class="line">哇，搞学习的时间终于开始了啊，额，这个宿舍环境，好像更适合看视频一点，打开教学视频，习</div><div class="line">惯的1.5倍速，连上云服务器，先操作一顿，看看上周用的vim的操作忘了没有。然后切到视频，额</div><div class="line">，这讲的也太慢了吧，完全不把我的基础当回事啊，这也讲。。 算了，切一下看看游戏下的怎么样</div><div class="line">了，19%，才这么点啊。切回去，切过来，25%，再切过来，咦，怎么不动了，难道热点断了，看一</div><div class="line">下手机，额，没有啊，==看，额，怎么错误了，怎么说。切回去把视频停一下，百度看看怎么回事。</div><div class="line">额，这垃圾游戏，百度都搜不到，额，这是啥啊，就是一个模拟器嘛，还下不下来。唉，算了，重试</div><div class="line">一遍吧。</div><div class="line"></div><div class="line">接下来是有点忧心忡忡的看着视频，一边心疼着流量啊，一边看。忍不了，切回去看看，2%,5%。。。</div><div class="line">额，40%，又不动了，又出错了。垃圾游戏，删掉。重新网上找一个。看一下手机，我靠，1G流量已经</div><div class="line">没了啊。算了，我去找个别的模拟器吧，还得搞学习呢，耽误我时间，分分钟搜到一个，赶紧下。 额</div><div class="line">，这次好像很顺利的样子，（百次切换后的十分钟。。）额，这个怎么有点不对的样子啊，头上怎么一</div><div class="line">个安卓的机器人啊，难道是只有安卓的才能用吗？这波就傻逼了。还先装的引擎，再下的游戏，额，这</div><div class="line">游戏都下了一半了，现在我是停不停啊，不会坑我吧。算了，中国有句古话说的好，来都来了是吧。。</div><div class="line">等等下完吧。</div><div class="line"></div><div class="line">终于下完了，我手机也提示2G的流量也没了。赶紧隆重的停一下视屏，装上看一看，额，怎么一个不是</div><div class="line">很熟悉的模拟器一样，上面就装了一个游戏，有点虚呀，兄弟。还是试试吧，擦，果然不可以啊，这下</div><div class="line">傻逼了。怎么说，哎，难道我老了，连这点都解决不了了。关机重启重下吧。</div><div class="line"></div><div class="line">重启！可是我的校园网没流量了啊，管他呢，先下了再说吧，出去吃饭了。。。。。。回来，赶紧看一</div><div class="line">下，哇，竟然下完了，看来西电的校园网还是有一点靠谱的嘛，装上试试，等等，这好像有点卡啊，这</div><div class="line">个，半天进不去啊。怎么他们说的可以啊，赶紧微信私聊一个人问一下，靠，他也很卡，刚刚自己还说</div><div class="line">可以的，擦。</div><div class="line"></div><div class="line">嗯，游戏总是很坑，但生活还得继续啊，周末的好天气也不忍心待在室内，难得在这个时间没有雾霾，</div><div class="line">已经快一点了，约的羽毛球和洗澡吃饭一条龙还没确定呢。赶紧找人啊，随便问一个，怎么不去？这也</div><div class="line">不去，只剩下我和这个破峰了？两个人怎么玩到四点去洗澡啊。额，再想想，于是看到师兄约篮球，要</div><div class="line">不怂恿看看？可是破峰竟然抛弃我准备先去洗澡了，但是这么好的天气，作为有点欠太阳的我是必须要</div><div class="line">出去运动一下的，那就去打篮球吧。。</div><div class="line"></div><div class="line">。。。</div><div class="line"></div><div class="line">打完球四点多，打的有点累啊，回来休息一波，也没啥事干，要不休息一下带这个破峰玩一局吧，结果</div><div class="line">洗澡就是五点多了，自己去洗个澡，买点吃的，回来还是用平板玩会游戏，吃个饭，给家里打个电话，</div><div class="line">已经七点多了，想起游戏有活动啊，上来看看，顺便看看视频，额，完全看不进去啊，还有点累啊。算</div><div class="line">了，随便看看视频之类的吧，反正不想学习。额，我的校园网没了，要不用免费网下个游戏吧，试试看</div><div class="line">怎么样，就荒野行动吧，反正最近这么火是吧，这个速度有点快啊，确定是我自己的网吗？看一下，是</div><div class="line">我的，放心不是书记的。下完了，再更新，额，怎么一兆多啊，不对啊，再看一下，果然是书记的，我</div><div class="line">靠，这就尴尬了 。。于是结果就是半个小时陪着这个破书记去搞了吃的额</div><div class="line"></div><div class="line">回来已经十点多了，游戏终于下好了，怂恿破峰下一个吧。我先去床上玩一把。于是玩到了12点了。该</div><div class="line">睡觉了，好困啊，睡吧。</div><div class="line"></div><div class="line">星期天到了，看来睡的早还是可以啊，八点多就醒了，简直是像上帝多要了两个多小时的生命啊，赶紧</div><div class="line">玩会游戏浪费一下，玩到九点，额，怎么有点困啊，算了，睡吧，昨天打球确实有点累啊，年纪大了，</div><div class="line">不能拉杆了啊。休息休息。。。已经11点了啊，赶紧起来看看，随便一收拾，又要吃饭了，唉，赶紧收</div><div class="line">拾一下衣服扔下去，然后吃个饭，去个超市回来正好收衣服，我真会过日子啊，哈哈。</div><div class="line"></div><div class="line">回来又是一点，挂好衣服，干啥了，听听歌，洗洗东西。额，快两点了啊，赶紧休息一下，三点了，想</div><div class="line">起来周末好像完全没学习啊，关键是还是入党的东西很多没填啊，还是去一下实验室吧。。</div></pre></td></tr></table></figure></p><p>终于差不多记完了，真的有点无聊，但是确实好像又好像拜托不了的周末啊，除了周内每天按时上班让人周末不想好好起床以外，还有一些确实需要做的事情，比如锻炼和洗刷，时间好像也就那些。或者再稍微加点娱乐，再加点别的赖床，晚上再睡晚一点，时间就更短了啊。</p><p>显然，时间当然没法安排的这么满，但是确实也不是一点留给该做事的时间都没有的。为什么别人都有了，而我只是看似想着学习却实际上啥都没干呢？<br>分析一下周末的时间：</p><ul><li><strong> 晚上的晚睡</strong>：没有理由的晚睡当然是透支了第二天的白天的时间，晚睡的一两个小时，直接一个上午几乎没了，然后下午再随便一玩，就觉得一天啥都没干。</li><li><strong> 无聊的折腾</strong>：有的时候很多的爱好并不是一件很好的事情，看看比赛的情况，刷个新闻，刷个朋友圈，看看游戏，再玩会游戏，直接学习时间就没了，直接体现就是在进度上。还会觉得很烦躁</li><li><strong> 当然还是有点懒啊</strong>： 谁都有不想做啥的时候，但是生活就是这样，这就不多说了。</li></ul><p>直到晚上写个人自传的时候，才想起来很多没得啥写，生活就像游戏一样，你玩的多爽杀了多少人，能给你带来的快乐，除了当时的快乐，还有之后你回头看过来，自己有多少收获，有的时候不功利是一种美德，但有时候那只能证明你太年轻了，换句话说就是傻逼了，快乐的生活还是要建立在将来看起来也仍然是快乐的不是吗。</p><h3 id="希望以后换种方式的周末吧"><a href="#希望以后换种方式的周末吧" class="headerlink" title="希望以后换种方式的周末吧"></a>希望以后换种方式的周末吧</h3>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网-剑指offer-3</title>
      <link href="/17-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-3/"/>
      <url>/17-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-3/</url>
      <content type="html"><![CDATA[<h4 id="T7：斐波那契数列"><a href="#T7：斐波那契数列" class="headerlink" title="T7：斐波那契数列"></a>T7：斐波那契数列</h4><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39</p></blockquote><p>斐波那契数列是很常用的数列，也是很简单的递归能够解决的，但是当n稍微大一点的时候，复杂度都让人无法接受。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">long long Fi(int n)&#123;</div><div class="line">    if(n==0)</div><div class="line">        return 0;</div><div class="line">    if(n==1)</div><div class="line">        return 1;</div><div class="line">    return Fi(n-1)+Fi(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样出现的问题主要是在递归的过程中会出现很多重复的计算，比如我们每次计算第n个的时候，都需要重新计算前面的n-1和n-2，这样每个值其实都会被计算两遍。简单的处理是：从下往上开始算，从第0个一直算到第n个。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Fibonacci(int n) &#123;</div><div class="line">        if(n&lt;=0)</div><div class="line">            return 0;</div><div class="line">        if(n==1||n==2)</div><div class="line">            return 1;</div><div class="line">        int newNum=1;</div><div class="line">        int oneNum=1,twoNum=1;</div><div class="line">        for(int i=3;i&lt;=n;++i)&#123;</div><div class="line">            newNum=oneNum+twoNum;</div><div class="line">            oneNum=twoNum;</div><div class="line">            twoNum=newNum;</div><div class="line">        &#125;</div><div class="line">        return newNum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T8：跳台阶"><a href="#T8：跳台阶" class="headerlink" title="T8：跳台阶"></a>T8：跳台阶</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>该类问题其实就是斐波那契数列的应用：考虑第一次跳的情况，如果第一跳1级，那么后面就是n种情况，如果第一次跳2级，后面就是n-2种，于是：<code>f(n)=f(n-1)+f(n-2)</code>；同理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int jumpFloor(int number) &#123;</div><div class="line">        if(number&lt;=0)</div><div class="line">            return 0;</div><div class="line">        int result=0;</div><div class="line">        if(number==1)</div><div class="line">            return 1;</div><div class="line">        int first_step=1;</div><div class="line">        int second_step=1;</div><div class="line">        while(number&gt;=2)&#123;</div><div class="line">            --number;</div><div class="line">            result=first_step+second_step;</div><div class="line">            first_step=second_step;</div><div class="line">            second_step=result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T9：变态跳台阶"><a href="#T9：变态跳台阶" class="headerlink" title="T9：变态跳台阶"></a>T9：变态跳台阶</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>同样的分析：1.把第n级和第n-1级看成一级，则有：f(n-1)种；2.把第n级和第n-1级分开，则到n-1级有：f(n-1)，n-1级到第n级只有一种，所以加起来是：2*f(n-1)<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int jumpFloorII(int number) &#123;</div><div class="line">        if(number&lt;=0)</div><div class="line">            return 0;</div><div class="line">        int result=1;</div><div class="line">        if(number==1)</div><div class="line">            return 1;</div><div class="line">        for(int i=1;i&lt;=number-1;++i)&#123;</div><div class="line">            result*=2;</div><div class="line">            &#125;</div><div class="line">        return result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的专业书阅读</title>
      <link href="/12-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E4%B8%93%E4%B8%9A%E4%B9%A6/"/>
      <url>/12-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E4%B8%93%E4%B8%9A%E4%B9%A6/</url>
      <content type="html"><![CDATA[<a id="more"></a><ul><li>《Python核心编程》 ed2</li><li>《C++　Primer 》ed5</li><li>《STL 源码剖析》</li><li>《Effective C++》</li><li>《Unix 网络编程》卷一</li><li>《Unix 网络编程》卷二</li><li>《Unix 环境高级编程》</li><li>《Linux多线程服务端编程》陈硕</li><li>《TCP/IP详解》卷一</li></ul>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我看的电影</title>
      <link href="/12-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/"/>
      <url>/12-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/</url>
      <content type="html"><![CDATA[<a id="more"></a><h1 id="记录我看的电影"><a href="#记录我看的电影" class="headerlink" title="记录我看的电影"></a>记录我看的电影</h1><hr><h2 id="2018年–"><a href="#2018年–" class="headerlink" title="2018年–"></a>2018年–</h2><h3 id="目击者之追凶豆瓣8-1分"><a href="#目击者之追凶豆瓣8-1分" class="headerlink" title="目击者之追凶豆瓣8.1分"></a><a href="https://movie.douban.com/subject/11600078/" target="_blank" rel="external">目击者之追凶</a>豆瓣8.1分</h3><p>看的时候主要是看评分这么高，而且还是台湾的，觉得应该就是个剧情比较好看的电影，慢慢看着都不觉得有多好看，只不过到后面越来越觉得剧情不简单了。尺度很大，不到最后一刻不知道结果的那种，但是从每个人的角度来理解这个剧情，又觉得每个人的特点都塑造的让人感叹。</p><h3 id="三块广告牌-豆瓣8-7分"><a href="#三块广告牌-豆瓣8-7分" class="headerlink" title="三块广告牌 豆瓣8.7分"></a><a href="https://movie.douban.com/subject/26611804/" target="_blank" rel="external">三块广告牌</a> 豆瓣8.7分</h3><p>毕竟是拿了奥斯卡最佳女主的。。</p><h3 id="前任3：再见前任-豆瓣5-7分"><a href="#前任3：再见前任-豆瓣5-7分" class="headerlink" title="前任3：再见前任 豆瓣5.7分"></a><a href="https://movie.douban.com/subject/26662193/" target="_blank" rel="external">前任3：再见前任</a> 豆瓣5.7分</h3><p>闲着 没事就看看了==</p><h3 id="非常嫌疑犯-豆瓣8-6分"><a href="#非常嫌疑犯-豆瓣8-6分" class="headerlink" title="非常嫌疑犯 豆瓣8.6分"></a><a href="https://movie.douban.com/subject/1292214/" target="_blank" rel="external">非常嫌疑犯</a> 豆瓣8.6分</h3><p><img src="http://blog-1252063226.cosbj.myqcloud.com/movie/001/001.jpg?raw=true" alt=""><br>觉得自己一开始就猜中了大坏蛋，但是中间仍然起伏，差点以为自己猜错了，不过结果还是差不多。<br>对于这样的悬疑片，突然觉得有了一点经验了，那种你算的很好的逻辑，很大程度是别人给你写好的逻辑圈套让你钻进去。<br>所以对于逻辑，还是要像马克思说的啊，从正反两面考虑。不管是狼人杀这种游戏，还是生活中的决定。<br>说回这个电影吧，剧情就不说了，还有整个电影的叙事方式，刚刚开始觉得有点乱，还是对美帝主义的一些情况不太了解。不过后面就觉得清晰了。而且电影里出现了很多干扰的东西，比如像医院里出现的那些人，总觉得会有所错觉，还有警局里的一些，可能是年代有点久远还是自己要求有点高了？。。</p><h3 id="穆赫兰道"><a href="#穆赫兰道" class="headerlink" title="穆赫兰道"></a><a href="">穆赫兰道</a></h3><h3 id="银翼杀手2049"><a href="#银翼杀手2049" class="headerlink" title="银翼杀手2049"></a>银翼杀手2049</h3><p>可能我们无法想象30年后地球上会发生什么，会不会真的连一点真的木头都变得很珍贵？会不会真的有一群复制人帮我们做着一些我们不太愿意做的事情，但是我们仍然在歧视他们？不过有些东西是我们能想象的，就比如现在所说的科技发展的界限，就像很多所提的，那就是伦理，那就是以人为本。从一方面来说，所有的发明和创造都是为了让人的生活变的更好，而不是给人类带来麻烦，另一方面，如果我们人类的创作也跟人一样有思想，我们应不应该像人一样尊重他们。</p><h3 id="羞羞的铁拳"><a href="#羞羞的铁拳" class="headerlink" title="羞羞的铁拳"></a>羞羞的铁拳</h3><p>真的，感觉是个啥，为了搞笑就在搞笑。。</p><hr><h2 id="2017年–"><a href="#2017年–" class="headerlink" title="2017年–"></a>2017年–</h2><h3 id="嘉年华"><a href="#嘉年华" class="headerlink" title="嘉年华"></a>嘉年华</h3><p><img src="http://blog-1252063226.cosbj.myqcloud.com/Linux/0009999999.jpg?raw=true" alt=""><br>值得一看的电影。如鲠在喉</p><h3 id="机器之血"><a href="#机器之血" class="headerlink" title="机器之血"></a>机器之血</h3><p>估计可能是成龙演的吧，毕竟61岁了，还这么拼，总让人觉得有点厉害了。但是电影从剧情到演员到画面，真的没有一点合格的吧，浪费时间了啊。</p><h3 id="无证之罪（1957）"><a href="#无证之罪（1957）" class="headerlink" title="无证之罪（1957）"></a>无证之罪（1957）</h3><h3 id="缝纫机乐队（2017）"><a href="#缝纫机乐队（2017）" class="headerlink" title="缝纫机乐队（2017）"></a>缝纫机乐队（2017）</h3><p>毕竟睿思一周热门啊，还是忍不住下下来看了一下。记得之前大鹏各种微博之类的请大家去看看，不过评分依然很低。所以看的时候本来也没有那么期待。看完之后觉得也没有那么烂吧，想起之前看的大鹏的煎饼侠，也不知道除了搞笑之外还记起来什么了。不过这个好像好了很多，因为我想以后可能不会记得这个有多搞笑，但应该会记得讲了个什么故事。<br>虽然电影对于大鹏来说可能有着特别的意义或者怎样，但是我看的时候还是觉得一如很多的国产电影，剧情不够瞎搞笑凑，然后就为了搞笑又加了很多无聊的东西，让剧情更烂了。所以这个也是这样，但是在最后强催的泪点环节，还是能够感觉到大鹏想告诉大家的东西，或者说是他对生活，对他自己的生活的一个理解？但是不重要是吗？电影可以就像一个人，但应该是我们发自肺腑的感叹，而不是要你用电影之外的话来告诉我们。就好像你做了一道菜，一定要在我们吃的时候加上旁白告诉我们现在吃的是什么，那可能不一定难吃，但一定不优秀。</p><h3 id="寻梦环游记（2017）-date：2017-12-2"><a href="#寻梦环游记（2017）-date：2017-12-2" class="headerlink" title="寻梦环游记（2017） date：2017-12-2"></a>寻梦环游记（2017） date：2017-12-2</h3><p>额，要不是评分实在太高了，我也不会去看个说是动画片的电影吧，很少见出来一周的电影还9.5分的，但是确实值得高分。</p><p>不愧是迪士尼啊，效果非常棒不说了。整个剧情，跟一些非常优秀的电影一样，塑造了一个存在于人们想象中有可能很合理的新世界，在那里，有很多匪夷所思却又言之合理的事情。然后在这个世界里出现了与现实有联系的矛盾。当然最后问题的解决，又给人现实很简单纯粹的思考。比如在这里，塑造了亡灵的世界，如果死了的人真的被人遗忘，就会真的死亡。你在现实里追逐梦想最终被人记住的，在亡灵的世界也可以活的风光，就像梦想可能不被理解，但是实现了一定很值得一样。最后的大反转又让人回归，家人是最重要的，即使你有梦想，也没必要去牺牲这些。简单的道理，但是如果像我这么说就很没意思了，所以，这就是我们为什么会喜欢优秀的电影了吧。</p><h3 id="天才枪手-2017"><a href="#天才枪手-2017" class="headerlink" title="天才枪手(2017)"></a>天才枪手(2017)</h3><p><a href="http://www.imdb.com/title/tt6788942/" target="_blank" rel="external">IMDI 8.2分</a> <strong> /</strong><a href="https://movie.douban.com/subject/27024903/" target="_blank" rel="external">豆瓣 8.3分</a><br>好吧，8分多纯粹就是看了个热闹啊。简直就像告诉你，优秀的人作弊都比人优秀啊，即使感觉满屏幕的bug也依然很没文化的wokaowokao了。。</p><h3 id="东方快车谋杀案-1974"><a href="#东方快车谋杀案-1974" class="headerlink" title="东方快车谋杀案(1974)"></a>东方快车谋杀案(1974)</h3><p><a href="http://www.imdb.com/title/tt0071877/" target="_blank" rel="external">IMDI 7.3分</a> <strong> /</strong><a href="https://movie.douban.com/subject/1292699/" target="_blank" rel="external">豆瓣 8.3分</a><br>能拿奥斯卡的一般特性，就像一般艺术到最后所反映的，除了一个完整的故事，精彩的剧情，还有整个电影对人物、风情、地域以及社会环境等的刻画，传达人性或这个世界我们需要的思考。这种深度，国产电影离别人几十年前的电影都相差甚远。想起冯小刚说的，中国电影拍不好，是因为中国的观众不行，我觉得观众始终是很少的一部分，因为更多的时候、其实观众不知道他们喜欢的究竟是什么，因为更好看的永远在后面，这就是电影行业的责任了。<br>再说这个电影吧，剧情的丰富就不必说了，从开头的各种铺垫，让我们在看到各种人物性格，国家的特点等，产生各种怀疑的时候，案件就开始了，于是现在看起来有点搞笑的主人公就开始了表演，整个审问和查找线索的过程让人敬佩，直到慢慢开始跟着他产生新的怀疑。。<br>在主人公宣布结果之前，我也似乎猜到了一点，他最后给了大家选择，这是大家都希望的，看到大家开始香槟庆祝的时候，我不禁在想，这样的结果，究竟是应该的吗？如果这样的谋杀也可以，法律又怎么会进步。<br>说到这里，又不禁想起来最近的江歌的事件，我只是在新闻上看到了，对此也表示很遗憾。不过在网上却各种签名投票之类的沸沸扬扬，诚然，在这种时候我们需要帮助受害者的家人，也想让罪人得到应有的报应，但这样可能真的不是最好的办法。就像规则可能有时候会有缺陷，但是如果每次都因为特殊事件让它临时违背，那跟没有也没区别。</p><h3 id="幸福终点站-2004"><a href="#幸福终点站-2004" class="headerlink" title="幸福终点站(2004)"></a>幸福终点站(2004)</h3><p><a href="http://www.imdb.com/title/tt0362227/" target="_blank" rel="external">IMDI 7.3分</a> <strong> /</strong><a href="https://movie.douban.com/subject/1292274/" target="_blank" rel="external">豆瓣 8.6分</a></p><h3 id="加勒比海盗5：死无对证"><a href="#加勒比海盗5：死无对证" class="headerlink" title="加勒比海盗5：死无对证"></a>加勒比海盗5：死无对证</h3><p><a href="http://www.imdb.com/title/tt1790809/" target="_blank" rel="external">IMDI 6.7分</a> <strong> /</strong><a href="https://movie.douban.com/subject/6311303/" target="_blank" rel="external">豆瓣 7.2分</a></p><h3 id="速度与激情8"><a href="#速度与激情8" class="headerlink" title="速度与激情8"></a>速度与激情8</h3><p><a href="http://www.imdb.com/title/tt0362227/" target="_blank" rel="external">IMDI 6.8分</a> <strong> /</strong><a href="https://movie.douban.com/subject/26260853/" target="_blank" rel="external">豆瓣 7.1分</a></p><h3 id="百万美元宝贝-Million-Dollor-baby"><a href="#百万美元宝贝-Million-Dollor-baby" class="headerlink" title="百万美元宝贝( Million Dollor baby)"></a>百万美元宝贝( Million Dollor baby)</h3><h3 id="陪安东尼度过漫长岁月"><a href="#陪安东尼度过漫长岁月" class="headerlink" title="陪安东尼度过漫长岁月"></a>陪安东尼度过漫长岁月</h3><h3 id="看不见的客人"><a href="#看不见的客人" class="headerlink" title="看不见的客人"></a>看不见的客人</h3><p><a href="http://www.imdb.com/title/tt4857264/" target="_blank" rel="external">IMDI 8.1分</a> <strong> /</strong><a href="https://movie.douban.com/subject/26580232/" target="_blank" rel="external">豆瓣 8.7分</a></p><h3 id="致命ID"><a href="#致命ID" class="headerlink" title="致命ID"></a>致命ID</h3><h3 id="雷神3"><a href="#雷神3" class="headerlink" title="雷神3"></a>雷神3</h3><h3 id="罗生门（日本）"><a href="#罗生门（日本）" class="headerlink" title="罗生门（日本）"></a>罗生门（日本）</h3><h3 id="心迷宫"><a href="#心迷宫" class="headerlink" title="心迷宫"></a>心迷宫</h3><h3 id="情遇曼哈顿"><a href="#情遇曼哈顿" class="headerlink" title="情遇曼哈顿"></a>情遇曼哈顿</h3><h3 id="复仇者联盟"><a href="#复仇者联盟" class="headerlink" title="复仇者联盟"></a>复仇者联盟</h3><h2 id="记录看的电视剧"><a href="#记录看的电视剧" class="headerlink" title="记录看的电视剧"></a>记录看的电视剧</h2><blockquote><p>电视剧看的不多，但是一看就要看完啊。等不了啊</p></blockquote><h3 id="琅琊榜之风起长林"><a href="#琅琊榜之风起长林" class="headerlink" title="琅琊榜之风起长林"></a>琅琊榜之风起长林</h3><p>自认为超过了1的水平。</p><ul><li>超级正的家国情怀和三观，虽然在这个人人都想买房买车的年代显得有点。。但是梦想总还是要有的是吧</li><li>将在其位谋其事，什么样的环境造就什么样的人演绎的很彻底。我第一次很理解所有的反派的行为。。<h3 id="猎场"><a href="#猎场" class="headerlink" title="猎场"></a>猎场</h3>就当是看胡歌了啊<h3 id="权力的游戏s7"><a href="#权力的游戏s7" class="headerlink" title="权力的游戏s7"></a>权力的游戏s7<a href=""></a></h3><h3 id="白夜追凶"><a href="#白夜追凶" class="headerlink" title="白夜追凶"></a>白夜追凶<a href=""></a></h3><h3 id="无证之罪"><a href="#无证之罪" class="headerlink" title="无证之罪"></a>无证之罪<a href=""></a></h3><h3 id="激战玄武门（纪录片）"><a href="#激战玄武门（纪录片）" class="headerlink" title="激战玄武门（纪录片）"></a>激战玄武门（纪录片）<a href=""></a></h3><h3 id="Justice（公开课）"><a href="#Justice（公开课）" class="headerlink" title="Justice（公开课）"></a>Justice（公开课）<a href=""></a></h3></li></ul>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> 娱乐 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux学习1-Linux的基本命令（1）</title>
      <link href="/12-Linux/linux-learn-1/"/>
      <url>/12-Linux/linux-learn-1/</url>
      <content type="html"><![CDATA[<blockquote><p>Linux的命令比较多，而且后台开发的时候基本操作服务器的时候都是采用命令行，当然不需要所有的都一次掌握，但是很多重要的用的多的还是需要掌握，不需要直接去记，还是需要多用才会熟练</p></blockquote><h5 id="shell相关"><a href="#shell相关" class="headerlink" title="shell相关"></a>shell相关</h5><h6 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h6><p><code>cat /etc/shells   //查看当前系统有那些shell</code><br><code>cat $SHELL</code></p><h6 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h6><p><code>cd ~    //切换路径到家目录</code></p><h6 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h6><p><code>history  //显示最近使用的命令</code><br><code>cd -  //在上下两个目录之间切换</code><br>``<br>主键盘快捷键：<br><img src="https://github.com/mianhk/image-save/blob/master/mingling1.jpg?raw=true" alt=""></p><h5 id="目录和文件"><a href="#目录和文件" class="headerlink" title="目录和文件"></a>目录和文件</h5><h6 id="类Unix系统目录结构"><a href="#类Unix系统目录结构" class="headerlink" title="类Unix系统目录结构"></a>类Unix系统目录结构</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/ 根目录</div><div class="line">    bin //系统可执行程序，如命令</div><div class="line">    boot //内核和启动程序，所有和启动相关的文件都保存在这里</div><div class="line">    grub //引导器相关文件</div><div class="line">    dev //设备文件</div><div class="line">    etc //系统软件的启动和配置文件，系统在启动过程中需要读取的文件都在这个目录。如LILO参数、用</div><div class="line">户账户和密码。</div><div class="line">    home //用户的主目录。下面是自己定义的用户名的文件夹</div><div class="line">    lib //系统程序库文件,这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32</div><div class="line">目录，几乎所有的应用程序都需要用到这些共享库。</div><div class="line">    media //挂载媒体设备，如光驱、U盘等</div><div class="line">    mnt //目录是让用户临时挂载别的文件系统，如挂载Windows下的某个分区，ubuntu默认还是挂载在/media</div><div class="line">目录。</div><div class="line">    opt //可选的应用软件包（很少使用）</div><div class="line">    proc //这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录</div><div class="line">的内容不在硬盘上而是在内存里。</div><div class="line">    sbin //管理员系统程序</div><div class="line">    selinux</div><div class="line">    srv</div><div class="line">    sys //udev用到的设备目录树，/sys反映你机器当前所接的设备</div><div class="line">    tmp //临时文件夹</div><div class="line">    usr //这是个最庞大的目录，我们要用到的很多应用程序和文件几乎都存放在这个目录下。]</div><div class="line">    bin // 应用程序</div><div class="line">    game //游戏程序</div><div class="line">    include</div><div class="line">    lib //应用程序的库文件</div><div class="line">    lib64</div><div class="line">    local //包含用户程序等</div><div class="line">    sbin //管理员应用程序</div></pre></td></tr></table></figure><h6 id="ls（列出文件夹中的文件）"><a href="#ls（列出文件夹中的文件）" class="headerlink" title="ls（列出文件夹中的文件）"></a>ls（列出文件夹中的文件）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-a 列出隐藏文件，文件中以“.”开头的均为隐藏文件，如：~/.bashrc</div><div class="line">-l 列出文件的详细信息</div><div class="line">-R 连同子目录中的内容一起列出</div></pre></td></tr></table></figure><p>ls -l开头显示的10个字符串，第一个表示的是文件类型，后面的9个分别表示：分为3组，每组3位。第一组表示文件属主的权<br>限，第二组表示同组用户的权限，第三组表示其他用户的权限。每一组的三个字符分别表示对文件的读、写和执行权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">首位表示：</div><div class="line">- 普通文件</div><div class="line">d 目录</div><div class="line">l 符号链接</div><div class="line">b 块设备文件</div><div class="line">c 字符设备文件</div><div class="line">s socket文件，网络套接字</div><div class="line">p 管道</div></pre></td></tr></table></figure></p><p>后九位对应的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">r 读</div><div class="line">w 写</div><div class="line">x 可执行。对于目录，表示进入权限。</div><div class="line">s 当文件被执行时，把该文件的UID或GID赋予执行进程的UID（用户ID）或GID（组 ID）。</div><div class="line">t 设置标志位（sticky bit）。如果是有sticky bit的目录，在该目录下任何用户只要有适当的权限即可创建文</div><div class="line">件，但文件只能被超级用户、目录拥有者或文件属主删除。如果是有sticky bit的可执行文件，在该文件执行后，</div><div class="line">指向其正文段的指针仍留在内存。这样再次执行它时，系统就能更快地装入该文件。</div><div class="line">- 没有相应位置的权限。</div></pre></td></tr></table></figure></p><h6 id="which-查看命令所在的位置"><a href="#which-查看命令所在的位置" class="headerlink" title="which(查看命令所在的位置)"></a>which(查看命令所在的位置)</h6><p><code>which ls    //查看ls命令所在的位置</code></p><h6 id="mv（移动）和cp（复制）"><a href="#mv（移动）和cp（复制）" class="headerlink" title="mv（移动）和cp（复制）"></a>mv（移动）和cp（复制）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv file1 file2  //文件重命名，file1和file2分别是原文件名和重命名的文件名</div><div class="line">mv file /dir     //移动文件</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//拷贝文件</div><div class="line">cp file1 file2</div><div class="line">cp file1 dir/</div><div class="line"></div><div class="line">//拷贝目录</div><div class="line">cp dir1 dir2 -r  //-r 选项在文件夹操作中，一般表示对文件夹中的文件递归操作</div><div class="line">cp dir1 ~/ -r</div></pre></td></tr></table></figure><h6 id="cat-查看文件里内容，输出到终端"><a href="#cat-查看文件里内容，输出到终端" class="headerlink" title="cat(查看文件里内容，输出到终端)"></a>cat(查看文件里内容，输出到终端)</h6><p>如果cat后面没有文件名，则读取标准输入</p><h6 id="ln-链接"><a href="#ln-链接" class="headerlink" title="ln(链接)"></a>ln(链接)</h6><p>链接分为两种，一种是硬链接（hard link），另一种是符号链接（Symbolic link）。建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。如果给ln命令加上-s选项，则建立符号链接。</p><h6 id="tree（显示目录的结构树）"><a href="#tree（显示目录的结构树）" class="headerlink" title="tree（显示目录的结构树）"></a>tree（显示目录的结构树）</h6><h6 id="wc-word-count"><a href="#wc-word-count" class="headerlink" title="wc(word count)"></a>wc(word count)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wc -l file //或–lines 只显示列数</div><div class="line">wc -w file //或–words 只显示字数</div><div class="line">wc -c file //或–bytes 或–chars 只显示 Bytes 数</div></pre></td></tr></table></figure><h6 id="od-显示数据"><a href="#od-显示数据" class="headerlink" title="od(显示数据)"></a>od(显示数据)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">od -tcx file1 //-t 指定数据的显示格式</div></pre></td></tr></table></figure><h6 id="du-显示目录的大小"><a href="#du-显示目录的大小" class="headerlink" title="du(显示目录的大小)"></a>du(显示目录的大小)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">du -hm /dir //以M为单位显示</div><div class="line">du -hb /dir //以B为单位</div><div class="line">du -hk /dir //以K为单位</div></pre></td></tr></table></figure><h6 id="df-查看磁盘的使用状况"><a href="#df-查看磁盘的使用状况" class="headerlink" title="df(查看磁盘的使用状况)"></a>df(查看磁盘的使用状况)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df --block-size=GB //以GB为单位显示</div><div class="line">df --block-size=MB //以MB为单位显示</div></pre></td></tr></table></figure><h5 id="文件属性和用户、用户组"><a href="#文件属性和用户、用户组" class="headerlink" title="文件属性和用户、用户组"></a>文件属性和用户、用户组</h5><h6 id="chmod（改变权限）"><a href="#chmod（改变权限）" class="headerlink" title="chmod（改变权限）"></a>chmod（改变权限）</h6><p>一种数字表示法一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0表示没有权限，</div><div class="line">1表示可执行权限，</div><div class="line">2表示可写权限，</div><div class="line">4表示可读权限，</div></pre></td></tr></table></figure></p><h6 id="whoami（显示当前用户名）"><a href="#whoami（显示当前用户名）" class="headerlink" title="whoami（显示当前用户名）"></a>whoami（显示当前用户名）</h6><h6 id="chown（更改某个文件或目录的属主和属组）"><a href="#chown（更改某个文件或目录的属主和属组）" class="headerlink" title="chown（更改某个文件或目录的属主和属组）"></a>chown（更改某个文件或目录的属主和属组）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown itcast:nogroup file1 //把一个文件改为itcast用户和nogroup用户组所有</div></pre></td></tr></table></figure><h6 id="chgrp-改变指定文件所属的用户组"><a href="#chgrp-改变指定文件所属的用户组" class="headerlink" title="chgrp(改变指定文件所属的用户组)"></a>chgrp(改变指定文件所属的用户组)</h6><h5 id="查找与检索"><a href="#查找与检索" class="headerlink" title="查找与检索"></a>查找与检索</h5><h6 id="find（在目录中搜索）"><a href="#find（在目录中搜索）" class="headerlink" title="find（在目录中搜索）"></a>find（在目录中搜索）</h6><p><code>find . -name &#39;file*&#39;  //在当前目录中搜索以file开头的文件</code></p><h6 id="grep-根据内容检索"><a href="#grep-根据内容检索" class="headerlink" title="grep(根据内容检索)"></a>grep(根据内容检索)</h6>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux学习-文件I/O</title>
      <link href="/12-Linux/linux-learn-2-file-IO/"/>
      <url>/12-Linux/linux-learn-2-file-IO/</url>
      <content type="html"><![CDATA[<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>一个进程默认打开三个文件描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">STDIN_FILENO 0</div><div class="line">STDOUT_FILENO 1</div><div class="line">STDERR_FILENO 2</div></pre></td></tr></table></figure></p><p>新打开文件返回文件描述符表中未使用的最小文件描述符。<br><strong>open函数 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">int open(const char *pathname, int flags);</div><div class="line">int open(const char *pathname, int flags, mode_t mode);</div><div class="line">返回值：成功返回新分配的文件描述符，出错返回-1并设置errno</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch6 函数</title>
      <link href="/12-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch6%E5%87%BD%E6%95%B0/"/>
      <url>/12-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch6%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。</p></blockquote><a id="more"></a><h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><h2 id="形参和实参："><a href="#形参和实参：" class="headerlink" title="形参和实参："></a>形参和实参：</h2><p>实参是形参的初始值，函数的形参列表可以为空。<br>局部静态对象，定义成static类型，在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><p>如果形参是引用类型，它将绑定到对应的实参上，称为引用传递；否则，将实参的值拷贝后赋给形参，称为值传递。</p><h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2><p>将实参的值拷贝给形参。当是指针形参时，指针的行为和其他非引用类型一样，执行指针拷贝类型时，拷贝的是指针的值。拷贝之后是不同的指针，但是指向的是相同的值，我们可以在函数中修改指针所指对象的值。在C++中，建议使用引用类型的形参替代指针。</p><h2 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h2><p><strong> 1.使用引用避免拷贝。 </strong>因为有的类类型是不能拷贝的，或者在拷贝一些大的类类型对象或者容器对象比较低效。<br>如果函数不需要改变引用参数的值，最好将其声明为常量引用。<br><strong> 2.使用引用形参返回额外信息。</strong>由于函数不能有多个返回值，在我们需要返回多个值的时候，可以额外传一个引用参数。<br><strong> 3.可以直接操作引用形参所引的对象。 </strong></p><h2 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h2><p>和其它初始化一样，当用实参初始化形参时会忽略掉顶层const。也就是，形参的顶层const会被忽略掉。（这个可以思考一下，我们可以通过形参的const在参数中控制是否需要改变形参，以及对应的实参，这样更方便我们传参数。当然有了这个我们就不能重载有无const的两个函数了，因为会被编译器相同对待。）<br>尽量使用常量引用，除了在使用的时候，无法把常量引用初始化为引用（很简单的道理），另外，也会给调用者一种误导。</p><h2 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h2><p>无法以值传递的方式使用数组参数。数组的特点：不允许拷贝、使用数组会将其转化为指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void print(const int*);</div><div class="line">void print(const int[]);</div><div class="line">void print(const int[10]);  //这里的维度表示我们期望数组含有多少个元素，实际不一定</div></pre></td></tr></table></figure></p><h3 id="关于数组长度"><a href="#关于数组长度" class="headerlink" title="关于数组长度"></a>关于数组长度</h3><p>由于传递数组引用的时候，只是数组的首元素指针，所以有时候我们需要在形参定义的时候，就将数组大小传递给形参。这里有几种方式。</p><h2 id="6-2-5-mian处理命令行选项"><a href="#6-2-5-mian处理命令行选项" class="headerlink" title="6.2.5 mian处理命令行选项"></a>6.2.5 mian处理命令行选项</h2><p>当使用argv[]中的实参时，第一个实参保存的是程序名，所以应该从第二个开始。</p><h2 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h2><p>有时候我们预先不知道向函数传递几个实参。1.如果所有的实参类型相同，可以传递名为initializee_list的标准库类型；2.如果实参类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。</p><h1 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h1><p>return语句终止当前执行的函数，并将控制权返回到调用该函数的地方。<br>return语句不要返回局部对象的引用或引用（因为局部对象会在函数调用完成后删除，会产生未定义的结果）。<br>c++11新标准中函数可以返回花括号包围的值列表，主函数main的返回值，非0的返回值由机器决定。</p><h1 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h1><p>拥有顶层const不影响传入函数的对象。另外，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。<br>不能仅仅通过函数的返回值区分两个同名的函数</p><h2 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h2><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。在不同的作用域中无法重载函数名。<br>在c++中，名字查找发生在类型检查之前。</p><h1 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h1><p>大多数程序都有用的特性：默认实参、内联函数、constexpr函数。</p><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>一旦某个形参赋予了默认值，后面的所有形参必须有默认值。函数调用时，实参按其位置进行解析，只能省略尾部的实参。<br>一个函数被声明多次的时候，在给定的作用域中一个形参只能被赋予一次默认实参，也就是函数的后续声明。</p><h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>将它在每个调用点上“内联的”展开，一般来说用于优化规模较小、流程直接、频繁调用的函数。</p><h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>constexpr函数指能用于常量表达式的函数。函数的返回值及所有形参的类型都得是字面值类型，并且函数体中必须有且只有一条return语句。<br>编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式的指定 为内联函数.<br>内联函数和constexpr函数通常定义在头文件中.</p><h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>assert预处理宏,以一个表达式作为条件.<br>我们可以使用一个#define 语句定义NDEBUG，关闭调试状态</p><h1 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h1><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换得来时。</p><h2 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h2><p>函数匹配第一步：选定本次调用对应的重载函数集。<br>候选函数的两个特征：与被调用的函数同名，其声明在调用点可见。<br>第二步考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数。</p><h2 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h2><p>确定最佳匹配的排序：</p><ul><li>1.精确匹配：实参形参类型相同，实参从数组或函数类型转化为对应的指针类型，实参添加顶层const或者从实参中删除顶层const。</li><li>2.通过const转换实现的匹配。</li><li>3.通过类型提升实现的匹配。</li><li>4.通过算术类型转换或指针转换实现的匹配。</li><li>5.通过类类型转换实现的匹配。</li></ul><h1 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h1><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p><h2 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h2><p>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。</p><h2 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h2><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上是被当成指针使用。<br>可以直接把函数当成实参使用，会自动转换成指针。</p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github简单使用</title>
      <link href="/10-Linux/github%E4%BD%BF%E7%94%A8/"/>
      <url>/10-Linux/github%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="github-使用"><a href="#github-使用" class="headerlink" title="github 使用"></a>github 使用</h3><h4 id="克隆本地仓库"><a href="#克隆本地仓库" class="headerlink" title="克隆本地仓库"></a>克隆本地仓库</h4><p>目的相当于从github的master分支上下载了整个代码仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@你的仓库地址</div></pre></td></tr></table></figure></p><h4 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h4><p>克隆了代码之后就可以直接在本地开始写了，写完之后，在仓库带有<figure class="highlight plain"><figcaption><span>-al ```看是否存在该目录)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">git add .   #将所有的改动添加到暂存区</div><div class="line">git commit -m &quot;你的注释&quot;  #添加到暂存区的文件，commit后准备提交到远程仓库</div><div class="line">git push origin master  #提交改动到远程仓库的master分支</div></pre></td></tr></table></figure></p><h4 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h4><p>当在另外一台电脑上对代码有所修改后，远程仓库与另一台电脑就代码有不同，这时候可以在与远程代码的不同的电脑上执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull origin master #拉区远程仓库代码，与本地合并</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网-剑指offer-2</title>
      <link href="/27-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-2/"/>
      <url>/27-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-2/</url>
      <content type="html"><![CDATA[<h4 id="T4：重建二叉树"><a href="#T4：重建二叉树" class="headerlink" title="T4：重建二叉树"></a>T4：重建二叉树</h4><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><p>二叉树是觉得很烦的东西了，比链表复杂很多，看着头都有点疼啊，但是没办法，生活就是这样，只有把不会的会了才会进步，怕的变得不怕才能越来越厉害。<br>常规的理解一下：二叉树的遍历序列分为三种：前序遍历、中序遍历和后序遍历。这样叫是根据根节点相对于其左右子节点而言的。所以很容易知道三种遍历序列的特点，比如对于前序遍历而言，第一个就是根节点，对于中序遍历，根节点的左边必然是左子树，右边为右子树。所以首先可以根据两个序列确定根节点，然后把两个序列都分别分为两个序列，两个左右子树的前序遍历和两个左右子树的后序遍历。于是便可以采用递归的方式分别对左右子树进行处理了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for binary tree</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</div><div class="line">        if(pre.size()==0||vin.size()==0||pre.size()!=vin.size())</div><div class="line">            return nullptr;</div><div class="line">        TreeNode *root=new TreeNode(pre[0]);</div><div class="line">        vector&lt;int&gt; pre1,pre2,vin1,vin2;</div><div class="line">        int i=0;</div><div class="line">        for(;i!=vin.size();++i)&#123;</div><div class="line">            if(root-&gt;val==vin[i])&#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //if(i==0)</div><div class="line">            //root-&gt;left=nullptr;</div><div class="line">        //else if(i==vin.size()-1)</div><div class="line">            //root-&gt;right=nullptr;</div><div class="line">        //else&#123;</div><div class="line">        for(int j=0;j&lt;i;++j)&#123;</div><div class="line">            pre1.push_back(pre[1+j]);</div><div class="line">            vin1.push_back(vin[j]);</div><div class="line">            &#125;</div><div class="line">        for(int j=i+1;j&lt;vin.size();++j)&#123;</div><div class="line">            pre2.push_back(pre[j]);</div><div class="line">            vin2.push_back(vin[j]);</div><div class="line">            &#125;</div><div class="line">        root-&gt;left=reConstructBinaryTree(pre1,vin1);</div><div class="line">        root-&gt;right=reConstructBinaryTree(pre2,vin2);</div><div class="line">        //&#125;</div><div class="line"></div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T5-用两个栈实现队列"><a href="#T5-用两个栈实现队列" class="headerlink" title="T5:用两个栈实现队列"></a>T5:用两个栈实现队列</h4><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote><p>对于这种简单的结构，实现起来可能还是比较简单一点，主要还是思考的过程，通过队列和栈的特点进行分析。队列是一个先进先出的结构，而栈是一个先进后出的结构。显然当我们把数据push到第一个栈，每次数据pop都把第一个栈的全部数据先放到第二个栈当中，然后再pop，肯定就达到了先入先出的目的了。<br>另外需要的是代码的编写。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int pop() &#123;</div><div class="line">        if(stack2.size()&lt;=0)&#123;</div><div class="line">            while(stack1.size()&gt;0)&#123;</div><div class="line">                int temp=stack1.top();</div><div class="line">                stack1.pop();</div><div class="line">                stack2.push(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int result=stack2.top();</div><div class="line">        stack2.pop();</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    stack&lt;int&gt; stack1;</div><div class="line">    stack&lt;int&gt; stack2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T6：旋转数组的最小数字"><a href="#T6：旋转数组的最小数字" class="headerlink" title="T6：旋转数组的最小数字"></a>T6：旋转数组的最小数字</h4><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p>对于数组或者双链表的问题，很多时候我们都可以采用<strong> 双指针</strong>的方法来解决，这通常能减小难度，就像这题，首先我们需要注意的是，旋转数组的特点，旋转之前是一个非递减排序，所以旋转之后必然是前面一个非递减排序加上后半部分的一个非递增排序。很容易想到的是，采用前后两个指针，根据两个指针中间的点的值，可以确定这个数组中最小的值在前半部分还是后半部分，然后移动某一指针到中间节点，知道两个指针之间相差1，就可以确定最小值。<br>然而，看题目还存在一个问题，就是题目所说的是一个非递减排序，而并非递增序列。（这就需要我们认真审题了），可以想到，如果出现了特殊的情况，例如存在几个相等值，导致左右两个指针和中间值都相同的时候，我们只能通过最原始的办法一个个进行判断了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</div><div class="line">        if(rotateArray.size()&lt;=0)</div><div class="line">            return 0;</div><div class="line">        int index1=0;</div><div class="line">        int index2=rotateArray.size()-1;</div><div class="line">        int indexMid=index1;</div><div class="line">        while(rotateArray[index1]&gt;=rotateArray[index2])&#123;</div><div class="line">            if(index2-index1==1)&#123;</div><div class="line">                indexMid=index2;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            indexMid=index1+(index2-index1)/2;</div><div class="line">            if(rotateArray[index1]==rotateArray[indexMid]&amp;&amp;</div><div class="line">               rotateArray[indexMid]==rotateArray[index2])</div><div class="line">                return MinInorder(rotateArray);</div><div class="line">            if(rotateArray[indexMid]&gt;=rotateArray[index1])</div><div class="line">                index1=indexMid;</div><div class="line">            else if(rotateArray[indexMid]&lt;=rotateArray[index2])</div><div class="line">                index2=indexMid;</div><div class="line">        &#125;</div><div class="line">        return rotateArray[indexMid];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int MinInorder(vector&lt;int&gt; rotateArray)&#123;</div><div class="line">        int result=rotateArray[0];</div><div class="line">        int index2=rotateArray[1];</div><div class="line">        while(index2!=rotateArray.size())&#123;</div><div class="line">            if(result&gt;rotateArray[index2])</div><div class="line">                result=rotateArray[index2++];</div><div class="line">            else</div><div class="line">               ++index2;</div><div class="line">               &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win7下安装Ubuntu双系统</title>
      <link href="/22-%E5%B7%A5%E5%85%B7/win7%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
      <url>/22-%E5%B7%A5%E5%85%B7/win7%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<blockquote><p>学(xian)习(de)所(dan)需(teng)，觉得一个虚拟机确实装的Ubuntu确实有点烦了，除了没有一个系统那样直接用起来爽以外，总觉得感受不到一个纯正的系统。而且虚拟机有时候懒得开了就算了。但是又舍不得直接把我换了固态之后就没有换过的系统直接换掉，毕竟我已经不是那个年轻的爱折腾的22岁的小伙子了，我23了。。于是就看着教程和xjbg装了双系统。同时的难度是，我的固态硬盘里放的系统，但是又不想把系统直接放在固态硬盘，只是希望通过固态启动一下，然后把其他的目录放在机械硬盘中</p></blockquote><a id="more"></a><h5 id="Win7准备"><a href="#Win7准备" class="headerlink" title="Win7准备"></a>Win7准备</h5><p>双系统的准备主要就是硬盘了，毕竟这么多学习资料是吧。。总还是要谨慎一点的。因为win7和linux系统的磁盘格式不一样，所以我们不能直接在win7里面分好磁盘。这里的工作是：将固态硬盘压缩300MB空间，作为Ubuntu的<code>/boot</code>分区，以供系统启动用。另外在机械硬盘中分出80GB空间，作为其他的<code>/</code>和<code>swap</code>分区。</p><h5 id="通过U盘做系统盘"><a href="#通过U盘做系统盘" class="headerlink" title="通过U盘做系统盘"></a>通过U盘做系统盘</h5><p>使用工具UtralISO，将下载好的Ubuntu系统，通过正常的模式写入到U盘中(这个随便百度一下就有了，经常装系统的这个就差不多知道了)</p><h5 id="重启装系统"><a href="#重启装系统" class="headerlink" title="重启装系统"></a>重启装系统</h5><p>首先还是熟悉的修改bios，按一下各种类似<code>F2</code>之类的键，进入BIOS设置，将启动项第一位改成U盘，然后重启。。<br>之后就是进去装系统了，主要是选磁盘的时候，把 固态硬盘中的未分配空间格式化为<code>/boot</code>，然后其他的机械硬盘中的，按照需要格式化为<code>/</code>和<code>/swap</code>,之后等着装完就好了。</p><h5 id="修改启动选项"><a href="#修改启动选项" class="headerlink" title="修改启动选项"></a>修改启动选项</h5><p>系统装完之后就要重启进入新系统了，这是惊喜而又刺激的发现，Ubuntu真好看，但是我的Win7去哪儿了。不过装了一百遍系统的我知道肯定还是个引导的问题，在网上找到了解决办法。在Ubuntu中输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo gedit /etc/default/grub</div><div class="line">#修改</div><div class="line">GRUB_DEFAULT=0 为：GRUB_DEFAULT=4</div><div class="line">#更新grub</div><div class="line">sudo update-grub</div><div class="line">在终端中找到：</div><div class="line">found win7...</div><div class="line">就说明win7引导被找到了，重启可以开始愉快的用了</div></pre></td></tr></table></figure></p><h6 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h6><p><a href="http://m.jb51.net/article/110288.htm" target="_blank" rel="external">http://m.jb51.net/article/110288.htm</a><br><a href="https://jingyan.baidu.com/article/e4d08ffdace06e0fd2f60d39.html" target="_blank" rel="external">https://jingyan.baidu.com/article/e4d08ffdace06e0fd2f60d39.html</a><br><a href="http://www.jianshu.com/p/c6750e459a94" target="_blank" rel="external">http://www.jianshu.com/p/c6750e459a94</a></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网刷题总结-剑指offer(1)</title>
      <link href="/15-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-1/"/>
      <url>/15-%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%89%91%E6%8C%87offer-1/</url>
      <content type="html"><![CDATA[<blockquote><p>说在前面：刷题真的是一件残酷的事情，就好比以前大学的时候只剩两天就考试了，刚刚看了一遍就开始先做题一样的感觉，面对无数的套路，幸运的时候还能庆幸自己能发现他们的套路。。<br>刷题的开始总是艰难的，希望有一天我能以上帝视角看清这些芸芸众生的时候，还能想起来当年我不止一次的一道题怼了一晚上照样白怼。</p></blockquote><h4 id="T1：二维数组的查找"><a href="#T1：二维数组的查找" class="headerlink" title="T1：二维数组的查找"></a>T1：二维数组的查找</h4><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>这里一般的思路肯定是，从行或者列开始找，根据递增的顺序，找到行或者列之后再判断列或者行，知道找到为止。最好的方法是，从左下角或者右上角开始找。原因是：这样的一行和一列的顺序是不一样的，这样我们找一行的时候没有就可以直接找下一行，充分利用递增的顺序，减少循环的次数。<br>其他的就是循环的写法了，关于数组，一定注意的是不要越界，这真的是我的痛啊，日常越界一百遍。<em>^</em>^_<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</div><div class="line">        bool found=false;</div><div class="line">        if(array.size()==0 ||array[0].size()==0)</div><div class="line">            return found;</div><div class="line">        for(int i=array[0].size()-1;i&gt;=0;--i)&#123;</div><div class="line">            if(target&gt;=array[0][i])&#123;</div><div class="line">                for(int j=0;j!=array.size();++j)&#123;</div><div class="line">                    if(target==array[j][i])</div><div class="line">                        found=true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                continue;</div><div class="line">        &#125;</div><div class="line">        return found;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T2：替换空格"><a href="#T2：替换空格" class="headerlink" title="T2：替换空格"></a>T2：替换空格</h4><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>替换的过程是，先找到这个空格，正常想法是，从前往后找，然后遇到就开始替换。但是注意到<em>对于一般题目，最直观的解法总不是最好的</em>，都是需要多从<strong>时间复杂度和空间复杂度想一想</strong>。就这个题目而言，直接从前往后替换，因为替换后的字符比原来多2个，所以每次替换我们都需要将后面的字符串向后移2个，这无疑会增加复杂度。一个很好的办法是：先统计空格的个数，计算出替换后的字符串长度，然后从后往前开始替换，这样就减少了移动的复杂度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void replaceSpace(char *str,int length) &#123;</div><div class="line">        if(length&lt;=0)</div><div class="line">            return;</div><div class="line">        int move_length=0;</div><div class="line">        int original_length=0;</div><div class="line">        for(int i=0;str[i]!=&apos;\0&apos;;++i)&#123;</div><div class="line">            ++original_length;</div><div class="line">            if(str[i]==&apos; &apos;)</div><div class="line">                ++move_length;</div><div class="line">        &#125;</div><div class="line">        int new_length=original_length+2*move_length;</div><div class="line">        if(new_length&gt;length)</div><div class="line">            return;</div><div class="line">        str[new_length]=&apos;\0&apos;;</div><div class="line">        while(original_length&gt;0)&#123;</div><div class="line">            --original_length;</div><div class="line">            if(str[original_length]==&apos; &apos;)&#123;</div><div class="line">                str[--new_length]=&apos;0&apos;;</div><div class="line">                str[--new_length]=&apos;2&apos;;</div><div class="line">                str[--new_length]=&apos;%&apos;;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                str[--new_length]=str[original_length];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="T3-从尾到头打印链表"><a href="#T3-从尾到头打印链表" class="headerlink" title="T3:从尾到头打印链表"></a>T3:从尾到头打印链表</h4><blockquote><p>输入一个链表，从尾到头打印链表每个节点的值。</p></blockquote><p>链表我们一般都是从头到尾处理的，要从尾到头打印，这里想到一个数据结构：<strong>栈</strong>，后入先出的特点。从头到尾遍历链表，并把节点的值存入栈中，再从栈一一弹出即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  struct ListNode &#123;</div><div class="line">*        int val;</div><div class="line">*        struct ListNode *next;</div><div class="line">*        ListNode(int x) :</div><div class="line">*              val(x), next(NULL) &#123;</div><div class="line">*        &#125;</div><div class="line">*  &#125;;</div><div class="line">*/</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</div><div class="line">        stack&lt;int&gt; stack;</div><div class="line">        vector&lt;int&gt; result;</div><div class="line">        while(head!=nullptr)&#123;</div><div class="line">            stack.push(head-&gt;val);</div><div class="line">            head=head-&gt;next;</div><div class="line">        &#125;</div><div class="line">        while(stack.size()!=0)&#123;</div><div class="line">            result.push_back(stack.top());</div><div class="line">            stack.pop();</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《effective C++》from line 1 to line 12</title>
      <link href="/09-cpp/effective-cpp-1/"/>
      <url>/09-cpp/effective-cpp-1/</url>
      <content type="html"><![CDATA[<blockquote><p>前面两章的内容主要是习惯使用c++，大部分都是《C++ primer》中的需要注意的一些东西，由于刚刚看完前面一本，所以有些还是有些印象的。这里大体总结一下。</p></blockquote><h4 id="L1-C-是一个语言联邦。"><a href="#L1-C-是一个语言联邦。" class="headerlink" title="L1:C++是一个语言联邦。"></a>L1:C++是一个语言联邦。</h4><p>包含着最初的以c语言为基础的C，面向对象的C++，C++的泛型编程，以及STL。在我们使用的过程中，可能会穿插，但是我们需要根据不同的情况使用不同的策略。</p><h4 id="L2：代替-define"><a href="#L2：代替-define" class="headerlink" title="L2：代替#define"></a>L2：代替#define</h4><p><code>#define</code>是在编译之前，也就是预处理的阶段就会被替换，这样我们在调试程序的时候看到的就是被替换的数字，会给别人甚至是之后调试的我们自己带来理解上的困难。另外，预处理器的工作是，直接把define的内容进行替换，当我们在define中写的表达式，并且在接下来使用的时候，可能产生无法理解的结果。所以当我们使用不想改变的常量时，使用<code>const</code>代替<code>#define</code>。<br>我们还可以使用<code>enum</code>来代替<code>#define</code>。这样显得会更接近一些，因为<code>enum</code>和<code>#define</code>一样，同时也不会被pointer或reference指向。<br>使用<code>inline</code>函数。</p><h4 id="L3-尽量使用const"><a href="#L3-尽量使用const" class="headerlink" title="L3:尽量使用const"></a>L3:尽量使用const</h4><p>这是一个很好理解的问题，就像你把东西给别人用，不想让别人动的地方就加一个<code>const</code>不让别人动一样。。。<br>具体的体现为：指针，不想被改变的变量，迭代器，成员函数等等。<br>我们可能还会为一个函数定义<code>const</code>和<code>非const</code>版本。</p><h4 id="L4：在使用对象前先初始化"><a href="#L4：在使用对象前先初始化" class="headerlink" title="L4：在使用对象前先初始化"></a>L4：在使用对象前先初始化</h4><p>嗯，记住。</p><h4 id="L5：了解c-会默认编写并调用哪些函数"><a href="#L5：了解c-会默认编写并调用哪些函数" class="headerlink" title="L5：了解c++会默认编写并调用哪些函数"></a>L5：了解c++会默认编写并调用哪些函数</h4><p>在面向对象编程时，记住三五法则。构造函数、拷贝构造函数、拷贝赋值运算符、移动赋值运算符、析构函数。记住这几个函数的作用，其在什么时候会被使用，如果没有的时候，系统会不会为我们生成。我们需不需要系统为我们生成。</p><h4 id="L6：不想编译器默认生成的函数，应该明确拒绝"><a href="#L6：不想编译器默认生成的函数，应该明确拒绝" class="headerlink" title="L6：不想编译器默认生成的函数，应该明确拒绝"></a>L6：不想编译器默认生成的函数，应该明确拒绝</h4><p>比如我们不希望编译器为我们生成默认的函数，我们应该将其定义为删除的或者定义为<code>private</code>的，也可以定义类似于uncopyable类似的base class。</p><h4 id="L7：为多态的基类声明virtual析构函数"><a href="#L7：为多态的基类声明virtual析构函数" class="headerlink" title="L7：为多态的基类声明virtual析构函数"></a>L7：为多态的基类声明virtual析构函数</h4><p>通常我们希望派生类覆盖或重写的函数，定义为virtual函数。析构函数作为对象被销毁时调用的函数，如果不是虚函数，那么可能在销毁的时候只会销毁基类的部分，局部销毁，造成资源泄露。</p><h4 id="L8：不要让异常逃离析构函数"><a href="#L8：不要让异常逃离析构函数" class="headerlink" title="L8：不要让异常逃离析构函数"></a>L8：不要让异常逃离析构函数</h4><p>析构函数绝对不要吐出异常，当遇到异常的时候应该捕捉任何异常，然后吞下或结束程序。<br>如果需要对某个操作函数运行期间抛出的异常做出反应，应该提供一个普通的函数执行操作，而不是在析构函数中。</p><h4 id="L9：绝不在构造和析构过程中调用virtual函数"><a href="#L9：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="L9：绝不在构造和析构过程中调用virtual函数"></a>L9：绝不在构造和析构过程中调用virtual函数</h4><p>构造和析构过程中，调用virtual函数的对象可能还没有产生，也就是派生类的对象，此时会产生未定义的行为。</p><h4 id="L10：另operator-返回一个reference-to-this"><a href="#L10：另operator-返回一个reference-to-this" class="headerlink" title="L10：另operator=返回一个reference to *this"></a>L10：另operator=返回一个reference to *this</h4><p>并不强制，只是为了防止一些调皮的调用者使用：<code>x=y=z=15</code>这样的操作。</p><h4 id="L11：在operator-中处理自赋值的情况"><a href="#L11：在operator-中处理自赋值的情况" class="headerlink" title="L11：在operator=中处理自赋值的情况"></a>L11：在operator=中处理自赋值的情况</h4><p>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，行为仍然正确。</p><h4 id="L12：复制对象时不忘每一个成分"><a href="#L12：复制对象时不忘每一个成分" class="headerlink" title="L12：复制对象时不忘每一个成分"></a>L12：复制对象时不忘每一个成分</h4><p>Copying函数应该确保复制对象内的所有成员变量和所有base class成分。<br>不要使用一个copying函数实现另一个copying函数，而是创建一个新的函数避免代码重复。</p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不知道怎么开的船？</title>
      <link href="/25-%E9%9A%8F%E7%AC%94/%E4%B8%8D%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E5%BC%80%E7%9A%84%E8%88%B9/"/>
      <url>/25-%E9%9A%8F%E7%AC%94/%E4%B8%8D%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E5%BC%80%E7%9A%84%E8%88%B9/</url>
      <content type="html"><![CDATA[<h3 id="2017-9-25-记录学习"><a href="#2017-9-25-记录学习" class="headerlink" title="2017-9-25 记录学习"></a>2017-9-25 记录学习</h3><h4 id="额，打开sublime，打出来第一个-号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。"><a href="#额，打开sublime，打出来第一个-号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。" class="headerlink" title="额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。"></a>额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。</h4><p>最近开始再一次准备看数据结构和算法，再一次，是不能再跟闹着玩的一次了。看着实验室最近找工作的师兄师姐，一边心疼他们，一边更心疼明年的自己。所以我也想到了也许很好的办法，不如抓紧时间现在先好好学习，头疼起来了，心就不疼了吧。<br>断断续续看完了c++ primer，加上之前看过一些数据结构，但是当我打开牛客网第一题的时候还是觉得自己像个傻逼，于是按照我通常的习惯，换了第二题，觉得更傻逼了。于是还是先打开书看看了。。<br>看看书啊，又刷刷题啊，自己还是经常在骂自己和夸自己和强行夸自己这几种有限状态中跳来跳去。<br>晚上，刷到那个链表翻转的题目，又是好久没搞出来，各种数组越界。明明只是就那么几个指针而已，反复看了好几遍。当方法论出了问题的时候，有的时候会忍不住怀疑世界观。作为一个还是对这个世界充满疑惑和兴趣的青年，我好奇地又在网上搜了一遍：C++学什么，C++怎么学，C++学习路线。。于是一晚上又没了，留下一份写有听过好多遍名字的书的TXT文档，一如一个多月前的某一个晚上。。<br>可能距离我们找工作也有快一年吧，时间说长不长，说短不短吧。其实我觉得能担心的可能一直不是时间，而是利用时间。<br>先写一下接下来一段时间的任务吧，不要又乱跑了：</p><ul><li>《Effictive C++》认真看，主线</li><li>有空看数据结构，刷题，不随便放弃题目。搞懂会写，写好了为止</li></ul>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch16 模板与泛型编程</title>
      <link href="/19-cpp/cpp-primer/ch16-notes/"/>
      <url>/19-cpp/cpp-primer/ch16-notes/</url>
      <content type="html"><![CDATA[<p>泛型编程与面向对象编程的区别是：面向对象编程能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。</p><h4 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h4><p>模板程序应该尽量减少对实参类型的要求。<br>模板的头文件通常包括声明和定义。<br>模板直到实例化时才生成代码。<br>泛型编程的一个目标就是另算法是“通用的”-适合于不同类型。所有标准库容器都定义了<code>==</code>和<code>!=</code>，但只有少数定义了<code>&lt;</code>运算符。因此尽量使用<code>!=</code>而不是<code>&lt;</code>。<br><strong> 类模板</strong>用来生成类的蓝图，一个类模板的每个实例都形成一个独立的类。默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。在类模板的作用域类，我们可以直接使用模板名而不必指定模板实参。<br>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给 所有友元模板实例，也可以只授权给特定实例。<br>当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。<br><strong> 成员模板</strong>：一个类（不管是模板类还是普通类）可以包含本身是模板的成员函数。这些成员函数被称为成员模板。成员模板不能是虚函数。<br>控制实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extern template class Blob&lt;string&gt;;  //声明，遇到extern模板声明时，编译器不会在本文件中生成实例化代码。，对于一个给定的实例化版本，可以有多个extern声明，但只能有一个定义。</div><div class="line">template int compare(const int&amp;,const int&amp;); //定义</div></pre></td></tr></table></figure></p><h4 id="16-2-模板实参推断"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断</h4><p>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。<br>一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。<br>如果函数参数类型不是模板参数，则可以进行正常的类型转换。<br><strong> 显式模板实参</strong>按由左至右的顺序与对应的模板参数匹配。</p><h4 id="16-3-重载与模板"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板</h4><h4 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h4><h4 id="16-5-模板特例化"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化</h4>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch15-面向对象程序设计</title>
      <link href="/19-cpp/cpp-primer/ch15-notes/"/>
      <url>/19-cpp/cpp-primer/ch15-notes/</url>
      <content type="html"><![CDATA[<blockquote><p>面向对象三个基本概念：数据抽象、继承和动态绑定（java里说的多态）。这章主要内容是继承和动态绑定。</p></blockquote><h4 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h4><h4 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h4><p>基类希望派生类进行覆盖的函数，通常将其定义为<strong> 虚函数</strong>，另一种是基类希望派生类继承但不要改变的函数。<br><code>protected</code>访问运算符：派生类可以访问，但是其他用户无法访问。<br>定义派生类：通过访问说明符控制派生类从基类继承而来的成员是否对派生类可见。<br>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为跟其他类一样，派生类会直接继承其在基类中的版本。<br>派生类到基类的转换。这可以让我们把派生类对象或者派生类对象的引用用在需要基类引用的地方，也可以把派生类指针用在需要基类指针的地方。但是，这里会出现一个问题，当我们使用基类的指针或者引用时，就不知道这个所绑定的对象到底是基类还是派生类了。<br>派生类构造函数。必须使用基类的构造函数初始化。（每个类控制自己的初始化过程。）<br>每个类定义各自的接口，派生类要遵循基类的接口。<br>如果基类中定义了静态成员，则在整个继承体系中只存在唯一的定义，不管定义了多少遍，都只存在唯一的实例。<br>对派生类的声明，不需要包含派生列表。<br>当我们不想让类被继承的时候，可以使用<code>final</code>关键字，跟在类名之后。<br>表达式的<strong> 静态类型</strong>在编译时是已知的，是变量声明时或者表达式生成式生成的类型。<strong> 动态类型</strong>则是变量或表达式表示的内存中的对象的类型。因此，基类的指针或引用的静态类型可能与动态类型不一致。<br>派生类向基类的自动类型转换只对指针和引用有效，在类型之间不存在这样的转换。当我们用一个派生类对象初始化或给一个基类对象赋值时，只有该派生类的对象中的基类部分会被拷贝、移动或赋值，派生类部分则会被忽略掉。</p><h4 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h4><p>我们必须为每一个虚函数提供定义，因为连编译器也无法确定到底使用的是哪一个虚函数。<br>如果我们在派生类中覆盖了某个虚函数时，可以再次使用<code>virtual</code>指出该函数的性质，但实际上并不一定要这么做。因为某个函数被声明成虚函数，则在所有的派生类中都是虚函数。</p><h4 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h4><p>在函数体声明的语句的分号前使用<code>=0</code>可以将一个函数声明为纯虚函数。<br>含有纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类负责覆盖该接口。我们不能直接创建一个抽象基类的对象。GCC的编译器中可能前面还是要加上<code>virtual</code><br><strong> 重构</strong>：重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。</p><h4 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h4><p>protected:对于类的用户来说是不可访问的，对于派生类的成员和友元来说是可访问的。但是只能通过<strong> 派生类对象</strong>来访问，<strong> 派生类</strong>对于一个基类中受保护的成员是无法访问的。<br>派生类向基类的转换：只有当D公有的继承B时，<strong> 用户代码</strong>才能使用基类向派生类的转换。无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换。如果D继承B的方式是公有的或受保护的，则D的派生类可以使用D向B的类型转换。<br>友元关系不能继承。基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员。<br>派生类可以使用<code>using</code>为那些可以访问的名字提供声明，以改变这些名字在它的派生类中的可访问性。</p><h4 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h4><p>每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。<br>当名字相同时，派生类的成员将隐藏基类的成员。基类可以通过<strong> 作用域运算符</strong>来使用隐藏的成员。一般情况下，我们应该不会这么使用，所以，平时继承类尽量不要覆盖继承而来的虚函数以外的基类的名字。<br><strong> 名字查找先于类型检查</strong>：如果派生类的成员与基类中的某个成员同名，则派生类将在其作用域内隐藏该基类成员。一旦编译器查找到名字后，不管形参列表是否相同，都不会再继续查找，这也是我们需要在覆盖虚函数时，保证形参列表是相同的。<br><code>using</code>声明语句指定一个名字而不是形参列表，所以我们在基类中使用一个<code>using</code>就可以把该函数的所有重载实例添加到派生类作用域中，派生类只需要定义特有的函数即可。</p><h4 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h4><p>位于继承体系中的类也需要控制当其对象执行一系列操作时发生怎样的行为：包括创建、移动、拷贝、赋值和销毁。<br>一般讲基类中的析构函数定义为虚函数，这样，继承体系中的派生类都会是虚析构函数，否则，若基类中的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。<br>虚析构函数将组织合成移动操作。<br>和普通成员的using声明不同，构造函数的using声明不会改变该构造函数的访问级别。<br>using声明语句不能指定explicit或constexpr。<br>当一个基类构造函数含有默认实参时，这些实参并不会被继承。派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p><h4 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8 容器与继承"></a>15.8 容器与继承</h4><p>容器不能直接存放继承体系中的对象，通常采用间接存储的方式。因为当我们把基类存储到一个容器中，当存入派生类对象，实际存入的只是派生类中基类的部分，显然不符合我们的需要。所以我们希望在具有继承关系的对象时，实际上存储的是基类的指针。（最好使用智能指针）</p><h4 id="15-9-文本查询程序再探"><a href="#15-9-文本查询程序再探" class="headerlink" title="15.9 文本查询程序再探"></a>15.9 文本查询程序再探</h4>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch13 拷贝控制</title>
      <link href="/14-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch13/"/>
      <url>/14-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch13/</url>
      <content type="html"><![CDATA[<p>通过定义的五种特殊的成员函数，控制类的对象在拷贝。赋值、移动或销毁时做什么。包括：拷贝构造函数、拷贝赋值运算符、拷贝赋值运算符、移动赋值运算符以及析构函数。</p><h4 id="13-1-拷贝、赋值、销毁"><a href="#13-1-拷贝、赋值、销毁" class="headerlink" title="13.1 拷贝、赋值、销毁"></a>13.1 拷贝、赋值、销毁</h4><h4 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h4><p>在旧标准的标准库中，容器中所保存的类必须是可以拷贝的，新标准中，可以在容器中保存不可拷贝的类型，只要他们能够被移动就可以。</p><h5 id="13-6-1-右值引用"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用</h5><p>通过&amp;&amp;来获得右值引用，意为绑定到右值的引用。<br><strong> 重要性质：只能绑定到一个将要销毁的对象。</strong><br><strong> 所引用的对象将要被销毁，该对象没有其他用户</strong><br>– 左值引用：返回左值引用的函数，赋值、下标、解引用、前置递增/递减运算符。<br>– 右值引用：返回非引用的函数，算数、关系、位以及后置递增/递减运算符。<br>区分的方法：一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。<a href="http://blog.csdn.net/yapian8/article/details/42341307" target="_blank" rel="external">右值引用比较</a></p><p><strong> move函数(utility头文件中)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int &amp;&amp;rr3=std::move(rr1);  //相当于告诉编译器，我们希望像处理右值一样处理左值rr1。</div><div class="line">                           //调用move后，除了赋值和销毁rr1外不会再使用它</div><div class="line">                           //使用move直接用std::move</div></pre></td></tr></table></figure></p><h6 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h6><p>目的：让类支持移动操作。<br>移动构造函数：第一个参数是一个该类类型的右值引用，任何其他额外的参数都要有默认实参。不需要分配新内存，直接接管原来的内存。不会跑异常，不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。（原因是标准库很多对于存在异常的处理方式，例如vector）<br>移动赋值运算符：首先要处理自赋值的情况。（为什么检查自赋值？因为右值可能是move调用返回的结果，不能在使用右侧运算符对象之前释放左侧运算对象的资源。）<br><strong> 如果类有拷贝构造函数和拷贝赋值运算符，没有定义移动操作时，编译器不会为其分配默认的移动操作，而是会采用对应的拷贝进行代替。如果没有定义任何的拷贝操作，才会为其合成移动构造函数或移动赋值运算符。</strong><br>移动操作不会被隐式的定义为删除的操作,定义为删除元素的原则：</p><ul><li>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或有类成员未定义自己的拷贝构造函数且编译器不能为其合成默认移动构造函数</li><li>有类成员的移动构造函数或移动赋值运算符被定义为删除的或不可访问的</li><li>类的析构函数被定义为删除的</li><li>有类成员是const的或是引用</li></ul><p><strong> 三/五法则 </strong>：<br>通常，拥有一个资源的类，必须定义拷贝构造函数、拷贝赋值运算符、析构函数才能工作，而由于大量的拷贝会影响资源的额外开销，定义移动构造函数和移动赋值运算符可以避免此类问题。</p><h5 id="13-6-1-右值引用和成员函数"><a href="#13-6-1-右值引用和成员函数" class="headerlink" title="13.6.1 右值引用和成员函数"></a>13.6.1 右值引用和成员函数</h5><p>区分移动和拷贝的重载函数通常有一个版本接受<code>const T&amp;</code>，另一个版本接受一个<code>T&amp;&amp;</code>。很多时候它们看起来调用的是一个函数，通常它们内部的构造也很接近，有一点差别。我们可以根据实参的类型进行判断，我们用的是左值和右值区分调用的版本。<br>有的时候我们想要避免对右值进行赋值（在旧的标准中是有可能发生的，并且新的标准为了向后兼容没有禁止），可以在参数列表后放置一个<strong> 引用限定符</strong>。还可以通过使用<code>&amp;</code>或者<code>&amp;&amp;</code>指出指向一个左值或者一个右值。eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    public:</div><div class="line">        Foo &amp;operator=(const Foo&amp;) &amp;; //只能向可修改的左值赋值。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>引用限定符可以区分重载版本，如同const可以用来区分一个成员函数的重载版本。一般当我们定义两个或两个以上的具有相同名字和相同参数列表的成员函数，就必须对所有函数加上引用限定符，或者都不加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    public:</div><div class="line">        Foo sorted() &amp;&amp;;</div><div class="line">        Foo sorted() const; //错误，需要加上引用限定符</div><div class="line">        /////////////////</div><div class="line">        Foo sorted(Comp*);</div><div class="line">        Foo sorted(Comp*) const; //正确，两个版本都没有引用限定符</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch14 重载运算符和类型转换</title>
      <link href="/14-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch14/"/>
      <url>/14-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch14/</url>
      <content type="html"><![CDATA[<h3 id="ch14-重载运算与类型转化"><a href="#ch14-重载运算与类型转化" class="headerlink" title="ch14 重载运算与类型转化"></a>ch14 重载运算与类型转化</h3><blockquote><p>当运算符作用于类的对象的时，通过重载运算符，使不同的运算符对于不同的类有着特定的含义，一方面能够简化类的使用者的逻辑，另一方面也能是程序更易于编写和阅读，而不至于编写更多的函数。</p></blockquote><a id="more"></a><h4 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h4><p>重载的运算符是特殊的函数：由operator关键字加上要定义的运算符号共同组成。作为函数，也包含返回类型、参数列表和函数体。参数列表个数与该运算符作用的算数对象数量一样多。<br>不应该被重载的运算符：逻辑与、逻辑或、逗号运算符、取地址运算符。<br>定义成成员还是非成员的判断：</p><ul><li>赋值、下标、调用、成员访问箭头等运算符必须是类的成员。</li><li>复合赋值运算符一般是类的成员</li><li>递增、递减、解引用等运算符。通常是类的成员</li><li>具有对称性的运算符可能转换任意一端的运算对象。如算数、相等性、关系、位运算符，通常应该是普通的成员函数。</li></ul><h4 id="14-2-输入输出运算符"><a href="#14-2-输入输出运算符" class="headerlink" title="14.2 输入输出运算符"></a>14.2 输入输出运算符</h4><p>输出的运算符尽量减少格式化操作，只需要打印信息就可以了。<br>输入输出运算符必须是非成员函数。<br>输入时可能会发生错误，例如：当流含有错误类型的数据时读取可能失败，当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。所以在输入操作中，输入运算符应该负责读取错误发生时，从错误中恢复。</p><h4 id="14-3-算术和关系运算符"><a href="#14-3-算术和关系运算符" class="headerlink" title="14.3 算术和关系运算符"></a>14.3 算术和关系运算符</h4><p>代码的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data</div><div class="line">operator-(const Sales_data &amp;lhs,const Sales_data &amp;rhs)&#123;</div><div class="line">    Sales_data item=lhs;</div><div class="line">    item-=rhs;  //调用重载的-=运算符来定义。性能相同，只是增加代码的 复用，增加可读性</div><div class="line">    return item;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong> 相等运算符</strong>的定义：如果定义了<code>==</code>，那么这个类也要定义<code>!=</code>（因为对于用户来说，当他们使用了<code>==</code>时，他们应该也希望能使用<code>!=</code>），并且相等运算符和不相等运算符的一个应该把工作委托给另外一个，这样一个预算负责实际比较，另外一个负责调用。<br><strong> 关系运算符</strong>:一般定义了相等运算符后，也会定义关系运算符，特别是<code>&lt;</code>运算符。<br>关系运算符的原则：如果存在唯一逻辑可靠的<code>&lt;</code>定义，就考虑定义<code>&lt;</code>运算符。如果该类同时包含<code>==</code>运算符，则当且仅当<code>&lt;</code>的定义与<code>==</code>产生一致的结果时才定义<code>&lt;</code>运算符。</p><h4 id="14-4-赋值运算符"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符</h4><p>赋值运算符<code>=</code>和符合赋值运算符<code>+=</code>，通常都定义为类的成员，并且都应该返回左侧运算对象的引用。</p><h4 id="14-5-下标运算符"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符</h4><p>当我们需要按元素在容器中的位置访问元素时，通常定义一个下标运算符<code>operator[]</code>，必须是成员函数。通常会定义两个版本，一个返回普通引用，一个返回常量引用。</p><h4 id="14-6-递增和递减运算符"><a href="#14-6-递增和递减运算符" class="headerlink" title="14.6 递增和递减运算符"></a>14.6 递增和递减运算符</h4><p>后置运算符接受一个额外的（不被使用）int类型的形参，当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参<br>。前置运算符返回递增或者递减后的对象的引用，后置运算符返回对象的原值（即递增或递减之前的原值），返回的是一个值而非引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class StrBlobPtr&#123;</div><div class="line">    public:</div><div class="line">        StrBlobPtr&amp; operator++();  //前置递增运算符</div><div class="line">        StrBlobPtr&amp; operator++(int); //后置递增运算符</div><div class="line">&#125;</div><div class="line">...</div><div class="line">p.operator++(0); //显式的调用后置递增运算符</div><div class="line">p.operator++(); // 显式的调用前置递增运算符</div></pre></td></tr></table></figure></p><h4 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h4><p>箭头运算符必须是类的成员，解引用运算符通常也是类的成员，即使并非必须这么做。<br>箭头运算符永远不能丢掉成员访问的这个基本含义，当我们重载箭头运算符时，可以改变的是从哪个对象中获取成员，而获取成员这一事实永远不变。<br>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p><h4 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h4><p>如果类重载了函数调用运算符，我们就可以像调用函数一样使用该类的对象。函数调用运算符必须是成员函数，一个类可以定义多个函数运算符，之间用参数的数量和类型进行区分。<br>函数对象通常作为泛型算法的实参<br>lambda表达式：当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在这个类中，含有一个重载的函数调用运算符。捕获的对象相当于类内含有数据成员。是否含有默认/移动构造函数通常视捕获的对象而定。<br>标准库定义了一组表示算数运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。<br>标准库规定其函数对象对于指针同样适用。eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vector&lt;string *&gt; nameTable;</div><div class="line">sort(nameTable.begin(),nameTable.end(),</div><div class="line">[](string *a,string *b)&#123;return a&lt;b&#125;);   //错误，nameTable中的指针之间没有关系，所以&lt;将产生未定义的行为</div><div class="line"></div><div class="line">sort(nameTable.begin(),nameTable.end(),less&lt;string* &gt;()); //正确</div></pre></td></tr></table></figure></p><p>C++中的<strong>  可调用对象</strong>：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。可调用的对象也有类型。<br>不同类型可能具有相同的调用形式，可以定义一个<strong> 函数表</strong>用于存储指向这些可调用对象的“指针”。<br><strong> 标准库function类型</strong>：是一个模板，当创建具体的function类型时，需要我们提供额外的信息。eg：<code>function&lt;int (int,int)&gt;</code>表示接受2个int、返回1个int的可调用对象。不能直接将重载函数的名字存入function类型的对象中，可存储函数指针而不是函数的名字。</p><h4 id="14-9-重载、类型转换与运算符"><a href="#14-9-重载、类型转换与运算符" class="headerlink" title="14.9 重载、类型转换与运算符"></a>14.9 重载、类型转换与运算符</h4><p><strong> 转换构造函数和类型转换运算符</strong>共同定义了类类型转换，有时也被称作用户定义的类型转换。<br><code>operator type() const; //type表示某种类型</code>因为类型转换运算符是隐式执行的，所以无法传递实参，也不能定义形参。为了避免具有误导性的类型转换，在不存在明显映射关系的时候，应不适用。<br>显式的类型转换运算符。eg:<code>explicit operator int() const;</code>当类型转换运算符是显式的，必须通过显式的强制类型转换才可以。<strong> 如果表达式被用作条件，编译器会显式的自动转换。</strong><br>无论我们什么时候在条件中使用了流对象，都会使用为IO类型定义operator bool。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct Integral&#123;</div><div class="line">    operator const int(); //将对象转换成 const int</div><div class="line">    operator int() const; //将对象转换成 int，用的相对较多</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>应该避免使用二义性的类型转换，总体原则：除了显式的向bool类型的转换外，应该尽量避免定义类型转换函数，并且尽可能限制某些看起来显然正确的显式构造函数。<br>错误eg：定义了两种将B类转换为A类的方法，一种使用B的类型转换运算符，一种使用A的以B为参数的构造函数。</p><ul><li>不要另两个类执行相同的类型转换。</li><li>避免转换目标是内置算数类型的类型转换。<br>函数重载的类型匹配：当调用重载函数时，如果两个或多个用户定义的类型转换都提供了可行的匹配，那么这些类型转换被认为一样好。这意味着我们设计的不足。</li></ul>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的书单2017</title>
      <link href="/10-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9C%8B%E7%9A%84%E6%9D%82%E4%B9%A6/"/>
      <url>/10-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9C%8B%E7%9A%84%E6%9D%82%E4%B9%A6/</url>
      <content type="html"><![CDATA[<h5 id="2017要看完的书，生活总得有一些flag是吧"><a href="#2017要看完的书，生活总得有一些flag是吧" class="headerlink" title="2017要看完的书，生活总得有一些flag是吧"></a>2017要看完的书，生活总得有一些flag是吧</h5><p><a href="http://item.jd.com/12125924.html" target="_blank" rel="external">《人类简史》尤瓦尔·赫拉利</a><br><a href="http://item.jd.com/12099462.html" target="_blank" rel="external">《未来简史》尤瓦尔·赫拉利</a></p><hr><h5 id="2015-2016看的书："><a href="#2015-2016看的书：" class="headerlink" title="2015-2016看的书："></a>2015-2016看的书：</h5><p><a href="http://item.jd.com/12125924.html" target="_blank" rel="external">经济学通识</a><br><a href="">霍乱时期的爱情</a><br><a href="">围城</a><br><a href="">雅库玛的诅咒</a><br><a href="">今天你真好看</a><br><a href="">鬼吹灯1</a><br><a href="">北京折叠</a><br><a href="">百年孤独</a><br><a href="">活着</a></p><hr><h5 id="东野圭吾-专场"><a href="#东野圭吾-专场" class="headerlink" title=" 东野圭吾 专场"></a><strong> 东野圭吾 </strong>专场</h5><p><a href="">白夜行</a><br><a href="">嫌疑人X的现身</a><br><a href="">秘密</a><br><a href="">信</a><br><a href="">恶意</a><br><a href="">假面饭店</a><br><a href="">放学后</a><br><a href="">解忧杂货店</a><br><a href="">彷徨之刃</a></p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的hexo折腾笔记</title>
      <link href="/10-%E5%B7%A5%E5%85%B7/%E6%88%91%E7%9A%84hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/10-%E5%B7%A5%E5%85%B7/%E6%88%91%E7%9A%84hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="我的hexo折腾笔记–记录一下折腾的过程"><a href="#我的hexo折腾笔记–记录一下折腾的过程" class="headerlink" title="我的hexo折腾笔记–记录一下折腾的过程"></a>我的hexo折腾笔记–记录一下折腾的过程</h3><blockquote><p>没错，这几天又开始折腾一下博客了，最近的节奏天天白天待在实验室怼论文，晚上看C++，时间安排比较紧凑，就觉得更需要阶段性的总结吧，所以又来写博客了，github始终是一个好的选择，于是入了Hexo的坑。。折腾的过程心情总是有些复杂，在激动和mmp之间徘徊，虽然很多问题在wiki和issue里都有，但还是想总结一下自己亲自踩的坑。</p></blockquote><a id="more"></a><h5 id="Next主题个性化之自动更换背景图片"><a href="#Next主题个性化之自动更换背景图片" class="headerlink" title="Next主题个性化之自动更换背景图片"></a>Next主题个性化之自动更换背景图片</h5><p><a href="https://blog.csdn.net/mango_haoming/article/details/78473243" target="_blank" rel="external">https://blog.csdn.net/mango_haoming/article/details/78473243</a></p><h5 id="修改主题：yilia"><a href="#修改主题：yilia" class="headerlink" title="修改主题：yilia"></a>修改主题：yilia</h5><p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">https://github.com/litten/hexo-theme-yilia</a></p><h5 id="2018-4-22-加入畅言评论"><a href="#2018-4-22-加入畅言评论" class="headerlink" title="2018-4-22 加入畅言评论"></a>2018-4-22 加入畅言评论</h5><p>详见：<a href="https://blog.csdn.net/lcyaiym/article/details/76762074" target="_blank" rel="external">https://blog.csdn.net/lcyaiym/article/details/76762074</a></p><h5 id="2018-4-10-加入豆瓣读书和电影"><a href="#2018-4-10-加入豆瓣读书和电影" class="headerlink" title="2018-4-10 加入豆瓣读书和电影"></a>2018-4-10 加入豆瓣读书和电影</h5><p>详细见：<a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="external">https://github.com/mythsman/hexo-douban</a></p><h5 id="页面中文无法显示的问题"><a href="#页面中文无法显示的问题" class="headerlink" title="页面中文无法显示的问题"></a>页面中文无法显示的问题</h5><p>这种中文问题，基本上都是编码的问题，但是开始各种都没找到原因，改了language里面的配置文件，最后发现是文件的编码，需要改成’无bom的utf-8的编码格式 ‘</p><h5 id="主界面无法显示categories和tags的问题"><a href="#主界面无法显示categories和tags的问题" class="headerlink" title="主界面无法显示categories和tags的问题"></a>主界面无法显示categories和tags的问题</h5><p>这个问题真的是搞的有点久，因为基本上都被人忽略了，也可能很多人都没遇到而我恰好遇到了吧，不懂前端的我只能对于这种玄学问题强行百度了。<br>解决办法：将categories和tags目录下的index文件分别改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">categories:</div><div class="line">type: &quot;categories&quot;</div><div class="line">layout: &quot;categories&quot;</div><div class="line">tags:</div><div class="line">type: &quot;tags&quot;</div><div class="line">layout: &quot;tags&quot;</div></pre></td></tr></table></figure></p><p>折腾完又不早了，希望以后好好看书，好好编程吧，最近没有什么特别大的梦想，只想安静的学习。。。</p><h5 id="绑定gitpages到自己的域名"><a href="#绑定gitpages到自己的域名" class="headerlink" title="绑定gitpages到自己的域名"></a>绑定gitpages到自己的域名</h5><p>打开<a href="https://education.github.com/" target="_blank" rel="external">学生包</a>，通过教育邮箱申请之后，可以在package中找到那么namecheap，注册通过GitHub进入，可以直接申请域名，会自动绑定到我们的gitpage，不过还需要一点点修改，就是把cname的www改成我们的gitpage页面，就可以了。。</p><h5 id="采用coding和gitpages双部署"><a href="#采用coding和gitpages双部署" class="headerlink" title="采用coding和gitpages双部署"></a>采用coding和gitpages双部署</h5><p>采用双部署的原因是国内访问github的速度有时候太感人了，有些人直接打不开，搞得有点尴尬，于是看到了网上所说的双部署，将默认的国内地址解析到coding的pages服务上，其他的绑定到gitpage上，这样国内的访问速度就快了。<br>具体的coding pages的搭建就不写了，在coding网站中建好仓库后，在我们本地的config文件后面的push repository 加上coding page仓库的地址就可以了。<br>具体的cname记录和A记录如下图：<br><a href=""></a><br><strong> Reference: </strong><br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo文档</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">Next主题文档</a><br><a href="http://blog.csdn.net/dengnanyi/article/details/53969684" target="_blank" rel="external">绑定到coding</a></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch7 类</title>
      <link href="/27-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch7%E7%B1%BB/"/>
      <url>/27-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch7%E7%B1%BB/</url>
      <content type="html"><![CDATA[<blockquote><p>类是面向对象编程的基础，使用类定义自己的数据类型，可以更方便的解决问题中的各种概念，使我们更容易编写、调试和修改程序。</p></blockquote><a id="more"></a><h3 id="7-1-定义抽象的数据类型"><a href="#7-1-定义抽象的数据类型" class="headerlink" title="7.1 定义抽象的数据类型"></a>7.1 定义抽象的数据类型</h3><ul><li>定义在类内部的函数时隐式的inline函数。</li><li>类的所有成员都必须在类的内部声明，但是成员函数体可以定义在类的内部或外部。</li><li>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。</li><li>成员函数体可以随意使用类中的其他成员而不需要在意这些成员出现的次序。</li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>编译器创建的构造函数又被称为合成的默认构造函数，合成的默认构造函数初始化类的数据成员规则为：存在类内初始值的时候，用它来初始化成员；否则，默认初始化该成员。<br>对于一个普通的类，一般要定义自己的默认构造函数：</p><ol><li>编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</li><li>对于某些类来说，合成的默认构造函数可能执行错误的操作。</li><li>有的时候编译器不能为某些类合成默认的构造函数。</li></ol><ul><li>构造函数没有返回类型。</li></ul><h4 id="拷贝。赋值和析构"><a href="#拷贝。赋值和析构" class="headerlink" title="拷贝。赋值和析构"></a>拷贝。赋值和析构</h4><p>除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象的时候发生的行为。<br>当我们不主动定义这些操作的的时候，编译器将替我们合成他们。但是有些类不能依赖于合成的版本。当类需要分配类对象之外的资源时，合成的版本常常会失效。</p><h3 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h3><p>在类的定义中，可以包含0个或多个访问说明符，每个访问说明符指定接下来的成员访问级别，一般来说，作为接口的一部分，构造函数和一部分成员函数应该定义在public说明符之后，而数据成员和作为实现部分的函数跟在private说明符之后。<br>class和struct唯一的区别是默认访问权限不同。</p><h3 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h3><p>类型成员、类的成员的类内初始值、可变数据成员、内联数据成员、从成员函数返回*this、关于如何定义类类型及友元类等。</p><h4 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h4><p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制。</p><h4 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h4><p>在类中，一些规模较小的函数常被定义为内联函数<br>两种方式：1、直接把函数定义放在类的内部<br>          2、把函数定义放在类的外部，显式的使用inline</p><ul><li>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</li><li>在实践中，设计良好的代码常常包含很多的小函数，通过调用这些小函数，可以完成其他一组函数的“实际”工作。</li></ul><h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><ul><li>对于一个类来说，它的成员和其他任何类的成员都不是一回事。</li><li>类的声明：不完全类型的使用：可以定义指向这种类型的指针或引用，也可以声明（但不能完全定义）以不完全类型作为参数或者返回类型的函数。</li></ul><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类中包括非公有成员在内的所有成员。</p><ul><li>还可以另一个类的成员函数为自己的友元。</li><li>如果一个类想把一组重载函数声明称它的友元，需要对每一个分别声明。</li><li>友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。</li></ul><h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><ul><li>一个类就是一个作用域</li><li>函数的返回类型通常出现在函数名之前，所以返回类型是在类的作用域外的。</li><li>名字查找规则：首先名字所在快寻找声明语句；查找外层作用；报错。</li></ul><h4 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h4><ul><li>如果成员是const或引用的话，必须进行初始化；当成员属于某种类类型且该类没有定义构造函数时，也必须初始化。</li><li>使用构造函数初始值：不仅仅是底层效率的问题。另有一些数据成员必须被初始化。</li><li>成员初始化顺序：构造函数初始化列表值说明用于初始化成员的值，而不限定初始化的具体执行顺序。（尽量按照顺序初始化，并且避免使用某些成员初始化其他成员）</li><li>委托构造函数：</li><li>默认构造函数的作用：当对象被默认初始化或值初始化时自动执行默认构造函数</li><li>默认初始化发生:</li></ul><ol><li>块作用域内不适用任何初始值定义一个非静态变量或数组时。</li><li>一个类本身含有类类型的成员且使用合成的默认构造函数。</li><li>类类型的成员没有在构造函数初始值列表中显式的初始化。</li></ol><ul><li>值初始化发生：</li></ul><ol><li>数组初始化时提供的初始值数量小于数组的大小</li><li>不使用初始值定义一个局部的静态变量</li><li>书写形如T()的表达式显式的请求值初始化</li></ol><ul><li><p>隐式的类类型转换：能通过一个实参调用的构造函数定义一条从构造函数的参数类型向类类型隐式转换的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string null_book=&quot;2132321&quot;;</div><div class="line">item.combine(null_book);//将一个string的实参传递给了combine成员。</div></pre></td></tr></table></figure></li><li><p>隐式类型转换只能一步，可以使用explicit阻止隐式类型转换。</p></li><li>字面值常量类至少提供一个constexpr构造函数<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3></li></ul>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch4 表达式</title>
      <link href="/05-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch4%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/05-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch4%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<blockquote><p>不管学习什么语言都会有这么一章，不管是c、java、Python，这都是会经历的一章，唉，无奈当时年少无知不止梦想是什么的我每每看到这些的时候都觉得很烦。当再一次翻开c++的这一章的时候，也有这样的感觉，似曾相识燕归来，却又无可奈何花落去。<br>我认为这一章的很多都不是需要太多的去深究，只需要有个大概的概念，然后更多的是在今后的编程过程中，不断的实践自然就知道了，是怎样写的。而且累死一些优先级的问题，更多的时候就像书里建议的那样，一个括号来的简单粗暴实用的多，所以，这章，就记一下实在有违常规的理解的内容吧。</p></blockquote><a id="more"></a><h3 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h3><ul><li>运算对象转换：小整数类型（如bool、char、short等）通常会被提升为较大的整数类型，主要是int。</li><li>左值和右值：一个左值表达式的求值结果时一个对象或者一个函数，以常量对象为代表的某些左值不能作为赋值语句的左侧运算对象。<strong> 简单归纳：当对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置） </strong></li><li>左值右值使用原则：需要右值的地方可以用左值代替，但是不能把右值当成左值使用。当一个左值被当成一个右值使用的时候，实际上使用的是它的内容（值  ）</li><li>需要用到左值的地方：<br>1.赋值运算符。需要左值作为其左值运算对象，得到结果仍然是一个左值<br>2.取地址符。返回一个指向该运算对象的指针，这个指针是一个右值<br>3.内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值<br>4.内置类型和迭代器的递增递减运算符作用于左值运算对象，得到的结果是左值。</li><li>关键字decltype中左值和右值的不同</li><li>处理复合表达式的经验：使用括号；如果改变了某个运算对象的值，就不要在表达式的其它地方再使用这个运算对象</li></ul><h3 id="4-2-算数运算符"><a href="#4-2-算数运算符" class="headerlink" title="4.2 算数运算符"></a>4.2 算数运算符</h3><p>溢出的情况，值会发生“环绕”</p><h3 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h3><p>进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值作为运算对象</p><h3 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h3><p>赋值运算满足右结合律<br>参与连续赋值的变量必须是相同的类型</p><h3 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h3><h3 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h3><p>解应用运算符的优先级低于点运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cond?expr1:expr2;</div><div class="line">//输出表达式中使用条件运算符</div><div class="line">cout&lt;&lt;((grade&lt;60)?&quot;fail&quot;:&quot;pass&quot;); //输出pass或者fail</div></pre></td></tr></table></figure></p><p>条件运算符可以嵌套，一般为了代码的可读性，嵌套不要超过三层。</p><h3 id="4-7-sizeof运算符"><a href="#4-7-sizeof运算符" class="headerlink" title="4.7 sizeof运算符"></a>4.7 sizeof运算符</h3><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得值是一个size_t类型的常量表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sizeof(type)</div><div class="line">sizeof expr</div></pre></td></tr></table></figure></p><h3 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h3><p>首先对左侧表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。</p><h3 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h3><h4 id="发生隐式类型转换"><a href="#发生隐式类型转换" class="headerlink" title="发生隐式类型转换"></a>发生隐式类型转换</h4><ul><li>比int小的整形值首先提升为较大的整数类型</li><li>条件中，非bool值转为bool值。</li><li>初始化过程中，初始值转化为变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型</li><li>如果算数预算或关系运算对象有多种类型，需要转换成同一种类型。</li><li>函数调用时，也可能发生类型转换</li></ul><h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cast-name&lt;type&gt;(expression)</div><div class="line">cast-name:static_cast,dynamic_cast,const_cast,reinterpret_cast</div></pre></td></tr></table></figure><p>static_cast:任何具有明确定义的类型转换，只要不包含底层const都可以使用。<br>const_cast:只能改变运算对象的底层const<br>dynamic_cast：支持运行时类型识别<br>reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释。（使用起来非常危险）</p><p><strong> 尽量避免强制类型转换 </strong></p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch3 字符串、向量和数组</title>
      <link href="/04-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch3/"/>
      <url>/04-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch3/</url>
      <content type="html"><![CDATA[<h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><h3 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h3><h3 id="头文件中不应该包含using声明"><a href="#头文件中不应该包含using声明" class="headerlink" title="头文件中不应该包含using声明"></a>头文件中不应该包含using声明</h3><p>因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。</p><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string s1;   //默认初始化</div><div class="line">string s2=s1;  //s2是s1的副本</div><div class="line">string s2(s1); //等价于string s2=s1,s2是s1的副本</div><div class="line">string s3=&quot;hiya&quot;;  //s3是字面值的副本，但是不包含字面值最后的那个空字符</div><div class="line">string s3(&quot;hiya&quot;);  //等价于string s3=&quot;hiya&quot;</div><div class="line">string s4(n,&apos;c&apos;);  //把s4初始化为连续n个字符c组成的字符串</div></pre></td></tr></table></figure><h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><ul><li>读写string对象</li><li>读取未知数量的string对象</li><li>使用getline读取一整行</li><li>string的empty和size操作<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3>size_type是一种无符号整形数，如果在表达式中混用了带符号数和无符号数会产生意想不到的后果。<h3 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h3>按字典顺序<h3 id="字面值和string类型相加"><a href="#字面值和string类型相加" class="headerlink" title="字面值和string类型相加"></a>字面值和string类型相加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//错误的方式</div><div class="line">string s=&quot;hello&quot;+&quot;,&quot; //错误，因为两个运算对象都不是string，不能把两个字面值直接相加</div><div class="line">string s1=&quot;hello&quot;+s1+&quot;,&quot; //正确</div></pre></td></tr></table></figure></li></ul><p><strong> 字符串字面值与string是不同的类型 </strong></p><h3 id="ex3-3-string类的输入运算和getline函数分别如何处理字符串"><a href="#ex3-3-string类的输入运算和getline函数分别如何处理字符串" class="headerlink" title="ex3.3 string类的输入运算和getline函数分别如何处理字符串"></a>ex3.3 string类的输入运算和getline函数分别如何处理字符串</h3><p>string的标准输入：自动忽略字符串开头的空白，从第一个真正的字符开始读取，直到下一个空白为止<br>getline函数：从给定的输入流中读取，直到遇到换行符为止。</p><h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><p>vector是一种类模板，需要后加一堆尖括号，在括号内放上信息。</p><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><ul><li>1.使用拷贝初始化</li><li>2.如果提供一个类内的初始值，只能使用拷贝初始化或者花括号形式初始化</li><li>3.如果提供的是初始值元素值的列表，则只能使用花括号初始化，而不能使用圆括号</li><li>4.创建指定数量的元素：采用圆括号<h3 id="3-3-2-像vector中添加元素"><a href="#3-3-2-像vector中添加元素" class="headerlink" title="3.3.2 像vector中添加元素"></a>3.3.2 像vector中添加元素</h3>push_back：像一个值添加到vector的尾部。（如果开始不知道有多少元素，c++中，一般先创建一个空的vector然后像其中添加元素最好）<br>不能使用下标形式添加元素，只能对确知已存在的元素执行下标操作。</li></ul><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p>迭代器这个名词可能有三种不同的含义：可能是迭代器概念本身，可能是容器定义的类型，还可能指某个迭代器对象。<br>某些对Vector对象的操作回事迭代器失效：一个是不能在范围for循环内向vector中添加元素，另一个是任何一种可能改变vector对象容量的操作，都有可能是vector对象的迭代器失效。</p><h3 id="迭代器的算数运算"><a href="#迭代器的算数运算" class="headerlink" title="迭代器的算数运算"></a>迭代器的算数运算</h3><p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。<br>迭代器之间的比较：参与比较的迭代器必须合法且指向同一个容器的元素（或者尾元素的下一个位置）</p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组与vector的区别：数组的大小确定不变，不能随意像数组中添加元素。性能很好，但是损失了灵活性。</p><h3 id="3-5-1-定义和初始化数组"><a href="#3-5-1-定义和初始化数组" class="headerlink" title="3.5.1 定义和初始化数组"></a>3.5.1 定义和初始化数组</h3><p>数组是一种复合类型，数组的维度必须是一个常量表达式。<br>定义数组的时候必须指定数组的类型。同时，数组的元素应该为对象，不存在引用的数组。</p><h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char a1[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，没有空字符</div><div class="line">char a2[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，含有显式的空字符</div><div class="line">char a3[]=&quot;C++&quot;;   //自动添加表示字符串结束的空字符</div></pre></td></tr></table></figure><h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p><strong> 要想理解数组的声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int &amp;refs[10]=...  //  错误！不存在数组的引用</div><div class="line">int (*Parray)[10]=&amp;arr; //Parray指向一个含有10个整数的数组</div><div class="line">int (&amp;arrRef)[10]=arr   //arrRef引用一个含有10个整数的数组</div><div class="line">int *ptrs[10];  //ptrs是一个含有10个整型指针的数组</div></pre></td></tr></table></figure></p><h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><ul><li>数组下标为<strong> size_t类型 </strong>，是一种机器相关的无符号类型。<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3>使用数组的时候编译器一般会把它转化成指针<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4>允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。<br>C风格字符串和字符数组的关系，尤其需要考虑串尾是否含有空字符。<br><strong> 问题：为什么没有指针相加？ </strong><br>指着也是一个对象，与指针有关的属性有三个，分别是指针的值（是一个内存地址值）、指针所指的对象、指针本身在内存中的存储位置。显然把两个地址加在一起是没有意义的。<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><h4 id="混用string对象和C风格字符串"><a href="#混用string对象和C风格字符串" class="headerlink" title="混用string对象和C风格字符串"></a>混用string对象和C风格字符串</h4></li><li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</li><li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（但不能两个都是）；在string对象的赋值运算中允许以空字符串结束的字符数组作为右侧的运算对象。<h4 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h4>允许使用数组初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址即可。但不能使用一个数组为另一个内置类型的数组赋初值，也不能使用vector对象初始化数组。<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。<br>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int ia[3][4] //大小为3的数组，每个元素是含有4个整数的数组</div></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch2 变量和基本类型</title>
      <link href="/04-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch2/"/>
      <url>/04-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch2/</url>
      <content type="html"><![CDATA[<p>数据类型决定了程序中数据和操作的意义。</p><a id="more"></a><h1 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h1><p>基本数据类型：<strong> 算数类型  空类型（void） </strong>,其中算数类型包括：字符、正整数、布尔值、浮点数。空类型不对应具体的值，用于一些特殊的场合。</p><h2 id="2-1-1-算数类型"><a href="#2-1-1-算数类型" class="headerlink" title="2.1.1 算数类型"></a>2.1.1 算数类型</h2><p>分为整形和浮点型。</p><h3 id="整形："><a href="#整形：" class="headerlink" title="整形："></a>整形：</h3><ul><li>bool:取值为true或者false。</li><li>char：基本的字符类型，一个char的大小与一个机器字节一样。</li><li>wchar_t,char16_t,char32_t<br><strong> rules: </strong>一个int至少和一个short一样大，一个long至少跟一个int一样大，一个long long至少跟一个long一样大。</li></ul><h3 id="浮点型："><a href="#浮点型：" class="headerlink" title="浮点型："></a>浮点型：</h3><ul><li>float：一般一个字，32bit</li><li>double：2个字，64bit</li><li>long double：3或4个字，96或128bit<h3 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a>带符号类型和无符号类型</h3><h2 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h2><h3 id="转换过程："><a href="#转换过程：" class="headerlink" title="转换过程："></a>转换过程：</h3></li><li>非bool到bool：初始为0则为false，其他为true</li><li>bool到非bool：初始值为false则为0，初始值为true为1</li><li>浮点数到整型：仅保留浮点数中的<strong> 小数点部分 </strong></li><li>整数到浮点数：小数部分记为0，如果整数所占的空间超过浮点类型的容量，会报错。</li><li>赋给无符号类型，当超出它表示范围的时候，转换为该无符号类型表示数值总数取模后的余数。</li><li>给带符号的数输出超过范围的值是，结果时<strong> 未定义的 </strong></li></ul><p>tips:一般不在算数表达式中使用bool值</p><h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p>一般不要混用无符号和有符号的类型，当无符号超过范围时，可能会出现取模的情况，放在循环中，或者计算结果中，会产生无法预计的结果</p><h2 id="2-1-3-字面值常量"><a href="#2-1-3-字面值常量" class="headerlink" title="2.1.3 字面值常量"></a>2.1.3 字面值常量</h2><p>顾名思义，字面值常量一望而知。每个字面值常量对应一种数据类型，字面量常量得形式和值决定了它的数据类型。</p><h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><p>严格来说，十进制字面值不会是负数，通常，负号并不在字面值内，它的作用仅仅是对字面值取负值而已。</p><h3 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h3><ul><li>char型字面值：由单引号括起来的一个字符</li><li>字符串字面值：由双引号括起来的零个或多个字符<br><strong> Note：字符串字面值的类型实际上是由常量字符组成的数组，编译器在每个字符串的结尾处添加一个空字符（’\0’），字符串的字面值的实际长度比它的内容多1。 </strong><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3>有两类不能直接使用的字符。不可打印的和特殊含义的字符（单引号，双引号，问号，反斜线），这些情况下需要使用转义字符。<h3 id="指定字面值类型"><a href="#指定字面值类型" class="headerlink" title="指定字面值类型"></a>指定字面值类型</h3>添加一定的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。前缀有：u（Unicode16）、U（Unicode32）、L（宽字符）、u8（UTF-8）。后缀有：u或者U（unsigned）、l或者L（ling）、ll或者LL（long long），f或者F（float）、l或者L（long double）。<h3 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h3>bool：true、false<br>指针：nullptr<h1 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h1>对于c++来说，一般“变量”和“对象”可以互换使用。对象时具有某种数据类型的内存空间。<h2 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h2>基本形式：类型说明符+一个或多个变量名组成的列表（变量名以逗号分隔）+分号<h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3>当对象在创建时获得了一个特定的值，称为被初始化了。<strong> 初始化和复制是两个完全不同的操作，注意这个概念很重要 </strong><br>初始化：在创建变量是赋予其一个初始值。<br>复制：把对象的当前值擦除，以一个新的值代替。<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3>无论是初始化对象还是某些时候为对象赋新值，都可以使用一组又花括号括起来的初始值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int units_sold=0;</div><div class="line">int units_sold=&#123;0&#125;;</div><div class="line">int units_sold&#123;0&#125;;</div><div class="line">int units_sold(0);</div></pre></td></tr></table></figure></li></ul><h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式的初始化，则其值由类确定。。建议初始化每一个内置类型的变量。</p><h2 id="2-2-2-变量声明与定义的关系"><a href="#2-2-2-变量声明与定义的关系" class="headerlink" title="2.2.2 变量声明与定义的关系"></a>2.2.2 变量声明与定义的关系</h2><p>声明使得名字为程序所知，定义负责创建与名字关联的实体。<br><strong> extern </strong>关键字：如果想声明一个变量而不是定义它，就在变量名前添加extern，而不显示的初始化变量。如果在函数体内部试图初始化一个有extern关键字标记的变量，会引发错误。</p><h2 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h2><p>用户自定义的标识符中不能出现两个连续的下划线，也不能以下划线紧连大写字母开头。定义在函数体内的标识符不能以下划线开头。</p><h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><ul><li>标识符要能体现实际含义</li><li>变量名一般小写字母</li><li>自定义的类名一般大写字母开头</li><li>标识符由多个单词组成时，单词应有明显区分，使用下划线<h2 id="2-2-4-名字的作用域"><a href="#2-2-4-名字的作用域" class="headerlink" title="2.2.4 名字的作用域"></a>2.2.4 名字的作用域</h2>当内层出现与外层相同的名字时，使用内层定义的名字。<h1 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h1>复合类型指的是基于其他类型定义的类型。这里介绍两种：引用和指针。<h2 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h2>引用为对象起了另外一个名字，引用；类型引用另外一种类型。通过将生命符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用必须初始化。<h3 id="引用即别名"><a href="#引用即别名" class="headerlink" title="引用即别名"></a>引用即别名</h3>引用并不是对象，只是一个已经存在的对象起的另外一个名字。定义了一个引用之后，对其做的所有操作都是在与之绑定的对象上进行的。<br>因为引用本身只是一个别名，不是一个对象，所以不能定义引用的引用。<h3 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h3>除了两种例外的情况，其他所有的引用类型都要与之绑定的对象严格比配。<br>引用只能绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。<h2 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h2>指针是“指向point to”的另外一种类型的复合引用。指针也实现了对其他对象的间接访问。<br>两者的不同点：</li><li>1.指针本身就是一个对象，允许对指针赋值和拷贝，而且指针的生命周期内可以指向多个不同的对象。</li><li>2.指针无需在定义时赋初值。<h3 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h3>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）<br>不能定义指向引用的指针（因为引用不是一个对象）。<br>除了两种例外的情况，所有指针的类型都要和它指向的对象严格匹配。<h3 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h3>指针的值（即地址）应该属于下面四种状态之一：</li><li>1.指向一个对象</li><li>2.指向紧邻对象所占空间的下一个位置</li><li>3.空指针，表示没有指向任何对象。</li><li>4.无效指针，上述之外的其他值。<h3 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h3>如果指针指向了一个对象，允许使用解引用符（操作符*）来访问对象。<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3>空指针不指向任何对象，得到空指针的办法：直接用字面值nullptr初始化指针或者将指针初始化为字面值0来生成空指针。<br><strong> 建议 </strong>：初始化所有指针<h3 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h3>记住赋值永远改变的是等号左侧的对象。<h3 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h3>只要一个指针拥有合法值，就能将它用在条件表达式中，只要不为空，条件都为true。<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h3>void* 是一种特殊的指针类型，可用于存放任意对象的地址。<h2 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h2>变量的定义包括：一个基本数据类型+一组声明符。基本数据类型只有一个，但是声明符的形式可以不同。<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3>当有多个修饰符连写在一起的时候，按照逻辑关系解释。<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3>引用本身不是对象，但是指针是对象，所以可以对指针引用。<br>面对一条复杂的指针或引用的声明语句时，从右向左阅读有助于弄清真实含义。<h1 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h1><h3 id="初始化和const"><a href="#初始化和const" class="headerlink" title="初始化和const"></a>初始化和const</h3>const与非const对象的区别就是，const类型的对象执行不改变起内容的操作。如：const int也能像int一样参与算术运算，也能转化为bool值。<h3 id="默认状态下，const对象仅在文件内有效"><a href="#默认状态下，const对象仅在文件内有效" class="headerlink" title="默认状态下，const对象仅在文件内有效"></a>默认状态下，const对象仅在文件内有效</h3>如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字。<h2 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h2>可以把引用绑定到const对象上，就像绑定到其他对象上一样，称为对常量引用，对常量的引用不能修改它所绑定的对象。<br><strong> 术语：常量引用是对const的引用 </strong>：并不存在常量引用，是对const的引用。<h3 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h3>引用情况的例外：第一种是，在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。<h3 id="对const的引用可能引用一个非const的对象"><a href="#对const的引用可能引用一个非const的对象" class="headerlink" title="对const的引用可能引用一个非const的对象"></a>对const的引用可能引用一个非const的对象</h3>此种行为是合法的，但是不能通过对const的引用改变对象的值，兑现可以通过其他的方式改变值。<h2 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h2>指向常量的指针不能改变其所指对象的值，要想存放常量对象的地址，只能只用指向常量的指针。<br>所谓指向常量的指针和引用，只是自以为指向了一个常量，所以自觉不去改变所指对象的值。<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3>*const：不变的是指针的值而不是指向的那个值。采用从右向左的方式阅读，看离最近的符号。<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3>顶层const表示指针本身是个常量，底层const表示指针指的对象是一个常量。<br>当对象执行拷贝操作时，顶层const不受影响，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转化。<h2 id="2-4-4-constexpr和常量表达式"><a href="#2-4-4-constexpr和常量表达式" class="headerlink" title="2.4.4 constexpr和常量表达式"></a>2.4.4 constexpr和常量表达式</h2>常量表达式指：值不会改变且在编译过程就能得到计算结果的表达式。（字面值、用常量表达式初始化的const对象）<h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3>声明为constexpr的变量一定是一个变量，且必须用常量表达式初始化。<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><h3 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h3>在constexpr如果定义了一个指针，则constexpr只对指针有效，与指针所指的对象无关。<h1 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h1><h2 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h2>类型别名是一个名字，是某种类型的同义词。使用方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef double wages  //wages 是double的别名</div><div class="line">typedef wages base,*p</div><div class="line"></div><div class="line">#别名声明</div><div class="line">using SI=Scales_item;</div></pre></td></tr></table></figure></li></ul><h3 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h3><h2 id="2-5-2-auto类型说明符"><a href="#2-5-2-auto类型说明符" class="headerlink" title="2.5.2 auto类型说明符"></a>2.5.2 auto类型说明符</h2><h3 id="复合类型、常量和auto"><a href="#复合类型、常量和auto" class="headerlink" title="复合类型、常量和auto"></a>复合类型、常量和auto</h3><ul><li>引用时的auto，以引用对象的类型作为auto的类型</li><li>auto一般会忽略掉顶层const，底层const会保留下来。</li><li>可以将引用的类型设为auto<h2 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h2>选择并返回操作数的类型，编译器分析表达式并得到类型，但并不实际计算值<h3 id="decltype和引用"><a href="#decltype和引用" class="headerlink" title="decltype和引用"></a>decltype和引用</h3>有些表达式将向decltype返回一个引用类型。如果表达式的内容是解引用操作，则decltype将得到引用类型。<br>解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。<br>decltype和auto的重要区别：decltype的结果类型与表达式形式密切相关。<br><strong> 如果给变量加上一层或多层括号，decltype就会得到引用类型。decltype((val))的结果永远是引用，decltype(val)只有当val本身是一个引用时才是引用。另外，赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型 </strong></li></ul><h1 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h1><h2 id="定义自己的数据结构"><a href="#定义自己的数据结构" class="headerlink" title="定义自己的数据结构"></a>定义自己的数据结构</h2><h2 id="定义自己的头文件"><a href="#定义自己的头文件" class="headerlink" title="定义自己的头文件"></a>定义自己的头文件</h2><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《c++primer》ch3 字符串、向量和数组</title>
      <link href="/04-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch3%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/04-cpp/cpp-primer/%E3%80%8Acpp%20primer%E3%80%8Bch3%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><h3 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h3><h3 id="头文件中不应该包含using声明"><a href="#头文件中不应该包含using声明" class="headerlink" title="头文件中不应该包含using声明"></a>头文件中不应该包含using声明</h3><p>因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。</p><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string s1;   //默认初始化</div><div class="line">string s2=s1;  //s2是s1的副本</div><div class="line">string s2(s1); //等价于string s2=s1,s2是s1的副本</div><div class="line">string s3=&quot;hiya&quot;;  //s3是字面值的副本，但是不包含字面值最后的那个空字符</div><div class="line">string s3(&quot;hiya&quot;);  //等价于string s3=&quot;hiya&quot;</div><div class="line">string s4(n,&apos;c&apos;);  //把s4初始化为连续n个字符c组成的字符串</div></pre></td></tr></table></figure><h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><ul><li>读写string对象</li><li>读取未知数量的string对象</li><li>使用getline读取一整行</li><li>string的empty和size操作<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3>size_type是一种无符号整形数，如果在表达式中混用了带符号数和无符号数会产生意想不到的后果。<h3 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h3>按字典顺序<h3 id="字面值和string类型相加"><a href="#字面值和string类型相加" class="headerlink" title="字面值和string类型相加"></a>字面值和string类型相加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//错误的方式</div><div class="line">string s=&quot;hello&quot;+&quot;,&quot; //错误，因为两个运算对象都不是string，不能把两个字面值直接相加</div><div class="line">string s1=&quot;hello&quot;+s1+&quot;,&quot; //正确</div></pre></td></tr></table></figure></li></ul><p><strong> 字符串字面值与string是不同的类型 </strong></p><h3 id="ex3-3-string类的输入运算和getline函数分别如何处理字符串"><a href="#ex3-3-string类的输入运算和getline函数分别如何处理字符串" class="headerlink" title="ex3.3 string类的输入运算和getline函数分别如何处理字符串"></a>ex3.3 string类的输入运算和getline函数分别如何处理字符串</h3><p>string的标准输入：自动忽略字符串开头的空白，从第一个真正的字符开始读取，直到下一个空白为止<br>getline函数：从给定的输入流中读取，直到遇到换行符为止。</p><h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><p>vector是一种类模板，需要后加一堆尖括号，在括号内放上信息。</p><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><ul><li>1.使用拷贝初始化</li><li>2.如果提供一个类内的初始值，只能使用拷贝初始化或者花括号形式初始化</li><li>3.如果提供的是初始值元素值的列表，则只能使用花括号初始化，而不能使用圆括号</li><li>4.创建指定数量的元素：采用圆括号<h3 id="3-3-2-像vector中添加元素"><a href="#3-3-2-像vector中添加元素" class="headerlink" title="3.3.2 像vector中添加元素"></a>3.3.2 像vector中添加元素</h3>push_back：像一个值添加到vector的尾部。（如果开始不知道有多少元素，c++中，一般先创建一个空的vector然后像其中添加元素最好）<br>不能使用下标形式添加元素，只能对确知已存在的元素执行下标操作。</li></ul><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p>迭代器这个名词可能有三种不同的含义：可能是迭代器概念本身，可能是容器定义的类型，还可能指某个迭代器对象。<br>某些对Vector对象的操作回事迭代器失效：一个是不能在范围for循环内向vector中添加元素，另一个是任何一种可能改变vector对象容量的操作，都有可能是vector对象的迭代器失效。</p><h3 id="迭代器的算数运算"><a href="#迭代器的算数运算" class="headerlink" title="迭代器的算数运算"></a>迭代器的算数运算</h3><p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。<br>迭代器之间的比较：参与比较的迭代器必须合法且指向同一个容器的元素（或者尾元素的下一个位置）</p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组与vector的区别：数组的大小确定不变，不能随意像数组中添加元素。性能很好，但是损失了灵活性。</p><h3 id="3-5-1-定义和初始化数组"><a href="#3-5-1-定义和初始化数组" class="headerlink" title="3.5.1 定义和初始化数组"></a>3.5.1 定义和初始化数组</h3><p>数组是一种复合类型，数组的维度必须是一个常量表达式。<br>定义数组的时候必须指定数组的类型。同时，数组的元素应该为对象，不存在引用的数组。</p><h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char a1[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，没有空字符</div><div class="line">char a2[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，含有显式的空字符</div><div class="line">char a3[]=&quot;C++&quot;;   //自动添加表示字符串结束的空字符</div></pre></td></tr></table></figure><h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p><strong> 要想理解数组的声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int &amp;refs[10]=...  //  错误！不存在数组的引用</div><div class="line">int (*Parray)[10]=&amp;arr; //Parray指向一个含有10个整数的数组</div><div class="line">int (&amp;arrRef)[10]=arr   //arrRef引用一个含有10个整数的数组</div><div class="line">int *ptrs[10];  //ptrs是一个含有10个整型指针的数组</div></pre></td></tr></table></figure></p><h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><ul><li>数组下标为<strong> size_t类型 </strong>，是一种机器相关的无符号类型。<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3>使用数组的时候编译器一般会把它转化成指针<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4>允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。<br>C风格字符串和字符数组的关系，尤其需要考虑串尾是否含有空字符。<br><strong> 问题：为什么没有指针相加？ </strong><br>指着也是一个对象，与指针有关的属性有三个，分别是指针的值（是一个内存地址值）、指针所指的对象、指针本身在内存中的存储位置。显然把两个地址加在一起是没有意义的。<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><h4 id="混用string对象和C风格字符串"><a href="#混用string对象和C风格字符串" class="headerlink" title="混用string对象和C风格字符串"></a>混用string对象和C风格字符串</h4></li><li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</li><li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（但不能两个都是）；在string对象的赋值运算中允许以空字符串结束的字符数组作为右侧的运算对象。<h4 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h4>允许使用数组初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址即可。但不能使用一个数组为另一个内置类型的数组赋初值，也不能使用vector对象初始化数组。<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。<br>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int ia[3][4] //大小为3的数组，每个元素是含有4个整数的数组</div></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单脚本git一键提交代码</title>
      <link href="/01-%E5%B7%A5%E5%85%B7/%E7%AE%80%E5%8D%95%E8%84%9A%E6%9C%ACgit%E4%B8%80%E9%94%AE%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/"/>
      <url>/01-%E5%B7%A5%E5%85%B7/%E7%AE%80%E5%8D%95%E8%84%9A%E6%9C%ACgit%E4%B8%80%E9%94%AE%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<hr><p>自己的git使用<br><a id="more"></a></p><blockquote><p>git是我们每天都会使用的工具，但是一般的使用还是直接通过几个简单的命令，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;...&quot;</div><div class="line">git push origin master</div></pre></td></tr></table></figure></p></blockquote><!-- more --><p>对于这种简单的步骤，我们每天都会重复无数次，所以巨懒如我就干脆搞个小脚本，直接点一下就提交了。。</p><h2 id="一、Window使用bat脚本一键提交代码"><a href="#一、Window使用bat脚本一键提交代码" class="headerlink" title="一、Window使用bat脚本一键提交代码"></a>一、Window使用bat脚本一键提交代码</h2><p>直接新建文件，保存成.bat格式，编辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">title GIT提交批处理——小二三不乌</div><div class="line">color 16</div><div class="line"></div><div class="line"></div><div class="line">echo 开始提交代码到本地仓库</div><div class="line">echo 当前目录是：%cd%</div><div class="line"></div><div class="line">echo 开始添加变更</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git add -A .</div><div class="line">echo 执行结束！</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 提交变更到本地仓库</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">set /p declation=输入修改:</div><div class="line">git commit -m &quot;%declation%&quot;</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 将变更情况提交到远程git服务器</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git push origin master</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 批处理执行完毕！</div><div class="line">echo;</div><div class="line"></div><div class="line">pause</div></pre></td></tr></table></figure></p><h2 id="二、编写Python脚本一键提交代码"><a href="#二、编写Python脚本一键提交代码" class="headerlink" title="二、编写Python脚本一键提交代码"></a>二、编写Python脚本一键提交代码</h2><p><strong>额，用Python 好像就比较简单，但是还得cmd输一下，所以还是算了吧。。。 </strong></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用gitpage+Hexo搭建自己的博客</title>
      <link href="/31-%E5%B7%A5%E5%85%B7/hexo+gitpage/"/>
      <url>/31-%E5%B7%A5%E5%85%B7/hexo+gitpage/</url>
      <content type="html"><![CDATA[<hr><h2 id="如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。"><a href="#如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。" class="headerlink" title="如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。"></a>如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。</h2><a id="more"></a><p><strong>摘自：<a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="external">https://xuanwo.org/2015/03/26/hexo-intor/</a> </strong>写的很详细了，就不仔细写一遍了，就当个记录吧，以后出问题了好解决一点。</p><h2 id="一、准备工作，准备需要准备好以下软件："><a href="#一、准备工作，准备需要准备好以下软件：" class="headerlink" title="一、准备工作，准备需要准备好以下软件："></a>一、准备工作，准备需要准备好以下软件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Node.js环境</div><div class="line">Git</div></pre></td></tr></table></figure><h3 id="1-Windows配置Node-js环境下载Node-js安装文件："><a href="#1-Windows配置Node-js环境下载Node-js安装文件：" class="headerlink" title="1.Windows配置Node.js环境下载Node.js安装文件："></a>1.Windows配置Node.js环境下载Node.js安装文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Windows Installer 32-bit</div><div class="line">Windows Installer 64-bit</div></pre></td></tr></table></figure><ul><li><p>根据自己的Windows版本选择相应的安装文件。<br><img src="https://xuanwo.org/imgs/opinion/Nodejs-install.png" alt=""></p></li><li><p>保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口：<br><img src="http://upload-images.jianshu.io/upload_images/6054281-bc2e6deb5f394f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li>在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~） 在打开的命令行界面中，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node -v</div><div class="line">npm -v</div></pre></td></tr></table></figure></li></ul><p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。<br>(<a href="https://xuanwo.org/imgs/opinion/Nodejs-test.png" target="_blank" rel="external">https://xuanwo.org/imgs/opinion/Nodejs-test.png</a>)</p><h3 id="2-配置Git环境下载Git安装文件："><a href="#2-配置Git环境下载Git安装文件：" class="headerlink" title="2.配置Git环境下载Git安装文件："></a>2.配置Git环境下载Git安装文件：</h3><p><a href="https://github.com/git-for-windows/git/releases/download/v2.6.3.windows.1/Git-2.6.3-64-bit.exe" target="_blank" rel="external">Git-2.6.3-64-bit.exe</a></p><p>然后就进入了Git的安装界面，如图：<br><img src="https://xuanwo.org/imgs/opinion/Git-install.png" alt=""><br>和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择：<br><img src="https://xuanwo.org/imgs/opinion/Git-path-setting.png" alt=""></p><blockquote><p>这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。</p></blockquote><p>一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git --version</div></pre></td></tr></table></figure></p><p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。<br><img src="https://xuanwo.org/imgs/opinion/Git-test.png" alt=""></p><h2 id="二、新建仓库"><a href="#二、新建仓库" class="headerlink" title="二、新建仓库"></a>二、新建仓库</h2><h3 id="1-打开https-github-com-，在下图的框中，分别输入自己的用户名，邮箱，密码。"><a href="#1-打开https-github-com-，在下图的框中，分别输入自己的用户名，邮箱，密码。" class="headerlink" title="1.打开https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。"></a>1.打开<a href="https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。" target="_blank" rel="external">https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。</a></h3><h3 id="2-创建代码库登陆之后，点击页面右上角的加号，选择New-repository："><a href="#2-创建代码库登陆之后，点击页面右上角的加号，选择New-repository：" class="headerlink" title="2.创建代码库登陆之后，点击页面右上角的加号，选择New repository："></a>2.创建代码库登陆之后，点击页面右上角的加号，选择New repository：</h3><p>进入代码库创建页面：<br>在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示：<br><img src="https://xuanwo.org/imgs/opinion/Github-new-repo-setting.png" alt=""><br>正确创建之后，你将会看到如下界面：<br><img src="https://xuanwo.org/imgs/opinion/Github-new-repo-look-like.png" alt=""><br>开启gh-pages功能点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图：<br><img src="https://xuanwo.org/imgs/opinion/Github-pages.png" alt=""><br>点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。<br>配置Hexo安装Hexo在自己认为合适的地方创建一个文件夹，然后在文件夹空白处按住Shift+鼠标右键，然后点击在此处打开命令行窗口。（同样要记住啦，下文中会使用在当前目录打开命令行来代指上述的操作）<br>在命令行中输入：<br><code>npm install hexo-cli -g</code><br>然后你将会看到:<br><img src="https://xuanwo.org/imgs/opinion/npm-install-hexo-cli.png" alt=""><br>可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入<br><code>npm install hexo --save</code></p><p>然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入：<br><code>hexo -v</code></p><p>如果你看到了如图文字，则说明已经安装成功了。<br><img src="https://xuanwo.org/imgs/opinion/hexo-v.png" alt=""><br>初始化Hexo接着上面的操作，输入：<br><code>hexo init</code></p><p>如图：<br><img src="https://xuanwo.org/imgs/opinion/hexo-init.png" alt=""><br>然后输入：<br><code>npm install</code></p><p>之后npm将会自动安装你需要的组件，只需要等待npm操作即可。</p><h2 id="首次体验Hexo"><a href="#首次体验Hexo" class="headerlink" title="首次体验Hexo"></a>首次体验Hexo</h2><p>继续操作，同样是在命令行中，输入：<br><code>hexo g</code></p><p>如图：<br><img src="https://xuanwo.org/imgs/opinion/hexo-g.png" alt=""><br>然后输入：<br><code>hexo s</code></p><p>然后会提示：<br><code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p><p>在浏览器中打开<code>http://localhost:4000/</code>，你将会看到：<br><img src="https://xuanwo.org/imgs/opinion/hexo-first-time.png" alt=""><br>到目前为止，Hexo在本地的配置已经全都结束了。</p><h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><blockquote><p>在配置过程中请使用yamllint来保证自己的yaml语法正确<br>修改全局配置文件此段落引用自<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo官方文档</a><br>您可以在 _config.yml 中修改大部份的配置。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>参数 | 描述<br>title | 网站标题<br>subtitle | 网站副标题<br>description | 网站描述<br>author | 您的名字<br>language | 网站使用的语言<br>timezone | 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</p><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>url</td><td>网址</td></tr><tr><td>root</td><td>网站根目录</td><td>permalink文章的 永久链接 格式:year/:month/:day/:title/permalink_default永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 <a href="http://yoursite.com/blog，则请将您的">http://yoursite.com/blog，则请将您的</a> url 设为 <a href="http://yoursite.com/blog">http://yoursite.com/blog</a> 并把 root 设为 /blog/。</td></tr></tbody></table><p>目录参数描述默认值source_dir资源文件夹，这个文件夹用来存放内容。sourcepublic_dir公共文件夹，这个文件夹用于存放生成的站点文件。publictag_dir标签文件夹tagsarchive_dir归档文件夹archivescategory_dir分类文件夹categoriescode_dirInclude code 文件夹`downloads/codei18n_dir国际化（i18n）文件夹:langskip_render跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 文章参数描述默认值new_post_name新文章的文件名称:title.mddefault_layout预设布局postauto_spacing在中文和英文之间加入空格falsetitlecase把标题转换为 title casefalseexternal_link在新标签中打开链接truefilename_case把文件名称转换为 (1) 小写或 (2) 大写0render_drafts显示草稿falsepost_asset_folder启动 Asset 文件夹falserelative_link把链接改为与根目录的相对位址falsefuture显示未来的文章truehighlight代码块的设置 分类 &amp; 标签参数描述默认值default_category默认分类uncategorizedcategory_map分类别名 tag_map标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。<br>参数描述默认值date_format日期格式MMM D YYYYtime_format时间格式H:mm:ss分页参数描述默认值per_page每页显示的文章量 (0 = 关闭分页功能)10pagination_dir分页目录page扩展参数描述theme当前主题名称。值为false时禁用主题deploy部署部分的设置配置Deployment首先，你需要为自己配置身份信息，打开命令行，然后输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;yourname&quot;</div><div class="line">git config --global user.email &quot;youremail&quot;</div></pre></td></tr></table></figure></p></blockquote><p>同样在_config.yml文件中，找到Deployment，然后按照如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git@github.com:yourname/yourname.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p><p>如果使用git方式进行部署，执行npm install hexo-deployer-git –save来安装所需的插件<br>然后在当前目录打开命令行，输入：<br><code>hexo d</code></p><p>随后按照提示，分别输入自己的Github账号用户名和密码，开始上传。 然后通过<a href="http://yourname.github.io/来访问自己刚刚上传的网站。" target="_blank" rel="external">http://yourname.github.io/来访问自己刚刚上传的网站。</a><br>添加新文章打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就能在执行hexo g的时候被渲染。 新建的文章头需要添加一些yml信息，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: hello-world   //在此处添加你的标题。</div><div class="line">date: 2017-5-11 08:55:29   //在此处输入你编辑这篇文章的时间。</div><div class="line">categories: Exercise   //在此处输入这篇文章的分类。</div><div class="line">toc: true    //在此处设定是否开启目录，需要主题支持。</div></pre></td></tr></table></figure></p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>如果成功完成了上述的全部步骤，恭喜你，你已经搭建了一个最为简单且基础的博客。但是这个博客还非常简单， 没有个人的定制，操作也比较复杂，下面的进阶技巧将会让你获得对Hexo更为深入的了解。<br>更换主题可以在此处寻找自己喜欢的主题 下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改：</p><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><h4 id="Plugins-http-hexo-io-plugins"><a href="#Plugins-http-hexo-io-plugins" class="headerlink" title="Plugins: http://hexo.io/plugins/"></a>Plugins: <a href="http://hexo.io/plugins/" target="_blank" rel="external">http://hexo.io/plugins/</a></h4><h4 id="Themes-http-hexo-io-themes"><a href="#Themes-http-hexo-io-themes" class="headerlink" title="Themes: http://hexo.io/themes/"></a>Themes: <a href="http://hexo.io/themes/" target="_blank" rel="external">http://hexo.io/themes/</a></h4><p>theme: landscape //themes文件夹中对应文件夹的名称</p><p>然后先执行<code>hexo clean</code>，然后重新<code>hexo g</code>，并且<code>hexo d</code>，很快就能看到新主题的效果了~</p><p><del>更换域名首先，需要注册一个域名。在中国的话，.cn全都需要进行备案，如果不想备案的话，请注册别的顶级域名，可以使用godaddy或新网或万网中的任意一家，自己权衡价格即可。 然后，我们需要配置一下域名解析。推荐使用DNSPod的服务，比较稳定，解析速度比较快。在域名注册商出修改NS服务器地址为：</del><br><del>f1g1ns1.dnspod.net</del><br><del>f1g1ns2.dnspod.net</del></p><p><del>以新网为例，首先点击域名管理进入管理页面：</del></p><p><del>然后点击域名后面的管理：</del></p><p><del>进入域名管理的操作界面，点击域名管理，来到域名管理界面：</del></p><p><del>点击修改域名DNS，然后选择填写具体信息，在下面的空框中填入DNSPod的NS服务器：</del></p><p><del>然后我们进入DNSPod的界面，开始真正进入域名解析的配置= =。在DNSPod中，首先添加域名，然后分别添加如下条目：</del></p><p><del>最后，我们对Github进行一下配置。</del><br><del>在自己本地的hexo目录下的source文件夹中，新建一个CNAME文件（注意，没有后缀名。），内容为yourdomin.xxx。然后再执行一下hexo d -g，重新上传自己的博客。 在github中打开你自己的库，进入库的setting界面，如果看到了如下提示，说明配置成功了。</del></p><p><del>在这一系列的操作中，包括修改NS服务器，设置A解析等等，都需要一定的时间。短则10分钟，长则24小时，最长不会超过72小时。如果超过72小时，请检查自己的配置过程，或者修改自己本地的DNS服务器。</del></p><p>##绑定域名：<br>有一个简单的办法，当然只是现在作为拥有GitHub学生包才可以用的，打开<a href="https://education.github.com/" target="_blank" rel="external">学生包</a>，通过教育邮箱申请之后，可以在package中找到那么namecheap，注册通过GitHub进入，可以直接申请域名，会自动绑定到我们的gitpage，不过还需要一点点修改，就是把cname的www改成我们的gitpage页面，就可以了。。</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>我为什么写博客？</title>
      <link href="/15-%E9%9A%8F%E7%AC%94/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/15-%E9%9A%8F%E7%AC%94/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h1 id="开博客的第一天–谈学习与博客"><a href="#开博客的第一天–谈学习与博客" class="headerlink" title="开博客的第一天–谈学习与博客"></a>开博客的第一天–谈学习与博客</h1><hr><h4 id="作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。"><a href="#作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。" class="headerlink" title="作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。"></a>作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。</h4><p>###<br><a id="more"></a></p><h4 id="那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。"><a href="#那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。" class="headerlink" title="那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。"></a>那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。</h4><p>###</p><h4 id="然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99-可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？"><a href="#然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99-可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？" class="headerlink" title="然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99.可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？"></a>然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99.可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？</h4><p>###</p><h4 id="今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。"><a href="#今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。" class="headerlink" title="今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。"></a>今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。</h4><p>###</p><h4 id="所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧："><a href="#所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧：" class="headerlink" title="所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧："></a>所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧：</h4><blockquote><p> When nothing seems to help,I go and look at a stonecutter hammering away at his rock perhaps a hundred times without as much as a crack showing in it.Yet at the hundred and first blow it will split in two,and I know it was not that blow that did it——but all that had gone before.<br>——Jacob Riis</p></blockquote>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day16(map)/"/>
      <url>/09-java/day16(map)/</url>
      <content type="html"><![CDATA[<h1 id="集合-MAP"><a href="#集合-MAP" class="headerlink" title="集合(MAP)"></a>集合(MAP)</h1><h2 id="Map集合：该集合存储键值对。一对一对往里存。而且要保证键的唯一性。"><a href="#Map集合：该集合存储键值对。一对一对往里存。而且要保证键的唯一性。" class="headerlink" title="Map集合：该集合存储键值对。一对一对往里存。而且要保证键的唯一性。"></a>Map集合：该集合存储键值对。一对一对往里存。而且要保证键的唯一性。</h2><ol><li>添加。</li><li>删除。clear()</li><li>判断。</li><li>获取。<br>Map：Hashtable：底层是哈希表数据结构，不能存入null键null值，是线程同步的。<br>HashMap:底层是哈希表数据结构，允许使用null键null值，该集合是不同步的。<br>TreeMap：底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。–和Set很像，其实Set底层就是使用了Map集合。<h2 id="Map子类对象的特点"><a href="#Map子类对象的特点" class="headerlink" title="Map子类对象的特点"></a>Map子类对象的特点</h2><h2 id="Map共性方法"><a href="#Map共性方法" class="headerlink" title="Map共性方法"></a>Map共性方法</h2><h2 id="Map-keySet"><a href="#Map-keySet" class="headerlink" title="Map-keySet"></a>Map-keySet</h2>map集合的两种取出方式：</li><li>keySet：将map中所有的键存入到set集合。因为set具备迭代器。所有可以迭代方式取出所有的键，在根据get方法。获取每一个键对应的值。</li><li>entrySet<br>Set<map.entry<k,v>&gt; entrySet:将Map集合中的映射关系存入了set集合中，而这个关系的数据类型就是：Map.entry。其实Entry也是一个借口，它是Map接口中的一个内部接口。<h2 id="Map练习"><a href="#Map练习" class="headerlink" title="Map练习"></a>Map练习</h2>当发现有映射关系时，可以选择map集合。因为map集合中存放的就是映射关系。<br>什么时候使用map集合？当数据之间存在映射关系时，就要先想map集合<br>##map扩展知识<br>map集合被使用是因为具备映射关系。</map.entry<k,v></li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day17(%E9%9B%86%E5%90%884-%E5%B7%A5%E5%85%B7%E7%B1%BB)/"/>
      <url>/09-java/day17(%E9%9B%86%E5%90%884-%E5%B7%A5%E5%85%B7%E7%B1%BB)/</url>
      <content type="html"><![CDATA[<h1 id="集合（工具类）"><a href="#集合（工具类）" class="headerlink" title="集合（工具类）"></a>集合（工具类）</h1><hr><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><h2 id="binarySerch"><a href="#binarySerch" class="headerlink" title="binarySerch"></a>binarySerch</h2><h2 id="替换反转"><a href="#替换反转" class="headerlink" title="替换反转"></a>替换反转</h2><h2 id="reserveOrder"><a href="#reserveOrder" class="headerlink" title="reserveOrder"></a>reserveOrder</h2><h2 id="Synlist"><a href="#Synlist" class="headerlink" title="Synlist"></a>Synlist</h2><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>用于操作数组的工具类，里面都是静态方法。</p><h2 id="集合变数组"><a href="#集合变数组" class="headerlink" title="集合变数组"></a>集合变数组</h2><p>1.指定类型的数组到底要定义多长呢？<br>当指定类型的数组长度小于集合的size，那么该方法会创建一个新的数组，长度为集合的size。当指定类型的数组长度小于了集合的size，就不会创建新数组，而是使用传递进来的数组，所以创建一个刚刚好的数组最优。<br>2.为什么要将集合变数组？<br>为了限定对元素的操作。</p><p>##增强for循环</p><p>##可变参数<br>方法的可变参数注意：<br>可变参数一定要定义在参数列表的最后面。</p><p>##静态导入<br>当类名方法重名时，需要指定具体的包名。<br>当方法重名时，指定具备所属的对象或者类</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多线程</title>
      <link href="/09-java/day11(%E5%A4%9A%E7%BA%BF%E7%A8%8B)/"/>
      <url>/09-java/day11(%E5%A4%9A%E7%BA%BF%E7%A8%8B)/</url>
      <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><hr><p>进程：是一个正在执行中的程序。<br>每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制单元。<br>线程：就是进程中的一个独立的控制单元。  线程在控制着进程的执行。<br>一个进程中至少有一个线程。<br>java VM启动的时候会有一个进程jav.exe。该进程中至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main方法中。该线程称之为主线程。<br>扩展：其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。</p><hr><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><ol><li>如何在自定义的代码中，自定义一个线程？<br>通过对API的查找，java已经提供了对线程这类事物的描述，就Thread类。<br>创建线程的第一种方式：继承Thread类。<br>步骤：定义类继承Thread；复写Thread类中的run方法；调用线程的start方法。<br>发现运行结果每次都不同。因为多个线程都获取cpu的执行权，CPU执行到谁，谁就运行。（多核除外），cpu在做着快速的切换，以达到看上去是同时运行的效果</li></ol><hr><h1 id="创建线程-run和start的特点"><a href="#创建线程-run和start的特点" class="headerlink" title="创建线程-run和start的特点"></a>创建线程-run和start的特点</h1><p>为什么要覆盖run方法？<br>Thread类用于描述线程。该类定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法。<br>也就是说Thread类中的run方法，用于存储线程要运行的代码。</p><h1 id="线程运行状态"><a href="#线程运行状态" class="headerlink" title="线程运行状态"></a>线程运行状态</h1><p>原来线程都有自己默认的名称。Thread-编号，该编号从0开始。<br>static Thread currentThread()：获取当前线程对象。<br>getName()：获取线程名称<br>设置线程名称：setName或者构造函数。</p><hr><h1 id="创建线程-runable接口"><a href="#创建线程-runable接口" class="headerlink" title="创建线程-runable接口"></a>创建线程-runable接口</h1><p>创建线程的第二种方式：实现Runable接口<br>步骤：</p><ol><li>定义类实现Runable接口</li><li>覆盖Runable接口中的run方法。  （将线程要运行的代码存放到该run方法中）</li><li>通过Thread类建立线程对象。</li><li>将Runable接口的子类对象作为实际参数传递给Thread类的构造函数。（自定义的run方法所属的对象时Runable接口的子类对象。所以要让线程去指定对象的run方法，就必须明确该run方法所属的对象）</li><li>调用Thread类的start方法开启线程并调用Runable接口子类的run方法。</li></ol><hr><p>实现方式和继承方式有什么区别呢？<br>实现方式：避免了单继承的局限性。在定义线程时，建议使用实现方式。<br>两种方式的区别：<br>继承Thread：线程代码存放在Thread子类的run方法中。<br>实现Runable：线程 代码存在接口的子类的run方法中。</p><hr><h1 id="多线程的安全问题"><a href="#多线程的安全问题" class="headerlink" title="多线程的安全问题"></a>多线程的安全问题</h1><p>多线程运行出现安全问题的原因：<br>当多条语句在操作同一个线程共享数据时，一个线程对多条语句值执行了一部分，还没有执行完，另一个线程参与执行。导致共享数据的错误。<br>解决办法：<br>对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中，其他线程不可以参与执行。<br>  java对于多线程的安全问题提供了专业的解决方式。<br>同步代码块。<br>synchronized（对象）{需要被同步的代码}<br>对象如同锁。持有锁的线程可以在同步中执行。没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有获取锁。<br>同步的前提：</p><ol><li>必须要有两个或两个以上的线程。</li><li>必须是多个线程使用同一个锁<br>3必须保证同步中只能有一个线程在运行。<br>好处：解决了多线程的安全问题。<br>弊端：多个线程需要判断锁，较为消耗资源。</li></ol><hr><h1 id="多线程-同步函数"><a href="#多线程-同步函数" class="headerlink" title="多线程-同步函数"></a>多线程-同步函数</h1><p><strong>同步函数的锁用的是this。<br>静态同步函数的锁是Class对象</strong></p><hr><h1 id="多线程-死锁"><a href="#多线程-死锁" class="headerlink" title="多线程-死锁"></a>多线程-死锁</h1>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day22(GUI)/"/>
      <url>/09-java/day22(GUI)/</url>
      <content type="html"><![CDATA[<h1 id="GUI-图形用户界面"><a href="#GUI-图形用户界面" class="headerlink" title="GUI(图形用户界面)"></a>GUI(图形用户界面)</h1><hr><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><h3 id="Awt与-Swing"><a href="#Awt与-Swing" class="headerlink" title="Awt与 Swing"></a>Awt与 Swing</h3><p>java.Awt： Abstract Window ToolKit (抽象窗口<br>工具包)，需要调用本地系统方法实现功能。属<br>重量级控件。<br>javax.Swing：在AWT的基础上，建立的一套图<br>形界面系统，其中提供了更多的组件，而且完全<br>由Java实现。增强了移植性，属轻量级控件。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day15(%E9%9B%86%E5%90%88%E7%B1%BB2)/"/>
      <url>/09-java/day15(%E9%9B%86%E5%90%88%E7%B1%BB2)/</url>
      <content type="html"><![CDATA[<h1 id="集合框架2"><a href="#集合框架2" class="headerlink" title="集合框架2"></a>集合框架2</h1><hr><p>##set<br>set：无序，不可以重复元素。<br>hashset：数据结构是哈希表，线程非同步的，保证元素唯一性的原理，判断元素的hashCode值是否相同。如果相同，判断equals<br>TreeSet：可以对set集合中的元素进行排序。<br>底层数据结构是二叉树。保证元素唯一性的依据：compareTo return 0<br>往TreeSet集合中存储自定义对象学生。想按照学生的年龄进行排序。<br>记住：排序时，当主要条件相同时，一定判断一下次要条件。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>TreeSet排序的第一种方式：让元素自身具备比较性。元素需要事项compareable接口，覆盖compareTo方法。这种方式也称为元素的自然顺序，或者叫做默认顺序。<br>TreeSet排序的第二种方式：当元素自身不具备比较性时，或者具备的比较性不是锁需要的。这时就需要让集合自身具备比较性。在集合初始化时，就有了比较方式。<br>当元素自身不具备比较性，或者具备的比较性不是所需要的。这时需要让容器自身具备比较性，定义了比较器，将比较器对象作为参数传递给TreeSet集合的构造函数。<br>当两种排序都存在时，以比较器为主。定义一个类实现Comparator接口，覆盖compare方法。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>JDK1.5之后出现的新特性，用于解决安全问题，是一个安全机制。<br>好处：</p><ol><li>将运行时期出现问题转移到编译时期，便于程序员解决。</li><li>避免了强制转换的麻烦。<br>泛型格式：通过&lt;&gt;来定义要操作的引用数据类型<br>在使用java提供的对象时，什么时候写泛型？<br>通常在集合框架中很常见，只要见到&lt;&gt;就要定义泛型。其实&lt;&gt;就是用来接收类型的。当使用集合时，将集合中的要存储的数据类型放到&lt;&gt;中即可。<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2>泛型类：带泛型的类。<br>当类中要操作的引用数据类型不确定的时候，早期定义Object来完成扩展，现在定义泛型完成扩展。<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2>泛型类定义的泛型，在整个类中有效，如果被方法使用，那么泛型类的对象没明确要操作的具体类型后，所有要操作的类型就已经固定了。为了让不同方法可以操作不同类型，而且类型还不确定，那么可以将泛型定义到方法上。<h2 id="静态方法泛型"><a href="#静态方法泛型" class="headerlink" title="静态方法泛型"></a>静态方法泛型</h2>特殊之处是：静态方法不可以访问类上定义的泛型，如果静态方法操作的引用数据类型不确定，可以将泛型定义在方法上。<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><h2 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h2>？： 通配符，也可以理解为占位符。<br>泛型的限定： ？ extends E：可以接收E类型或者E的子类型。上限<pre><code>？ super E：可以接收E类型或者E的父类型。下限</code></pre></li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day8(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14)/"/>
      <url>/09-java/day8(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14)/</url>
      <content type="html"><![CDATA[<h1 id="面向对象（4）–多态"><a href="#面向对象（4）–多态" class="headerlink" title="面向对象（4）–多态"></a>面向对象（4）–多态</h1><hr><h2 id="多态概念"><a href="#多态概念" class="headerlink" title="多态概念"></a>多态概念</h2><p>多态：可以理解为事物存在的多种体现形态</p><h2 id="多态的扩展性"><a href="#多态的扩展性" class="headerlink" title="多态的扩展性"></a>多态的扩展性</h2><ol><li>多态的体现<br> 父类的引用指向了自己的子类对象<br> 父类的引用也可以接收自己的子类对象</li><li>多态的前提<br> 必须是类与类之间有关系，要么继承，要么实现。<br> 通常还有一个前提：存在覆盖</li><li>多态的好处<br> 多态的出现大大的提高程序的扩展性</li><li>多态的弊端：<br> 提高了扩展性，但是只能用父类的引用访问父类中的成员</li><li>多态的应用</li></ol><h2 id="多态–转型"><a href="#多态–转型" class="headerlink" title="多态–转型"></a>多态–转型</h2><p>向上转型，向上转型<br>千万不要出现这样的操作，就是将父类对象转换成子类类型。<br>我们能转换的是父类应用指向了自己的子类对象时，该引用可以被提升，也可以被强制转换。<br>多态自始至终都是子类对象在做着变化</p><h2 id="多态成员的特点"><a href="#多态成员的特点" class="headerlink" title="多态成员的特点"></a>多态成员的特点</h2><p>在多态中成员函数的特点：<br>在编译时期：参阅引用型变量所属的类中是否有调用的方法，如果有，编译通过，如果没有，编译失败。<br>在运行时期：参阅对象所属的类中是否有调用的方法。<br>简单总结就是：成员函数在多态调用时，编译看左边，运行看右边。<br>在多态中，成员变量的特点：无论编译还是运行，都参考左边（引用型变量所属的类）。<br>在多态中，静态成员函数的特点：无论编译还是运行，都参考左边（引用型变量所属的类）。</p><h2 id="多态的实例"><a href="#多态的实例" class="headerlink" title="多态的实例"></a>多态的实例</h2><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day7(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13)/"/>
      <url>/09-java/day7(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13)/</url>
      <content type="html"><![CDATA[<h1 id="面向对象（3）"><a href="#面向对象（3）" class="headerlink" title="面向对象（3）"></a>面向对象（3）</h1><h1 id="（继承，final，抽象类，接口）"><a href="#（继承，final，抽象类，接口）" class="headerlink" title="（继承，final，抽象类，接口）"></a><em>（继承，final，抽象类，接口）</em></h1><hr><h2 id="1-继承（概述）"><a href="#1-继承（概述）" class="headerlink" title="1.继承（概述）"></a>1.继承（概述）</h2><ul><li><strong>继承：</strong></li></ul><p>1.提高了代码的复用性</p><p>2.继承让类与类之间有了关系，有了关系才有了多态的特性。</p><p>注意：千万不要为了获取其他类的功能，简化代码而继承。<br>必须是类与类之间有所属关系才可以继承，所属关系 is a。</p><p><strong>java语言中：java只支持单继承，不支持多继承。</strong></p><p>  因为多继承容易带来安全隐患：当多个父类中定义了相同的功能，当功能内容不同时，子类对象不确定要运行哪一个。<br>  但是java保留了这种机制，并用另一种体现形式来完成表示，多实现。</p><ul><li><strong>java支持多层继承。</strong></li></ul><ul><li><strong>如何使用一个继承体系中的功能？</strong></li></ul><p>想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系的共性功能。</p><p>通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了<br>那么在具体调用时，要创建最子类的对象。<br>因为：1.可能父类不能创建对象 2.创建子类可以使用更多的功能，包括基本的也包括特有的<br>简单的说，就是查阅父类，创建子类</p><h2 id="2-聚集关系"><a href="#2-聚集关系" class="headerlink" title="2.聚集关系"></a>2.聚集关系</h2><p>聚集：has a<br>聚合：<br>组合：</p><p>子父类出现后，类成员的特点<br>类成员：<br>1.变量<br>2.函数<br>3.构造函数</p><h2 id="3-1-子父类中的变量的特点"><a href="#3-1-子父类中的变量的特点" class="headerlink" title="3.1.子父类中的变量的特点"></a>3.1.子父类中的变量的特点</h2><p>如果子类中出现非私有的同名成员变量时，子类要访问本类中的变量，用this<br>super代表的是父类对象的引用</p><h2 id="3-2-子父类中的函数的特点"><a href="#3-2-子父类中的函数的特点" class="headerlink" title="3.2.子父类中的函数的特点"></a>3.2.子父类中的函数的特点</h2><p>当子类和父类中出现一样的函数时，当子类对象调用该函数，会运行子类函数的内容。如同父类的函数被覆盖一样。<br>这种情况是函数的另一个特性：重写（覆盖）<br>当子类继承父类，沿袭了父类的功能，但是功能的内容却和父类不一致。这时没有必要定义新功能，而是使用覆盖特殊，保留父类的功能定义，并重写功能内容。</p><p>覆盖：<br>1.子类覆盖父类，必须保证子类权限大于父类权限，否则编译失败<br>2.静态只能覆盖静态。</p><h2 id="3-3-子父类中构造函数的特点–子类的实例化过程"><a href="#3-3-子父类中构造函数的特点–子类的实例化过程" class="headerlink" title="3.3.子父类中构造函数的特点–子类的实例化过程"></a>3.3.子父类中构造函数的特点–子类的实例化过程</h2><p>重载：只看重名函数的参数列表。<br>重写：子类父类方法要一模一样。</p><p>子父类中的构造函数：<br>在对子类对象进行初始化 时，弗父类的构造函数也会运行，那是因为子类的构造函数第一行默认有一条隐式语句super()；<br>super()：会访问父类中空参数的构造函数。而且子类中所有的构造函数默认第一行都是super()<br>为什么子类一定要访问父类中的构造函数？<br>因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要先查看父类如何对这些数据进行初始化的，所以子类在对象进行初始化时，要先访问一下父类中的构造函数<br>如果要访问父类中指定的构造函数，可以用super语句来指定。</p><p>注意：super语句一定定义在子类构造函数的第一行。</p><ul><li>子类的实例化过程：</li></ul><p>结论：子类所有的构造函数默认都会访问父类中空参数的构造函数，因为子类每一个构造函数的第一行都有一句隐式的super()<br>当父类中没有空的构造函数时，子类必须手动通过super或者this语句形式来指定要访问父类中的构造函数。<br>当然：子类中的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数</p><h2 id="4-final关键字"><a href="#4-final关键字" class="headerlink" title="4.final关键字"></a>4.final关键字</h2><p>final：最终，作为一个修饰符</p><ol><li>可以修饰类，函数，变量</li><li>被final修饰的类不可以被继承,为了避免被继承，被子类复写功能</li><li>被final修饰的方法不可以被复写</li><li>被final修饰的变量是一个常量只能赋值一次，既可以修饰局部变量，也可以修饰成员变量。<br> 在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这值起个名字，方便于阅读，而这个值不需要改变，所以加个final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成，单词间通过_连接。</li><li>内部类定义在类中的局部位置时，只能访问该局部被final修饰的局部变量。</li></ol><h2 id="5-抽象类"><a href="#5-抽象类" class="headerlink" title="5.抽象类"></a>5.抽象类</h2><p>当多个类中出现相同功能，但是功能的主体不同，这时可以向上抽取，这时只能抽取功能定义，而不抽取功能主题<br>抽象：看不懂<br>抽象类的特点：</p><ol><li>抽象方法一定在抽象类中。</li><li>抽象方法和抽象类都必须被abstract关键字修饰。</li><li>抽象类不可以用new创建对象，因为调用抽象方法没意义。</li><li>抽象类中的方法要被使用，必须由子类复写起所有的抽象方法之后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。</li></ol><p>抽象类和一般类没有太大的不同。<br>该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。<br>这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。</p><p>抽象类比一般类多了个抽象函数。就是在类中可以定义抽象方法。<br>抽象类不可以实例化。<br>特殊：抽象类中可以不定义抽象方法，这样做仅仅是为了不让该类建立对象。</p><h2 id="6-模板方法设计模式"><a href="#6-模板方法设计模式" class="headerlink" title="6.模板方法设计模式"></a>6.模板方法设计模式</h2><p>在定义功能时，功能的一部分是确定的，但是有一部分功能时不确定的，而确定的部分在使用不确定的部分，就将不确定的部分暴露出去，</p><h2 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h2><ul><li><strong>接口</strong>：初期理解，可以认为是一个特殊的抽象类<br>当抽象类中的方法都是抽象的，那么该类可以通过接口的形式实现<br>class 用于定义类<br>interface 用于定义接口<br>接口定义时，格式特点：</li></ul><ol><li>接口中常见定义：常量，抽象方法。</li><li>接口中的成员都有固定的修饰符。常量：public static final<br>方法：public abstract<br>记住，接口中的成员都是public的<br>接口是不可以创建对象的，因为有抽象方法。<br>需要被子类实现，子类对接口中的抽象方法全部覆盖后，子类才可以实例化。否则子类是一个抽象类</li></ol><ul><li><strong>接口可以被类多实现</strong><br><strong>接口与接口之间可以多继承</strong><h2 id="8-接口的特点"><a href="#8-接口的特点" class="headerlink" title="8.接口的特点"></a>8.接口的特点</h2></li></ul><ol><li>接口是对外暴露的规则</li><li>接口是程序的程序扩展</li><li>接口可以用来多实现</li><li>类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口</li><li>接口与接口之间可以有继承关系</li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day21(IO%E6%B5%813)/"/>
      <url>/09-java/day21(IO%E6%B5%813)/</url>
      <content type="html"><![CDATA[<p>#IO流（3）</p><hr><h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>该类不是算是IO体系中子类，而是继承自Object。<br>但是它是IO包中的成员，因为它具备读和写功能。颞部封装了一个数组，而且通过指针对数组的元素进行操作。<br>可以通过getFilePointer获取指针位置。同时可以通过seek改变指针位置。<br>其实完成读写的原理就是内部封装了字节输入流和输出流。通过构造函数可以看出，该类只能操作文件。而且操作文件还有模式。<br>该对象的构造函数要操作的文件不存在，会自动创建。如果存在不会覆盖。</p><h2 id="ByteArrayStream"><a href="#ByteArrayStream" class="headerlink" title="ByteArrayStream"></a>ByteArrayStream</h2>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day12(%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)/"/>
      <url>/09-java/day12(%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)/</url>
      <content type="html"><![CDATA[<p>#多进程（二）</p><hr><h2 id="1线程间通信"><a href="#1线程间通信" class="headerlink" title="1线程间通信"></a>1线程间通信</h2><p>线程间通讯：其实就是多个线程在操作同一个资源，但是操作的动作不同。</p><p>##2解决安全问题</p><h2 id="3等待唤醒机制"><a href="#3等待唤醒机制" class="headerlink" title="3等待唤醒机制"></a>3等待唤醒机制</h2><p>wait  notify notifyAll 都使用在同步中，因为要对持有监视器（锁）的线程操作。所以要使用在同步中，以为只有同步才具有锁。<br>为什么这些操作线程的方法要定义在Object类中呢？<br>因为这些方法在操作同步中线程时，都必须要标识他们所操作线程只有的锁。只有同一个锁上的等待线程，可以被同一个锁上的notify唤醒。不可以对不同锁中的线程进行唤醒。<br>也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法定义在Object类中。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day20(IO%E6%B5%812)/"/>
      <url>/09-java/day20(IO%E6%B5%812)/</url>
      <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><hr><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>用来将文件或文件夹封装成对象。<br>方便对文件与文件夹的属性信息进行操作。<br>File对象可以作为参数传递给</p><h2 id="File类的常见方法"><a href="#File类的常见方法" class="headerlink" title="File类的常见方法"></a>File类的常见方法</h2><p>1.创建<br>boolean createNewFile()<br>boolean mkdir()<br>boolean mkdirs()</p><p>2.删除<br> boolean delete()  删除失败返回false<br>void deleteOnExit()  在程序退出时删除文件</p><p>3.判断<br>boolean exists() 文件或目录是否存在。<br>记住在判断文件对象是否是文件或者目录时，必须要先判断该文件对象封装的内容是否存在，通过exists判断。<br>boolean isFile()<br>boolean isDirectory()</p><p>4.获取信息。<br> String getName()<br> String getParent()  该方法返回的是绝对路径中的父目录，如果获取的是相对路径，则返回null。<br> String getPath()<br> File getAbsoluteFile()<br>  long lastModified()<br>long length()</p><h2 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h2><p>static File[] listRoots()<br> String[] list() 调用list方法的必须是封装的一个目录。该目录还必须存在。</p><h2 id="列出目录下所有的内容"><a href="#列出目录下所有的内容" class="headerlink" title="列出目录下所有的内容"></a>列出目录下所有的内容</h2><p>递归<br>递归要注意：<br>1.限定条件。<br>2.要注意递归的次数，尽量避免内存溢出。</p><h2 id="删除一个带内容的目录"><a href="#删除一个带内容的目录" class="headerlink" title="删除一个带内容的目录"></a>删除一个带内容的目录</h2><p>删除原理：<br>在Windows中，删除目录从里面往外删除的。既然是从里往外删除，就需要用到递归。</p><h2 id="创建java文件列表"><a href="#创建java文件列表" class="headerlink" title="创建java文件列表"></a>创建java文件列表</h2><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><p>properties是hashtables的子类，也就是说它具备map集合的特点。而且它里面存储的键值对都是字符串。是集合中和IO技术相结合的集合容器。<br>该对象的特点：可以用于键值对形式的配置文件。</p><p>##IO包中的其他类<br>打印流：该流提供了打印方法，可以将各种数据类型的数据都原样打印。<br>字节打印流<br>PrintStream<br>构造函数可以接收的参数类型。</p><ol><li>file对象。File</li><li>字符串路径</li><li>字节输出流<br>字符打印流<br>PrintWrite</li><li>file对象。File</li><li>字符串路径</li><li>字节输出流</li></ol><h2 id="合并流和切割文件"><a href="#合并流和切割文件" class="headerlink" title="合并流和切割文件"></a>合并流和切割文件</h2>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day9(%E5%86%85%E9%83%A8%E7%B1%BB)/"/>
      <url>/09-java/day9(%E5%86%85%E9%83%A8%E7%B1%BB)/</url>
      <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><hr><h2 id="内部类访问规则"><a href="#内部类访问规则" class="headerlink" title="内部类访问规则"></a>内部类访问规则</h2><ol><li>内部类可以直接访问外部类中的成员，包括私有<br> 之所以可以直接访问外部类中的成员，是因为内部类中持有了 一个外部类的引用，格式：外部类名.this</li><li>外部类要访问内部类，必须建立内部类对象。<br> 直接访问内部类中的成员<br>访问格式：<br>当内部类定义在外部类的成员位置上，就可以被成员修饰符所修饰。<br>比如，private：将内部类在外部类中进行封装。<br> static：内部类就具备static的特性。<br>当内部类被static修饰后，只能直接访问外部类中的static成员，出现了访问局限。<br>在外部其他类中，如何访问内部类的非静态成员呢？<h2 id="内部类定义的原则"><a href="#内部类定义的原则" class="headerlink" title="内部类定义的原则"></a>内部类定义的原则</h2>当描述事物时，事物的内部还有事物，该事物用内部类来描述。因为内部事物在使用外部事物的内容。</li></ol><p>内部类定义在局部时，</p><ol><li>不可以被成员修饰符修饰</li><li>可以直接访问外部类中的成员，因为还持有外部类中的引用。但是不可以访问它所在的局部中的变量，只能访问被final修饰的局部变量  、<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2></li><li>匿名内部类其实就是内部类的简写格式</li><li>定义匿名内部类的前提：内部类必须是继承一个类或者实现接口。</li><li>匿名内部类的格式：new 父类或者接口（）{定义子类的内容}</li><li>其实匿名内部类就是一个匿名子类对象，而且这个对象有点胖。可以理解为带内容的对象</li><li>匿名内部类中定义的方法最多不要超过三个</li></ol><h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><p>异常：就是程序在运行时出现不正常的情况。<br>异常的由来：问题也是现实生活中一个具体的事物，也可以通过java的类的形式进行描述。并封装成对象。其实就是java对不正常情况进行描述后的对象体现<br>对于问题的划分：两种：一种是严重的问题，一种是不严重的问题</p><p>对于严重的，java通过Error类进行描述。<br>对于Error，一般不编写针对性的代码进行处理<br>对于非严重的，java通过Exception类进行描述。（可以使用针对性的处理方式进行处理 ）</p><h2 id="异常try-catch"><a href="#异常try-catch" class="headerlink" title="异常try-catch"></a>异常try-catch</h2><p>异常的处理：java提供了特有的语句进行处理<br>对捕获到的异常对象进行常见的方法操作。<br>String getMessage</p><h2 id="异常声明throws"><a href="#异常声明throws" class="headerlink" title="异常声明throws"></a>异常声明throws</h2><h2 id="多异常处理"><a href="#多异常处理" class="headerlink" title="多异常处理"></a>多异常处理</h2><p>对多异常的处理。</p><ol><li>声明异常时，建议声明更为具体的异常。这样处理的可以更具体。</li><li>对方声明几个异常，就对应有几个catch块。不要定义多余的catch块<br> 如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面<br>建立在进行catch处理时，catch中一定要具体的处理方式。不要简单的定义一句e.peintStackTrace()，也不要简单的就书写一条输出语句。</li></ol><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>项目中会出现特有的问题，而这些问题并未被java所描述并封装对象。所以对于这些特有的问题可以按照java对问题封装的思想。将特有的问题。进行自定义的异常封装。<br>当在函数内部出现了throw抛出异常对象，那么就必须要给对应的处理动作。<br>要么在内部try catch处理，要么在函数上声明让调用者处理。<br>发现打印的结果中只有异常的名称，缺没有异常的信息。<br>因为自定义的异常并未定义信息。<br>父类中已经把异常信息的操作都完成了。所以子类只要在构造时，将异常信息传递给父类通过super语句。那么直接就可以通过getMessage方法获取自定义的异常。</p><hr><p>自定义异常：必须是自定义类继承Exception。原因是：<br>异常体系有一个特点：因为异常类和异常对象都被抛出。他们都具备可抛性。这个可抛性是Throwable这个体系中的独有特点。只有这个体系中的类和对象才可以被throw和throws操作。</p><h2 id="throws-和throw的区别：throws使用在函数上。throw使用在函数内。"><a href="#throws-和throw的区别：throws使用在函数上。throw使用在函数内。" class="headerlink" title="throws 和throw的区别：throws使用在函数上。throw使用在函数内。"></a>throws 和throw的区别：throws使用在函数上。throw使用在函数内。</h2><p>throws后面跟的异常类，可以跟多个。用逗号隔开。throw后面跟的是异常对象。</p><h2 id="RuntimeException运行时异常。"><a href="#RuntimeException运行时异常。" class="headerlink" title="RuntimeException运行时异常。"></a>RuntimeException运行时异常。</h2><p>如果在函数内抛出该异常，函数上可以不用声明，编译一样通过。<br>如果在函数上声明了该异常。调用者可以不用进行处理。编译一样通过。<br>之所以不用在函数声明，是因为不需要让调用者处理，当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，对代码尽心修正。<br>自定义异常时，如果该异常的发生，无法再继续进行运算，就让自定义异常继承RuntimeException<br>对于异常分两种：</p><ol><li>编译时被检测的异常。</li><li>编译时不被检测的异常（运行时异常。RuntimeException以及其子类）</li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day13(String)/"/>
      <url>/09-java/day13(String)/</url>
      <content type="html"><![CDATA[<h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><hr><h2 id="StringBuffer-是字符串缓冲区。是一个容器，"><a href="#StringBuffer-是字符串缓冲区。是一个容器，" class="headerlink" title="StringBuffer 是字符串缓冲区。是一个容器，"></a>StringBuffer 是字符串缓冲区。是一个容器，</h2><ol><li>而且长度是可变化的。</li><li>可以操作多个数据类型。</li><li>最终会通过toString方法变成字符串<br>C（create）U（update）R（read）D（delete）<br>1.存储<br>StringBuffer append（）：将指定的数据作为参数添加到到已有数据的结尾处<br>StringBuffer insert（index，数据）：可以将数据 插入到数据指定index位置<br>2.删除<br>String<br>3.获取<br>4.修改</li></ol><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>java升级的三个因素：<br>1.提高效率<br>2.简化书写<br>3.安全性</p><h2 id="基本数据类型对象包装类"><a href="#基本数据类型对象包装类" class="headerlink" title="基本数据类型对象包装类"></a>基本数据类型对象包装类</h2><p>byte   Byte<br>short  short<br>int Integer<br>long  Long<br>boolean Boolean<br>float Float<br>double  Double<br>char  Character<br>基本数据类型对象包装类的最常见作用：就是用于基本数据类型和字符串类型之间做转换。<br>基本数据类型转成字符串。  基本数据类型+“”或者 基本数据类型.toString(基本数据类型值)<br>字符串转基本类型。基本数据类型包装类 a=Xxx.parseXxx(String)</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/"/>
      <url>/09-java/day5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/</url>
      <content type="html"><![CDATA[<h1 id="面向对象编程-二"><a href="#面向对象编程-二" class="headerlink" title="面向对象编程(二)"></a>面向对象编程(二)</h1><ul><li>封装（private）<br>匿名对象使用的方式：只调用一次<br>注意，封装只是私有的一种表现形式。不私有也能封装。</li><li><p>构造函数<br>构造函数和一般函数在写法上有不同<br>构造函数在对象一建立就运行，<br>而一般方法是在对象调用的时候才运行，是给对象添加对象具备的功能。<br>一个对象建立，构造方法运行</p></li><li><p>构造代码块<br>作用：给对象初始化，对象一建立就运行，而且优先于构造函数执行。<br>  和构造函数的区别：<br>  构造代码块是给所有的对象初始化，构造函数是给特定的对象初始化。<br>  构造代码块 中定义的是不同对象共性的特性.</p></li><li><p>this关键字</p></li></ul><ol><li>变量名起的没有意义，可读性非常差</li><li>局部变量和成员变量一样了，局部中有就在局部中使用，没有的话就在成员变量中找,将局部的值赋给成员变量，引出了this关键字</li><li>this:看上去，是用于区分局部变量和成员变量同名的情况</li><li>this到底代表的是什么<br> this：就代表本类的对象，到底代表哪一个呢？<br> this代表它所在函数所在对象的引用<br> 简单说：哪个对象在调用this所在的函数，this就代表哪个对象</li></ol><ul><li>this关键字在构造函数间的调用<br>this语句：用于构造函数间互相调用<br>this语句只能放在构造函数的第一行。因为初始化动作要先执行<br>不允许死循环调用</li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day14(%E9%9B%86%E5%90%88%E7%B1%BB)/"/>
      <url>/09-java/day14(%E9%9B%86%E5%90%88%E7%B1%BB)/</url>
      <content type="html"><![CDATA[<h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><hr><h2 id="集合框架（体系概述）"><a href="#集合框架（体系概述）" class="headerlink" title="集合框架（体系概述）"></a>集合框架（体系概述）</h2><p>为什么出现集合类？<br>数组是固定长度的，集合是可变长度的。<br>为什么出现这么多的容器？<br>因为每一个容器对数据的存储方式都有不同。这个存储方式称之为：数据结构。</p><p>##集合框架（共性方法）</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>什么是迭代器？<br>其实就是集合中元素的取出方式。<br>把取出方式定义在集合的内部，这样取出方式就可以直接访问集合内容的元素。那么取出方式就被定义成了内部类。而每一个容器的结构数据不同，所以取出的动作细节也不一样。但是都有共性内容：判断和取出。那么可以将这些共性抽取。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="List集合共性方法"><a href="#List集合共性方法" class="headerlink" title="List集合共性方法"></a>List集合共性方法</h3><p>List：元素是有序的，元素可以重复，因为该集合体系有索引。<br>Set：元素是无序的，不能重复。<br>List：特有方法：凡是可以操作角标的方法都是该体系特有的方法。<br>增：add addAll<br>删： remove<br>改：set<br>查：get subList listIterator</p><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>在迭代器时，只能用迭代器的方法操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。<br>该接口只能通过List集合的ListIterator方法获取。</p><h3 id="List集合具体对象的特点"><a href="#List集合具体对象的特点" class="headerlink" title="List集合具体对象的特点"></a>List集合具体对象的特点</h3><p>List：<br>ArrayList：底层的数据结构使用的是数组，查找很快，但是增删稍慢 （可变长度的）<br>Linkedlist：底层使用的是链表数据结构。特点是增删速度很快，查询稍慢<br>Vector：底层是数组数据结构。线程同步，被ArrayList替代了 ，现在一般不用了。枚举是Vector特有的取出方式。发现枚举和迭代器很像。其实枚举和迭代是一样的。因为枚举的名称以及方法的名称都过长。所以被迭代器取代了。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList特有方法：addFirst(),addLast(),getFirst(),getLast(),removeFirst(),removeLast()<br>JDK1.6出现了替代方法。<br>offerFriest  peekFirst poolFirst<br>堆栈：先进后出<br>队列： 先进先出 FIFO<br>List集合判断元素是否相同，依据的是元素的equals方法。</p><p>##set<br>set：元素是无序（存入和取出的顺序不一定一致）<br>set集合的功能和collection是一致的。<br>HashSet：底层数据结构是哈希表。HashSet是如何保证元素的唯一性的呢？是通过元素的两个方法。hashCode和equals来完成。如果元素的HashCode值相同，才会判断equals是否为true，如果元素的hashCode不同，不会判断equals。<br>注意：对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashcode和equals方法。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day19(IO%E6%B5%81)/"/>
      <url>/09-java/day19(IO%E6%B5%81)/</url>
      <content type="html"><![CDATA[<p>#IO流</p><hr><h2 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h2><p>缓冲区的出现是为了提高流的操作效率而出现的。所以在创建缓冲区之前，必须要先有流对象。<br>为了 提高字符写入流效率，加入了缓冲技术,只要将需要提高效率的流对象作为参数传递给缓冲区的构造函数即可。<br>记住只要用到缓冲区，就要记得刷新。<br>其实关闭缓冲区，其实就是在关闭缓冲区的流对象。<br>该缓冲区中提供了一个跨平台的newLine（）</p><h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>为了提高效率，加入缓冲技术。将字符读取流对象作为参数传进缓冲对象的构造函数。<br>readLine方法返回的时候只返回回车符之前的数据内容，并不返回回车符。<br>readLine方法的原理：无论是读取一行，还是读取多个字符，其实最终都是在硬盘上一个个读取。所以最终使用的还是read方法一次读一个的方法。</p><h2 id="MyBufferedReader"><a href="#MyBufferedReader" class="headerlink" title="MyBufferedReader"></a>MyBufferedReader</h2><h2 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h2><p>定义：当想要对已有的对象进行功能增强时，可以定义一个类，将已有对象传入，基于已有的功能，并提供加强功能。那么自定义的该类称为装饰类。<br>装饰类通常会通过构造方法接收被装饰的对象。并基于被装饰的对象的功能，提供更强的功能。</p><h2 id="装饰和继承的区别"><a href="#装饰和继承的区别" class="headerlink" title="装饰和继承的区别"></a>装饰和继承的区别</h2><p>装饰模式比继承要灵活，避免了继承体系臃肿。而且降低了类与类之间的关系。<br>装饰类因为增强已有对象，具备的功能和已有的是相同的，只不过提供了更强的功能。所以装饰类和被装饰类通常都属于一个体系中的。</p><h2 id="LineNumberReader"><a href="#LineNumberReader" class="headerlink" title="LineNumberReader"></a>LineNumberReader</h2><h2 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h2><p>FileReader:<br>FileWriter:<br>字节流：<br>InputStream：<br>OutputStream:</p><h2 id="复制一个图片"><a href="#复制一个图片" class="headerlink" title="复制一个图片"></a>复制一个图片</h2><p>思路：<br>1.用字节读取流对象和图片关联。<br>2.用字节写入流对象创建一个图片文件，用于存储获取到的图片数据。</p><ol><li>通过循环读写，完成数据的存储。</li><li>关闭资源<h2 id="读取转换流"><a href="#读取转换流" class="headerlink" title="读取转换流"></a>读取转换流</h2><h2 id="写入转换流"><a href="#写入转换流" class="headerlink" title="写入转换流"></a>写入转换流</h2><h2 id="流操作的基本规律"><a href="#流操作的基本规律" class="headerlink" title="流操作的基本规律"></a>流操作的基本规律</h2>最痛苦的就是流对象有很多，不知道该用哪一个。<br>通过两个明确来完成。<br>1.明确源和目的。<br> 源：输入流。InputStream   Reader<br> 目的：输出流。OutputStream Writer<br>2.操作的数据是否是纯文本。<br> 是：字符流。<br> 否：字节流。<br>3.当体系明确后，再明确要使用哪个具体的对象。<br>通过设备来进行区分：<br>源设备：内存，硬盘，键盘<br>目的设备：内存，硬盘，控制台。</li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day18(%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1)/"/>
      <url>/09-java/day18(%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1)/</url>
      <content type="html"><![CDATA[<p>#其他对象</p><hr><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>可不可以在jvm启动时，动态加载一些属性信息。</p><p>##Runtime对象<br>该类并没有提供构造函数。说明不可以new 对象，那么会直接想到该类中的方法都是静态的，发现该类中海油非静态方法。<br>说明该类肯定会提供了方法获取本类对象，而且该方法是静态的，并返回值类型是本类类型。<br>由这个特点可以看出该类使用了单例设计模式执行。</p><p>##Date</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>day5(面向对象2)</title>
      <link href="/09-java/day10(%E5%BC%82%E5%B8%B8%E5%8C%85%E8%AE%BF%E9%97%AE)/"/>
      <url>/09-java/day10(%E5%BC%82%E5%B8%B8%E5%8C%85%E8%AE%BF%E9%97%AE)/</url>
      <content type="html"><![CDATA[<h2 id="异常-finally"><a href="#异常-finally" class="headerlink" title="异常-finally"></a>异常-finally</h2><h2 id="异常-处理语句其他格式"><a href="#异常-处理语句其他格式" class="headerlink" title="异常-处理语句其他格式"></a>异常-处理语句其他格式</h2><h2 id="异常-覆盖时的异常特点"><a href="#异常-覆盖时的异常特点" class="headerlink" title="异常-覆盖时的异常特点"></a>异常-覆盖时的异常特点</h2><p>异常在子父类覆盖中的特点：</p><ol><li>子类在覆盖父类时，如果父类的方法抛出异常，子类的覆盖方法，只能抛出父类的异常或该异常的子类。</li><li>如果父类方法抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集。</li><li>如果父类或接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常。<br> 如果子类方法发生了异常。那么就必须要进行try处理，绝对不能抛。<br>##　异常练习<h2 id="异常–总结"><a href="#异常–总结" class="headerlink" title="异常–总结"></a>异常–总结</h2>是什么：是对问题的描述。将问题进行对象的封装</li></ol><hr><p>异常体系：Throwable<br>                       |–Eroor<br>                |–Exception<br>                    |–RuntimeException<br>异常体系的特点：在异常体系中的所有类以及建立的对象都具备可抛性。也就是说可以被throw和throws关键字所操作。只有异常体系具备这个特点。</p><hr><p>throw和throws的用法：<br>throw：定义在函数内，用于抛出异常对象<br>throws：定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开<br>当函数内有throw抛出异常对象，并未进行try处理。必须要在函数上声明，都在编译失败。<br>注意：除了RuntimeException除外，函数内如果声明的是RuntimeException异常，函数上可以不用声明。</p><hr><p>如果函数声明了异常，调用者需要处理。处理方法可以throws可以try<br>异常有两种：</p><ol><li>编译时被检测异常：该异常在编译时，如果没有处理（没有抛出也没try），编译失败。该异常被标识，代表这可以被处理。</li><li>运行时异常（编译时不检测）：在编译时不需要检测，编译器不检查。该异常的发生，建议不处理，让程序停止。需要对代码进行修正。</li></ol><hr><p>注意：finally中定义的通常是：关闭资源代码。因为资源必须释放。<br>    finally只有一种情况不被执行。当执行到System.exit(0)；finally不被执行</p><hr><p>自定义异常：<br>定义类继承Exception或者RuntimeException</p><ol><li>为了让该自定义类具备可抛性</li><li>让该类具备异常操作的共性方法</li></ol><hr><p>自定义异常好处：按照java面向对象的思想，将程序中出现的特有问题进行封装。</p><ol><li>将问题进行封装</li><li>将问题和代码进行分离，方便于阅读<br>异常处理的原则：</li><li>处理方式有两种：try或者throws</li><li>调用到抛出异常的功能时，抛出几个，就处理几个</li><li>多个catch，父类的catch放在最下面</li><li>catch内，需要定义针对性的处理方式。不要简单的定义printStackTrace输出语句，也不要不写。当捕捉到的异常，本功能处理不了时，可以继续在catch中抛出。  如果该异常处理不了，但并不属于该功能出现的异常。也可以将异常转换后再抛出和该功能相关的异常。  或者异常可以处理，当需要将异常产生的和本功能相关的问题提供出去，让调用者知道，并处理。也可以捕获异常处理后，转换新的异常。<br>5.</li></ol><hr><p>异常的注意事项：<br>在子类覆盖时：</p><ol><li>子类抛出的异常必须是父类异常的子类或者子集</li><li>如果父类或者接口没有异常抛出时，子类覆盖出现异常，只能try不能抛</li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
