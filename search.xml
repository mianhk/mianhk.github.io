<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kubernetes之webhook</title>
      <link href="/2021/09/25/kubernetes/1-k8s-webhook/k8s-webhook/"/>
      <url>/2021/09/25/kubernetes/1-k8s-webhook/k8s-webhook/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <p><strong>Admission Webhook</strong>调用图</p><p><img src="img1-20210925120413030.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年总结</title>
      <link href="/2020/12/26/2020_summary/"/>
      <url>/2020/12/26/2020_summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2020，仿佛还是刚刚开始，不过已经快要过完了。三月份一到周末就跟家人一起去爬山的日子感觉就在不久前，现在也已12月了，口罩从冬天戴到了冬天，感觉都已经记不起原来从没戴过口罩的生活是什么样的了。疫情影响着生活的大小方面，不过在此还是总结自己吧。</p></blockquote><a id="more"></a>  <h1 id="工作">工作</h1><p>首先在工作上，整体给自己打个70分吧。在整体完成方面觉得还不错了，做的事情也算是比较多了：</p><ul><li><strong>前端</strong>：由于去年用Python写了个系统，需要一些前端的展示，但是组内唯一的前端同学又排期不过来，于是就直接撸起了vue。甚至在Q2的时候，昨晚本身系统的前端后，还帮忙做了很多其他的需求。从最开始还没接触过js到后面开始已经踩了很多坑了，但是在写代码方面还不是很熟练，后续如果有时间希望还是能整体补一补。</li><li><strong>日常项目</strong>：主要是围绕MySQL数据库的一些项目，来保证备份的数据、系统的高可用、数据传输等方面，技术栈用的go，不过因为项目数量比较多，虽然能够完成项目的任务，但是在项目的深层理解上还不够。在数据传输项目中，基本是由自己一个人主导，目前进展也相对比较顺利。</li><li><strong>MySQL运维</strong>： 从年初接了100个实例的MySQL运维，到年底前又因为开发任务比较重把MySQL集群交接给新人。从开始接触时候的啥都不会，到把90%实例完成版本升级，交接后带着新人处理日常问题。这一点还是想给自己点个赞的，毕竟虽然这一年时间都有运维工作，但是在其他方面也都没落下过。</li><li><strong>TiDB</strong>：由于很多业务量的增长，对TiDB的需求也有增加，下半年开始也有一部分工作重心在TiDB。目前主要工作是接入到内部系统中，在这一部分也基本是自己主导。也一直在学习TiDB相关的内容，中间还参加了一个TiDB的性能竞赛，拿了第三名。</li></ul><p>回头看这些，工作量还是很饱满，以及在日常的工作中，也发现了自己的一些问题：</p><ul><li><p><strong>专注</strong>：工作量比较饱满，但是工作深度不够。不管是作为工具写了一两个月的前端，还是搭着做了一年的MySQL运维，在深度方面都有些欠缺，对于前端来说，可能后面也不一定会用到，但是基础是可以看看的。而对于MySQL，是很多工作的基础，需要随时补。另外后面也应该在多项工作中，找到专注的点，把这些点优先做好。</p></li><li><p><strong>沟通表达能力</strong>： 其实以前并没有觉得自己表达的不好，可能是以前上学的时候也没往这上面说。现在工作期间，沟通交流基本上是每天都有，如何能够更好的表达自己，更有效的沟通来提高工作效率，是重要的技能。</p></li></ul><h1 id="学习">学习</h1><p>学习方面，今年真的是有点惭愧了。</p><ul><li><strong>读书</strong>：真的是一本都没有完整的读完，一本《经济学原理》教材看了一半，觉得讲的很好，但就是没看完。</li><li><strong>编程方面</strong>： 主要还是在学在用Go，前端方面也没有系统的去学习，其实是学习了一点吧，但是又因为其他事情落下了。</li></ul><h1 id="生活">生活</h1><h2 id="重要事件"><strong>重要事件</strong></h2><p>今年最重要的事情就是新冠疫情了，而且已经持续了一年，现在到了年底，又开始蠢蠢欲动了。不知道什么时候能开始成为大家的回忆了。</p><p>买房。从毕业开始就在酝酿，今年来上班已经是五月了，来之后开始关注，到7月底买，算是一件大事了。</p><ul><li><strong>娱乐</strong>：能算是娱乐的比较多了。</li><li><strong>旅游</strong>：除了年初去北京出差学习回来后，都没出过省了</li><li><strong>体重</strong>： 继续保重中</li></ul><h1 id="hello-2021">Hello，2021</h1><h2 id="工作-v2">工作</h2><p><strong>专注、增加深度</strong>：在把事情做好的同时，能够更多的思考，而不是停留在表面。</p><p><strong>提高沟通表达能力</strong>： 说话慢一点；说话是为了让别人听明白，而不是自己明白；时常注重梳理好逻辑，不至于在讨论问题时被带偏</p><h2 id="学习-v2">学习</h2><p><strong>技术能力</strong>： 没啥可说的，一直都是最重要的。但是毕竟时间有限，优先做好什么。</p><p><strong>看书</strong>：每年都给自己一点目标，但是好像都没有完成，今年还是继续定一下，继续看自己的脸皮：12本吧，一个月一本了。</p><p><strong>博客</strong>：坚持，每月一篇；重在输出，而不是记录。学习过的内容，能够按照自己的想法写出来，这样才是更好的掌握。</p><h2 id="生活-v2">生活</h2><p><strong>慢一点</strong>：关注身边有趣有意义的事情，记录一些重要的事情和节点。</p><p><strong>体重</strong>：减重10%？</p><p><strong>旅游</strong>：疫情如果允许就出去玩一次。</p><p><strong>娱乐</strong>：注重半衰期更长的娱乐（运动、电影、纪录片之类），杜绝无营养的短视频和无聊的游戏（浪费时间又无法从中体验到该有的愉悦感，比如最近开始捡起来玩的dota2。。）</p><p><strong>其他折腾</strong>： 功利的对待自己的时间。</p><p>最后，2021年，继续加油，最后附上一张小豆的照片吧。</p><p><img src="https://blog-1252063226.cos.ap-beijing.myqcloud.com/img/image-20201228003035033.png" alt="image-20201228003035033"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 日常总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】Binlog详解</title>
      <link href="/2020/11/05/binlog/"/>
      <url>/2020/11/05/binlog/</url>
      
        <content type="html"><![CDATA[<p>Binlog作为MySQL重要的灵魂之一，在MySQL的主从同步、问题定位、数据恢复、增量备份等都发挥着重要的作用。也是MySQL多年来被大家信任的原因之一，同时Binlog也随着MySQL的流行被大家熟知，不过对于很多人来说，只是知道Binlog记录MySQL操作的功能，以及做过简单的解析查看操作SQL，却并没有深入。最近与Binlog交流比较多，就正好梳理下。</p><a id="more"></a>  <h1 id="什么是binlog">什么是Binlog</h1><p>Binlog是MySQL server层的日志，记录MySQL的数据更新或潜在更新的SQL语句。Binlog是与innodb引擎中的undo log和redo log不一样的</p><h2 id="binlog作用">Binlog作用</h2><p>binlog的作用主要包括：</p><ul><li>主从同步：在一个MySQL集群中，从库通过拉取主库的Binlog，在本地进行回放执行，从而同步主库的数据更新，达到主从同步的目的。主从同步也是一般生产环境MySQL服务高可用的必要保障。</li><li>数据恢复：作为一个数据存储工具，可能存在写错数据的情况，需要回滚到某一时间点，可以通过解析Binlog，通过binlog2sql等工具，来闪回到指定的时间点。</li><li>增量备份：一般生产环境都会对MySQL数据进行定期的备份，以应对MySQL集群的快速扩容、版本升级等需求，全量备份耗时较长，且占用空间较多，因此一般采用全量备份+增量备份的方式对集群数据进行备份，其中增量备份备份的就是Binlog。</li><li>问题定位：由于所有的数据更新都会记录在Binlog中，所以Binlog也是解决问题的一把好手，通过分析Binlog，有时是快速解决问题的途径。</li></ul><h2 id="binlog格式">Binlog格式</h2><p>Binlog格式分为三种：statement、row、mixed</p><ul><li>statement：记录数据更新的SQL。意思是binlog记录数据更新的语句，优点是节省binlog日志量，减少磁盘占用（只是在部分时候）。这种方式很简单，但是会存在问题，比如SQL中出现了now()等函数，还需要保存语句执行时候的一些信息，才能使语句在回放的时候不至于数据不一致。但是仍然有一些函数无法被复制。</li><li>row：记录数据变更的行记录。记录每一行被更改的记录，这样就能保证函数的执行也能被完全的记录，问题是，如果某条语句更新的行数较多（如变更表结构），会产生较多的Binlog，日志量增长很大。</li><li>mixed：是statement和row格式的一种折中，结合了两者的优点。会自动切换采用row还是statement格式，但是还是会存在数据不一致的问题。级联复制在特殊情况下会binlog丢失。</li></ul><p>在实际生产环境中，为了保证数据完全一致，还是会采用row格式的binlog，毕竟作为底层软件，首先应该保证正确，其次才是节省。</p><h2 id="binlog何时写入">Binlog何时写入</h2><p>Binlog在事务commit前才会写入（由于innodb的两阶段提交，会先写Binlog再写redo log）。</p><p>同时binlog的写入会通过参数<code>sync_binlog</code> 控制，如果设置为0，则表示不会主动控制Binlog的刷新，由文件系统控制缓存的刷新，设为0安全，当MySQL异常重启会丢失缓存中的事务。一般生产环境主库会设置为1，保证每次事务都能被写到磁盘。</p><h2 id="与其他日志的区别">与其他日志的区别</h2><h1 id="使用binlog">使用Binlog</h1><h2 id="mysql配置">MySQL配置</h2><p>Binlog的配置有一下几个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log_bin &#x3D; on   # 开启binlog</span><br><span class="line">binlog_format &#x3D; row  # binlog格式为row </span><br><span class="line">log_bin &#x3D; &#x2F;home&#x2F;work&#x2F;mysql&#x2F;log&#x2F;mysql-bin.log # binlog 位置</span><br><span class="line">expire_logs_days &#x3D; 7  # binlog清理周期7天</span><br><span class="line">max_binlog_size &#x3D; 1G  # binlog文件大小</span><br><span class="line">sync_binlog &#x3D; 1   # binlog刷盘控制，为1表示每次事务都会刷盘</span><br><span class="line">max_binlog_cache_size &#x3D; 2147483648  # 最大binlog缓存大小，如果一个事务的binlog超过此大小，会报错</span><br><span class="line">binlog_rows_query_log_events &#x3D; on  # 展示SQL</span><br></pre></td></tr></table></figure><h2 id="查看binlog">查看Binlog</h2><h3 id="查看binlog信息">查看Binlog信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 查看现有的binlog文件</span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 | 142554153 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line"></span><br><span class="line"># 查看当前binlog位点</span><br><span class="line">mysql&gt; show master status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             File: mysql-bin.000001</span><br><span class="line">         Position: 142556517</span><br><span class="line">     Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line">Executed_Gtid_Set: 727332c9-1a67-11eb-8021-fa163e7d3507:1-841889,</span><br><span class="line">73841e3c-ec47-11ea-9d43-fa163e263d6f:1-150</span><br><span class="line"></span><br><span class="line"># 清理binlog</span><br><span class="line">PURGE BINARY LOGS TO &#39;mysql-bin.000001&#39;; # 清理到</span><br><span class="line">PURGE BINARY LOGS BEFORE &#39;2014-04-28 23:59:59&#39;;</span><br><span class="line"></span><br><span class="line"># 查看binlog事件</span><br><span class="line">show binlog events in &#39;mysql-bin.000001&#39;;</span><br></pre></td></tr></table></figure><h3 id="远程查看">远程查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -R -hhostname -uroot -p123456 mysql-bin.000001 &gt; binlog.sql</span><br></pre></td></tr></table></figure><h3 id="本地查看">本地查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --base64-output&#x3D;DECODE-ROWS --start-position&#x3D;start_position --end-position&#x3D;end_position --start-time&#x3D;start_time --end-time&#x3D;end_time -v -v mysql-bin.000776 | less</span><br></pre></td></tr></table></figure><h1 id="binlog内容">Binlog内容</h1><h2 id="binlog基本格式">Binlog基本格式</h2><p>如官方文档所说:</p><ul><li>binlog文件以一个值为0Xfe62696e的魔数开头，这个魔数对应0xfe ‘b’‘i’‘n’。</li><li>binlog由一系列的binlog event构成。每个binlog event包含header和data两部分。</li></ul><p>​          <code>header</code>部分提供的是event的公共的类型信息，包括event的创建时间，服务器等</p><p>​          <code>data</code>部分提供的是针对该event的具体信息，如具体数据的修改</p><ul><li>最后一个<code>rotate event</code>用于说明下一个binlog文件</li><li>binlog索引文件是一个文本文件，其中内容为当前的binlog文件列表。比如下面就是一个mysql-bin.index文件的内容</li></ul><p>以执行一个insert语句为例，会产生如下几个binlog event。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="binlog事件解析">Binlog事件解析</h2><h1 id="注意">注意</h1><h2 id="事务的写入顺序">事务的写入顺序</h2><p>Reference：</p><p><a href="https://dev.mysql.com/doc/internals/en/binary-log.html" target="_blank" rel="noopener">官方Binlog解析</a></p><p>https://www.cnblogs.com/igoodful/p/11920740.html</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL45讲总结</title>
      <link href="/2020/06/23/yuque/MySQL45%E8%AE%B2%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/23/yuque/MySQL45%E8%AE%B2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="01-基础架构：一条-sql-查询语句是如何执行的？">01 | 基础架构：一条 SQL 查询语句是如何执行的？</h1><p>配置：wait_timeout：控制 Sleep 连接保持时间。线上未配置，默认 8 小时，</p><h4 id="sql-执行步骤">SQL 执行步骤</h4><p>客户端-连接器（管理连接、权限验证）-查询缓存（命中则直接返回，基本没啥用）-分析器（词法分析、语法分析，语法错误在这就能看到了）-优化器（执行计划生成、索引选择）-存储引擎（存储数据、提供读写接口）</p><h4 id="server-层">server 层</h4><p>连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h4 id="存储引擎">存储引擎</h4><p>负责数据的存储和提取。</p><h3 id="连接器">连接器</h3><p>Sleep：表示是空闲连接。</p><p>数据库长连接和短连接：长连接是连接成功后，如果客户端持续有请求，则一直使用同一个连接。优点：减少建立连接的动作，尽量使用短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>全部使用长连接问题：可能 MySQL 占用内存会涨的很快，因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的，会在连接断开才释放，如果长连接积累，会导致内存占用较大。解决办法：定期断开长连接；5.7 版本，执行比较大的操作的后，mysql_reset_connection 来重新初始化连接资源，恢复连接到刚刚创建时的状态。miproxy 连接数太多会自己断开</p><p>内存：操作系统 10G，应用 8G，线程级别的内存占用，一个连接占多大，tcp 占 1M，文件系统描述符。</p><p>为啥会用 swap 内存，操作系统配置：是否使用 swap    cpu 结构有关 对称一致访问：每个核心访问最近的 32G 内存最快，开了的话，cpu0 访问 32G，这个进程用了 32G 就会用 swap 分区。 smp  numa</p><h3 id="查询缓存">查询缓存</h3><p>基本没用了</p><h3 id="分析器">分析器</h3><p>词法分析：识别关键字，以及表名之类。语法分析：根据语法规则判断语法是否错误。</p><h3 id="优化器">优化器</h3><p>索引顺序选择，多表 join 顺序等。</p><h3 id="执行器">执行器</h3><p>执行前判断对表有没有相应权限。（没分析完词法，不知道是哪张表）</p><p>问题：1.Sleep 连接是不是杀了一直没影响2.miproxy 对连接的管理：长短连接，长连接的维护。<em>功能怎么实现的，</em>3.MySQL 内存的使用。（innodb_buffer_size_pool 之外的内存）。 4.数据库权限和表权限验证时间不一样</p><h1 id="02-日志系统：一条-sql-更新语句是如何执行的？">02 | 日志系统：一条 SQL 更新语句是如何执行的？</h1><p>线上配置：innodb_flush_log_at_trx_commit：为 1 时保证每次事务的 redo log 都会持久化到磁盘。sync_binlog：为 1 时保证每次事务的 binlog 都持久化到磁盘。</p><p>更新流程：两阶段提交，涉及和 binlog</p><p>||||||</p><table><thead><tr><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">redo log</td></tr><tr><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td></tr><tr><td style="text-align:left">binlog</td></tr><tr><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td></tr></tbody></table><p>redo log：保证了 MySQL crash-safe 能力。记录更新时，先把记录写到 redo log 并更新内存。binlog：。。，crash-safe：有了 redo-log，可以保证数据库异常重启时，从 redo log 读取后写入内存再写入磁盘，保证数据部丢失。</p><p>两阶段提交：更新写入到内存后，redolog 处于 prapare 阶段，然后写 binlog，再调用引擎的提交事务接口，将 redolog 改成提交状态。server 是作为一个协调者。innodb 只知道干啥。发起 commit 时候，innodb redo  write innodb 没完成不能马上写磁盘。</p><p>MySQL 磁盘满，会休眠，磁盘满。innodb 队列变长了，可能都建立连接不成功：gdbc 建立连接会 show 变量，要不建立连接不成功，要不就连接数暴涨。原因：如果在写完 binlog 到提交事务之间 MySQL crash 的问题。或者从备份恢复的时候。</p><p>问题：备份恢复 apply log 是在：将 redo log 的数据写入磁盘吗？</p><h1 id="03-事务隔离：为什么你改了我还看不见？">03 | 事务隔离：为什么你改了我还看不见？</h1><p>线上配置：</p><p>事务 ACID：Atomicity、Consistency、Isolation、Durability（原子性、一致性、隔离性、持久性）</p><p>多个事务同时执行会出现的问题：脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）隔离级别：读未提交：可以看到未提交的事务读提交：只有提交的事务才会被看到可重复读：一个事务执行过程中看到的数据，总是和启动时看到的一样。不管其他的事务有没有启动。串行化：顾名思义</p><p>|</p><table><thead><tr><th style="text-align:left">脏读</th><th style="text-align:left">不可重复读</th><th style="text-align:left">幻读</th><th style="text-align:left">视图开启时间（对于一个查询）</th></tr></thead><tbody><tr><td style="text-align:left">读未提交</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">读提交</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">可重复读</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">串行化</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr></tbody></table><p>幻读的原因：update 等操作的当前读，需要读取当前的数据，这个时候就会读到最新的更新数据了。表现为：单独 select 没有值，然后 insert 或者 update，发现值已经有了。</p><p>MVCC：undo log 实现</p><h1 id="04-深入浅出索引-上">04 | 深入浅出索引（上）</h1><p>innodb 索引类型：主键索引和：根据叶子节点的内容主键索引：叶子节点内容是整行数据非主键索引：叶子节点内容是主键的值。也叫二级索引。使用二级索引，如果想获得整列的值，需要先从索引找到主键值，然后再根据主键查，需要回表。</p><p>索引维护：分裂：某个数据页满了，新插入数据的时候。合并：相邻两个页删除了数据，利用率很低的时候。ps：自增主键是不会分裂的，因为一直是增长的。</p><p>问题： 1.同时插入较多数据时，索引维护是不是比较占资源。 2.业务字段做主键：只有一个索引；该索引必须是唯一索引？</p><h1 id="05-深入浅出索引-下">05 | 深入浅出索引（下）</h1><p>避免回表的方式：覆盖索引（组合索引）：索引使用注意： 1.最左前缀原则：不管是对于组合索引，还是对于 2.索引下推：MySQL5.6 优化，多个 and 条件的时候，对索引中的字段先过滤，减少回表次数。 2.索引列使用函数会导致索引失效</p><h1 id="06-全局锁和表锁-：给表加个字段怎么有这么多阻碍？">06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h1><p>加锁范围分类：全局锁、表级锁和行锁。全局锁加全局锁方法：Flush tables with read lock (FTWRL)。使用场景：全库逻辑备份（innodb 已经不需要了，可以使用–single-transaction）表级锁分为表锁和元数据锁（MDL）表锁：lock tables … read/write。元数据锁：当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。所以给小表加字段，如果读取较多的话，也会阻塞，会阻塞所有的查询和更新，如果客户端有重试机制，会导致该库线程打满。</p><p>尽量使用 FTWRL 而不是 set global read_only=1：1.read_only 可能会用来判断是主库还是备库。2.FTWRL 命令时，如果客户端异常断开，MySQL 会自动释放，set global read_only 会导致 MySQL 一直只读。</p><h1 id="07-行锁功过：怎么减少行锁对性能的影响？">07 | 行锁功过：怎么减少行锁对性能的影响？</h1><p>线上配置：innodb_lock_wait_timeout：10innodb_deadlock_detect：on两阶段锁协议：行锁在需要的时候才加上，但是在事务结束后才释放。所以要把可能影响并发的锁放在后面。死锁和死锁检测策略：一直等待到超时：innodb_lock_wait_timeout：一直等待锁，直到超时。值不能太大，也不能太小。死锁检测：发现死锁后，主动回滚死锁链条中的某偶一个事务，让其他事务执行。</p><p>问题：死锁检测成本：每个新来的线程，都要要判断会不会由于自己的加入导致死锁，如果同时更新同一行的线程很多的时候。CPU 消耗。原理怎么做的。</p><h1 id="08-事务到底是隔离的还是不隔离的？">08 | 事务到底是隔离的还是不隔离的？</h1><p>undolog：实现了 MVCC数据可见性，锁是实现隔离级别。查询和更新是当前读还是一致性读。一致性读：可重复读隔离级别下，读取数据时，会根据 row trx_id 找到是否能读到当前值，不在的话会根据 redo log 往前找。当前读：操作数据都是要读当前。可重复读隔离级别下，如果需要更新数据，只能拿最新的数据更新，这个时候虽然别的事务还没有提交，但还是能看到的。undolog 大小。共享表空间</p><h1 id="09-普通索引和唯一索引-应该怎么选择？">09 | 普通索引和唯一索引，应该怎么选择？</h1><h1 id="12-为什么我的-mysql-会-抖-一下？">12 | 为什么我的 MySQL 会“抖”一下？</h1><p>线上配置：innodb_flush_neighbors：1innodb_io_capacity：5000innodb_max_dirty_pages_pct：75</p><p>为什么会抖一下：1.redo log 满了。redo log 中的 checkpoint 前移动，需要刷脏页。（应该避免，因为此时数据库服务已经阻塞，需要控制刷脏页频率）  一般不会设置，不同百分比的时候不一样。 2.内存不足，需要淘汰脏页。buffer_pool     3.日常刷脏页。对应 MySQL 的配置。4.MySQL 正常关闭。</p><p>正常使用的数据库，buffer 一般未被使用的情况比较少，如果一个查询，需要的内存比较大，查询需要从磁盘读取很多页的时候，也要将脏页刷到磁盘中。可用的页，刷脏页，写到磁盘，redolog checkpoint 往前走，free list flush list lru list</p><p>脏页刷盘参考：一个是脏页比例，一个是 redo log 写盘速度。</p><p>如果高配机器 redo log 设置比较小的话：redo log 很容易被写满，就会导致经常要因为 redo log 满了而刷盘。表现为：磁盘压力很小，但是数据库出现间歇性的性能下跌</p><h1 id="13-为什么表数据删掉一半-表文件大小不变？">13 | 为什么表数据删掉一半，表文件大小不变？</h1><p>：怎么正确的回收表空间innodb_file_per_table：1 默认值删除整个表数据会删除，但是删除表中的部分数据，空间是怎么回收的。</p><p>delete 删除一条记录：将记录标记为已删除，之后可以复用。delete 删除多条记录：如果整个页被删除，则整页都被标记为可复用。相邻的两页使用率低，会合并。但空间均不会被释放。同理：插入数据，如果当前页已满，肯定会开启新页，也会造成数据空洞。</p><p>压缩空间：alter table A engine=InnoDB。5.5 之前不要用，会阻塞 DML。5.6 版本之后：Online DDL（先建新表，并将旧表的更新写在一个文件中，新表搞好之后，再读取文件中的更新。<strong>会有很短时间的 MDL 写锁</strong>）</p><p>DDL 过程如果是 Online 的，就一定是 inplace 的？</p><h1 id="14-count-这么慢-我该怎么办？">14 | count(*)这么慢，我该怎么办？</h1><p>不加 where 条件：MyISAM 引擎：把一个表的总行数存在了磁盘上，因此执行 count(*)的时候会直接返回这个数，效率很高；InnoDB 引擎：数据一行一行地从引擎里面读出来，然后累积计数。show table status：不准确。</p><p>加 where 条件：InnoDB 引擎：选择从引擎读</p><p>效率排序：count(字段)&lt;count(主键 id)&lt;count(1)≈count(<em>)count(</em>)：特殊处理过，因为不会为 null，server 会按行累计。</p><p>count(1)：InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。count(主键 id)：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。count(字段)：根据是否为 not null 进行判断。</p><h1 id="15-答疑文章-一-：日志和索引相关问题">15 | 答疑文章（一）：日志和索引相关问题</h1><p>日志相关： 1.两阶段提交不同瞬间 MySQL 异常重启怎么保证数据完整性：测试</p><h1 id="16-order-by-是怎么工作的？">16 | “order by”是怎么工作的？</h1><h2 id="全字段排序">全字段排序</h2><p>排序过程对字符串做了“紧凑”处理。即使 name 字段的定义是 varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</p><p>max_length_for_sort_data</p><h2 id="rowid-排序">rowid 排序</h2>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言基础学习(3)</title>
      <link href="/2019/09/12/yuque/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(3)/"/>
      <url>/2019/09/12/yuque/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(3)/</url>
      
        <content type="html"><![CDATA[<p>配置了 Ubuntu 相关编程环境，学习 Go 语言基础内容，主要是跟着官方教程走一遍，对比 C++的一些不同点学习。</p><h1 id="一-go-语言变量-函数">一.Go 语言变量、函数</h1><h2 id="1-变量的初始化">1.变量的初始化</h2><ul><li>可以通过 <code>var a int</code>  或者采用 <code>a:=3</code>  省略变量的类型，Go 语言会自动推导变量的类型。</li></ul><h2 id="2-go-语言的基本类型">2.Go 语言的基本类型</h2><ul><li>多了一个 rune 类型，教程里没有仔细介绍，也很少使用，之后再注意。</li></ul><h2 id="3-类型转换">3.类型转换</h2><ul><li>Go 语言中不同类型的项之间需要显示转换，没有隐式类型转换。</li></ul><h2 id="4-函数有多返回值">4.函数有多返回值</h2><h1 id="二-go-语言中的流程控制">二.Go 语言中的流程控制</h1><h2 id="1-go-语言中的循环只有-for">1.Go 语言中的循环只有 for</h2><ul><li>所有的循环都采用 for 来实现，for 的使用与 C++类似，但是 for 后面不需要小括号，一定需要大括号。</li><li>可以在 for 循环中定义变量，但作用于只在 for 循环中。</li><li>需要注意的是，Go 语言只有后置++，没有前置++。</li><li>另外，for 语句中可以有空项，但是分号要写上。</li><li>当 for 用来写 while 循环时，可以直接采用 <code>for i&lt;100{}</code> ，不需要写上全部分号。</li></ul><h2 id="2-if-语句">2.if 语句</h2><ul><li>if 语句表达式外不需要小括号，但是一定需要大括号，这点与 for 语句的使用是类似的。</li><li>可以在 if 语句中执行一个简单的语句，分号隔开后再加判断语句。</li><li>同样，else 后面也需要大括号</li></ul><h2 id="3-switch-语句">3.switch 语句</h2><ul><li>Go 语言的 switch 中的 case 可以不是常量，也可以不是整数。</li><li>Switch 中的 case 语句，自带 break，不需要再写 break。</li></ul><h2 id="4-defer-语句">4.defer 语句</h2><ul><li>defer 语句会推迟到外层函数执行结束后执行。</li><li>defer 语句会压栈，当有多个 defer 语句时，后面的 defer 语句会先执行。</li></ul><h1 id="三-slice">三.slice</h1><ul><li>切片就像数组的引用，改变切片会改变底层的值</li><li>切片的默认行为，可以不写完整的上下限，切片默认有上下限</li><li>只是截取切片是不会改变切片大小的</li><li>切片的长度就是它所包含的元素个数，容量是从它的第一个元素开始数，到其底层数组元素末尾的个数</li><li>切片的零值是  <code>nil</code></li></ul><h1 id="四-主要问题记录">四.主要问题记录</h1><h2 id="1-fmt-println-函数中的执行顺序问题">1. fmt.Println()函数中的执行顺序问题</h2><p>当 Println()中打印多个函数的执行结果时，Println()会先顺序调用每个函数，将其结果保存，之后再顺序打印。例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">sum:=x+y</span><br><span class="line">fmt.Println(sum)</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>,<span class="number">2</span>),add(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="2-切片的容量扩展问题">2.切片的容量扩展问题</h2><p>类似于 C++中的 vector，切片的容量扩展，大部分时候也是采用 2 倍扩展，但是也有稍许的差别，在学习过程中无意发现，查看源码可以看到 append 的实现。就 int 而言，当元素个数小于 20 时，当 slice 的容量不够时，继续 append 会将 cap+1，超过 20 后才会 cap*2。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo折腾笔记</title>
      <link href="/2019/08/13/yuque/Hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/08/13/yuque/Hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="博客基本架构">博客基本架构</h2><p>如下图所示，博客更新只需要在语雀上发布对应的文章即可，剩下的工作都会自动化进行。</p><h2 id="对应工具">对应工具</h2><p>语雀：编写博客腾讯云云函数: webhook 解析更新文档推送至 github 私有仓库travis-ci：当私有仓库有更新时，通过 hexo 生成静态页面，并推送至 mianhk.github.io 仓库cloud-flare：网页 CDN</p><h2 id="2019-5-12">2019-5-12</h2><blockquote><p>没错，这几天又开始折腾一下博客了，最近的节奏天天白天待在实验室怼论文，晚上看 C++，时间安排比较紧凑，就觉得更需要阶段性的总结吧，所以又来写博客了，github 始终是一个好的选择，于是入了 Hexo 的坑。。折腾的过程心情总是有些复杂，在激动和 mmp 之间徘徊，虽然很多问题在 wiki 和 issue 里都有，但还是想总结一下自己亲自踩的坑。</p></blockquote><p>修改语雀自动同步，不用再本地编辑和推送了，见：<a href="https://www.yuguocong.cn/yuque/mwklk2.html">https://www.yuguocong.cn/yuque/mwklk2.html</a></p><p>更换了主题：<a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">Aircloud</a></p><h2 id="2018-12-24">2018-12-24</h2><h3 id="hexo-添加分类">Hexo 添加分类</h3><p>在文件中使用<code>categories</code>，然后配置<code>themes/_config.yml</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;</span><br><span class="line">  #categories: &#x2F;categories&#x2F;</span><br><span class="line">  archives: &#x2F;archives&#x2F;</span><br><span class="line">  tags: &#x2F;tags&#x2F;</span><br><span class="line">  books: &#x2F;books</span><br><span class="line">  movies: &#x2F;movies</span><br><span class="line">  friends: &#x2F;categories&#x2F;friends</span><br><span class="line">  about: &#x2F;categories&#x2F;about</span><br></pre></td></tr></table></figure><h3 id="添加背景图片">添加背景图片</h3><p>使用插件 jquery-backstretch，编辑文件<code>/themes/next/layout/_layout.swig</code>,将下面的代码添加到最后面 body 的前面:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;jquery-backstretch&#x2F;2.0.4&#x2F;jquery.backstretch.min.js&quot;&gt;&lt;&#x2F;script&gt;;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  $(&quot;body&quot;).backstretch(&quot;http:&#x2F;&#x2F;blog-1252063226.cosbj.myqcloud.com&#x2F;network&#x2F;20181224194730.png&quot;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>但是好像没有效果，于是在文件<code>themes\next\source\css_custom\custom.styl</code>中添加了如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(https:&#x2F;&#x2F;source.unsplash.com&#x2F;random&#x2F;1600x900);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改背景的不透明度</span><br><span class="line">.main-inner &#123;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    padding: 60px 60px 60px 60px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-hexo-neat-进行压缩以增加页面速度">使用 hexo-neat 进行压缩以增加页面速度</h3><p>采用<code>hexo-neat</code>进行压缩，插件地址为：https://github.com/rozbo/hexo-neat，使用步骤为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装hexo-neat</span><br><span class="line">$ npm install hexo-neat --save</span><br></pre></td></tr></table></figure><p>添加配置到根目录下的<code>_config.yml</code>，在最后加上(这里跟别人的有一些改动，因为有一些配置出了问题，找了很久，但是还是没有解决，干脆就不折腾了):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.html&#39;</span><br><span class="line"># 压缩css</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.css&#39;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.js&#39;</span><br><span class="line">    - &#39;**&#x2F;jquery.fancybox.pack.js&#39;</span><br><span class="line">    - &#39;**&#x2F;index.js&#39;</span><br></pre></td></tr></table></figure><p>不用再做其他的改动，压缩前后的对比为：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557751534763-6f377175-946d-4f32-bc8e-1cbaf76c4355.png#align=left&amp;display=inline&amp;height=179&amp;margin=%5Bobject%20Object%5D&amp;originHeight=179&amp;originWidth=717&amp;size=0&amp;status=done&amp;style=none&amp;width=717" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/187932/1557751534766-e8651cdc-63b9-40d7-979c-f796aabb328a.jpeg#align=left&amp;display=inline&amp;height=407&amp;margin=%5Bobject%20Object%5D&amp;originHeight=407&amp;originWidth=1117&amp;size=0&amp;status=done&amp;style=none&amp;width=1117" alt=""></p><h5 id="主页文章添加阴影效果">主页文章添加阴影效果</h5><h5 id="在网站底部加上访问量">在网站底部加上访问量</h5><h5 id="添加热度">添加热度</h5><h5 id="网站底部字数统计">网站底部字数统计</h5><h5 id="修改-代码块自定义样式">修改``代码块自定义样式</h5><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：(颜色可以自己定义):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加访问量">添加访问量</h5><p>打开<code>\themes\next\layout\_partials\footer.swig</code>文件,搜索<code>&lt;div class=&quot;copyright&quot;&gt;</code>，在这个<code>div</code>标签前边加上如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;dn-lbstatics.qbox.me&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>然后再在合适的位置添加如下代码，放在 footer.swig 文件的末尾:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;powered-by&quot;&gt;</span><br><span class="line">&lt;i class&#x3D;&quot;fa fa-user-md&quot;&gt;&lt;&#x2F;i&gt;&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">  本站访客数:&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h5 id="设置博文内链接为蓝色">设置博文内链接为蓝色</h5><p>通过路径：<code>themes\next\source\css\_common\components\post\</code>,打开<code>post.styl</code>文件，在文件中添加，如下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">      color: #0593d3;</span><br><span class="line">      border-bottom: none;</span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        color: #0477ab;</span><br><span class="line">        text-decoration: underline;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="设置文章末尾-本文结束-标记">设置文章末尾”本文结束”标记</h5><h5 id="显示每篇文章字数">显示每篇文章字数</h5><h5 id="文章末尾添加版权说明">文章末尾添加版权说明</h5><p>直接修改<code>主题配置文件</code>，定位到<code>post_copyright</code>，将<code>enable</code>由<code>false</code>改为<code>true</code>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;3.0&#x2F;</span><br></pre></td></tr></table></figure><h5 id="实现-fork-me-on-github">实现 fork me on github</h5><p>在右上角或者左上角实现 fork me on github。点击<a href="https://blog.github.com/2008-12-19-github-ribbons/" target="_blank" rel="noopener">这里</a>挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;you&quot;&gt;&lt;img style&#x3D;&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src&#x3D;&quot;https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;github&#x2F;ribbons&#x2F;forkme_left_darkblue_121621.png&quot; alt&#x3D;&quot;Fork me on GitHub&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>粘贴刚才复制的代码到<code>themes/next/layout/_layout.swig</code>文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面)，并把<code>href</code>标签改为 github 地址：</p><h5 id="修改文章底部的-号标签">修改文章底部的#号标签</h5><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将其中的 <code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h5 id="添加搜索功能">添加搜索功能</h5><p>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>编辑 <code>站点配置文件</code> （站点根目录下），新增以下内容到任意位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>编辑 <code>主题配置文件</code> （主题目录下），启用本地搜索功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h5 id="图床修改">图床修改</h5><p>由于以前都是直接使用的 github 私人仓库做的图床，但是有时候就是访问不到，因为博客是采用双部署的，可能 coding 上的已经是外链了被屏蔽了，所以还是得想点别的办法了。看到网上说的各种，其实都还是有点问题，最终发现最近的腾讯对象存储，发现还真的可以。软件名：picgo链接：<a href="https://sspai.com/post/42310" target="_blank" rel="noopener">https://sspai.com/post/42310</a>使用方法：<a href="https://github.com/Molunerfinn/PicGo/wiki/%E8%AF%A6%E7%BB%86%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8#v5%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/wiki/详细窗口的使用#v5 版本说明</a></p><h5 id="next-主题个性化之自动更换背景图片">Next 主题个性化之自动更换背景图片</h5><p><a href="https://blog.csdn.net/mango_haoming/article/details/78473243" target="_blank" rel="noopener">https://blog.csdn.net/mango_haoming/article/details/78473243</a></p><h5 id="修改主题：yilia-已取消">修改主题：yilia（已取消）</h5><p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></p><h5 id="2018-4-22-加入畅言评论-已取消">2018-4-22 加入畅言评论（已取消）</h5><p>详见：<a href="https://blog.csdn.net/lcyaiym/article/details/76762074" target="_blank" rel="noopener">https://blog.csdn.net/lcyaiym/article/details/76762074</a></p><h5 id="2018-4-10-加入豆瓣读书和电影">2018-4-10 加入豆瓣读书和电影</h5><p>详细见：<a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener">https://github.com/mythsman/hexo-douban</a></p><h5 id="页面中文无法显示的问题">页面中文无法显示的问题</h5><p>这种中文问题，基本上都是编码的问题，但是开始各种都没找到原因，改了 language 里面的配置文件，最后发现是文件的编码，需要改成’无 bom 的 utf-8 的编码格式 ’</p><h5 id="主界面无法显示-categories-和-tags-的问题">主界面无法显示 categories 和 tags 的问题</h5><p>这个问题真的是搞的有点久，因为基本上都被人忽略了，也可能很多人都没遇到而我恰好遇到了吧，不懂前端的我只能对于这种玄学问题强行百度了。解决办法：将 categories 和 tags 目录下的 index 文件分别改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">tags:</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>折腾完又不早了，希望以后好好看书，好好编程吧，最近没有什么特别大的梦想，只想安静的学习。。。</p><h5 id="绑定-gitpages-到自己的域名">绑定 gitpages 到自己的域名</h5><p>打开<a href="https://education.github.com/" target="_blank" rel="noopener">学生包</a>，通过教育邮箱申请之后，可以在 package 中找到那么 namecheap，注册通过 GitHub 进入，可以直接申请域名，会自动绑定到我们的 gitpage，不过还需要一点点修改，就是把 cname 的 www 改成我们的 gitpage 页面，就可以了。。</p><h5 id="采用-coding-和-gitpages-双部署">采用 coding 和 gitpages 双部署</h5><p>采用双部署的原因是国内访问 github 的速度有时候太感人了，有些人直接打不开，搞得有点尴尬，于是看到了网上所说的双部署，将默认的国内地址解析到 coding 的 pages 服务上，其他的绑定到 gitpage 上，这样国内的访问速度就快了。具体的 coding pages 的搭建就不写了，在 coding 网站中建好仓库后，在我们本地的 config 文件后面的 push repository 加上 coding page 仓库的地址就可以了。具体的 cname 记录和 A 记录如下图：</p><p>** Reference: **<a href="https://tding.top/archives/12c6c559.html" target="_blank" rel="noopener">域名操作</a><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 文档</a><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next 主题文档</a><a href="http://blog.csdn.net/dengnanyi/article/details/53969684" target="_blank" rel="noopener">绑定到 coding</a><a href="https://zhuanlan.zhihu.com/p/33616481" target="_blank" rel="noopener">Hexo 搭建的 GitHub 博客之优化大全</a><a href="https://wafer.li/Hexo/%E8%A7%A3%E5%86%B3%20Travis%20CI%20%E6%80%BB%E6%98%AF%E6%9B%B4%E6%96%B0%E6%97%A7%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决 Travis CI 总是更新旧博客的问题</a><a href="http://www.tianguolangzi.com/2018/01/17/hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">修改背景图片</a><a href="https://xyzardq.github.io/2016/11/02/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">Hexo 添加分类</a><a href="https://segmentfault.com/a/1190000017797561" target="_blank" rel="noopener">云端写作，自动部署</a><a href="https://luan.ma/post/yuque2blog/" target="_blank" rel="noopener">静态博客使用语雀编辑器</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言基础学习(4)</title>
      <link href="/2019/07/04/yuque/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(4)/"/>
      <url>/2019/07/04/yuque/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(4)/</url>
      
        <content type="html"><![CDATA[<ol><li>类型别名type S string 与type S = string 区别？</li></ol><p>type S string 是类型声明，S 是一种新的类型，给 S 定义的方法，接口等和 string 没有关系。而 type S = string 只是一种别名，可以理解为，S 和 String 是完全一样的，只是换了一种叫法而已。类型别名和原类型方法是一样的。也不能在 Switch 中使用两者同时作为分支。</p><ol start="2"><li>go 语言中没有按地址传递，可以深究一下如何传递 slice，再回复到邮件中</li></ol><p>Go 语言中只有按值传递，通过源码可以看到，slice 是一个结构体。结构体中包括真正的数组和长度以及容量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line">len   int</span><br><span class="line">cap   int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数传递 slice 时，其实传递的 slice 结构体，其中包括 array 的首地址、len 和 cap。通过下面的代码可以有以下的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func add_slice(a []int)&#123;</span><br><span class="line">a[0]&#x3D;2</span><br><span class="line">a[1]&#x3D;3</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func append_slice(a []int)&#123;</span><br><span class="line">a&#x3D;append(a,5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func modify_slice(a *[]int)&#123;</span><br><span class="line">*a&#x3D;append(*a,6)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">a:&#x3D;[]int&#123;1,2,3&#125;</span><br><span class="line"></span><br><span class="line">add_slice(a)</span><br><span class="line">fmt.Println(a)  &#x2F;&#x2F;输出[2 3 3]</span><br><span class="line"></span><br><span class="line">append_slice(a)</span><br><span class="line">fmt.Println(a)  &#x2F;&#x2F;输出[2 3 3]</span><br><span class="line"></span><br><span class="line">modify_slice(&amp;a)</span><br><span class="line">fmt.Println(a)   &#x2F;&#x2F;输出[2 3 3 6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是改变 slice 内部的值时，看起来像是按引用传递，因为可以改变 slice 内的值，但是实际上是在参数传递的过程中，传递了 array 的首地址，而 slice 在内存中是一连串的地址，所以知道首地址就可以修改整个数组内部的值。    但是由于是按值传递，所以不能在函数内对 slice 进行 append。如果需要改变 slice 的长度，可以通过传入 slice 的指针。    由于 slice 传递的形式，需要在编程中多多注意，避免进坑。另外看到一个关于传递 slice 的操作，加深了一下对 slice 传参的理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; []int&#123;7,8,9&#125;</span><br><span class="line">b:&#x3D;[]int&#123;&#125;</span><br><span class="line">b&#x3D;append(b,1,2,3)  &#x2F;&#x2F;a,b初始化的方式不一样，导致两者的cap不一样</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;a len: %d cap:%d data:%+v\n&quot;, len(a), cap(a), a)  &#x2F;&#x2F;a len: 3 cap:3 data:[7 8 9]</span><br><span class="line">fmt.Printf(&quot;b len: %d cap:%d data:%+v\n&quot;, len(b), cap(b), b)  &#x2F;&#x2F;b len: 3 cap:4 data:[1 2 3]</span><br><span class="line"></span><br><span class="line">append_slice(a)    &#x2F;&#x2F;显然append是没有效果的</span><br><span class="line">fmt.Printf(&quot;a len: %d cap:%d data:%+v\n&quot;, len(a), cap(a), a)</span><br><span class="line">p :&#x3D; unsafe.Pointer(&amp;a[2])  &#x2F;&#x2F;根据slice在内存的连续性，拿到最后一位的指针地址</span><br><span class="line">q :&#x3D; uintptr(p)+8           &#x2F;&#x2F;将指针往后移一位，因为是int，所以是8</span><br><span class="line">t :&#x3D; (*int)(unsafe.Pointer(q))</span><br><span class="line">fmt.Println(*t)             &#x2F;&#x2F;输出0</span><br><span class="line"></span><br><span class="line">append_slice(b)</span><br><span class="line">fmt.Printf(&quot;b len: %d cap:%d data:%+v\n&quot;, len(b), cap(b), b)</span><br><span class="line">p1 :&#x3D; unsafe.Pointer(&amp;b[2])</span><br><span class="line">q1 :&#x3D; uintptr(p1)+8</span><br><span class="line">t1 :&#x3D; (*int)(unsafe.Pointer(q1))</span><br><span class="line">fmt.Println(*t1)    &#x2F;&#x2F;输出10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func append_slice(a []int) &#123;</span><br><span class="line">a &#x3D; append(a, 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，直接 append 到 slice 的值，如果 cap 够的话，是会 append 上的，但是由于 len 的值没有改变，所以看不到，可以通过 unsafe 指针观察到结果。但是如果 cap 不够，继续 append，会导致重新分配内存空间，append 在新的位置上，此时通过 unsafe 指针也拿不到 append 的值。</p><ol start="3"><li>关于函数的执行顺序：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func add1(x,y int) int&#123;</span><br><span class="line">fmt.Println(&quot;in add1. sum1&#x3D; &quot;,x,y)</span><br><span class="line">return x+y</span><br><span class="line">&#125;</span><br><span class="line">func add(x,y,z,t int) int&#123;</span><br><span class="line">sum:&#x3D;0</span><br><span class="line">sum&#x3D;add1(x,y)+add1(z,t)</span><br><span class="line">fmt.Println(&quot;in add. sum&#x3D;&quot;,sum)</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">fmt.Println(add(1,2,3,4),add(2,3,4,5))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">in add1. sum1&#x3D;  1 2</span><br><span class="line">in add1. sum1&#x3D;  3 4</span><br><span class="line">in add. sum&#x3D; 10</span><br><span class="line">in add1. sum1&#x3D;  2 3</span><br><span class="line">in add1. sum1&#x3D;  4 5</span><br><span class="line">in add. sum&#x3D; 14</span><br><span class="line">10 14</span><br></pre></td></tr></table></figure><p>可以看到，add1 的结果是最先执行的，再执行 add，最后才执行 fmt.Println（）.是按后序遍历的顺序。</p><h1 id="go-语言学习">go 语言学习</h1><ul><li>命名返回值:没有参数的  return  语句返回已命名的返回值</li><li>println 的执行顺序。会先把函数计算结束之后，再按照顺序输出</li><li>没有条件的 switch 同  <code>switch true</code>  一样。</li><li>defer 函数调用会被压入一个栈中，所以后 defer 的值会先输出</li><li>结构体指针的使用：修改结构体指针的值时，不需要带*号。</li><li>数组定义的几种方式</li></ul><h1 id="关于切片">关于切片</h1><ul><li><p>切片就像数组的引用，改变切片会改变底层的值</p></li><li><p>切片的默认行为，可以不写完全部的上下限，因为切片默认有上下限</p></li><li><p>只是截取切片是不会改变切片大小的</p></li><li><p>切片的长度就是它所包含的元素个数。</p></li><li><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数</p></li><li><p>切片的零值是  <code>nil</code></p></li><li><p>函数的闭包</p></li><li><p>接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法，可以定义别名，<code>**type **MyFloat float64</code></p></li></ul><h1 id="关于方法和接口">关于方法和接口</h1><ul><li><p>指针参数的函数必须接受一个指针,而以指针为接收者的方法被调用时，接收者既能为值又能为指针</p></li><li><p>跟 C++中一样，使用指针接收者可以修改接收者指向的值；另外，可以避免每次在调用方法时复制该值。</p><p>1.函数执行顺序是否是后序遍历的方式，可以再嵌套一层方法试试？ 画个调用树出来看看？我在网上没有找到相关的解释，就自己查看了 fmt.Println()函数的源码，会先调用 Fprintln 函数，而 Fprintln 会先执行传入的函数，存在 p 的 buf 中，之后转换成 string 再打印。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func Println(a ...interface&#123;&#125;) (n int, err error) &#123;</span><br><span class="line">return Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br><span class="line">func Sprintln(a ...interface&#123;&#125;) string &#123;</span><br><span class="line">p :&#x3D; newPrinter()</span><br><span class="line">p.doPrintln(a)</span><br><span class="line">s :&#x3D; string(p.buf)</span><br><span class="line">p.free()</span><br><span class="line">return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时也重新把打印语句加复杂了一下，结果与预期相符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func add(x,y int) int&#123;</span><br><span class="line">sum:&#x3D;x+y</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line">func main()&#123;</span><br><span class="line">fmt.Println(add(1,2),add(add(1,1),add(3,7)),add(4,5))</span><br><span class="line">&#125;</span><br><span class="line">运行结果为：</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">9</span><br><span class="line">3 12 9</span><br></pre></td></tr></table></figure><ol start="2"><li>切片的增长为什么是 20，是否在大于 1024 或某个值时，有其他的增长方法？ 比如 增加 1.2 倍？ 可以贴源码作为论据查看了一下 slice 中的 growslice 函数，可以看到当容量小于 1024 时，是按照 2 倍进行增长的，当超过 1024 时，按照 1.25 倍进行增长，应该是从节省空间的角度考虑，毕竟对一个很长的数组，再插入同样长度的数的概率很小。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap :&#x3D; old.cap</span><br><span class="line">doublecap :&#x3D; newcap + newcap</span><br><span class="line">if cap &gt; doublecap &#123;</span><br><span class="line">newcap &#x3D; cap</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if old.len &lt; 1024 &#123;</span><br><span class="line">newcap &#x3D; doublecap</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; Check 0 &lt; newcap to detect overflow</span><br><span class="line">&#x2F;&#x2F; and prevent an infinite loop.</span><br><span class="line">for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;</span><br><span class="line">newcap +&#x3D; newcap &#x2F; 4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Set newcap to the requested cap when</span><br><span class="line">&#x2F;&#x2F; the newcap calculation overflowed.</span><br><span class="line">if newcap &lt;&#x3D; 0 &#123;</span><br><span class="line">newcap &#x3D; cap</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码测试上述结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">var a []int</span><br><span class="line">for i:&#x3D;0;i&lt;1500;i++&#123;</span><br><span class="line">a&#x3D;append(a,i)</span><br><span class="line">if i%100&#x3D;&#x3D;0&#123;</span><br><span class="line">fmt.Printf(&quot;len: %d , cap; %d\n&quot;,len(a),cap(a))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line">len: 1 , cap; 1</span><br><span class="line">len: 101 , cap; 128</span><br><span class="line">len: 201 , cap; 256</span><br><span class="line">len: 301 , cap; 512</span><br><span class="line">len: 401 , cap; 512</span><br><span class="line">len: 501 , cap; 512</span><br><span class="line">len: 601 , cap; 1024</span><br><span class="line">len: 701 , cap; 1024</span><br><span class="line">len: 801 , cap; 1024</span><br><span class="line">len: 901 , cap; 1024</span><br><span class="line">len: 1001 , cap; 1024</span><br><span class="line">len: 1101 , cap; 1280</span><br><span class="line">len: 1201 , cap; 1280</span><br><span class="line">len: 1301 , cap; 1696</span><br><span class="line">len: 1401 , cap; 1696</span><br></pre></td></tr></table></figure><p>如上符合源码结果，所以之前的分析有些问题，但是 append 多个值的时候，与之前的结果相同。再次查看源码，发现实际上还有内存对齐的考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capmem &#x3D; roundupsize(uintptr(newcap) * sys.PtrSize)</span><br></pre></td></tr></table></figure><p>其中 capmem 会根据 roundupsize 函数进行内存对齐。其中 uintptr(newcap)表示新容量的大小，sys.PtrSize 表示一个元素的大小，int 时为 8。roundupsize 函数的实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func roundupsize(size uintptr) uintptr &#123;</span><br><span class="line">if size &lt; _MaxSmallSize &#123;</span><br><span class="line">if size &lt;&#x3D; smallSizeMax-8 &#123;</span><br><span class="line">return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)&#x2F;smallSizeDiv]])</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)&#x2F;largeSizeDiv]])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if size+_PageSize &lt; size &#123;</span><br><span class="line">return size</span><br><span class="line">&#125;</span><br><span class="line">return round(size, _PageSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：_MaxSmallSize=32768,2 的 15 次方，是 32K。当需要分配的 size 大于 32K 时，需要 mchche 向 mcentral 申请；当 size 小于 32K 时，计算应该分配的 sizeclass，直接去 mchche 申请。（关于具体的内存申请方面，在后面的开发需要的时候再仔细研究）当 size 小于 smallSizeMax-8=1024-8=1016 时，采用 size_to_class8 的分配方式，大于 1016 时采用 size_to_class128 的分配方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_to_class8 &#x3D; [smallSizeMax&#x2F;smallSizeDiv + 1]uint8&#123;0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31&#125;</span><br><span class="line">size_to_class128 &#x3D; [(_MaxSmallSize-smallSizeMax)&#x2F;largeSizeDiv + 1]uint8&#123;31, 32, 33, 34, 35, 36, 36, 37, 37, 38, 38, 39, 39, 39, 40, 40, 40, 41, 42, 42, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 47, 47, 47, 48, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66&#125;</span><br><span class="line">class_to_size &#x3D; [_NumSizeClasses]uint16&#123;0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个数组值的不同，并且间隔的粒度也不同，当 size 较小时，间隔为 8，当 size 较大时，间隔为 128.而为了内存优化考虑，class_to_size 会控制分配大小，间隔从 8-4096以 int 为例</p><table><thead><tr><th style="text-align:left">个数</th><th style="text-align:left">1</th><th style="text-align:left">2</th><th style="text-align:left">3</th><th style="text-align:left">4</th><th style="text-align:left">5</th><th style="text-align:left">6</th><th style="text-align:left">7</th><th style="text-align:left">8</th><th style="text-align:left">9</th></tr></thead><tbody><tr><td style="text-align:left">字节数</td><td style="text-align:left">8</td><td style="text-align:left">16</td><td style="text-align:left">24</td><td style="text-align:left">32</td><td style="text-align:left">40</td><td style="text-align:left">48</td><td style="text-align:left">56</td><td style="text-align:left">64</td><td style="text-align:left">72</td></tr><tr><td style="text-align:left">所占空间</td><td style="text-align:left">8</td><td style="text-align:left">16</td><td style="text-align:left">32</td><td style="text-align:left">32</td><td style="text-align:left">48</td><td style="text-align:left">48</td><td style="text-align:left">64</td><td style="text-align:left">64</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left">size_to_class8</td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">3</td><td style="text-align:left">4</td><td style="text-align:left">4</td><td style="text-align:left">5</td><td style="text-align:left">5</td><td style="text-align:left">6</td></tr></tbody></table><h2 id="tips">Tips</h2><p>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var rmdirs []func()</span><br><span class="line">for _, d :&#x3D; range tempDirs() &#123;</span><br><span class="line">  dir :&#x3D; d &#x2F;&#x2F; NOTE: necessary!如果没有这一行会导致传入同样的dir</span><br><span class="line">  os.MkdirAll(dir, 0755) &#x2F;&#x2F; creates parent directories too</span><br><span class="line">  rmdirs &#x3D; append(rmdirs, func() &#123;</span><br><span class="line">  os.RemoveAll(dir)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ...do some work…</span><br><span class="line">for _, rmdir :&#x3D; range rmdirs &#123;</span><br><span class="line">rmdir() &#x2F;&#x2F; clean up</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Golang】go语言学习(1)-初识切片</title>
      <link href="/2019/07/02/yuque/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0(1)/"/>
      <url>/2019/07/02/yuque/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="基础记录">基础记录</h1><ul><li>命名返回值:没有参数的  return  语句返回已命名的返回值</li><li>println 的执行顺序。会先把函数计算结束之后，再按照顺序输出</li><li>没有条件的 switch 同  <code>switch true</code>  一样。</li><li>defer 函数调用会被压入一个栈中，所以后 defer 的值会先输出</li><li>结构体指针的使用：修改结构体指针的值时，不需要带*号。</li><li>数组定义的几种方式</li></ul><h1 id="关于切片">关于切片</h1><ul><li><p>切片就像数组的引用，改变切片会改变底层的值</p></li><li><p>切片的默认行为，可以不写完全部的上下限，因为切片默认有上下限</p></li><li><p>只是截取切片是不会改变切片大小的</p></li><li><p>切片的长度就是它所包含的元素个数。</p></li><li><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数</p></li><li><p>切片的零值是  <code>nil</code></p></li><li><p>函数的闭包</p></li><li><p>接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法，可以定义别名，<code>**type **MyFloat float64</code></p></li></ul><h1 id="关于方法和接口">关于方法和接口</h1><ul><li><p>指针参数的函数必须接受一个指针,而以指针为接收者的方法被调用时，接收者既能为值又能为指针</p></li><li><p>跟 C++中一样，使用指针接收者可以修改接收者指向的值；另外，可以避免每次在调用方法时复制该值。</p><p>1.函数执行顺序是否是后序遍历的方式，可以再嵌套一层方法试试？ 画个调用树出来看看？我在网上没有找到相关的解释，就自己查看了 fmt.Println()函数的源码，会先调用 Fprintln 函数，而 Fprintln 会先执行传入的函数，存在 p 的 buf 中，之后转换成 string 再打印。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.doPrintln(a)</span><br><span class="line">s := <span class="keyword">string</span>(p.buf)</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时也重新把打印语句加复杂了一下，结果与预期相符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">sum:=x+y</span><br><span class="line">fmt.Println(sum)</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>,<span class="number">2</span>),add(add(<span class="number">1</span>,<span class="number">1</span>),add(<span class="number">3</span>,<span class="number">7</span>)),add(<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line">运行结果为：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">12</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ol start="2"><li>切片的增长为什么是 20，是否在大于 1024 或某个值时，有其他的增长方法？ 比如 增加 1.2 倍？ 可以贴源码作为论据查看了一下 slice 中的 growslice 函数，可以看到当容量小于 1024 时，是按照 2 倍进行增长的，当超过 1024 时，按照 1.25 倍进行增长，应该是从节省空间的角度考虑，毕竟对一个很长的数组，再插入同样长度的数的概率很小。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码测试上述结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">1500</span>;i++&#123;</span><br><span class="line">a=<span class="built_in">append</span>(a,i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">100</span>==<span class="number">0</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"len: %d , cap; %d\n"</span>,<span class="built_in">len</span>(a),<span class="built_in">cap</span>(a))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"><span class="built_in">len</span>: <span class="number">1</span> , <span class="built_in">cap</span>; <span class="number">1</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">101</span> , <span class="built_in">cap</span>; <span class="number">128</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">201</span> , <span class="built_in">cap</span>; <span class="number">256</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">301</span> , <span class="built_in">cap</span>; <span class="number">512</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">401</span> , <span class="built_in">cap</span>; <span class="number">512</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">501</span> , <span class="built_in">cap</span>; <span class="number">512</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">601</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">701</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">801</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">901</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1001</span> , <span class="built_in">cap</span>; <span class="number">1024</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1101</span> , <span class="built_in">cap</span>; <span class="number">1280</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1201</span> , <span class="built_in">cap</span>; <span class="number">1280</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1301</span> , <span class="built_in">cap</span>; <span class="number">1696</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">1401</span> , <span class="built_in">cap</span>; <span class="number">1696</span></span><br></pre></td></tr></table></figure><p>如上符合源码结果，所以之前的分析有些问题，但是 append 多个值的时候，与之前的结果相同。再次查看源码，发现实际上还有内存对齐的考虑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br></pre></td></tr></table></figure><p>其中 capmem 会根据 roundupsize 函数进行内存对齐。其中 uintptr(newcap)表示新容量的大小，sys.PtrSize 表示一个元素的大小，int 时为 8。roundupsize 函数的实现如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">roundupsize</span><span class="params">(size <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> size &lt; _MaxSmallSize &#123;</span><br><span class="line"><span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uintptr</span>(class_to_size[size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uintptr</span>(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line"><span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> round(size, _PageSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：_MaxSmallSize=32768,2 的 15 次方，是 32K。当需要分配的 size 大于 32K 时，需要 mchche 向 mcentral 申请；当 size 小于 32K 时，计算应该分配的 sizeclass，直接去 mchche 申请。（关于具体的内存申请方面，在后面的开发需要的时候再仔细研究）当 size 小于 smallSizeMax-8=1024-8=1016 时，采用 size_to_class8 的分配方式，大于 1016 时采用 size_to_class128 的分配方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_to_class8 &#x3D; [smallSizeMax&#x2F;smallSizeDiv + 1]uint8&#123;0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31&#125;</span><br><span class="line">size_to_class128 &#x3D; [(_MaxSmallSize-smallSizeMax)&#x2F;largeSizeDiv + 1]uint8&#123;31, 32, 33, 34, 35, 36, 36, 37, 37, 38, 38, 39, 39, 39, 40, 40, 40, 41, 42, 42, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 47, 47, 47, 48, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66&#125;</span><br><span class="line"></span><br><span class="line">class_to_size &#x3D; [_NumSizeClasses]uint16&#123;0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个数组值的不同，并且间隔的粒度也不同，当 size 较小时，间隔为 8，当 size 较大时，间隔为 128.而为了内存优化考虑，class_to_size 会控制分配大小，间隔从 8-4096以 int 为例</p><table><thead><tr><th>个数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>字节数</td><td>8</td><td>16</td><td>24</td><td>32</td><td>40</td><td>48</td><td>56</td><td>64</td><td>72</td></tr><tr><td>所占空间</td><td>8</td><td>16</td><td>32</td><td>32</td><td>48</td><td>48</td><td>64</td><td>64</td><td>80</td></tr><tr><td>size_to_class8</td><td>1</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>5</td><td>5</td><td>6</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git】Git使用总结</title>
      <link href="/2019/05/26/yuque/Git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2019/05/26/yuque/Git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="配置-user-信息">配置 user 信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &#39;your_name&#39;</span><br><span class="line">git config --global user.email &#39;your_email&#39;</span><br><span class="line"></span><br><span class="line">git config --local  #local只对某个仓库有效</span><br><span class="line">git config --global  #global对当前用户的所有仓库有效</span><br><span class="line">git config --system  #对系统所有登录用户有效，一般不用没什么意义</span><br><span class="line"></span><br><span class="line">git config --global --list #显示配置项</span><br></pre></td></tr></table></figure><p>local 比 global 优先级要高</p><h1 id="给文件重命名">给文件重命名</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#原来的使用：</span><br><span class="line">mv readme readme.md</span><br><span class="line">git add readme.md</span><br><span class="line">git rm readme</span><br><span class="line">#直接使用</span><br><span class="line">git mv readme readme.md</span><br></pre></td></tr></table></figure><h1 id="查看-gitlog">查看 gitlog</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log #只显示当前分支</span><br><span class="line">git log --all --graph #可以看所有的分支</span><br><span class="line">git log --oneline --all -n4 #一行显示所有分支最近的4个</span><br></pre></td></tr></table></figure><h1 id="git-目录">.git 目录</h1><p>HEAD：整个仓库正在工作的分支config：存放仓库本地的配置信息，记录 user 等信息refs：objects：包括文件夹和 pack</p><h1 id="commit-tree-和-blob-之间的关系">commit、tree 和 blob 之间的关系</h1><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1558841650988-46fcccb5-6359-4112-8808-e60284941018.png#align=left&amp;display=inline&amp;height=681&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=681&amp;originWidth=1132&amp;size=170368&amp;status=done&amp;style=none&amp;width=1132" alt="image.png">一个 commit 对应一棵 tree，每个文件夹对应一个 tree</p><h1 id="分离头指针">分离头指针</h1><p>表示某个变更没有基于某个 branch，在切换分支的时候，这些变更很有可能会被 git 当做垃圾清理，所以如果认为这些变更有用的话，一定要与某个 branch 绑定才能得到保留。</p><h1 id="head-和-branch">HEAD 和 branch</h1><p>切换分支时，HEAD 指向会发生变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD HEAD^  #与上一次HEAD比较</span><br><span class="line">git diff HEAD HEAD^^ #与上上次进行比较</span><br><span class="line">git diff HEAD HEAD^3 #与上上上次进行比较</span><br></pre></td></tr></table></figure><h1 id="常用场景">常用场景</h1><h2 id="删除分支">删除分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &#39;分支名&#39;  #清除分支的命令</span><br><span class="line">git branch -D &#39;分支名&#39;  #确信清除没有影响，采用D清除</span><br></pre></td></tr></table></figure><h2 id="修改-commit-的-message">修改 commit 的 message</h2><p>在维护自己的分支的时候，还没有提交的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend   #修改最新的commit的message</span><br><span class="line">git rebase -i &#39;commit id&#39;  #修改更久的commit的message</span><br><span class="line">  然后按照提示进行修改</span><br></pre></td></tr></table></figure><h2 id="整理多个-commit-为-1-个">整理多个 commit 为 1 个</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &#39;commit-id&#39;  # commit-id为最久的想合并的</span><br></pre></td></tr></table></figure><h2 id="比较暂存区和-head-所含文件的差异">比较暂存区和 HEAD 所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached  #表示暂存区和HEAD的区别</span><br></pre></td></tr></table></figure><h2 id="比较工作区和暂存区的区别">比较工作区和暂存区的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff #默认比较的是工作区和暂存区的区别</span><br><span class="line">git diff --文件名 #比较文件</span><br></pre></td></tr></table></figure><h2 id="让暂存区恢复成和-head-一样">让暂存区恢复成和 HEAD 一样</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD #将暂存区所有的变更恢复成HEAD</span><br></pre></td></tr></table></figure><h2 id="工作区的文件恢复成暂存区一样">工作区的文件恢复成暂存区一样</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &#39;文件名&#39;</span><br></pre></td></tr></table></figure><h2 id="取消暂存区部分文件的修改">取消暂存区部分文件的修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD --&#39;文件名&#39;  # 将暂存区某一文件恢复成HEAD</span><br></pre></td></tr></table></figure><h2 id="消除最近的几次提交">消除最近的几次提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &#39;commit-id&#39; #慎用</span><br></pre></td></tr></table></figure><h2 id="看不同提交的指定文件的差异">看不同提交的指定文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff &#39;branch1&#39; &#39;branch2&#39; -- &#39;文件名&#39;</span><br><span class="line">git diff &#39;commit-id1&#39; &#39;commit-id2&#39; -- &#39;文件名&#39;</span><br></pre></td></tr></table></figure><h2 id="正确删除文件的方法">正确删除文件的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &#39;文件名&#39;</span><br></pre></td></tr></table></figure><h2 id="开发临时加塞紧急任务处理方式">开发临时加塞紧急任务处理方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash apply</span><br><span class="line">或者 git stach pop  #两者区别是会丢掉</span><br></pre></td></tr></table></figure><h2 id="git-的备份">Git 的备份</h2><ul><li>哑协议：不显示进度条</li><li>智能协议：</li></ul><h1 id="tips">Tips</h1><h2 id="同步含有git的文件夹及问题解决">同步含有git的文件夹及问题解决</h2><p>同步含有 git 的文件夹真的有点烦，由于没有注意同步结果，只是一直在看 travis 构建结果，结果半天没有发现问题，后来发现了也不知道怎么解决，看远程仓库的代码是一个关联的文件夹形式，表示这是一个 git 的文件夹，但是点不开，本地的也没有上传。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习(2)-极客时间</title>
      <link href="/2019/04/28/yuque/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0(2)-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
      <url>/2019/04/28/yuque/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0(2)-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="第一个-go-程序">第一个 go 程序</h1><ul><li>go 语言主函数没有返回值，需要使用 os 包， <code>os.exit()</code> ，也不能直接函数传参。</li></ul><h1 id="变量-常量和其他语言的区别">变量、常量和其他语言的区别</h1><ul><li>赋值可以自动类型推断： <code>a:=1</code> ，怎么方便怎么来就行</li><li>快速连续赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">Monday&#x3D;itoa+1</span><br><span class="line">  Tuesday</span><br><span class="line">  Wednesday</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const(</span><br><span class="line">Open&#x3D;1&lt;&lt;itoa</span><br><span class="line">  Close</span><br><span class="line">  Pending</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="运算符">运算符</h1><ul><li>算数运算符：没有前置的++、–</li><li>比较运算符：用 <code>==</code>  比较时，相同维数的数组可以比较</li><li>逻辑运算符</li><li>位运算符： <code>&amp;^</code> ：按位清零</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &amp;^ 0 --1</span><br><span class="line">1&amp;^ 1 --0</span><br><span class="line">0&amp;^1 --0</span><br><span class="line">0&amp;^0 --0</span><br></pre></td></tr></table></figure><h1 id="条件和循环">条件和循环</h1><ul><li>循环：只支持 <code>for</code> ，并且没有括号，while 条件的写法为</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n&lt;<span class="number">5</span>&#123;</span><br><span class="line">n++</span><br><span class="line">  fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>条件：条件一定要是个布尔值或表达式。支持在 if 语句中对变量赋值</li><li>switch 条件：条件表达式不限制为常量或者整数；单个 case 中，可以出现多个结果选项，使用逗号分隔；不需要 break；可以不设定 switch 之后的条件表达式</li></ul><h1 id="数组和切片">数组和切片</h1><h2 id="数组">数组</h2><ul><li>数组的声明：声明同时初始化：<code>arr3:=[...]int{1,3,4,5}</code></li><li>数组的遍历</li><li>数组截取：a[index_begin(包含),index_end(不包含)]</li></ul><h2 id="切片">切片</h2><ul><li>切片的声明方式：与数组的声明有点相似</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s0 []<span class="keyword">int</span></span><br><span class="line">s1:=[]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">s2:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">4</span>)  <span class="comment">//([]type,len,cap)  len个元素会被初始化为零值，</span></span><br><span class="line">                       <span class="built_in">cap</span>中其它未初始化的元素不能访问</span><br></pre></td></tr></table></figure><ul><li>切片的增长方式：类似于 c++的 vector。</li><li>切片共享存储结构：切片截取后，计算 cap 得到的结果。其实切片截取，指向的是内部共享的切片存储空间。所以修改截取的切片的数据，其他截取的相同区域也会发生改变。这是一个容易出错的问题。</li></ul><h2 id="切片和数组的区别">切片和数组的区别</h2><ul><li>容量是否可伸缩</li><li>是否可以进行比较</li></ul><h1 id="map-基础">Map 基础</h1><ul><li>Map 声明方式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>:<span class="number">1</span>,<span class="string">"two"</span>:<span class="number">2</span>,<span class="string">"three"</span>:<span class="number">3</span>&#125;</span><br><span class="line">m1:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">m1[<span class="string">"one"</span>]=<span class="number">1</span></span><br><span class="line">m2:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>,<span class="number">10</span>)  <span class="comment">//10表示初始化的cap,不需要初始化len</span></span><br></pre></td></tr></table></figure><ul><li>元素访问：当访问的 key 不存在时，仍然会返回零值，编程时需要根据 nil 来判断元素是否存在</li></ul><h1 id="map-与工厂模式">Map 与工厂模式</h1><ul><li>Map 的 value 可以是一个方法</li><li>与 Go 的 Dock type 接口方式一起，可以方便的实现单一方法对象的工厂模式</li><li>Go 内置集合中没有 Set，可以通过 map 实现<code>mySet:=**map**[int]bool{}</code></li></ul><h1 id="字符串">字符串</h1><ul><li>string 是数据类型，不是引用或指针类型。零值不是空，而是空字符串。</li><li>string 是只读的 byte slice，不能重复赋值。len 函数可以表示它所包含的 byte 数</li><li>string 的 byte 数组可以存放任何数据</li></ul><h2 id="unicode-和-utf-8">Unicode 和 UTF-8</h2><ul><li>Unicode 是一种字符集（code point）</li><li>UTF-8 是 Unicode 的存储实现（转换为）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556503870325-262231e2-8b69-42ab-8711-83d68d74069e.png#align=left&amp;display=inline&amp;height=270&amp;name=image.png&amp;originHeight=398&amp;originWidth=671&amp;size=46907&amp;status=done&amp;width=456" alt="image.png"></p><h1 id="go-语言的函数">Go 语言的函数</h1><ul><li>函数可以返回多个值</li><li>所有参数都是值传递：slice，map，channel 会有传引用的错觉</li><li>函数可以作为变量的值</li><li>函数可以作为参数和返回值</li></ul><h1 id="可变参数及-defer">可变参数及 defer</h1><ul><li>延迟执行函数：defer。类似于其他语言中的 finally，主要作用是最后关闭一些资源或者关闭一些锁</li></ul><h1 id="行为的定义和实现">行为的定义和实现</h1><h2 id="封装数据和行为">封装数据和行为</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span>&#123;</span><br><span class="line">Id <span class="keyword">string</span></span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">实例的创建和初始化</span><br><span class="line">e:=Employee&#123;<span class="string">"0"</span>,<span class="string">"Bob"</span>,<span class="number">20</span>&#125;</span><br><span class="line">e1:=Employee&#123;Name:<span class="string">"Mike"</span>,Age:<span class="number">30</span>&#125;</span><br><span class="line">e2:=<span class="built_in">new</span>(Employee)  <span class="comment">//这里返回的是实例的指针</span></span><br><span class="line">e2.Id=<span class="string">"2"</span>  <span class="comment">//通过实例的指针访问指针不需要“-&gt;”</span></span><br></pre></td></tr></table></figure><h2 id="行为-方法-定义">行为（方法）定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span><span class="title">String1</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"ID:%s-Name:%s-Age:%d"</span>,e.Id,e.Name,e.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐使用的方式，类似于c++的引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span><span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"ID:%s-Name:%s-Age:%d"</span>,e.Id,e.Name,e.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="go-语言的相关接口">Go 语言的相关接口</h1><h2 id="duck-type">Duck Type</h2><p>方法签名是一样的，就认为是这样的</p><ul><li>接口是非入侵性的，实现不依赖于接口定义</li><li>接口的定义可以包含在接口使用者包内</li></ul><h2 id="接口变量">接口变量</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556508509894-85f1967f-80e0-4a9e-9db7-a2b01ba96f30.png#align=left&amp;display=inline&amp;height=338&amp;name=image.png&amp;originHeight=338&amp;originWidth=701&amp;size=40266&amp;status=done&amp;width=701" alt="image.png"></p><h2 id="自定义类型">自定义类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntConv <span class="function"><span class="keyword">func</span> <span class="params">(op <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><h1 id="扩展与复用">扩展与复用</h1><h1 id="不一样的接口类型-一样的多态">不一样的接口类型，一样的多态</h1><h2 id="空接口与断言">空接口与断言</h2><ul><li>空接口可以表示任何类型</li><li>通过断言来将空接口转换为制定类型 <code>v,ok:=p.(int) //ok=true时为转换成功</code></li></ul><h2 id="go-接口最佳实践">Go 接口最佳实践</h2><ul><li>倾向于使用小的接口定义，很多接口只包含一个方法。实现的负担较小。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type Reader <span class="keyword">interface</span>&#123;</span><br><span class="line">Read(p []<span class="keyword">byte</span>)(n <span class="keyword">int</span>,err error)</span><br><span class="line">&#125;</span><br><span class="line">Type Writer <span class="keyword">interface</span>&#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>)(n <span class="keyword">int</span>,err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>较大的接口定义，可以由多个小接口定义组合而成。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type ReadWrite <span class="keyword">interface</span>&#123;</span><br><span class="line">Reader</span><br><span class="line">  Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只依赖于必要功能的最小接口，方法才能更多的被复用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreData</span><span class="params">(reader Reader)</span> <span class="title">error</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="编写好的错误处理">编写好的错误处理</h1><ul><li>没有异常机制</li><li>error 类型实现了 error 接口</li><li>可以通过 errors.New 来快速创建错误实例</li></ul><h1 id="panic-和-recover">panic 和 recover</h1><h2 id="panic">panic</h2><ul><li>panic 用于不可恢复的错误</li><li>panic 退出前会执行 defer 指定的内容</li></ul><h2 id="panic-vs-os-exit">panic vs os.Exit</h2><ul><li>os.Exit 退出时不会调用 defer 指定的函数</li><li>os.Exit 退出时不会输出当前调用栈信息</li></ul><h2 id="recover">recover</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer func()&#123;</span><br><span class="line">if err:&#x3D;recover();err!&#x3D;nil&#123;</span><br><span class="line">  &#x2F;&#x2F;恢复错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><ul><li>不要强制恢复错误，有的时候“Let it crash”可能更好，让程序重启来恢复。</li></ul><h1 id="构建可复用的模块-包">构建可复用的模块（包）</h1><h2 id="package">package</h2><ul><li>基本复用模块单元：以<strong>首字母大写</strong>来表名可被包外代码访问</li><li>代码在 package 可以和所在的目录了不一致（相对于 Java 而言）</li><li>同一目录里的 Go 代码的 package 要保持一致</li></ul><h2 id="init-方法">init 方法</h2><ul><li>在 main 被执行前，所有依赖的 package 的 init 方法都会被执行</li><li>不同包的 init 函数按照包导入的依赖关系决定执行顺序</li><li>每个包可以有多个 init 函数</li><li>包的每个源文件也可以有多个 init 函数，比较特殊</li></ul><h2 id="go-get">go get</h2><ul><li>通过 go get 来获取远程依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u 强制从网络更新远程依赖</span><br></pre></td></tr></table></figure><ul><li>注意代码在 Github 上的组织形式，以适应 go get：直接以代码路径开始，不要有 src</li></ul><h1 id="依赖管理">依赖管理</h1><h2 id="go-未解决的依赖问题">Go 未解决的依赖问题</h2><ul><li>同一环境下，不同项目使用同一包的不同版本</li><li>无法管理对包的特定版本的依赖</li></ul><h2 id="vendor-路径">vendor 路径</h2><p>Go1.5 release 版本，vendor 目录被添加到除了 GOPATH 和 GOROOT 以外的依赖目录查找方案。查找依赖包路径的解决方案：</p><ol><li>当前包下的 vendor 目录</li><li>向上级目录查找，直到找到 src 下的 vendor 目录</li><li>在 GOPATH 下面查找依赖包</li><li>在 GOROOT 目录下查找</li></ol><p>其他第三方依赖管理工具：godep，glide，<strong>dep</strong>**</p><h1 id="协程机制">协程机制</h1><h2 id="线程-vs-协程">线程 vs 协程</h2><ul><li>创建时默认的 stack 大小：JAVA 1M vs Goroutine 2K</li><li>和 KSE（Kernel Space Entity）：java Thread 是 1:1；GO M:N</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556704202218-7913c997-6b91-48e2-9dc6-49b057a39342.png#align=left&amp;display=inline&amp;height=432&amp;name=image.png&amp;originHeight=432&amp;originWidth=618&amp;size=110172&amp;status=done&amp;width=618" alt="image.png"></p><h1 id="共享内存并发机制">共享内存并发机制</h1><h2 id="lock">Lock</h2><h2 id="waitgroup">WaitGroup</h2><p>相当于 Java 的 join</p><h1 id="csp-并发机制">CSP 并发机制</h1><h2 id="csp-vs-actor">CSP vs Actor</h2><ul><li>和 Actor 的直接通讯不同，CSP 模式是通过 Channel 进行通讯的，更松耦合一些</li><li>Go 中 Channel 是有容量限制并且独立于处理 Goroutine，而如 Erlang，Actor 模式中的 mailbox 容量是无限的，接收进程也总是被动地处理消息。</li></ul><h2 id="channel">Channel</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556705599268-5d3769a6-8c93-4827-a9c2-525810d0cc3a.png#align=left&amp;display=inline&amp;height=910&amp;name=image.png&amp;originHeight=910&amp;originWidth=1703&amp;size=565338&amp;status=done&amp;width=1703" alt="image.png">两种情况：一种是一直等待，一种 Buffered Channel ，更松耦合的 Channel，消息发送方可以在容量没满的时候一直放，满了之后需要等待。对于接收方来说，只要 Channel 内有消息就可以一直接收。</p><h1 id="多路选择和超时">多路选择和超时</h1><h2 id="select">select</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1556712290363-e32d5fa7-eb01-4d32-8fed-14ae04a0042d.png#align=left&amp;display=inline&amp;height=301&amp;name=image.png&amp;originHeight=301&amp;originWidth=861&amp;size=79632&amp;status=done&amp;width=861" alt="image.png">运行到 select 时，当任一个事件准备好了，就可以对应响应。当不想一直等待某事件时，可以进行超时控制。</p><h1 id="channel-的关闭和广播">channel 的关闭和广播</h1><p>解决怎么知道 channel 数据完了的问题</p><h2 id="channel-的关闭">channel 的关闭</h2><ul><li>向关闭的 channel 发送数据，会导致 panic</li><li>v,ok&lt;-ch；ok 为 bool 值，true 表示正常接收，false 表示通道关闭</li><li>所有的 channel 接收者都会在 channel 关闭时，立即从阻塞等待中返回且上述 ok 值为 false。这个广播机制常被利用，进行向多个订阅者发送信号，如：退出信号。</li></ul><h1 id="任务的取消">任务的取消</h1><h1 id="context-与任务取消">Context 与任务取消</h1><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557062963366-c9338325-f390-4dce-ae1d-f0874f9612ba.png#align=left&amp;display=inline&amp;height=372&amp;name=image.png&amp;originHeight=298&amp;originWidth=786&amp;size=58395&amp;status=done&amp;width=982.4999853596094" alt="image.png"></p><h2 id="context">Context</h2><ul><li>根 Context：通过 context.Background()创建</li><li>子 Context：context.WithCancel(parentContext)创建</li><li>ctx,cancel：context.WithCancel(context.Background())</li><li>当前 Context 被取消时，基于他的子 context 也会被取消</li><li>接收取消通知&lt;-ctx.Done()</li></ul><p>还有一些其他的方法</p><h1 id="典型并发任务">典型并发任务</h1><h2 id="只运行一次-常见的并发任务">只运行一次（常见的并发任务）</h2><p>在常见的多任务环境下，只执行一次。单例模式（懒汉式，线程安全）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleInstance *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSingletonObj</span><span class="params">()</span> *<span class="title">Singleton</span></span>&#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;    <span class="comment">//传入创建方法</span></span><br><span class="line">fmt.Println(<span class="string">"Create Obj"</span>)</span><br><span class="line">singleInstance=<span class="built_in">new</span>(Singleton)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> singleInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所需任意任务完成">所需任意任务完成</h2><h2 id="所有任务完成">所有任务完成</h2><h2 id="对象池">对象池</h2><p>数据库连接，网络连接，经常将这些对象池化，避免重复创建。</p><h2 id="sync-pool-对象缓存">sync.pool 对象缓存</h2><p>从名字来看，像是 go 语言提供的池。其实是对象的缓存<img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557066107461-3144bf63-f63c-4522-b25d-af4bd721daab.png#align=left&amp;display=inline&amp;height=517&amp;name=image.png&amp;originHeight=414&amp;originWidth=846&amp;size=118933&amp;status=done&amp;width=1057.4999842420223" alt="image.png"></p><ul><li>如果私有对象不存在则保存为私有对象</li><li>如果私有对象存在，就放入当前 Processor 子池的共享池中</li></ul><p>使用：<img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557066277648-e57411da-71d5-4673-93bc-a82e0315284b.png#align=left&amp;display=inline&amp;height=341&amp;name=image.png&amp;originHeight=273&amp;originWidth=497&amp;size=37422&amp;status=done&amp;width=621.2499907426537" alt="image.png"></p><p>**sync.pool 对象的生命周期—**sync.pool 不能作为对象池的原因</p><ul><li>GC 会清除 sync.pool 缓存的对象</li><li>sync.pool 对象的缓存有效期为下一次 GC 之前</li></ul><p>总结：</p><ul><li>适合于通过复用，降低复杂对象的创建和 GC 代价</li><li>协程安全，会有锁的开销</li><li>声明周期受 GC 影响，不适合于做连接池等，需自己管理生命周期资源的池化</li><li>所以具体要看锁的开销大，还是初始化的开销大</li></ul><h1 id="测试">测试</h1><h2 id="单元测试">单元测试</h2><p>表格测试</p><h3 id="内置单元测试框架">内置单元测试框架</h3><ul><li>Fail，Error：该测试失败，该测试继续，其他测试继续执行</li><li>FailNow，Fatal：该测试失败，该测试中止，其他测试继续执行</li></ul><p>代码覆盖率</p><h2 id="benchmark">Benchmark</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557067837101-3bdadb6b-821f-4dbd-9b3a-c9efe304bc7a.png#align=left&amp;display=inline&amp;height=491&amp;name=image.png&amp;originHeight=393&amp;originWidth=679&amp;size=77590&amp;status=done&amp;width=848.7499873526397" alt="image.png">以 Benchmark 开头，参数类型稍有不同。通过 ResetTimer 和 StopTimer 将测试代码隔开</p><p>命令行下运行：</p><h2 id="bbd">BBD</h2><p>Behavior Driven Development常用框架：goconvey</p><h2 id="反射编程">反射编程</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557107233067-f50d5086-e384-46cc-bd5e-0a2446ec3d8f.png#align=left&amp;display=inline&amp;height=390&amp;name=image.png&amp;originHeight=312&amp;originWidth=820&amp;size=64732&amp;status=done&amp;width=1024.99998472631" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557107389241-fb6b5237-7e73-48e9-83a9-e6c6ae45f6aa.png#align=left&amp;display=inline&amp;height=356&amp;name=image.png&amp;originHeight=285&amp;originWidth=755&amp;size=35453&amp;status=done&amp;width=943.7499859370294" alt="image.png"></p><h2 id="万能程序">万能程序</h2><p>DeepEqual比较切片和 map与配置相关的，要求灵活性和复用性时，可以反射的</p><h2 id="不安全编程">不安全编程</h2><p>unsafe，一般涉及到库的交互，与 c 语言交互。“不安全”行为危险性：Go 语言中不支持强制类型转换。下列操作看似可以，实际不能转换，而且实际使用起来很危险。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i:&#x3D;10</span><br><span class="line">f:&#x3D;*(*floa64)(unsafe.Pointer(&amp;i))</span><br></pre></td></tr></table></figure><p>场景 2：用到内置的 Atomic 操作，指针原子操作，并发读写</p><h1 id="架构模式">架构模式</h1><h2 id="pipe-filter-架构">Pipe-Filter 架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557108759332-46d3b8e2-5573-419b-80b6-63cfbf5feaa1.png#align=left&amp;display=inline&amp;height=510&amp;name=image.png&amp;originHeight=408&amp;originWidth=782&amp;size=86362&amp;status=done&amp;width=977.4999854341152" alt="image.png"></p><ul><li>非常适合与数据处理及数据分析系统<img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557108843135-278143cd-9e6a-4b4f-ae49-b800e98a261c.png#align=left&amp;display=inline&amp;height=474&amp;name=image.png&amp;originHeight=379&amp;originWidth=690&amp;size=86777&amp;status=done&amp;width=862.4999871477487" alt="image.png"></li></ul><h2 id="micro-kernel">micro kernel</h2><p>特点：易于拓展，错误隔离，保持架构一致性要点：</p><ul><li>内核包含公共流程或通用逻辑</li><li>将可变成或可扩展部分规划为扩展点</li><li>抽象扩展点行为，定义接口</li><li>利用插件进行扩展</li></ul><p>生产过程任务的开发</p><h2 id="内置-json-解析">内置 json 解析</h2><p>远程过程调用等过程中，会用 json，以及在配置文件中，很多使用 json</p><h2 id="easyjson">easyjson</h2><p>go 内置的，一般适用于配置文件解析，对于 qps 较高，运用了反射，效率较低。尽量使用高性能的 json 解析</p><h2 id="http-服务">HTTP 服务</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557111353880-2f261975-45c5-4dcd-9281-44ac48f2fbcb.png#align=left&amp;display=inline&amp;height=442&amp;name=image.png&amp;originHeight=354&amp;originWidth=862&amp;size=103367&amp;status=done&amp;width=1077.499983943999" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2019/png/187932/1557111366213-f5138ca3-fd5f-4da1-992a-f68e1681d3ff.png#align=left&amp;display=inline&amp;height=445&amp;name=image.png&amp;originHeight=356&amp;originWidth=771&amp;size=101595&amp;status=done&amp;width=963.7499856390061" alt="image.png"></p><h2 id="构建-restful-服务">构建 Restful 服务</h2><p>更好的 router，httprouter面向资源的架构（Resource Oriented Architecture）</p><h2 id="性能分析工具">性能分析工具</h2><p>学习函数式编程：《计算机程序的构造和解释》functional programming《Restful Web Service》《Go 程序设计语言》《面向模式的软件架构》1,2,3 本</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习基础(3)</title>
      <link href="/2019/01/25/yuque/MySQL%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80(3)/"/>
      <url>/2019/01/25/yuque/MySQL%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80(3)/</url>
      
        <content type="html"><![CDATA[<h1 id="三大范式">三大范式</h1><p>**第一范式（1NF）：**无重复的列。要求：表所有的属性不可再分。如果不符合第一范式，则不符合关系模型的定义。**第二范式（2NF）：**属性完全依赖于主键 [ 消除部分子函数依赖 ]。要求：在满足 1NF 前提，每一行能够唯一标识，不存在非主键字段。常用方法可以增加一个单字段的主键。<strong>第三范式（3NF）</strong>：属性不依赖于其它非主属性 [ 消除传递依赖 ]。要求：在满足 2NF 前提，不出现类似于 A-&gt;B-&gt;C 的情况，这样的传递依赖可以分为两个表，分别保存。</p><p>通用的原则：</p><ul><li>每个实体都有一个表。</li><li>为每一个关系（二维表）增加一个逻辑主键作为标识。</li><li>出现二维表对应的关系，采用 1:1, 1:N, M:n 的形式将关联关系设计。</li></ul><h1 id="mysql-日志类型">MySQL 日志类型</h1><p><strong>错误日志</strong>：记录启动、运行或停止 mysqld 时出现的问题<strong>查询日志</strong>：记录建立的客户端连接和执行的所有语句（包括错误的）<strong>二进制日志</strong>：记录所有更改数据的语句、还用于主从复制<strong>慢日志</strong>：记录所有执行时间超过 long_query_time 秒的所有查询</p><h1 id="索引">索引</h1><p>索引：对数据库表中一或多个列的值进行排序的结构，是帮助 MySQL 高效获取数据的数据结构，可以 加快检索表中的数据，而不必扫描整个数据库。缺点是：需要占用额外的空间，并且需要定期维护，每条记录的 INSERT,DELETE,UPDATE 操作可能付出更多的磁盘 IO。同时不必要的索引反而会使查询速度变慢。索引查询的适用的情况：基于一个范围的检索，一般查询返回结果集小于表中记录数的 30%。基于非唯一性索引的检索。数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</p><h1 id="事务">事务</h1><p>事务：并发控制的基本单位，是一个操作序列，这些操作要么都执行，要么都不执行，是一个不可分割的工作单位。</p><h2 id="事务的隔离级别">事务的隔离级别</h2><p>分为四个级别：<br>未提交读:允许脏读，可能读到其他会话没有提交的数据。已提交读:只能读到已经提交的数据。ORACAL 等多数数据库的默认隔离级别。<br>可重复读:可重复读，同一事务内的查询都是和事务开始时一致的，Innodb 的默认隔离级别。<br>串行读：完全串行化的读，每次读都需要获得表级共享锁，读写相互会阻塞。</p><p>对应：脏读、不可重复读、幻读情况为：脏读：当一个事务正在访问数据，并且对数据进行了修改，这个修改还没提交到数据库。另一个事务也访问这个数据，使用了这个数据。  不可重复读：一个事务内，多次读同一数据。这个事务还没结束时，另一个事务也访问这个数据，导致第一个事务两次访问的数据不一样。  幻读：第一个事务对表中的每一行数据进行了修改，同时第二个事务也访问这个表中的数据，这种修改是向表中插入而来一行数据，那么以后就会发生操作第一个事物的用户表中发现表中还有没修改的数据行，像是产生了幻觉。<a href="https://www.cnblogs.com/zhoujinyi/p/3437475.html" target="_blank" rel="noopener">MySQL 四种事务隔离级的说明</a></p><h1 id="drop-delete-与-truncate">DROP、DELETE 与 TRUNCATE</h1><p>DROP：不仅删除表的数据，还删除表的结构。DELETE 和 TRUNCATE 只删除表的数据不删除表的结构。删除速度：DROP&gt; DELETE&gt;TRUNCATE适用场景：当不需要一张表的时候，适用 DROP；删除部分数据行的时候，用 DELETE，并且使用 where 子句；保留表而删除所有数据的时候用 TRUNCATE。</p><h1 id="存储引擎">存储引擎</h1><p>MySQL 目前用的比较多的两种，是 Innodb 和 Myisam</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习总结(2)</title>
      <link href="/2019/01/23/yuque/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/"/>
      <url>/2019/01/23/yuque/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在关系型数据库里面，每个实体有自己的一张表，所有属性都是这张表的字段，表与表之间根据关联字段&quot;连接&quot;在一起。</p></blockquote><h1 id="什么是连接">什么是连接</h1><p><strong>两张表根据关联字段，组合成一个数据集。当两张表的关联字段不匹配时，例如表 A 和表 B，处理方式为：</strong></p><ul><li>只返回两张表匹配的记录，内连接（inner join）。</li><li>返回匹配的记录，以及表 A 多余的记录，左连接（left join）。</li><li>返回匹配的记录，以及表 B 多余的记录，右连接（right join）。</li><li>返回匹配的记录，以及表 A 和表 B 各自的多余记录，全连接（full join）。</li></ul><p>这里看到了阮一峰老师的一个总结，引用了图片：             <img src="https://cdn.nlark.com/yuque/0/2019/jpeg/187932/1548247519305-bff75e42-9992-499e-9c1b-d75b9e56fe13.jpeg#align=left&amp;display=inline&amp;height=295&amp;originHeight=295&amp;originWidth=602&amp;size=0&amp;status=done&amp;width=602" alt=""></p><h1 id="内连接-inner-join">内连接（inner join）</h1><ul><li>MySQL 默认的连接就是内连接，可以省略 inner。</li><li>有条件的内连接：</li></ul><p>where：数据过滤，理解上，数据交叉连接完成后再进行过滤。on：在连接时，就对数据进行判断。using：要求负责连接的两个实体之间的字段名称一致。      在有同名字段时，使用 using，通用条件时，使用 on，在数据过滤时（不是连接的过滤）时，使用 where。</p><h1 id="外连接-outer-join">外连接（outer join）</h1><p>连接的数据不真实存在。意思是外连接的两个表，存在单个表中没有的数据。</p><h2 id="左连接-left-join">左连接（left join）</h2><p>在连接时，出现了左边表连接不到右边表的情况，则左边表的数据会被保留，而右边表的数据连接不到左表的情况，会被抛弃。</p><h2 id="右连接-right-join">右连接（right join）</h2><p>在连接时，出现了左边表连接不到右边表的情况，则数据会被抛弃，而右边表的数据连接不到左表的情况，会被保留。</p><h2 id="全连接-full-join">全连接（full join）</h2>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】MySQL学习基础(1)</title>
      <link href="/2019/01/14/yuque/MySQL%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80(1)/"/>
      <url>/2019/01/14/yuque/MySQL%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库和-sql">数据库和 SQL</h1><p>SQL(StructuredQuery Language)：结构化查询语言。包括 DDL（Data Definition Language 数据定义语言）、DML（Data Management Language 数据管理语言）、DCL（Data Control Language 数据库控制语言）。其中 DML 包括：DQL（Data Query Language 数据查询语言）和 DML（Data Management Language 数据管理语言），一般来说，数据查询和管理都称为数据管理语言。</p><h1 id="安装"><a href="">安装</a></h1><h1 id="基础">基础</h1><h2 id="dml">DML</h2><h3 id="数据库操作">数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">database</span> db_name;   <span class="comment"># 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">database</span> db_name <span class="keyword">if</span> <span class="keyword">not</span> exits;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库查询</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">databases</span>;   <span class="comment"># 查看当前存在的数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name;  <span class="comment"># 查看数据库创建的语言，显示结果为</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择数据库</span></span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">database</span>;  <span class="comment"># 操作表时会使用默认的数据库，所以需要先使用USE表示使用的是哪一个数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据库中表</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span> [<span class="keyword">like</span> <span class="string">'pattern_%'</span>]; <span class="comment"># 可以使用通配符匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">database</span> db_name;   <span class="comment">#还有其他的两种，记得区分结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">database</span> db_name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库权限修改</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.* <span class="keyword">TO</span> <span class="string">'your_mysql_name'</span>@<span class="string">'your_client_host'</span>; <span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="表操作">表操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_name (列结构)[表选项]</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet (<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>), owner <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">                   species <span class="built_in">VARCHAR</span>(<span class="number">20</span>), sex <span class="built_in">CHAR</span>(<span class="number">1</span>), birth <span class="built_in">DATE</span>, death <span class="built_in">DATE</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从外部导入数据到表</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'/path/pet.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> pet</span><br><span class="line">       <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\r\n'</span>;  <span class="comment"># 从本地导入，分隔符为"\r\n"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据到表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> pet</span><br><span class="line">       <span class="keyword">VALUES</span> (<span class="string">'Puffball'</span>,<span class="string">'Diane'</span>,<span class="string">'hamster'</span>,<span class="string">'f'</span>,<span class="string">'1999-03-30'</span>,<span class="literal">NULL</span>); <span class="comment"># 如果设置了NOT NULL，则需要</span></span><br><span class="line">       在插入数据的时候该项有值</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 修改列定义</span></span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name[<span class="keyword">ADD</span>|<span class="keyword">DROP</span>|<span class="keyword">CHANGE</span>|<span class="keyword">MODIFY</span>] <span class="comment">#添加|删除|重命名|修改</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 修改表选项</span></span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name 新的表选型</span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> pet <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> UTF8;</span><br></pre></td></tr></table></figure><h3 id="数据操作">数据操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name (field_list) <span class="keyword">VALUES</span> (<span class="keyword">values</span>); <span class="comment">#</span></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="keyword">SELECT</span> field_list <span class="keyword">FROM</span> tbl_name conditions;</span><br><span class="line"><span class="keyword">SELECT</span> field_list <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> conditions <span class="keyword">LIKE</span> <span class="string">'a%'</span>; <span class="comment"># %为通配符</span></span><br><span class="line"><span class="keyword">SELECT</span> field_list <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> <span class="keyword">REGEXP_LIKE</span>(field_name,regex); <span class="comment"># 使用正则表达式匹配</span></span><br><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tbl_name conditions;</span><br><span class="line"><span class="comment"># 修改数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> tbl_name <span class="keyword">SET</span> <span class="keyword">field</span>=new_value, conditions;</span><br></pre></td></tr></table></figure><h2 id="mysql-数据类型">Mysql 数据类型</h2><h3 id="整型-默认有符号-无符号要指定-unsigned">整型:默认有符号，无符号要指定 unsigned</h3><p>TINYINT:1 字节 无符号：-128—127  有符号： 0—255SMALLINT:2 字节 无符号：-32768—32767 有符号：0-65536MEDIUMINT：3 字节INT：4 字节BIGINT:8 字节可以听过类似 INT(2)表示显示的宽度，显示宽度不影响数值的范围，只是为了表示</p><h3 id="小数">小数</h3><p><strong>浮点数： **  可以通过</strong>TYPE(M,D)**控制数值位数，M 为所有的数值位数，D 为小数位数float：单精度浮点数，默认精度位数为 6 左右double：双精度浮点数，默认精度 16 左右** 定点数： DECIMAL(M,D) **同样的 M 为所有的数值位数，D 为小数位数，M 默认为 10，D 默认为 0</p><h3 id="日期和时间">日期和时间</h3><table><thead><tr><th style="text-align:center">DATATIME</th><th style="text-align:center">8</th><th style="text-align:center">YYYY-MM-DD HH:MM:SS</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">TIMESTAMP</td><td style="text-align:center">4</td><td style="text-align:center">YYYY-MM-DD HH:MM:SS</td><td style="text-align:center">从 1970 年开始</td></tr><tr><td style="text-align:center">DATE</td><td style="text-align:center">3</td><td style="text-align:center">YYYY-MM-DD</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TIME</td><td style="text-align:center">3</td><td style="text-align:center">HH:MM:SS</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">YEAR</td><td style="text-align:center">1</td><td style="text-align:center">YYYY</td><td style="text-align:center">范围为 1901-2155</td></tr></tbody></table><h3 id="字符串">字符串</h3><p>**CHAR(M) :**表示固定长度。M 表示允许的字符串长度,限制了字符串的长度**VARCHAR(M): **可变长度 。M 表示允许的最大长度，在内存中表示，需要多一个字节保存字符串的总长度，因此如果有时候不是很需要改变长度的话，尽量用固定长度的 CHAR</p><h2 id="列属性">列属性</h2><h3 id="主键">主键</h3><p>可以唯一标识某条记录的字段或字段的集合。通常的做法是，设计每个表存在一个可以唯一标识的主键字段，最好利用与实体信息不相关的属性，作为唯一标识，与业务逻辑不发生关系，只用来记录标识，例如 ID。设置方式：在字段上设置或者定义完字段后再定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在字段上设置</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> (<span class="number">5</span>));</span><br><span class="line"><span class="comment"># 定义完字段后再设置</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet1 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> (<span class="number">5</span>),PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>));</span><br></pre></td></tr></table></figure><h3 id="自动增长">自动增长</h3><p>为每条记录提供唯一的标识，每次插入记录时，某个字段的值都自动加 1，使用 auto_increment 标识。要求需要整型和索引。在插入数据的时候，可以选择插入 null 也可以不插入。  自动增长的初始值默认是 1，也可以通过 auto_increment n 重新设置从 n 开始增长。也可以手动插入自动增长的值，但是如果是主键的话，不能重复。</p><h1 id="注意事项">注意事项</h1><ul><li>数据库语言关键字一般用大写，虽然大小写都可以，但是为了区分。</li><li>数据库名的大小写取决于系统，所以操作的时候尽量有自己的规范，进行大小写区分。</li><li>NULL 是区别于 0 或者’ '的</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2018年终总结</title>
      <link href="/2018/12/16/yuque/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/16/yuque/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2018 年总结。</p></blockquote><a id="more"></a>  <blockquote><p>2018 已经到了尾声了，还从来没好好总结一年，该养成及时总结反思的习惯。</p></blockquote><h1 id="学习">学习</h1><ul><li><p>找工作相关的内容：编程语言 C++/Python/Shell 脚本等，计算机网络、数据库、操作系统、服务器 Nginx 都有了一定的学习和总结，但是还是理论的较多一些，实践倒是有，但是还远远不够。</p></li><li><p>跟着 github 上写了个 C++的 web 服务器，不过还是有很多不明白，只是面试的时候能讲一讲。</p></li><li><p>另外找完工作后，开始要学习 Go 语言，还有数据库的基础，其实总觉得数据库自己掌握的还是很少，而且以后就是 DBA 了，更要把基础打劳一点。</p></li></ul><h1 id="工作">工作</h1><p>首先今年最重要的就是找工作了，说实话，找工作的策略并不是很好，但是也是跟自己的复习有关系吧，对于数据结构和算法，看了很多，自己也刷了很多题，但是一些复杂的算法，以及广度还是不够，所以在面试的时候遇到难点的算法题就很虚。另外就是找工作的策略上，海投的时候投了很多，以至于找工作的很多的精力都花在了不想去的公司上，而好几个大公司都没有准备好。</p><p>拿到的 Offer 还是很乱的，国企、研究所、互联网基本上都有。总结下 Offer 有：  国企银行：银联、招银网络  研究所：航天 804、中电 20 所、中电 54 所、中船重工 701  互联网：老虎证券、竞技世界、vipkid、好未来、新思科技、oppo、海康威视、大华、小米等  最后看其实找到的工作也不是很好，其实也有个原因是小米很早给了意向就不是很想找了，很多面试都没去。策略有些问题，不过最后的结果也还不错，能回武汉工作。当然找工作的过程其实也有很大的收获，不只是技术上的，还有心理上的。</p><p>关于实验室的工作，就还是那样，感觉自己的态度有一些问题，就是太不重视了，总是以老板为驱动，总想着自己以后也不从事这方面，就比较不在意，这样就有些问题。</p><h1 id="生活">生活</h1><p>关于身体健康。减肥这个事情，说了很多遍，也有的时候能坚持，但是还是一直保重的状态。而且年底马上就要去当伴郎了，作为伴郎里最胖的一个，压力很大呀。今年看来希望渺茫了，把 flag 留给明年吧。</p><p>关于读书。最近也都很久没看了。今年除了找工作看的一些专业书外，别的都看的很少了，需要加强呀。</p><p>关于感情。跟亲爱的在一起了，到今天也已经 300 天了，时间过得很快，异地恋其实在一起的时间也不是很多，刚刚到一个月，但是互相很能为对方着想，有问题积极解决，保持几乎每天都开视频。不过关于两人的相处，还有很多需要慢慢改进。也剩明年半年的异地了，期待明年。</p><p>关于家人朋友。爷爷今年去世了，享年 85 岁。小时候爸妈不在家，基本上爷爷奶奶从小把我带大，远在西安的我没能看到最后一面，虽然知道这一天总是会来，但是觉得太快了，以后再也没有过年在家吃饭的时候还叫上我一起陪着喝个白酒的了，喝了酒又开始讲自己小时候躲日本鬼子，年轻的时候修长江大桥了，讲以前穷日子的时候了。。你总是在长大，只是时间让你感觉长大的方式不再那么温柔了。</p><h1 id="流水">流水</h1><ul><li><p>2.24 开始跟亲爱的在一起</p></li><li><p>3 月，开始准备 miniweb</p></li><li><p>4 月，参加华为的比赛，但是没有进 64</p></li><li><p>7 月，爷爷</p></li><li><p>8-9 月，找工作</p></li></ul><h1 id="总结">总结</h1><p>总之，关于 2018 年，是失去也是收获的一年，但是不管怎么样，那都是这一年的自己，也需要更好的总结来让新的一年变得更好。</p><ul><li><p>保持专注和思考。一直觉得认真是自己的优势之一，但是今年却感觉做很多事情的时候，不是很能专注，做事的效率不是很高了。另一个是抓住重点，时间有限，尽量做更有价值的事情，把时间看做重要的成本。这永远是核心竞争力的保证。</p></li><li><p>学会沟通。通过谈恋爱，以前觉得自己是一个很爱说话的人，很喜欢开玩笑的人，但现在发现自己不是一个很会沟通的人。现在发现这两个还是有区别的，笑的再好，不会沟通，问题还在那，只不过暂时忘了而已。</p></li><li><p>学会自律。自律才能自由，用自己的想法约束自己的行为，这才是更高程度的自由，而不是想吃就吃，想玩就玩。</p></li><li><p>提高自己。身体上，精神上。看书和锻炼，</p></li></ul><h1 id="2019-计划">2019 计划</h1><p>一年之计在于春，先提前订点小目标吧。等年底了再来看。</p><ul><li><p>看 50 本书，包括专业书和业余书。专业书主要是接下来工作需要的，数据库和 Go 语言方面。业余书主要关注历史和经济。</p></li><li><p>锻炼身体。把肚子减下去，要在 130 一下了吧，咳咳。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> CentOS7安装并使用MySQL</title>
      <link href="/2018/12/07/yuque/CentOS7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8MySQL/"/>
      <url>/2018/12/07/yuque/CentOS7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8MySQL/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MySQL 在 CentOS 上的安装和使用</p></blockquote><a id="more"></a>  <h1 id="yum-安装">yum 安装</h1><p>date: 2018-12-9 21:57:59update: 2018-12-9 21:57:59 1.首先找到官网 yum 的地址：<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a>，找到 redhat 的版本<strong>Red Hat Enterprise Linux 7 / Oracle Linux 7 (Architecture Independent), RPM Package</strong>,并复制 download 的地址，然后下载下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.进行 rpm 解包并安装 mysql-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">yum update</span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure><p>3.修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown mysql:mysql -R /var/lib/mysql</span><br></pre></td></tr></table></figure><p>4.然后就可以启动 mysql 了。。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><h1 id="问题记录">问题记录</h1><p>当然，看着上面好像很爽，很快的样子，但是没想到接下来坑还是很多的。都有点怀疑自己了，到现在装个 mysql 还这么多问题。关键是，网上的解决办法，都是什么乱七八糟的。</p><h2 id="1-状态查看-灰色">1.状态查看-灰色</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl status mysqld</span><br><span class="line">● mysqld.service - MySQL Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:mysqld(<span class="number">8</span>)</span><br><span class="line">           http://dev.mysql.com/doc/refman/en/using<span class="literal">-systemd</span>.html</span><br><span class="line"></span><br><span class="line">➜  ~ ps ajx | grep mysql</span><br><span class="line"> <span class="number">1768</span>  <span class="number">1784</span>  <span class="number">1784</span>  <span class="number">1784</span> ?           <span class="literal">-1</span> Ssl    <span class="number">999</span>   <span class="number">0</span>:<span class="number">19</span> mysqld</span><br></pre></td></tr></table></figure><p>1.看了一下版本号，没错是 8.0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mysqladmin --version</span><br><span class="line">mysqladmin  Ver 8.0.13 <span class="keyword">for</span> Linux on x86_64 (MySQL Community Server - GPL)</span><br></pre></td></tr></table></figure><p>2.然后 mysql 连一波，出问题，连不上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mysql</span><br><span class="line">ERROR 2002 (HY000): Can<span class="string">'t connect to local MySQL server through socket '</span>/var/lib/mysql/mysql.sock<span class="string">' (2)</span></span><br></pre></td></tr></table></figure><p>看样子是没有这个 socket，应该是位置不对，于是<code>sudo find / -name mysql.sock</code>赶紧搜一下，什么都没有，没有办法，重启一下试试吧。 3.重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo systemctl restart mysqld</span><br><span class="line">Job <span class="keyword">for</span> mysqld.service failed because the control process exited with error code. See <span class="string">"systemctl status mysqld.service"</span> and <span class="string">"journalctl -xe"</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>不行，换种方式重启看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ service mysqld start</span><br><span class="line">Redirecting to /bin/systemctl start mysqld.service</span><br><span class="line">==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===</span><br><span class="line">Authentication is required to manage system services or units.</span><br><span class="line">Authenticating as: root</span><br><span class="line">Password:</span><br><span class="line">polkit-agent-helper-1: pam_authenticate failed: Authentication failure</span><br><span class="line">==== AUTHENTICATION FAILED ===</span><br><span class="line">Failed to start mysqld.service: Access denied</span><br><span class="line">See system logs and <span class="string">'systemctl status mysqld.service'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><h2 id="2-错误：2002">2.错误：2002</h2><p>错误详情：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2)</p><p>这个错误网上找了一下，有看起来还可以的处理:<a href="http://blog.51cto.com/pengjc/1861088" target="_blank" rel="noopener">http://blog.51cto.com/pengjc/1861088</a> 。但是实际上我打开都没有这个文件，搜也没有搜到，于是放弃，这个问题应该不算个问题，先放着解决别的。</p><h2 id="3-错误：service-failed">3.错误：service failed</h2><p>错误详情：Job for mysqld.service failed because the control process exited with error code. See “systemctl status mysqld.service” and “journalctl -xe” for details.看了一下网上的解决办法，说是由于权限的问题：<a href="https://www.cnblogs.com/ivictor/p/5146247.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivictor/p/5146247.html</a> ，通过命令<code>chown mysql.mysql /var/run/mysqld/</code>，但是问题还是没有解决。  看了一下<a href="https://stackoverflow.com/questions/42317139/job-for-mysqld-service-failed-see-systemctl-status-mysqld-service" target="_blank" rel="noopener">stackoverflow</a>上面的说法，先通过<code>tail -f /var/log/mysqld.log</code>查看一下,，但是我的这个问题不是因为没有权限，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~  tail /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line">2018-12-07T09:13:21.651467Z 0 [ERROR] [MY-010119] [Server] Aborting</span><br><span class="line">2018-12-07T09:13:21.655750Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.13)  MySQL Community Server - GPL.</span><br><span class="line">2018-12-07T09:15:40.466437Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.13) starting as process 12759</span><br><span class="line">2018-12-07T09:15:40.965670Z 0 [ERROR] [MY-012681] [InnoDB] mmap(137428992 bytes) failed; errno 12</span><br><span class="line">2018-12-07T09:15:40.965740Z 1 [ERROR] [MY-012956] [InnoDB] Cannot allocate memory <span class="keyword">for</span> the buffer pool</span><br><span class="line">2018-12-07T09:15:40.965766Z 1 [ERROR] [MY-012930] [InnoDB] Plugin initialization aborted with error Generic error.</span><br><span class="line">2018-12-07T09:15:40.965794Z 1 [ERROR] [MY-010334] [Server] Failed to initialize DD Storage Engine</span><br><span class="line">2018-12-07T09:15:40.965949Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed.</span><br><span class="line">2018-12-07T09:15:40.965977Z 0 [ERROR] [MY-010119] [Server] Aborting</span><br><span class="line">2018-12-07T09:15:40.966835Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.13)  MySQL Community Server - GPL.</span><br></pre></td></tr></table></figure><p>搜了一下这个问题：<code>[ERROR] [MY-012681] [InnoDB] mmap(137428992 bytes) failed; errno 12</code>看样子是内存映射出错，再通过命令<code>journalctl -xe</code>看一下,同时也找到了原因：原来是<strong>swap 分区是 0(https://blog.csdn.net/sxyandapp/article/details/77091007),于是一阵操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ free -m</span><br><span class="line">/dev/vda1            /                    ext4       noatime,acl,user_xattr 1 1</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            992         516         304           0         171         321</span><br><span class="line">Swap:             0           0           0</span><br><span class="line"></span><br><span class="line">➜  ~ dd <span class="keyword">if</span>=/dev/zero of=/swap bs=1M count=512</span><br><span class="line">dd: failed to open ‘/swap’: Permission denied</span><br><span class="line"></span><br><span class="line">➜  ~ sudo dd <span class="keyword">if</span>=/dev/zero of=/swap bs=1M count=512</span><br><span class="line">512+0 records <span class="keyword">in</span></span><br><span class="line">512+0 records out</span><br><span class="line">536870912 bytes (537 MB) copied, 4.01658 s, 134 MB/s</span><br><span class="line"></span><br><span class="line">➜  ~ sudo mkswap /swap</span><br><span class="line">Setting up swapspace version 1, size = 524284 KiB</span><br><span class="line">no label, UUID=9bbac588-e6ee-4b1c-a398-4ac460ad476a</span><br><span class="line"></span><br><span class="line">➜  ~ sudo swapon /swap</span><br><span class="line">swapon: /swap: insecure permissions 0644, 0600 suggested.</span><br><span class="line"></span><br><span class="line">➜  ~ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            992         516          64           0         410         317</span><br><span class="line">Swap:           511           0         511</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vi /etc/fstab</span><br><span class="line"><span class="comment">#在其中添加如下一行,保证下次系统启动后，此swap分区被自动加载，需要修改系统的fstab文件</span></span><br><span class="line">/swap swap swap defaults 0 0</span><br></pre></td></tr></table></figure><p>之后再重启就好了。</p><h2 id="4-错误：登录问题">4.错误：登录问题</h2><p>错误详情：error: ‘Access denied for user ‘root’@‘localhost’ (using password: NO)’</p><p>这个其实是密码的问题，没有设置密码的时候，mysql 会生成一个临时的密码，通过命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo grep <span class="string">'temporary password'</span> /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line">2018-12-07T09:08:22.908621Z 5 [Note] [MY-010454] [Server] A temporary password is generated <span class="keyword">for</span> root@localhost: TdqPeZ-n;4Ah</span><br></pre></td></tr></table></figure><p>可以看到生成的临时密码，然后用临时密码登录即可。</p><h2 id="5-修改密码">5.修改密码</h2><p>可能因为 8.0 的版本，修改的密码不能过于简单，并且命令好像也有些不一样了，用的是``</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'MyNewPass'</span>;</span><br></pre></td></tr></table></figure><p>看到一个别人的回答：<img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1544177770052-39cd9fe0-1c11-4059-be21-08de2d19446b.png#align=left&amp;display=inline&amp;height=148&amp;originHeight=148&amp;originWidth=695&amp;status=done&amp;width=695" alt="">应该是后面才改的？</p><h1 id="6-外网连接-mysql">6.外网连接 mysql</h1><p>由于两台服务器的版本有点不一样，修改外网连接也有点不一样。</p><h2 id="mysql5-7"><a href="https://blog.csdn.net/w20228396/article/details/70143500" target="_blank" rel="noopener">MySQL5.7</a></h2><p>1.修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf   <span class="comment"># bind-address=127.0.0.1 修改成 bind-address=0.0.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">service mysql restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程连接mysql的账号</span></span><br><span class="line">&gt; grant all on *.* to root@<span class="string">'%'</span> identified by <span class="string">'123456'</span>;</span><br><span class="line">&gt; flush privileges;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">*.*          第一个*表示库，第二个*表示表; *.*对全部数据库的全部表授权，so.ok 表示只对so这个库中的ok表授权</span><br><span class="line">root        表示要给哪个用户授权，这个用户可以是存在的用户，也可以是不存在的</span><br><span class="line"><span class="string">'%'</span>          表示允许远程连接的IP地址，%代表允许所有IP连接</span><br></pre></td></tr></table></figure><h2 id="mysql8-0"><a href="https://stackoverflow.com/questions/50177216/how-to-grant-all-privileges-to-root-user-in-mysql-8-0" target="_blank" rel="noopener">MySQL8.0</a></h2><p>8.0 的版本总结的对权限的管理严格很多，毕竟数据很重要，只有安全才能放心。尝试过上述方式，但是连接不上。最终在 Stack Overflow 上找到了办法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'root'</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>但是修改之后还是会有问题，出现了 2059 错误：  <img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1544449883818-59e9985f-7a74-47f5-954e-4e8aa80ced7c.png#align=left&amp;display=inline&amp;height=129&amp;originHeight=129&amp;originWidth=586&amp;status=done&amp;width=586" alt="">解决方式可以采用修改密码为简单密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL validate_password.policy=0;</span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'12345678'</span>;</span><br></pre></td></tr></table></figure><h1 id="使用过程问题">使用过程问题</h1><h2 id="1-导入数据出错">1.导入数据出错</h2><p>错误代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD DATA LOCAL INFILE &#39;&#x2F;home&#x2F;mianhk&#x2F;pet.txt&#39; INTO TABLE pet;</span><br><span class="line">ERROR 1148 (42000): The used command is not allowed with this MySQL version</span><br><span class="line"></span><br><span class="line">mysql&gt; LOAD DATA INFILE &#39;&#x2F;home&#x2F;mianhk&#x2F;pet.txt&#39; INTO TABLE pet;</span><br><span class="line">ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it ca</span><br><span class="line">nnot execute this statement</span><br><span class="line"></span><br><span class="line">mysql&gt; LOAD DATA INFILE &#39;&#x2F;home&#x2F;mianhk&#x2F;pet.txt&#39; INTO TABLE pet LINES TERMINATED BY &#39;\r\n&#39;;</span><br><span class="line">ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it ca</span><br><span class="line">nnot execute this statement</span><br></pre></td></tr></table></figure><p>原因：secure_file_priv 设置了指定目录，需要在指定的目录下进行数据导出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%secure%&#39;;</span><br><span class="line">+--------------------------+-----------------------+</span><br><span class="line">| Variable_name            | Value                 |</span><br><span class="line">+--------------------------+-----------------------+</span><br><span class="line">| require_secure_transport | OFF                   |</span><br><span class="line">| secure_file_priv         | &#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F; |+--------------------------+-----------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>数据导入需要注意的:</p><ul><li>空值要用 <code>\N</code>  代替，而不能直接使用空</li><li>分隔符一般用 <code>tab</code></li><li>注意换行符</li></ul><h1 id="总结">总结</h1><p>总之，感觉之前 windows 和 ubuntu 下都没有这么麻烦，这里总结一下吧，感觉以后会用的很多，不想踩坑了。</p><h1 id="参考：">参考：</h1><p><a href="https://juejin.im/entry/5af5d2786fb9a07aaf3547cc" target="_blank" rel="noopener">MySQL8.0.11 连接错误 2059 解决方法</a><a href="https://stackoverflow.com/questions/50177216/how-to-grant-all-privileges-to-root-user-in-mysql-8-0" target="_blank" rel="noopener">How to grant all privileges to root user in MySQL 8.0</a><a href="https://www.cnblogs.com/echo-coding/p/9172636.html" target="_blank" rel="noopener">centos mysql 初探 – 配置、基本操作及问题</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 使用语雀编辑器写静态博客</title>
      <link href="/2018/11/14/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/11/14/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本来以为已经是最后一次折腾了，但是总是生活不停，折腾不止，觉得本地文件管起来还是有点麻烦，看到语雀 markdown 又做的这么好，前几天还准备拿它当云笔记用，但是据说底层存的都是 md 格式，有的时候又还是不太方便，不过做编辑器来说确实很爽了，自带图床，还有 github 上开源的一个接口。</p></blockquote><a id="more"></a><h1 id="准备工作">准备工作</h1><h2 id="更新-node-js-和-npm">更新 node.js 和 npm</h2><p>刚刚来就是坑，不过还是准备从正常的步骤开始说吧，就是博客基于的是 nodejs，很多包的安装都是采用 npm 统一管理的，因为有些插件需要使用新的版本，所以需要先更新一下，这里只说一下 windows 下面的操作。</p><h3 id="更新-node-js">更新 node.js</h3><p>window 下并没有网上说的乱七八糟的命令行更新方式，直接在<a href="http://nodejs.cn/" target="_blank" rel="noopener">官网</a>下载最新的安装包就可以。然后安装在之前的位置进行覆盖就可以更新了。更新之后通过命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$node -v</span><br><span class="line">v10.13.0</span><br></pre></td></tr></table></figure><h3 id="更新-npm">更新 npm</h3><p>通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$npm install -g npm</span><br><span class="line"></span><br><span class="line">#更新后的版本可以看到</span><br><span class="line">$npm -v</span><br><span class="line">6.4.1</span><br></pre></td></tr></table></figure><h3 id="更新包">更新包</h3><p>可以使用命令查看可以更新的包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$npm outdated         #查看需要更新的包：</span><br><span class="line">Package                 Current  Wanted  Latest  Location</span><br><span class="line">hexo-helper-live2d      MISSING   3.1.0   3.1.0  hexo-site</span><br><span class="line">hexo                      3.3.9   3.8.0   3.8.0  hexo-site</span><br><span class="line">hexo-douban              0.2.14  0.2.16   1.0.6  hexo-site</span><br><span class="line">hexo-generator-archive    0.1.4   0.1.5   0.1.5  hexo-site</span><br><span class="line">hexo-generator-search     2.2.5   2.3.0   2.3.0  hexo-site</span><br><span class="line">hexo-renderer-ejs         0.2.0   0.2.0   0.3.1  hexo-site</span><br><span class="line">hexo-renderer-marked     0.2.11  0.2.11   0.3.2  hexo-site</span><br><span class="line">hexo-server               0.2.2   0.2.2   0.3.3  hexo-site</span><br><span class="line">$npm install --save  #</span><br></pre></td></tr></table></figure><p>之后修改<code>package.json</code>文件，修改到对应的版本。然后执行命令，进行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install --save</span><br></pre></td></tr></table></figure><h2 id="安装语雀文章下载插件">安装语雀文章下载插件</h2><p>首先这里鸣谢开源的插件：[<a href="https://github.com/x-cold/yuque-hexo" target="_blank" rel="noopener">yuque-hexo</a>](https://github.com/x-cold/yuque-hexo)，通过工具可以将语雀知识库中的文件同步到本地，大部分功能和步骤在仓库中都有些，但是自己做的时候还是踩了坑，这里就还是写一下吧。</p><h3 id="1-创建语雀知识库">1.创建语雀知识库</h3><p>打开<a href="https://www.yuque.com/" target="_blank" rel="noopener">语雀</a> 创建自己的博客知识库，并且要<strong>设置成公开的。可以在设置中看到链接如下：</strong><img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1542204775155-271c9311-4643-4ccd-8692-24ab7351e0cb.png#width=375" alt="">同时打开<a href="https://www.yuque.com/mianhk/gaqqwc" target="_blank" rel="noopener">blog 知识库</a>:<a href="https://www.yuque.com/mianhk/gaqqwc" target="_blank" rel="noopener">https://www.yuque.com/mianhk/gaqqwc</a>可以打开知识库。</p><h3 id="2-在本地安装-yuque-hexo">2.在本地安装 yuque-hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g yuque-hexo</span><br></pre></td></tr></table></figure><h3 id="3-配置-package-json">3.配置 package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;clean&quot;: &quot;npm run clean:yuque &amp;&amp; hexo clean&quot;,</span><br><span class="line">  &quot;clean:yuque&quot;: &quot;DEBUG&#x3D;yuque-hexo.* yuque-hexo clean&quot;,</span><br><span class="line">  &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class="line">  &quot;publish&quot;: &quot;npm run clean &amp;&amp; npm run deploy&quot;,</span><br><span class="line">  &quot;dev&quot;: &quot;hexo s&quot;,</span><br><span class="line">  &quot;sync&quot;: &quot;DEBUG&#x3D;yuque-hexo.* yuque-hexo sync&quot;,</span><br><span class="line">  &quot;reset&quot;: &quot;npm run clean:yuque &amp;&amp; npm run sync&quot;</span><br><span class="line">&#125;, </span><br><span class="line">  &quot;yuqueConfig&quot;: &#123;</span><br><span class="line">  &quot;baseUrl&quot;: &quot;https:&#x2F;&#x2F;www.yuque.com&#x2F;api&#x2F;v2&quot;,    #这是语雀的永久链接，直接复制就可以</span><br><span class="line">  &quot;login&quot;: &quot;mianhk&quot;,                      #用户名，上个链接的第一个下划线</span><br><span class="line">  &quot;repo&quot;: &quot;gaqqwc&quot;,                      #知识库链接，第二个下划线</span><br><span class="line">  &quot;mdNameFormat&quot;: &quot;slug&quot;,               #导出本地的文件名为随机的数字，比直接的中文title要好看，</span><br><span class="line">                                              可以直接用了</span><br><span class="line">  &quot;postPath&quot;: &quot;source&#x2F;_posts&#x2F;yuque&quot;     #存在本地文件夹的位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-删除和同步文章">4.删除和同步文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#删除文章</span><br><span class="line">$yuque-clean</span><br><span class="line">[INFO] yuque-hexo clean start.</span><br><span class="line">[INFO] remove yuque posts: F:\blog\mianhk.github.io\source\_posts\yuque\</span><br><span class="line">[INFO] remove yuque local file: F:\blog\mianhk.github.io\yuque.json</span><br><span class="line">[INFO] yuque-hexo clean finished.</span><br><span class="line"></span><br><span class="line">#同步文章</span><br><span class="line">$yuque-hexo sync</span><br><span class="line">[INFO] yuque-hexo sync start.</span><br><span class="line">[INFO] remove yuque posts: F:\blog\mianhk.github.io\source\_posts\yuque\</span><br><span class="line">[INFO] loading config: F:\blog\mianhk.github.io\package.json</span><br><span class="line">[INFO] downloading articles: &#123;&quot;baseUrl&quot;:&quot;https:&#x2F;&#x2F;www.yuque.com&#x2F;api&#x2F;v2&quot;,&quot;login&quot;:&quot;mianhk&quot;,&quot;repo&quot;:&quot;gaqqwc&quot;,&quot;mdNameFormat&quot;:&quot;slug&quot;,&quot;postPath&quot;:&quot;source&#x2F;_posts&#x2F;yuque&quot;&#125;</span><br><span class="line">[INFO] reading from local file: F:\blog\mianhk.github.io\yuque.json</span><br><span class="line">[INFO] download article body: 11月生活小结</span><br><span class="line">[INFO] download articls done!</span><br><span class="line">[INFO] writing to local file: F:\blog\mianhk.github.io\yuque.json</span><br><span class="line">[INFO] create posts director (if it not exists): F:\blog\mianhk.github.io\source\_posts\yuque</span><br><span class="line">[INFO] generate post file: F:\blog\mianhk.github.io\source\_posts\yuque\xzxhcv.md</span><br><span class="line">[INFO] yuque-hexo sync finished.</span><br></pre></td></tr></table></figure><h3 id="5-修改文章的-title-和-tag-等">5.修改文章的 title 和 tag 等</h3><p>还是跟之前的格式直接写即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">update:</span><br><span class="line">categories:</span><br><span class="line">tags: []</span><br></pre></td></tr></table></figure><h3 id="6-部署博客">6.部署博客</h3><h1 id="记录一些坑">记录一些坑</h1><ul><li><p>知识库一定要是公开的</p></li><li><p>windows 下更新 nodejs 不能用 n，即使强制使用了也还是无法更新</p></li><li><p>新版本的 npm。如果改了 package.json，且 package.json 和 lock 文件不同，那么执行<code>npm i</code>时 npm 会根据 package 中的版本号以及语义含义去下载最新的包，并更新至 lock。</p></li></ul><h2 id="reference">Reference:</h2><ul><li><p><a href="https://github.com/x-cold/yuque-hexo" target="_blank" rel="noopener">https://github.com/x-cold/yuque-hexo</a></p></li><li><p><a href="https://luan.ma/post/yuque2blog/" target="_blank" rel="noopener">https://luan.ma/post/yuque2blog/</a></p></li><li><p><a href="https://www.zhihu.com/question/62331583" target="_blank" rel="noopener">https://www.zhihu.com/question/62331583</a></p></li><li><p><a href="https://tommy.net.cn/2018/02/26/upgrade-hexo-to-v3-5-0/" target="_blank" rel="noopener">将 Hexo 升级到 v3.5.0</a></p></li><li><p><a href="https://github.com/x-cold/blog/blob/master/package.json#L26" target="_blank" rel="noopener">Demo Json</a></p></li></ul><p><a href="https://segmentfault.com/a/1190000017797561" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017797561</a><a href="https://lkc.im/archives/1d99.html" target="_blank" rel="noopener">https://lkc.im/archives/1d99.html</a><a href="https://x-d.xyz/2019/04/02/yuque/Hexo%E5%8D%9A%E5%AE%A2%E4%BA%91%E7%AB%AF%E5%86%99%E4%BD%9C%EF%BC%8C%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/" target="_blank" rel="noopener">https://x-d.xyz/2019/04/02/yuque/Hexo%E5%8D%9A%E5%AE%A2%E4%BA%91%E7%AB%AF%E5%86%99%E4%BD%9C%EF%BC%8C%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 语雀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 11月生活小结(2018)</title>
      <link href="/2018/11/05/yuque/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%93(2018)/"/>
      <url>/2018/11/05/yuque/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%93(2018)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近又到了生活有点不知道干什么的时候，有的时候觉得自己对什么都很有信心，有的时候又觉得什么都做不好。想起来以前总是站在自己的角度看一些事情，看自己。直到现在有时候看看，自己的问题，一直放在那，并没有好多少，只不过我像对待其他人一样宽容的对待了自己。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1541420058802-2a13e83c-eb31-4adb-9ce0-5b8443a9ff3b.png#width=596" alt=""></p><h2 id="专注的做自己该做的事情">专注的做自己该做的事情</h2><p>发现自己原来一直是个喜欢折腾的人，平时折腾 Linux，折腾 chrome 的插件，学一些东西的时候，好像总是把关注点搞错了。先以几件事举个例子吧。</p><h3 id="学习-c">学习 C++</h3><p>比如学个语言，C++，先在网上搜 Windows 下 C 好用的编辑器，嗯，找到了 Dev C，觉得还挺好的，确实，直接编译就能运行，而且还是 gcc 的编译，也比较符合现在吧，总比那些 VC6.0 要好。然后写了一段，刷题的时候发现怎么有的时候中文粘贴会有问题，垃圾，赶紧换一个。</p><p>于是就看到了网上的很多说 vim 搭建 IDE 很酷，而且 vim 自己也用过，自己也恰好有台云服务器，自己要做的也是 Linux 下的 C++开发，也恰好可以练习一些比如 gcc 工具链呀，写写 Makefile 呀，嗯，于是网上找了一堆 vim 的配置，配置的很酷，找了很多，各种修改，甚至白天都没心思干活了也要搞好，中午回宿舍开着电脑马上开始弄，到了后面折腾的都累了，在 github 上找到了一个别人配好的，看了一下界面，唉，算了就这个吧。于是 vim 下一阵操作，还学了配置的一些快捷键：诸如切换窗口，切换文件，语法错误之类的，还有即时运行之类的操作。就像下面这样。。</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/187932/1541417270624-4fa02e68-1d4c-4852-8be2-24498600aff1.png#width=504" alt=""></p><p>过段时间发现，这个云服务器下面写代码还是不太好，1M 的小水管，有的时候会卡，这就很难受了，而且说得联系 Makefile 那些，其实能练的也比较少，一般都是直接 make 一下文件就好了，或者是一个写好的 Makefile 直接全编译了。于是又转回了 Windows，试了一下宇宙 IDE–VS，果然不一样，先下个最新版吧，2017 怎么这么大呀，算了，换 2015 吧，额，2015 好像也有点大，要不就试试 2013 吧，这个大小好像还凑和，于是下载下来，一顿折腾，终于可以写了，唉，这个怎么每次还要加 pause 才行呀，而且这个小黑框输入也太难受了，而且打开一下这么大，算了，溜了溜了。</p><p>又看到 Idea 家的跨平台的 Clion，因为之前用过 idea，所以觉得还不错，现代的 IDE，那就用用看吧，但是这个环境，还要配置MINGW64 呀，算了，配置吧，网上一大堆了，虽然有些有坑，虽然有的时候网速很慢，但是没事，我能克服困难。。于是就用了这个，确实还挺好看的，用着也还算顺手吧，赶紧把主题呀，各种呀配置一下呀，哦，还有 vim，这么好用的工具。试了一段时间写项目确实不错，做个小项目，写起来还可以的。但是是要在 Linux 下编译的呀，于是又找到了 ftp 工具。。。</p><p>讲道理到这应该也差不多了，但是，Clion 每次打开也是很大了，总感觉不是很方便，要不还是？ 哦，最近正好出了一个编辑器还挺好用的，网上看着各种推荐，vscode，网上都说还可以，微软做的，我试试吧。哎，做编辑器确实可以，平时写个算法之类的呀。于是又是各种插件折腾，对了，再弄个 c++的编译环境吧，但是这个编译也有点慢呀，算了，忍忍吧。</p><p>上面大概是这一年多以来学习 C++过程的坑了，不知道很多 Programmer 是不是也跟我一样，但是回头想想真的花了很多乱七八糟的时间来做一些无关紧要的事情，其实就是没有抓住重点吧。</p><h3 id="服务器和博客的折腾">服务器和博客的折腾</h3><p>因为一直有台服务器，为了不用开虚拟机就做 Linux 操作，自己在上面的折腾也算是蛮多吧，从最开始想跑个微信（一个 github 上的项目），然后折腾 vim，折腾挖矿（收益当然是不用说，但是当时感觉还不错），后面又折腾 Jupyter notebook，tmux，zsh，也是花费了不少的时间，但是结果是，关于真正技术方面的，反而学到的比较少。</p><h2 id="what-s-next">What’s Next</h2><p>有的时候自己也在想这些原因，以前可能也会有些这样，但是至少能在一方面能够保持很好的一个学习状态，但是直到最近，可能也是找完了工作吧，心态也有些放松了，所以就更。但是，真正的自由，是在自律的条件下的。所以计划和要求也还是要有的：</p><ul><li><p>学习 MySQL 和 Go 语言</p></li><li><p>每周至少一篇技术博客</p></li><li><p>上班时间，就干该干的事情</p></li><li><p>玩的时候，一定不要想着学习</p></li><li><p>不吃夜宵</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 生活 </tag>
            
            <tag> 日常总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Travis CI 自动部署博客</title>
      <link href="/2018/10/26/tools/hexo_travis-ci/"/>
      <url>/2018/10/26/tools/hexo_travis-ci/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hexo的又双叒一次折腾，以前觉得hexo部署博客还是很麻烦，除了每次操作完都得等待生成一下，还有的就是有时候很久一生成，都是看人品出错，以前也弄过那种自动的脚本，每天自己生成然后push，但是出错的时候就又是很麻烦。直到这次看到了Travis CI…</p></blockquote><a id="more"></a><p>听到持续集成这个词还是最近逛github的时候，看到一些讨论才搜了一下这个，不过之前也是想过这个问题，毕竟有痛点就会想。之前折腾hexo博客的时候，试过在windows下面写个bat脚本，定时<code>hexo clean hexo g -d</code>一下，但是有时候文件太多搞乱了，就出问题了，一段时间没弄，就又得回来折腾。后面也试过就不在windows下面操作了，干脆只在博客文件夹弄，然后编辑器自动ftp到服务器上，再在服务器上自动生成，好像也没啥区别。直到看到Travis CI，才知道大佬们为啥都这么青睐hexo了。那就开整吧。</p><h1 id="travis思想">Travis思想</h1><p>简单点就是，当我们的github公开仓库与Travis CI绑定后，在仓库中建立一个Travis CI<code>.travis.yml</code>文件，每当<code>.travis.yml</code>文件中监听的分支发现有变动时，会根据<code>.travis.yml</code>中的配置进行操作。</p><h1 id="github准备">Github准备</h1><p>首先是准备gitpages，仓库之前已经有了，这个是放生成的静态页面的，还有一个仓库，放的是博客的源码。之前的一般操作都是在源码博客中通过<code>hexo g -d</code>后push到gitpages目录中，所以大部分操作一般都是在这个源码中进行的，gitpages仓库是用来展示的，准确来说是gitpages仓库的master分支。</p><p>由于Travis CI可以监听某个分支，所以这样一想，就不用弄两个仓库了，只需要弄两个分支即可：源码放在source分支，并又Travis CI监听，每次push后会自动push到master分支，完成博客的自动部署。</p><p>Travis CI连接到仓库需要token才能操作，就相当于一把钥匙，可以在<code>Settings</code>-&gt;<code>Developer settings</code>-&gt;<code>Personal access tokens</code>-&gt;<code>Generate new token</code>,填写<code>Token description</code>，之后勾选<code>repo</code>，选择<code>generate token</code>。如图：</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026151507.png" /> </div><br><p>点击复制按钮复制<code>token</code>：</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026151704.png" /> </div><br><h1 id="travis-ci设置">Travis CI设置</h1><h2 id="github账号登录">github账号登录</h2><p>在<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI网站</a>通过github账号登录后，开启gitpages仓库的同步，然后点击<code>settings</code>进行设置。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026155513.png" /> </div><br><h2 id="通用设置和配置环境变量">通用设置和配置环境变量</h2><p>之后开启设置，并设置环境变量(主要是为了travis的自动部署，但是token直接公开有风险，因此需要在这里设置):</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026155627.png" /> </div><br><h1 id="在source分支创建-travis-yml文件">在source分支创建<code>.travis.yml</code>文件</h1><p>在gitpages仓库的source分支创建。这里涉及几个git的操作，真是坑踩多了，自然就会多用几个命令了。。</p><h2 id="拉取远程仓库并创建新分支">拉取远程仓库并创建新分支</h2><p>操作步骤为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 克隆项目到本地</span><br><span class="line">&gt; git clone git@github.com:mianhk&#x2F;mianhk.github.io.git</span><br><span class="line"># 创建并切换到source分支</span><br><span class="line">&gt; git checkout -b source</span><br></pre></td></tr></table></figure><p>切换到source分支后，将本地除<code>.git</code>文件夹的其他文件删除，并将之前的源码文件拷贝到当前文件夹，然后提交到远程的source分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提交本地hexo分支到远程仓库的hexo分支</span><br><span class="line">git push origin hexo:hexo</span><br></pre></td></tr></table></figure><h2 id="创建-travis-yml文件">创建.travis.yml文件</h2><p>当然这个文件网上一找一大堆，也不是我自己写的，参考：https://juejin.im/post/5a1fa30c6fb9a045263b5d2a  自己进行了一点修改：具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 使用语言</span><br><span class="line">language: node_js</span><br><span class="line"># node版本</span><br><span class="line">node_js: stable</span><br><span class="line"># 设置只监听哪个分支</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - source</span><br><span class="line"># 缓存，可以节省集成的时间，这里我用了yarn，如果不用可以删除</span><br><span class="line">cache:</span><br><span class="line">  apt: true</span><br><span class="line">  directories:</span><br><span class="line">    - node_modules</span><br><span class="line"># tarvis生命周期执行顺序详见官网文档</span><br><span class="line">before_install:</span><br><span class="line">- export TZ&#x3D;&#39;Asia&#x2F;Shanghai&#39; # 更改时区</span><br><span class="line">- git config --global user.name &quot;mianhk&quot;</span><br><span class="line">- git config --global user.email &quot;gcyu@gmail.com&quot;</span><br><span class="line"># 由于使用了yarn，所以需要下载，如不用yarn这两行可以删除</span><br><span class="line">#- curl -o- -L https:&#x2F;&#x2F;yarnpkg.com&#x2F;install.sh | bash</span><br><span class="line">#- export PATH&#x3D;$HOME&#x2F;.yarn&#x2F;bin:$PATH</span><br><span class="line">- npm install -g hexo-cli</span><br><span class="line">install:</span><br><span class="line"># 不用yarn的话这里改成 npm i 即可</span><br><span class="line">#- yarn</span><br><span class="line">- npm i</span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo generate</span><br><span class="line">after_success:</span><br><span class="line">- cd .&#x2F;public</span><br><span class="line">- git init</span><br><span class="line">- git add --all .</span><br><span class="line"># commit 中间添加时间信息</span><br><span class="line">- git commit -m &quot;Travis CI Auto Builder at &#96;date +&quot;%Y-%m-%d %H:%M&quot;&#96;&quot;  </span><br><span class="line"># 这里的 REPO_TOKEN 即之前在 travis 项目的环境变量里添加的</span><br><span class="line">- git push --quiet --force https:&#x2F;&#x2F;$REPO_TOKEN@github.com&#x2F;mianhk&#x2F;mianhk.github.io.git</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>之后便可以通过在本地或者其他电脑上通过git在source分支上的操作实现自动部署了。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20181026161116.png" /> </div><br> <h1 id="一些坑">一些坑</h1><p>一些拷贝文件产生的错误，导致中间出错了好几次，通过调整文件进行本地测试的时候，没有问题，但是自动构建就还是出问题。需要将原来的源码中的<code>config.yml</code>的push选项进行一下修改。</p><h1 id="reference">Reference</h1><p><a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" target="_blank" rel="noopener">使用Travis CI自动部署Hexo博客</a><br><a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener">Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 折腾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结-操作系统</title>
      <link href="/2018/06/24/interview/interview_operation/"/>
      <url>/2018/06/24/interview/interview_operation/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的分页分段">操作系统的分页分段</h1><p><a href="https://www.cnblogs.com/onepeace/p/5066736.html" target="_blank" rel="noopener">操作系统之分页分段介绍</a></p><h2 id="分页存储">分页存储</h2><ul><li>思想：将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)或物理块，每个物理块的大小一般取2的整数幂。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）。</li><li>逻辑地址道物理地址变化原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。</li><li>优点：没有外碎片，提高内存的利用率。一个程序不必连续存放。便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。</li><li>缺点：无论数据有多少，都只能按照页面大小分配，容易产生内部碎片。无法体现程序逻辑。页长与程序的逻辑大小不相关。不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。</li></ul><h2 id="分段存储">分段存储</h2><ul><li>思想：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中（写c程序时会用到），并且每个程序可以有多个相同类型的段。段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。<br>在为某个段分配物理内存时，可以采用<strong>首先适配法、下次适配法、最佳适配法</strong>等方法。在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。</li><li>地址映射: 在分段存储中，整个进程的地址空间是<strong>二维</strong>的，即其逻辑地址由段号和段内地址两部分组成。</li><li>优点：分段对程序员可见。段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。方便编程，分段共享，分段保护，动态链接，动态增长。</li><li>缺点：主存空间分配比较麻烦。外部碎片。由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚拟地址和实存地址的最低若干二进制位作为段内地址，并与段号进行直接拼接，必须用加法操作通过段起址与段内地址的求和运算得到物理地址。</li></ul><h2 id="分页存储和分段存储的区别">分页存储和分段存储的区别</h2><ol><li>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；段则是信息的逻辑单位，它含有一组其意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。</li><li>页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li><li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址是，即需给出段名，又需给出段内地址。</li><li>分页信息很难保护和共享、分段存储按逻辑存储所以容易实现对段的保存和共享。</li></ol><h2 id="段页存储">段页存储</h2><p>程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180622105842.png" /> </div><br>  为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块<p>它首先将程序按其逻辑结构划分为若干个大小不等的逻辑段，然后再将每个逻辑段划分为若干个大小相等的逻辑页。主存空间也划分为若干个同样大小的物理页。辅存和主存之间的信息调度以页为基本传送单位，每个程序段对应一个段表，每页对应一个页表。</p><p>段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量</p><p>CPU访问时，段表指示每段对应的页表地址，每一段的页表确定页所在的主存空间的位置，最后与页表内地址拼接，确定CPU要访问单元的物理地址。</p><p>段页存储管理方式综合了段式管理和页式管理的优点，但需要经过两级查表才能完成地址转换，消耗时间多。</p><ul><li>过程：检查是否越界。利用段表始址和段号来求出该段所对应的段表项在段表中的位置，得到该段的页表始址。读出该页所在的物理块号b。构建物理地址。</li><li>优点：提供了大量的虚拟存储空间。有效地利用主存，为组织多道程序运行提供了方便。</li><li>缺点：增加了硬件成本、系统的复杂性和管理上的开销。存在系统抖动的风险。存在内碎片。各种表占用更多的空间。</li></ul><h1 id="linux自旋锁">Linux自旋锁</h1><h1 id="线程同步">线程同步</h1><p>http://bestmind.space/posts/%E5%B8%B8%E8%A7%81C-%E9%9D%A2%E8%AF%95%E9%A2%98/<br>线程同步和线程互斥的区别线程同步的方式:互斥锁、读写锁(共享-独占锁)、条件变量和信号量</p><h1 id="进程间通信">进程间通信</h1><p>进程间的通信方式管道、有名管道、信号、共享内存、消息队列、信号量、套接字、文件.(1)管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。  管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的首端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。分为普通管道、流管道、命名管道。<br>(2)命名管道(named pipe):命名管道也是半双工的通信方式，它克服了管道没有名字的限制，并且它允许无亲缘关系进程间的通信。命令管道在文件系统中有对应的文件名，命名管道通过命令mkfifo或系统调用mkfifo来创建。<br>(3)信号:信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。除了用于进程通信外，进程还可以发送信号给进程本身。<br>(4)消息队列：克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小的限制。由消息链表的结构实现。<br>(5)信号量(semophore):信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br>(6)共享内存：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<br>(7)套接字: 与其他通信机制不同的是，它可用于不同机器间的进程通信。但是将通信转移到了应用层。</p><h1 id="select-poll-epoll的区别">select、poll、epoll的区别</h1><h1 id="死锁">死锁</h1><p>指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><p>死锁产生的四个必要条件:互斥条件:一个资源每次只能被一个进程使用不可剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系.</p><h2 id="死锁避免">死锁避免</h2><p>银行家算法：检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。</p><h2 id="死锁解除">死锁解除</h2><ol><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li><li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol><h1 id="进程有哪几种状态？">进程有哪几种状态？</h1><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；阻塞状态： 进程等待某种条件，在条件满足之前无法执行；</p><h1 id="操作系统中进程调度策略有哪几种？">操作系统中进程调度策略有哪几种？</h1><p>FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU</p><p>SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度</p><p>优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化</p><p>时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</p><p>多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</p><p>多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p><h1 id="虚拟内存">虚拟内存</h1><p>为什么有虚拟内存：对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上缺页：如果虚拟内存的页并不存在于物理内存中，会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。</p><p>页面置换算法：FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p><p>LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；</p><p>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</p><p>OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p><h2 id="多线程中栈与堆是公有的还是私有的">多线程中栈与堆是公有的还是私有的</h2><p>一般来说栈是私有的，堆是公有的。但是在多线程中，可以为特定的线程创建私有的堆。</p><h2 id="进程是资源分配的最小单位-线程是cpu调度的最小单位">进程是资源分配的最小单位，线程是CPU调度的最小单位</h2><p>进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。<br>与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。<br>线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。<br>因此一个简单的解释就是：进程拥有PCB，而多个线程共享一个进程的PCB。</p><h3 id="进程和线程的区别">进程和线程的区别</h3><p><a href="https://segmentfault.com/a/1190000005884656" target="_blank" rel="noopener">进程与线程的一个简单解释</a>地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。<br>通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。<br>调度和切换：线程上下文切换比进程上下文切换要快得多。<br>在多线程OS中，进程不是一个可执行的实体。</p><div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180622095406.png" /> </div><br><h2 id="进程的基本状态">进程的基本状态</h2><p>状态：运行、阻塞、挂起阻塞、就绪、挂起就绪<br>状态之间的转换：准备就绪的进程，被CPU调度执行，变成运行态；<br>运行中的进程，进行I/O请求或者不能得到所请求的资源，变成阻塞态；<br>运行中的进程，进程执行完毕（或时间片已到），变成就绪态；<br>将阻塞态的进程挂起，变成挂起阻塞态，当导致进程阻塞的I/O操作在用户重启进程前完成（称之为唤醒），挂起阻塞态变成挂起就绪态，当用户在I/O操作结束之前重启进程，挂起阻塞态变成阻塞态；<br>将就绪（或运行）中的进程挂起，变成挂起就绪态，当该进程恢复之后，挂起就绪态变成就绪态；</p><figure class="highlight plain"><figcaption><span>const char * const task_state_array[] </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &quot;R (running)&quot;,        &#x2F;*   0 *&#x2F;</span><br><span class="line">  &quot;S (sleeping)&quot;,        &#x2F;*   1 *&#x2F;</span><br><span class="line">  &quot;D (disk sleep)&quot;,    &#x2F;*   2 *&#x2F;</span><br><span class="line">  &quot;T (stopped)&quot;,        &#x2F;*   4 *&#x2F;</span><br><span class="line">  &quot;t (tracing stop)&quot;,    &#x2F;*   8 *&#x2F;</span><br><span class="line">  &quot;X (dead)&quot;,        &#x2F;*  16 *&#x2F;</span><br><span class="line">  &quot;Z (zombie)&quot;,        &#x2F;*  32 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180622100813.png" /> </div><br>         <h3 id="1-进程管理-cpu">1.进程管理-&gt;CPU</h3><h4 id="任务调度算法">任务调度算法</h4><p>1.先来先服务算法优点：简单，易于理解和实现。缺点：一批任务的平均周转时间取决于各个任务到达的顺序，如果短任务位于长任务之后，那么将增大平均周转时间。<br>2.短作业优先算法<br>SJF算法的基本思路是：各个任务在开始执行之前，必须事先预计好它的执行时间，然后调度器将根据这些时间，从中选择用时较短的任务优先执行。SJF算法有两种：不可抢占方式和可抢占方式。其中可抢占方式又叫最短剩余时间优先算法（Shortest Remaining Time First，SRTF）。<br>3.时间片轮转算法时间片轮转算法（Round Robin，RR）的基本思路是：把系统当中的所有就绪任务按照先来先服务的原则，排成一个队列，然后再每次调度的时候，把处理器分派给队列当中的第一个任务，让它去执行一小段CPU时间（即时间片，time slice）。当这个时间片结束时，如果任务还没有执行完成的话，将会发生时钟中断，在时钟中断里面，调度器将会暂停当前任务的执行，并把它送到就绪队列的末尾，然后执行当前的队首任务。反之，如果一个任务在它的时间片用完之前就已经结束了或者阻塞了，那么它就会立即让出CPU给其他任务。<br>优点：公平性，各个就绪任务能得到相同的时间片；活动性，每个就绪任务能一直保持活动。<br>缺点：时间片的大小q要适当选取，如果选择不当，将会影响到系统的性能和效率。如果q太大，每个任务都在一个时间片内完成，这就退化为先来先服务算法了。如果q太小，每个任务需要更多的时间片才能运行结束，这就使任务之间的切换次数增加，从而增大了系统的管理开销，降低了CPU的使用效率。一般来说，q值选取在20ms~50ms比较合适。<br>4.优先级算法<br>优先级调度算法（priority）的基本思路是：给每个任务都设置一个优先级，然后在任务调度的时候，在所有处于就绪状态的任务中选择优先级最高的任务去运行。上文提到的短作业优先算法其实也是一种优先级算法，每个任务的优先级就是它的运行时间，运行时间越短，优先级越高。</p><h4 id="进程与线程">进程与线程</h4><p>简单的一句话：进程是资源分配的基本单位、线程是资源调度的基本单位。这句话看起来很简单，但是核心却不仅仅如此。</p><h4 id="进程">进程</h4><h5 id="进程间通信方式">进程间通信方式</h5><ul><li>管道（pipe）,流管道(s_pipe)和有名管道（FIFO）<br>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。<br>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。</li><li>信号（signal）<br>信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</li><li>消息队列消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享内存共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li><li>信号量信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li></ul><h3 id="linux-的启动流程">Linux 的启动流程</h3><p>BIOS-&gt;主引导记录-&gt;操作系统-&gt;<strong>加载内核(/boot)</strong>:载入内核文件-&gt;<strong>启动初始化进程</strong>：运行第一个程序 /sbin/init，初始化系统环境。-&gt;<strong>确定运行级别</strong>:运行这些开机启动的程序。-&gt;<strong>加载开机启动程序</strong>-&gt;<strong>用户登录</strong>-&gt;<strong>进入 login shell</strong>-&gt;打开 non-login shell</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180622222745.png" /> </div><br>[Linux 的启动流程-阮一峰](https://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html)]]></content>
      
      
      <categories>
          
          <category> 面试经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 面试 </tag>
            
            <tag> 工作 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结-C++</title>
      <link href="/2018/06/24/interview/interview_cpp/"/>
      <url>/2018/06/24/interview/interview_cpp/</url>
      
        <content type="html"><![CDATA[<h2 id="编程基础">编程基础</h2><h3 id="c-内存管理方式">C++ 内存管理方式</h3><p>堆、栈、自由存储区、全局/静态存储区、常量存储区自由存储区存储malloc申请的内存<br>(1)从静态存储区域分配 。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如 全局变量， static 变量 。(2)在栈上创建 。在执行函数时， 函数内局部变量的存储单元都可以在栈上创建 ，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。(3)从堆上分配 ， 亦称动态内存分配 。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</p><h3 id="extern-c-和extern的作用">extern &quot;C&quot;和extern的作用</h3><p>extern &quot;C&quot;的主要作用就是为了能够正确实现C<ins>代码调用其他C语言代码。加上extern &quot;C&quot;后，会指示编译器这部分代码按C语言的进行编译，而不是C</ins>的。<br>(http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)</p><h3 id="为什么需要内存对齐">为什么需要内存对齐</h3><h3 id="c-内存问题">c++内存问题</h3><ol><li><p>缓冲区溢出（buffer overrun）。<br>用 std::vector<char>/std::string 或自己编写 Buffer class 来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。</p></li><li><p>空悬指针/野指针。<br>用 shared_ptr/weak_ptr</p></li><li><p>重复释放（double delete）。</p></li><li><p>内存泄漏（memory leak）。</p></li><li><p>不配对的 new[]/delete。<br>把 new[] 统统替换为 std::vector/scoped_array。</p></li><li><p>内存碎片（memory fragmentation）。</p></li></ol><h3 id="static关键字">static关键字</h3><h4 id="作用：">作用：</h4><ul><li>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值</li><li>在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问</li><li>在模块内的 static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内。起到了隐藏的作用</li><li>在类的 static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝</li><li>在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量</li></ul><h4 id="静态全局变量不要放在头文件里">静态全局变量不要放在头文件里</h4><p>(https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)  第6条</p><p><a href="https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html" target="_blank" rel="noopener">C++中的static关键字的总结</a></p><h3 id="几个复制的声明">几个复制的声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void * ( * (*fp1)(int))[10];  &#x2F;&#x2F;fp1是一个指针，指向一个函数，函数参数为int，函数返回参数是一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个void* 指针。</span><br><span class="line">float (*(* fp2)(int,int,int))(int);  &#x2F;&#x2F;fp2是一个指针，指向一个函数，函数参数为3个int，函数的返回值是一个指针，指针指向一个函数，函数的参数是1个int，返回float。 </span><br><span class="line">int (* ( * fp3)())[10]();  &#x2F;&#x2F;fp3是一个指针，指向一个函数，函数没有参数，函数返回值为一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个函数指针，函数没有参数，返回int。</span><br></pre></td></tr></table></figure><h3 id="strlen-和sizeof">strlen()和sizeof()</h3><p>区别与联系：</p><ol><li>种类：<br>sizeof是运算符，并不是函数，结果在编译时得到,因此sizeof不能用来返回动态分配的内存空间的大小。用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系；strlen是字符处理的库<strong>函数</strong>,当数组名作为参数传入时，实际上数组就退化成指针了。。</li><li>输入参数：<br>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化），还可以用函数做参数；strlen的参数只能是字符指针且结尾是’\0’的字符串。</li><li>功能：<br>sizeof():获得保证能容纳实现所建立的最大对象的字节大小<br>strlen():返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。</li><li>返回：<br>当适用于一个结构类型时或变量， sizeof 返回实际的大小，当适用于一静态地空间数组， sizeof 归还全部数组的尺寸。sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸</li></ol><p>https://blog.csdn.net/21aspnet/article/details/1539951</p><h3 id="变量声明和定义">变量声明和定义</h3><ul><li><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p></li><li><p>相同变量可以再多处声明（外部变量extern），但只能在一处定义。</p></li></ul><h3 id="结构体和union">结构体和union</h3><p>1.在存储多个成员信息时，编译器会自动给struct第个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。</p><p>2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。</p><p>3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。</p><p><strong>未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。</strong><br>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct sTest</span><br><span class="line">&#123;</span><br><span class="line">int a;  &#x2F;&#x2F;sizeof(int) &#x3D; 4</span><br><span class="line">char b;  &#x2F;&#x2F;sizeof(char) &#x3D; 1</span><br><span class="line">short c； &#x2F;&#x2F;sizeof(short) &#x3D; 2       </span><br><span class="line">&#125;x;  #最终实际占用不止4+1+2，因为要考虑内存对齐的问题</span><br><span class="line"></span><br><span class="line">union uTest</span><br><span class="line">&#123;</span><br><span class="line">int a;   &#x2F;&#x2F;sizeof(int) &#x3D; 4</span><br><span class="line">double b;  &#x2F;&#x2F;sizeof(double) &#x3D; 8</span><br><span class="line">char c;  &#x2F;&#x2F;sizeof(char) &#x3D; 1</span><br><span class="line">&#125;x;   #分配的内存 size 就是8 byte</span><br></pre></td></tr></table></figure><p><strong>pragma pack () 取消指定对齐，恢复缺省对齐</strong></p><h3 id="static">static</h3><h3 id="malloc-new和free-delete">malloc/new和free/delete</h3><ul><li><p>malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。</p></li><li><p>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</p></li><li><p>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</p></li><li><p>free和delete对应。当delete一个对象数组时，delete只删除了一个，需要使用delete[]</p></li></ul><h3 id="const">const</h3><h4 id="宏定义和const函数的区别">宏定义和const函数的区别</h4><ul><li>宏在编译时完成替换，直接进行替换，执行起来更快，但是可能会存在一些风险；函数调用在运行时需要跳转到具体调用函数。如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define area(x) x*x</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int y&#x3D;area(2+2);</span><br><span class="line">std::cout&lt;&lt;y&lt;&lt;std::endl;   # 输出为8&#x3D;2+2*2+2，而不是以为的16</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。</p></li><li><p>宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</p></li><li><p>一般可以对const常量进行调试，但不能对宏常量进行调试。</p></li><li><p>宏函数不要在最后加分号。</p></li></ul><p>总之，一般尽量用const比较好。</p><h4 id="const的分辨-顶层const和底层const">const的分辨(顶层const和底层const)</h4><p>一般来说，const的分辨可以直接通过看const的最左侧，如果是指针，则指针是const，若为类型，则变量为const。当const在最左侧时，看const右侧。</p><ul><li>常量指针和指针常量： 常量指针是一个指针，读成常量的指针，指向一个只读变量。如<code>int const *p</code>或<code>const int *p</code>。<br>指针常量是一个常量，指针的值可以改变。如<code>int *const p</code>。</li></ul><h3 id="指针和引用">指针和引用</h3><h4 id="区别">区别</h4><ol><li>指针是具体的变量，需要占存储空间。引用只是别名，不占用具体存储空间。这是最基本的一点，其他的特点也就可想而知了。</li><li>指针可以先声明，但是引用声明的时候就必须初始化，不存在空的引用很容易理解。</li><li>指针变量可以改变所指的对象。但是引用一旦声明了就不能再改变引用的对象了。</li></ol><h4 id="引用相关问题">引用相关问题</h4><ol><li>引用是某个变量的别名，因此定义的时候必须初始化，也不能把该引用再改成其他变量的别名。</li><li>声明一个引用并没有定义新变量，引用本身不是一种数据类型。也不占用存储空间。</li><li><s>不能建立数组的引用</s>。其实这句话的意思是：不能建立引用的数组，例如：int &amp; ref[3] = { 2, 3, 5}; 但是可以建立数组的引用:例如：int arr[3]; int (&amp;tef)[3] = arr;<br>原因是：引用时不占空间的，声明引用数组没法分配空间。见<a href="https://blog.csdn.net/tkp2014/article/details/48858377" target="_blank" rel="noopener">为什么不能建立引用数组</a></li><li>将引用作为函数的参数时，可以避免对变量或者对象的复制，因此不会调用对象的拷贝构造函数。当不希望传入的引用参数不被改变时，使用const引用。</li><li>函数中不能返回局部变量的引用，不能返回函数内部ne分配的内存的引用。（虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄露。）。 可以返回类成员的引用，但最好是const。</li><li>当类中存在const或者引用时成员变量时，必须使用初始化表。</li></ol><h4 id="指针相关问题">指针相关问题</h4><h5 id="指针的相关判断">指针的相关判断</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    int *p[10]</span><br><span class="line">    int (*p)[10]</span><br><span class="line">    int *p(int)</span><br><span class="line">    int (*p)(int)</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">  </span><br><span class="line">- int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。  </span><br><span class="line">    </span><br><span class="line">- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</span><br><span class="line">    </span><br><span class="line">- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</span><br><span class="line">    </span><br><span class="line">- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 指针与数组名</span><br><span class="line">- 二者均可通过增减偏移量来访问数组中的元素。</span><br><span class="line"></span><br><span class="line">- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</span><br><span class="line"></span><br><span class="line">- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</span><br><span class="line"></span><br><span class="line">##### 野指针</span><br><span class="line">空悬指针，不是指向null的指针，是指向垃圾内存的指针。  </span><br><span class="line">- 产生原因及解决办法：</span><br><span class="line">    - 指针变量未及时初始化 &#x3D;&gt; 定义指针变量及时初始化，要么置空。</span><br><span class="line">- 指针free或delete之后没有及时置空 &#x3D;&gt; 释放操作后立即置空。</span><br><span class="line">##### 指针和数组的区别</span><br><span class="line">数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。  </span><br><span class="line">1. 修改内容上的差别:指针可能指向一块内存，但是指向的常量却无法通过下标计算。</span><br></pre></td></tr></table></figure><p>char a[] = “hello”;a[0] = ‘X’;char *p = “world”; // 注意p 指向常量字符串，指向的是常量区p[0] = ‘X’; // 编译器不能发现该错误，运行时错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++&#x2F;C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</span><br></pre></td></tr></table></figure><p>char a[] = “hello world”;char *p = a;cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节cout&lt;&lt; sizeof§ &lt;&lt; endl; // 4 字节//计算数组和指针的内存容量void Func(char a[100]){cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### volatile</span><br><span class="line">- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。</span><br><span class="line">    </span><br><span class="line">- 多线程中被几个任务共享的变量需要定义为volatile类型。  </span><br><span class="line"></span><br><span class="line">### 堆栈</span><br><span class="line">#### 区别</span><br><span class="line">1. 申请方式不同：栈由系统自动分配，堆由程序员手动分配  </span><br><span class="line">2. 申请大小不同：栈顶和栈底都是设定好的，大小固定，可以通过&#96;ulimit -a&#96;查看，通过&#96;ulimit -s&#96;修改。堆向高地址扩展，是不连续的内存区域，大小可以调整。    </span><br><span class="line">3. 申请效率不同：栈由系统分配，速度快，没有碎片。堆速度慢，且有碎片。</span><br><span class="line"></span><br><span class="line">#### 内存分配</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;nkguohao&#x2F;article&#x2F;details&#x2F;8771867 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 面向对象</span><br><span class="line">### 面向对象三大特性</span><br><span class="line">- 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。</span><br><span class="line">    </span><br><span class="line">- 继承性：让某种类型对象获得另一个类型对象的属性和方法。</span><br><span class="line"></span><br><span class="line">- 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。</span><br><span class="line"></span><br><span class="line">### 构造函数和析构函数</span><br><span class="line">1.构造函数、析构函数中都不要调用虚函数  </span><br><span class="line">   </span><br><span class="line">我们知道，构造函数一般不能是虚函数，而析构函数一般必须是虚函数。原理也很清晰，构造函数，由于构造顺序是从基类到派生类，所以调用虚函数，可能派生类还没有构造出来，没有意义。而对于析构函数来说，又必须是虚函数，因为只有先从子类对象进行销毁，才能保证资源不泄露。    </span><br><span class="line">   </span><br><span class="line">在构造函数和析构函数中都不要调用虚函数也是这个道理。  </span><br><span class="line"></span><br><span class="line">### 成员变量和成员函数</span><br><span class="line">1.静态成员变量是需要初始化  </span><br><span class="line">其实这样说的是有点问题的，应该是静态成员是需要定义的。</span><br><span class="line">因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。    </span><br><span class="line">《c++primer》里面说在类外定义和初始化是保证static成员变量只被定义一次的好方法。 但static const int就可以在类里面初始化</span><br></pre></td></tr></table></figure><p>class Base{public:static int class_p;   //只有声明，而没有定义，不能直接调用};int Base::class_p=3;   //进行定义  https://blog.csdn.net/qq_16209077/article/details/52602601</p><pre><code>### 拷贝构造函数调用情况：  1. 用一个类的对象去初始化该类的另一个对象时。  2. 函数形参是类的对象时，调用函数将函数的形参和实参结合的时候。   3. 函数返回值是类的对象，函数调用完成返回时。     #### 重写拷贝构造函数一般会默认生成类的拷贝构造函数，但是当涉及动态分配存储空间时，默认的拷贝构造函数就会有问题，因此需要重写拷贝构造函数，并且采用深拷贝。  浅拷贝和深拷贝：### 多态多态：对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：  编译时多态：函数和运算符的重载。  运行时多态：继承和虚函数。  ### 友元特性：单向的，传递性，不能继承  ## 标准模板库## 编译和调试### 编译过程预处理-&gt;编译-&gt;汇编-&gt;链接- 预处理：展开宏定义；处理条件编译；处理#include指令；去掉注释；添加行号和文件名标识；保留所有#pragma编译器指令。  - 编译：词法分析；语法分析；语义分析；中间语言生成；目标代码生成与优化。  - 链接：各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。### 静态库和动态库二者的不同点在于代码被载入的时刻不同。静态库和动态库的最大区别,静态情况下,把库直接加载到程序中,而动态库链接的时候,它只是保留接口,将动态库与程序代码独立,这样就可以提高代码的可复用度，和降低程序的耦合度。  - 静态库的代码在编译过程中已经被载入可执行程序,程序运行时将不再需要该静态库，因此可执行程序体积比较大。在Linux中以`.a`结尾  - 动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小,在程序运行时还需要动态库存在。不同的应用程序如果调用相同的库,那么在内存中只需要有一份该动态库(共享库)的实例。在Linux中以`.so`结尾  当静态库和动态库同名时， gcc命令将优先使用动态库.为了确保使用的是静态库, 编译时可以加上 -static 选项，因此多第三方程序为了确保在没有相应动态库时运行正常，喜欢在编译最后应用程序时加入-static  **优缺点**：  1.动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。     2.动态库更新很容易，当库发生变化时，接口没变只需要用新的动态库替换掉就可以。静态库需要重新编译。  3.静态库静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会高一些。  ## 安全相关### 类型安全类型安全很大程度上可以理解为内存安全。类型安全的代码不会试图去访问自己没有被授权的内存区域。  对于C语言来说，很多操作都不是类型安全的。例如打印的时候:`printf(&quot;%f\n&quot;,10)  //编译通过，没有报错，结果为0.000000`.  对于C++来说，有些操作也不是类型安全的，比如不同类型指针之间可以强制转换(reinterpret cast)    注：C#、Java是类型安全的  C++使用得当，可以远比C更有类型安全性。（1）操作符new返回的指针类型严格与对象匹配，而不是void*；  （2）C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；  （3）引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；  （4）一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；  （5）C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。  ### 线程安全如果代码在多线程运行和单线程运行具有相同的结果，那就是线程安全的。  线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。  ### 异常安全 当异常抛出时，带有异常安全的函数会：（1）不泄露任何资源一般采用RAII技术，即以对象管(智能指针)理资源来防止资源泄漏。(2)不允许数据被破坏（例如正常指针变野指针）(3)少些try catch，因为大量的try catch会影响代码逻辑。导致代码丑陋混乱不优雅  解决异常安全的问题：1.多使用RAII，使用智能指针来管理内存。由于unwind机制的保证，当异常发生时，函数栈内已构造的局部对象的析构函数会被一一调用，在析构函数内释放资源，也就杜绝了内存泄漏的问题。   2.做好程序设计。特别是异常发生时的回滚机制的正确使用，copy-and-swap是有效的方法。  3.注意需要异常保证的函数内部的调用函数，异常安全等级是以有最低等级异常保证的函数确定的。一个系统即使只有一个函数不是异常安全的，那么系统作为一个整体就不是异常安全的。  4.流对象，资源对象，new对象，不应该直接作为参数，一旦抛出异常，就可能会导致严重的问题，函数也许会被错误的执行，资源也许会泄漏。  5.减少全局变量的使用。   6.如果不知道如何处理异常，就不要捕获异常，直接终止比吞掉异常不处理要好。  7.保证构造、析构、swap不会失败     [类型安全 与 线程安全 、异常安全、事务安全](https://blog.csdn.net/lingling_1/article/details/46924991)## 其他### 为什么说栈比堆要快1. 分配和释放：堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，具体可以看看MALLOC和FREE的源代码，他们做了很多额外的工作，而栈却不需要这些。  2. 访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。  3. 堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。### c++协程的实现[ucontext-人人都可以实现的简单协程库](https://blog.csdn.net/qq910894904/article/details/41911175)## 设计模式### 单例模式### 工厂方法### 观察者模式### 怎么判断两个结构体变量是否相等？1，元素的话，一个个比咯：if(p1-&gt;age==p2-&gt;age)...有一个元素不等，即是两个实例不相等！没什么效率高的方法吧！2，指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真！3，重载==运算符；### ### Refeence:[常见C++面试题](http://bestmind.space/posts/%E5%B8%B8%E8%A7%81C-%E9%9D%A2%E8%AF%95%E9%A2%98/)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面试 </tag>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-刷题总结</title>
      <link href="/2018/06/20/Exercise/re_sword_to_offer/"/>
      <url>/2018/06/20/Exercise/re_sword_to_offer/</url>
      
        <content type="html"><![CDATA[<h2 id="01-二维数组中的查找">01.二维数组中的查找</h2><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>分析：由于每一行都有递增的特性，我们可以采用类似二分搜索的方法。将数组分成行列来进行搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        if(0&#x3D;&#x3D;array.size())</span><br><span class="line">            return false;</span><br><span class="line">        int raw&#x3D;array.size();</span><br><span class="line">        int col&#x3D;array[0].size();</span><br><span class="line">        for(int i&#x3D;0;i&lt;raw;++i)&#123;</span><br><span class="line">            if(array[i][col-1]&gt;&#x3D;target)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;col;++j)&#123;</span><br><span class="line">                    if(array[i][j]&#x3D;&#x3D;target)</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="02-替换空格">02.替换空格</h2><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>考虑到是在原字符串上操作，如果遇到一个空格就替换的话，需要把后面的都要后移两位，这个复杂度就大了，所以可以先遍历第一遍，找到空格的总数，之后就可以计算替换后的字符串长度。再经过第二遍遍历，从后往前开始替换，这样就不用移动了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">         if(length&lt;&#x3D;0)</span><br><span class="line">             return;</span><br><span class="line">        int origin_length&#x3D;0,new_length&#x3D;0,space_num&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;str[i]!&#x3D;&#39;\0&#39;;++i)&#123;</span><br><span class="line">            origin_length++;</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">                space_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        new_length&#x3D;origin_length+2*space_num;</span><br><span class="line">        if(new_length&gt;length)</span><br><span class="line">            return;</span><br><span class="line">        str[new_length]&#x3D;&#39;\0&#39;;</span><br><span class="line">        while(origin_length&gt;0)&#123;</span><br><span class="line">            --origin_length;</span><br><span class="line">            if(str[origin_length]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                str[--new_length]&#x3D;&#39;0&#39;;</span><br><span class="line">                str[--new_length]&#x3D;&#39;2&#39;;</span><br><span class="line">                str[--new_length]&#x3D;&#39;%&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                str[--new_length]&#x3D;str[origin_length];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="03-从尾到头打印链表">03.从尾到头打印链表</h2><blockquote><p>输入一个链表，从尾到头打印链表每个节点的值。</p></blockquote><p>分析：由于链表我们必须从头到尾遍历才能从链表尾开始，所以直接打印的话，需要先从前往后遍历一遍找到链表尾节点，再从后往前遍历打印。能够进行的改善是，通过增加O(N)的空间复杂度，第一次遍历的时候，将数据放在一个栈中，之后再从栈中把所有的数都弹出来就好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(!head)</span><br><span class="line">            return res;</span><br><span class="line">        stack&lt;int&gt; istack;</span><br><span class="line">        while(head)&#123;</span><br><span class="line">            istack.push(head-&gt;val);</span><br><span class="line">            head&#x3D;head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!istack.empty())&#123;</span><br><span class="line">            res.push_back(istack.top());</span><br><span class="line">            istack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="04-重建二叉树">04.重建二叉树</h2><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><p>分析：首先需要知道的是前序遍历和后续遍历的特点，程序中可以维护4个子数组，当进行递归调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.empty() || pre.size()!&#x3D;vin.size())</span><br><span class="line">            return nullptr;</span><br><span class="line">        vector&lt;int&gt; pre1,pre2,vin1,vin2;</span><br><span class="line">        TreeNode* root&#x3D;new TreeNode(pre[0]);</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(;i&lt;vin.size();++i)&#123;</span><br><span class="line">            if(pre[0]&#x3D;&#x3D;vin[i])</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;不需要判断i &#x3D;&#x3D;0 或者i&#x3D;&#x3D;vin.size()-1的情况</span><br><span class="line">        for(int j&#x3D;0;j&lt;i;++j)&#123;</span><br><span class="line">            pre1.push_back(pre[1+j]);</span><br><span class="line">            vin1.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;pre.size();++j)&#123;</span><br><span class="line">            pre2.push_back(pre[j]);</span><br><span class="line">            vin2.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left&#x3D;reConstructBinaryTree(pre1,vin1);</span><br><span class="line">        root-&gt;right&#x3D;reConstructBinaryTree(pre2,vin2);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过上述的方法有个问题，虽然看起来比较好理解，但是增加了空间复杂度，其实这里可以多加一个递归函数就好了，所以觉得还是需要重新写一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* recurse(vector&lt;int&gt;&amp; pre,int begin1,int end1,vector&lt;int &gt;&amp; vin,int begin2,int end2)&#123;</span><br><span class="line">        if(begin1&gt;end1 || begin2&gt;end2)  &#x2F;&#x2F;退出条件</span><br><span class="line">            return nullptr;</span><br><span class="line">        TreeNode* root&#x3D;new TreeNode(pre[begin1]);</span><br><span class="line">        for(int i&#x3D;begin2;i&lt;&#x3D;end2;++i)&#123;</span><br><span class="line">            if(pre[begin1]&#x3D;&#x3D;vin[i])&#123;</span><br><span class="line">                root-&gt;left&#x3D;recurse(pre,begin1+1,begin1+i-begin2,vin,begin2,i-1);  &#x2F;&#x2F;递归的重点，这个要考虑清楚</span><br><span class="line">                root-&gt;right&#x3D;recurse(pre,begin1+1+i-begin2,end1,vin,1+i,end2);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.empty() || pre.size()!&#x3D;vin.size())</span><br><span class="line">            return nullptr;</span><br><span class="line">        return recurse(pre,0,pre.size()-1,vin,0,vin.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="05-用两个栈实现队列">05.用两个栈实现队列</h2><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote><p>分析：由于栈是先进后出，队列是先进先出，于是可以想到，两个栈，必然能够实现一个队列。原理就是，当push的时候就往第一个栈push，pop的时候就从第二个栈pop，当第二个栈的数为空时，从第一个栈pop再push到第二个栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int top&#x3D;stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        return top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="06-旋转数组的最小数字">06.旋转数组的最小数字</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p>分析：对于排序的数组，即使被旋转过，也能想到的是，采用二分查找。不过可能会存在的问题的是：当整个数组的值都是<code>1 0 0 1 1</code>之类的时候，就会失效了，只是非递减，但是不一定递增。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(0&#x3D;&#x3D;rotateArray.size())&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int begin&#x3D;0,end&#x3D;rotateArray.size()-1;</span><br><span class="line">        while(begin&lt;end-1)&#123;</span><br><span class="line">            int mid&#x3D;begin+(end-begin)&#x2F;2;</span><br><span class="line">            if(rotateArray[begin]&lt;rotateArray[mid])</span><br><span class="line">                begin&#x3D;mid;</span><br><span class="line">            else if(rotateArray[begin]&gt;rotateArray[mid])</span><br><span class="line">                end&#x3D;mid;</span><br><span class="line">            else&#123;</span><br><span class="line">                int res&#x3D;begin;</span><br><span class="line">                for(size_t i&#x3D;1;i&lt;rotateArray.size();++i)&#123;</span><br><span class="line">                    res&#x3D;(res&lt;rotateArray[i]?res:rotateArray[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="07-斐波那契数列">07.斐波那契数列</h2><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p></blockquote><p>分析：斐波拉契数列原理很简单，不过按照原理写的显然复杂度过高了，这里我们可以采用变量存下之前计算过的数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)</span><br><span class="line">            return 1;</span><br><span class="line">        int first&#x3D;1,second&#x3D;1,res&#x3D;0;</span><br><span class="line">        while(--n&gt;1)&#123;</span><br><span class="line">            res&#x3D;first+second;</span><br><span class="line">            first&#x3D;second;</span><br><span class="line">            second&#x3D;res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="08-跳台阶">08.跳台阶</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>分析：原理同斐波拉契数列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number&lt;&#x3D;2)</span><br><span class="line">            return number;</span><br><span class="line">        int first&#x3D;1,second&#x3D;2,res&#x3D;0;</span><br><span class="line">        while(--number&gt;1)&#123;</span><br><span class="line">            res&#x3D;first+second;</span><br><span class="line">            first&#x3D;second;</span><br><span class="line">            second&#x3D;res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="09-变态跳台阶">09.变态跳台阶</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f(n)&#x3D;f(1)+f(2)+...+f(n-1)</span><br><span class="line">f(n+1)&#x3D;f(1)+f(2)+...+f(n-1)+f(n)&#x3D;2f(n)</span><br><span class="line">&#x2F;&#x2F;代码如下：</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        if(number&lt;&#x3D;2)</span><br><span class="line">            return number;</span><br><span class="line">        int res&#x3D;2;</span><br><span class="line">        while(--number&gt;&#x3D;2)&#123;</span><br><span class="line">            res*&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-矩形覆盖-todo">10.矩形覆盖 /TODO:</h2><h2 id="11-二进制中1的个数">11.二进制中1的个数</h2><blockquote><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p></blockquote><p>分析：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int count&#x3D;0;</span><br><span class="line">         while(n)&#123;</span><br><span class="line">             count++;</span><br><span class="line">             n&#x3D;n&amp;(n-1);</span><br><span class="line">         &#125;</span><br><span class="line">         return count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="12-数值的整数次方">12.数值的整数次方</h2><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p></blockquote><p>分析：求一个数的次方，一个就是幂数是负数的处理，另一个就是，对幂的处理，连乘必然带来复杂度，可以想到的是2<sup>4可以表示为(2</sup>2)^2，想到这里，考虑的开水奇偶exponent的奇偶性了，奇数的时候直接乘以base，偶数的时候自乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        bool flag&#x3D;true;</span><br><span class="line">        if(exponent&lt;0)&#123;</span><br><span class="line">            flag&#x3D;false;</span><br><span class="line">            exponent*&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        double res&#x3D;1;</span><br><span class="line">        while(exponent)&#123;</span><br><span class="line">            if(exponent&amp;1)&#123;</span><br><span class="line">                res*&#x3D;base;</span><br><span class="line">                exponent--;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                exponent&#x3D;exponent&#x2F;2;</span><br><span class="line">                res*&#x3D;res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag?res:(1&#x2F;res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13-调整数组顺序使奇数位于偶数前面">13.调整数组顺序使奇数位于偶数前面</h2><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">if(array.empty())</span><br><span class="line">return;</span><br><span class="line">int begin&#x3D;0,end&#x3D;array.size();</span><br><span class="line">int even&#x3D;-1;</span><br><span class="line"></span><br><span class="line">while(begin&lt;end)&#123;</span><br><span class="line">while((array[begin]&amp;1) &amp;&amp; (begin&lt;end))&#123;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line">even&#x3D;begin;</span><br><span class="line">while((!(array[begin]&amp;1)))&#123;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line">if(begin&gt;&#x3D;end)</span><br><span class="line">return;</span><br><span class="line">int temp&#x3D;array[begin];</span><br><span class="line">while(even&lt;begin)&#123;</span><br><span class="line">array[begin]&#x3D;array[begin-1];</span><br><span class="line">begin--;</span><br><span class="line">&#125;</span><br><span class="line">array[even]&#x3D;temp;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14-链表中倒数第k个结点">14.链表中倒数第k个结点</h2><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><p>分析：采用两个指针一起移动是一个很好的办法，不过需要考虑是否越界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        ListNode* p1&#x3D;pListHead;</span><br><span class="line">        for(int i&#x3D;0;i&lt;k;++i)&#123;</span><br><span class="line">            if(!p1)</span><br><span class="line">               return nullptr;</span><br><span class="line">            p1&#x3D;p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p1)&#123;</span><br><span class="line">            p1&#x3D;p1-&gt;next;</span><br><span class="line">            pListHead&#x3D;pListHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-反转链表">15.反转链表</h2><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><p>分析：注意断开链表重连的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">&#x2F;&#x2F;最开始的一版代码，采用的是栈，看起来比较复杂。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        if((!pHead)||(!pHead-&gt;next))</span><br><span class="line">            return pHead;</span><br><span class="line">        stack&lt;ListNode*&gt; list_stack;</span><br><span class="line">        while(pHead-&gt;next)&#123;</span><br><span class="line">            list_stack.push(pHead);</span><br><span class="line">            pHead&#x3D;pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead&#x3D;pHead;</span><br><span class="line">        while(!list_stack.empty())&#123;</span><br><span class="line">            pHead-&gt;next&#x3D;list_stack.top();</span><br><span class="line">            pHead&#x3D;pHead-&gt;next;</span><br><span class="line">            list_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        pHead-&gt;next&#x3D;nullptr;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;采用在链表中的穿针引线。涉及到链表的断开与重连，维护三个指针，分别为：pre,cur,next</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        ListNode* pre&#x3D;nullptr;</span><br><span class="line">        ListNode* cur&#x3D;pHead;</span><br><span class="line">        while(cur)&#123;</span><br><span class="line">            ListNode* next&#x3D;cur-&gt;next;</span><br><span class="line">            cur-&gt;next&#x3D;pre;</span><br><span class="line">            pre&#x3D;cur;</span><br><span class="line">            cur&#x3D;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;采用递归实现</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        if(!pHead||!pHead-&gt;next)</span><br><span class="line">            return pHead;</span><br><span class="line">        ListNode* rHead&#x3D;ReverseList(pHead-&gt;next);</span><br><span class="line">        &#x2F;&#x2F; head-&gt;next此刻指向head后面的链表的尾节点</span><br><span class="line">        &#x2F;&#x2F; head-&gt;next-&gt;next &#x3D; head把head节点放在了尾部</span><br><span class="line">        pHead-&gt;next-&gt;next&#x3D;pHead;</span><br><span class="line">        pHead-&gt;next&#x3D;nullptr;</span><br><span class="line">        </span><br><span class="line">        return rHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="16-合并两个排序的链表">16.合并两个排序的链表</h2><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;当一个链表为空时，直接返回另一个链表</span><br><span class="line">        if(!pHead1)</span><br><span class="line">            return pHead2;</span><br><span class="line">        if(!pHead2)</span><br><span class="line">            return pHead1;</span><br><span class="line">        ListNode* vHead&#x3D;new ListNode(0);  &#x2F;&#x2F;设立虚拟的头节点</span><br><span class="line">        ListNode* vHeadHead&#x3D;vHead;</span><br><span class="line">        while(pHead1 &amp;&amp; pHead2)&#123;  &#x2F;&#x2F;一旦有一个链表为空，就退出循环</span><br><span class="line">            if(pHead1-&gt;val&lt;&#x3D;pHead2-&gt;val)&#123;</span><br><span class="line">                vHead-&gt;next&#x3D;pHead1;</span><br><span class="line">                pHead1&#x3D;pHead1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                vHead-&gt;next&#x3D;pHead2;</span><br><span class="line">                pHead2&#x3D;pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            vHead&#x3D;vHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;另一个链表不为空时，加在后面</span><br><span class="line">        if(!pHead1)</span><br><span class="line">            vHead-&gt;next&#x3D;pHead2;</span><br><span class="line">        else</span><br><span class="line">            vHead-&gt;next&#x3D;pHead1;</span><br><span class="line">        return vHeadHead-&gt;next;  &#x2F;&#x2F;返回虚拟头节点的下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;采用递归实现</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pHead1)</span><br><span class="line">            return pHead2;</span><br><span class="line">        if(!pHead2)</span><br><span class="line">            return pHead1;</span><br><span class="line">        ListNode* vHead&#x3D;nullptr;</span><br><span class="line">        if(pHead1-&gt;val&lt;&#x3D;pHead2-&gt;val)&#123;</span><br><span class="line">            vHead&#x3D;pHead1;</span><br><span class="line">            vHead-&gt;next&#x3D;Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            vHead&#x3D;pHead2;</span><br><span class="line">            vHead-&gt;next&#x3D;Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        return vHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-树的子结构">17.树的子结构</h2><blockquote><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(TreeNode* pRoot1,TreeNode* pRoot2)&#123;</span><br><span class="line">        if(!pRoot2)    &#x2F;&#x2F;注意不能先判断pRoot1再判断pRoot2，因为，只要pRoot2为空的时候，都是true了，而不管这时候pRoot1是不是为空。</span><br><span class="line">            return true;</span><br><span class="line">        if(!pRoot1)</span><br><span class="line">            return false;</span><br><span class="line">        if(pRoot1-&gt;val!&#x3D;pRoot2-&gt;val)</span><br><span class="line">            return false;</span><br><span class="line">        return dfs(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;dfs(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if((!pRoot2)||(!pRoot1))</span><br><span class="line">            return false;</span><br><span class="line">        return (dfs(pRoot1,pRoot2)||HasSubtree(pRoot1-&gt;left,pRoot2)||HasSubtree(pRoot1-&gt;right,pRoot2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="18-二叉树的镜像">18.二叉树的镜像</h2><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p></blockquote><p>分析：简单的递归解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(pRoot&#x3D;&#x3D;nullptr)</span><br><span class="line">            return;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">        swap(pRoot-&gt;left,pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-顺时针打印矩阵">19.顺时针打印矩阵</h2><h2 id="20-包含min函数的栈">20.包含min函数的栈</h2><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p></blockquote><p>分析：维护两个栈，其中一个是压入数据的栈，另一个是min栈，存储当前数据的最小的值。只有压入的数小于min栈的时候，才压入新值，否则继续压入最小值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        stk.push(value);</span><br><span class="line">        if(!stk_min.empty())&#123;</span><br><span class="line">            if(value&lt;stk_min.top())</span><br><span class="line">                stk_min.push(value);</span><br><span class="line">            else&#123;</span><br><span class="line">                int temp&#x3D;stk_min.top();</span><br><span class="line">                stk_min.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            stk_min.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        stk_min.pop();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return stk_min.top();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    stack&lt;int&gt; stk_min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="21-栈的压入-弹出序列">21.栈的压入、弹出序列</h2><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p></blockquote><p>思路：判断是否是压入弹出序列，可以直接使用一个栈进行压入，然后在压入的过程中判断是否跟弹出序列的值相同，是的话则先弹出，最后判断栈是否为空即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        stack&lt;int&gt; istack;</span><br><span class="line">        int i&#x3D;0,j&#x3D;0;</span><br><span class="line">        while(i&lt;pushV.size())&#123;</span><br><span class="line">        istack.push(pushV[i++]);</span><br><span class="line">        while(j&lt;popV.size() &amp;&amp; istack.top()&#x3D;&#x3D;popV[j])&#123;</span><br><span class="line">        istack.pop();</span><br><span class="line">        ++j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return istack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="22-从上往下打印二叉树">22.从上往下打印二叉树</h2><blockquote><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p></blockquote><p>分析：层序遍历，需要每遍历一个节点，就将他们的左右节点保存起来，当前层遍历完后，再顺序遍历他们的孩子节点。于是很容易想到先入先出的结构，队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(root&#x3D;&#x3D;nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; ique;</span><br><span class="line">        ique.push(root);</span><br><span class="line">        while(!ique.empty())&#123;</span><br><span class="line">            TreeNode* temp&#x3D;ique.front();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">            ique.pop();</span><br><span class="line">            </span><br><span class="line">            if(temp-&gt;left)</span><br><span class="line">                ique.push(temp-&gt;left);</span><br><span class="line">            if(temp-&gt;right)</span><br><span class="line">                ique.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="23-二叉搜索树的后序遍历序列">23.二叉搜索树的后序遍历序列</h2><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">return Verify(sequence,0,sequence.size());</span><br><span class="line">    &#125;</span><br><span class="line">    bool Verify(vector&lt;int&gt; sequence,int start,int end)&#123;</span><br><span class="line">        int i&#x3D;start;</span><br><span class="line">        if(start&#x3D;&#x3D;end)</span><br><span class="line">            return false;</span><br><span class="line">for(;i&lt;end-1;++i)&#123;</span><br><span class="line">if(sequence[i]&gt;sequence[end-1])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        for(int j&#x3D;i;j!&#x3D;end;++j)&#123;</span><br><span class="line">            if(sequence[j]&lt;sequence[end-1])&#123;</span><br><span class="line">                 return false;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        bool left&#x3D;true;</span><br><span class="line">        if(i&gt;start)</span><br><span class="line">            left&#x3D;Verify(sequence,start,i);</span><br><span class="line">        </span><br><span class="line">        bool right&#x3D;true;</span><br><span class="line">        if(i&lt;end-1)</span><br><span class="line">            right&#x3D;Verify(sequence,i,end-1);</span><br><span class="line">        return left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="24-二叉树中和为某一值的路径">24.二叉树中和为某一值的路径</h2><blockquote><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return res;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        if(expectNumber-root-&gt;val&#x3D;&#x3D;0 &amp;&amp; root-&gt;left&#x3D;&#x3D;nullptr &amp;&amp; root-&gt;right&#x3D;&#x3D;nullptr)</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        if(!temp.empty())</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="25-复杂链表的复制">25.复杂链表的复制</h2><p>代码问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        while(pHead-&gt;next)&#123;</span><br><span class="line">&#x2F;&#x2F;        cout&lt;&lt;pHead-&gt;label&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;            RandomListNode* pTemp&#x3D;pHead;   &#x2F;&#x2F;傻了吧</span><br><span class="line">            RandomListNode* pTemp&#x3D;new RandomListNode(pHead-&gt;label);  </span><br><span class="line">            pTemp-&gt;next&#x3D;pHead-&gt;next;</span><br><span class="line">            cout&lt;&lt;pTemp-&gt;next-&gt;label&lt;&lt;endl;</span><br><span class="line">            pHead-&gt;next&#x3D;pTemp;</span><br><span class="line">            pHead&#x3D;pTemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">                &#x2F;&#x2F;拆分</span><br><span class="line">        pNode&#x3D;pHead;</span><br><span class="line">RandomListNode* newHead&#x3D;pHead-&gt;next;</span><br><span class="line">        RandomListNode* pTemp&#x3D;pNode-&gt;next;</span><br><span class="line">while(pNode)&#123;</span><br><span class="line">pNode-&gt;next&#x3D;pTemp-&gt;next;</span><br><span class="line">pNode&#x3D;pNode-&gt;next;</span><br><span class="line">pTemp-&gt;next&#x3D;pNode?pNode-&gt;next:NULL;</span><br><span class="line">&#x2F;&#x2F;pTemp-&gt;next&#x3D;pNode-&gt;next;</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;&quot;pTemp: &quot;&lt;&lt;pTemp-&gt;label&lt;&lt;endl;</span><br><span class="line">pTemp&#x3D;pTemp-&gt;next;</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;&quot;text&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">    if(!pHead)</span><br><span class="line">    return pHead;</span><br><span class="line">    RandomListNode* pNode&#x3D;pHead;</span><br><span class="line"></span><br><span class="line">    while(pNode)&#123;</span><br><span class="line">    RandomListNode* pClone&#x3D;new RandomListNode(pNode-&gt;label);</span><br><span class="line">    pClone-&gt;next&#x3D;pNode-&gt;next;</span><br><span class="line">    pNode-&gt;next&#x3D;pClone;</span><br><span class="line">    pNode&#x3D;pClone-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNode&#x3D;pHead;</span><br><span class="line">while(pNode)&#123;</span><br><span class="line">RandomListNode* pClone&#x3D;pNode-&gt;next;</span><br><span class="line">if(pNode-&gt;random)</span><br><span class="line">pClone-&gt;random&#x3D;pNode-&gt;random-&gt;next;</span><br><span class="line">pNode&#x3D;pClone-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pNode&#x3D;pHead;</span><br><span class="line">RandomListNode* newHead&#x3D;pNode-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(pNode-&gt;next)&#123;</span><br><span class="line">RandomListNode* pTemp&#x3D;pNode-&gt;next;</span><br><span class="line">pNode-&gt;next&#x3D;pTemp-&gt;next;</span><br><span class="line">pNode&#x3D;pTemp;</span><br><span class="line">&#x2F;&#x2F;pNode&#x3D;pNode-&gt;next;                  &#x2F;&#x2F;这种不行，搞得我折腾了很久</span><br><span class="line">&#x2F;&#x2F;pTemp-&gt;next&#x3D;pNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26-二叉搜索树与双向链表">26.二叉搜索树与双向链表</h2><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。TODO:</p></blockquote><h2 id="27-字符串的排列">27.字符串的排列</h2><h2 id="28-数组中出现次数超过一半的数字">28.数组中出现次数超过一半的数字</h2><p>解决一个问题，最终输出的判断，是1，还是0。如果大于1的话，万一最后只剩下了一个呢。所以还需要再判断最后剩下的结果是不是符合条件的，即是大于一般数目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        if(numbers.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        int count&#x3D;1;</span><br><span class="line">        int num&#x3D;numbers[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;numbers.size();++i)&#123;</span><br><span class="line">            if(numbers[i]&#x3D;&#x3D;num)</span><br><span class="line">                count++;</span><br><span class="line">            else&#123;</span><br><span class="line">                if((--count)&lt;&#x3D;0)&#123;</span><br><span class="line">                    num&#x3D;numbers[i];</span><br><span class="line">                    count&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断结果是否符合条件</span><br><span class="line">        count&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;numbers.size();++i)&#123;</span><br><span class="line">            if(num&#x3D;&#x3D;numbers[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count*2&gt;numbers.size()?num:0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="29-最小的k个数">29.最小的K个数</h2><p>存在的问题，写程序的时候越界，没有判断好边界条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; min_stack;</span><br><span class="line">        if(input.empty()||(k&lt;&#x3D;0)||(k&gt;input.size()))  &#x2F;&#x2F;边界条件的判断</span><br><span class="line">            return min_stack;</span><br><span class="line">        for(int i&#x3D;0;i&lt;input.size();++i)&#123;</span><br><span class="line">            sort(min_stack.begin(),min_stack.end());</span><br><span class="line">            if(min_stack.size()&lt;k)&#123;</span><br><span class="line">                min_stack.push_back(input[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">            &#x2F;&#x2F;cout&lt;&lt;&quot;min_stack[min_stack.size()-1]: &quot;&lt;&lt;min_stack[min_stack.size()-1]&lt;&lt;endl;</span><br><span class="line">                if(input[i]&lt;min_stack[min_stack.size()-1])&#123;</span><br><span class="line">                    min_stack.pop_back();</span><br><span class="line">                    min_stack.push_back(input[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min_stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="30-连续子数组的最大和">30.连续子数组的最大和</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">    int  res&#x3D;array[0];</span><br><span class="line">    int cur&#x3D;array[0];</span><br><span class="line">    for(int i&#x3D;1;i&lt;array.size();++i)&#123;</span><br><span class="line">    cur+&#x3D;array[i];</span><br><span class="line">    if(cur&lt;array[i])</span><br><span class="line">    cur&#x3D;array[i];</span><br><span class="line">    res&#x3D;(res&gt;cur?res:cur);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="31-整数中1出现的次数-从1到n整数中1出现的次数">31.整数中1出现的次数（从1到n整数中1出现的次数）</h2><h2 id="32-把数组排成最小的数">32.把数组排成最小的数</h2><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    static bool equal(int a,int b)&#123;</span><br><span class="line">        string str1&#x3D;to_string(a)+to_string(b);</span><br><span class="line">        string str2&#x3D;to_string(b)+to_string(a);</span><br><span class="line">        return str1&lt;str2;</span><br><span class="line">    &#125;</span><br><span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        string result;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),equal);</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;0;i&lt;numbers.size();++i)&#123;</span><br><span class="line">            result+&#x3D;to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="33-丑数">33.丑数</h2><blockquote><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        if(index&lt;&#x3D;0)        </span><br><span class="line">            return 0;</span><br><span class="line">        vector&lt;int &gt; res(index);</span><br><span class="line">        res[0]&#x3D;1;</span><br><span class="line">        int x&#x3D;0,y&#x3D;0,z&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;index;++i)&#123;</span><br><span class="line">            res[i]&#x3D;min(2*res[x],min(3*res[y],5*res[z]));</span><br><span class="line">            if(res[i]&#x3D;&#x3D;2*res[x])</span><br><span class="line">                x++;</span><br><span class="line">            if(res[i]&#x3D;&#x3D;3*res[y])</span><br><span class="line">                y++;</span><br><span class="line">            if(res[i]&#x3D;&#x3D;5*res[z])</span><br><span class="line">                z++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[index-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34-第一个只出现一次的字符位置">34.第一个只出现一次的字符位置</h2><blockquote><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p></blockquote><p>一般对于这种字符的处理，因为字符一般都是不超过256的，所以尤其是计数之类的，我们可以首先考虑数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    int FirstNotRepeatingChar(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str.size()&lt;&#x3D;0)</span><br><span class="line">            return -1;</span><br><span class="line">        int array[256]&#x3D;&#123;0&#125;;</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.size();++i)&#123;</span><br><span class="line">            array[int(str[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.size();++i)&#123;</span><br><span class="line">            if(array[int(str[i])]&#x3D;&#x3D;1)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return str.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="35-数组中的逆序对">35.数组中的逆序对</h2><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>//TODO:</p></blockquote><h2 id="36-两个链表的第一个公共结点">36.两个链表的第一个公共结点</h2><blockquote><p>输入两个链表，找出它们的第一个公共结点。</p></blockquote><p>需要知道的一个常识是，对于只有一个单链表，两个链表有公共节点，意味着从公共节点开始，之后两个链表都是公共的，因此他们有共同的终点。有了这个就好办了。可以将两个链表一直遍历，当遍历到链表尾的时候，就换另一个链表，当他们有公共节点时，在他们遍历到同一个节点时停止遍历，此节点即为第一个公共节点。</p><p><strong>对于这种将两个不同的长度，通过两个结合在一起，使两个长度相等的方法，其实我们用到过很多次。例如本题中的找公共节点，原因是两个链表长度不同。还有之前的一个判断两个string的大小，可以把他们放在一起，这样他们的长度就相同了，可以直接用string的方法进行比较。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">        ListNode* p1&#x3D;pHead1;</span><br><span class="line">        ListNode* p2&#x3D;pHead2;</span><br><span class="line">        while(p1!&#x3D;p2)&#123;</span><br><span class="line">            p1&#x3D;(p1&#x3D;&#x3D;nullptr?pHead2:p1-&gt;next);</span><br><span class="line">            p2&#x3D;(p2&#x3D;&#x3D;nullptr?pHead1:p2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37-数字在排序数组中出现的次数">37.数字在排序数组中出现的次数</h2><blockquote><p>统计一个数字在排序数组中出现的次数。</p></blockquote><p>显然很容易想到的是二分法,没有用函数的话，就存在一个找到没找到的问题，在这采用了一个返回值的处理。如果没找到，(end-begin-1)&lt;0，则可以判断是没有找到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">        if(data.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        int begin&#x3D;0,end&#x3D;data.size()-1;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        int mid;</span><br><span class="line">        while(begin&lt;&#x3D;end)&#123;</span><br><span class="line">        mid&#x3D;(begin+end)&#x2F;2;</span><br><span class="line">&#x2F;&#x2F;        cout&lt;&lt;&quot;dsdasads&quot;&lt;&lt;endl;</span><br><span class="line">if(data[mid]&#x3D;&#x3D;k)</span><br><span class="line">break;</span><br><span class="line">            else if(data[mid]&lt;k)&#123;</span><br><span class="line">                begin&#x3D;mid+1;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(data[mid]&gt;k)&#123;</span><br><span class="line">                end&#x3D;mid-1;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        begin&#x3D;end&#x3D;mid;</span><br><span class="line">        while(data[begin]&#x3D;&#x3D;k)</span><br><span class="line">            --begin;</span><br><span class="line">        while(data[end]&#x3D;&#x3D;k)</span><br><span class="line">            ++end;</span><br><span class="line">        count&#x3D;(end-begin-1)&gt;0?(end-begin-1):0;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="38-二叉树的深度">38.二叉树的深度</h2><h2 id="39-平衡二叉树">39.平衡二叉树</h2><h2 id="40-数组中只出现一次的数字">40.数组中只出现一次的数字</h2><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p></blockquote><p>数组中只出现一次的数字，当有一个的时候，很容易利用的特性是：全部异或，最后剩下的那个就是。原因是一个数跟自身异或，结果为0.那么出现有两个的时候呢。很容易想到的还是异或，最后的结果是两个只出现一次数字异或的结果，再进行分组解决。分组的依据是：因为有两个不同的数字只出现一次，所以整个数组异或的结果必然不为0，不为0就肯定有一位为1.按该位是否为1来进行划分即可。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span><br><span class="line">        if(data.empty())</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F;第一次遍历一遍，求两个数字最后的异或</span><br><span class="line">        int res&#x3D;data[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;data.size();++i)&#123;</span><br><span class="line">            res&#x3D;res^data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(res&#x3D;&#x3D;0)</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F;由于存在两个只出现一次的数字，所以res的值为这两个数字的异或，因此肯定不为0，肯定不为0意味着肯定有一位是1.找出这一位是1的</span><br><span class="line">        int index&#x3D;0;</span><br><span class="line">        while((res&amp;1)&#x3D;&#x3D;0)&#123;</span><br><span class="line">            res&#x3D;res&gt;&gt;1;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        *num1&#x3D;*num2&#x3D;0;        </span><br><span class="line">        &#x2F;&#x2F;根据index位为不为1，将数组分为两部分。</span><br><span class="line">        int x;</span><br><span class="line">        for(int i&#x3D;0;i&lt;data.size();++i)&#123;</span><br><span class="line">            if((x&#x3D;data[i]&gt;&gt;index)&amp;1)</span><br><span class="line">                *num1^&#x3D;data[i];</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                *num2^&#x3D;data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="41-和为s的连续正数序列">41.和为S的连续正数序列</h2><blockquote><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        &#x2F;&#x2F;边界条件的判断</span><br><span class="line">        if(sum&lt;0)</span><br><span class="line">            return res;</span><br><span class="line">            </span><br><span class="line">        int end&#x3D;0;</span><br><span class="line">        int tempSum&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;遍历数组</span><br><span class="line">        while(end&lt;sum)&#123;</span><br><span class="line">            if(tempSum&#x3D;&#x3D;sum)&#123;</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                end&#x3D;temp[0];  &#x2F;&#x2F;这一句其实很重要,因为要考虑将end从最开始重新开始计算，不然可能会有所遗漏,eg:9&#x3D;2+3+4&#x3D;4+5，其中4会重复</span><br><span class="line">                temp.erase(temp.begin(),temp.end());</span><br><span class="line">                tempSum&#x3D;0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tempSum&gt;sum)&#123;</span><br><span class="line">                tempSum-&#x3D;temp[0];</span><br><span class="line">                temp.erase(temp.begin());</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(++end);</span><br><span class="line">            tempSum+&#x3D;end;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="42-和为s的两个数字">42.和为S的两个数字</h2><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p></blockquote><p>输出乘积最小的，显然距离最大的乘积就越小，所以，可以直接前后两个指针搜索，搜到的第一个就是。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int &gt; res;</span><br><span class="line">        if(array.empty())</span><br><span class="line">            return res;</span><br><span class="line">            </span><br><span class="line">        int i&#x3D;0,j&#x3D;array.size()-1;</span><br><span class="line">        while(i&lt;j)&#123;</span><br><span class="line">            int temp&#x3D;array[i]+array[j];</span><br><span class="line">            if(temp&gt;sum)</span><br><span class="line">                --j;</span><br><span class="line">            if(temp&lt;sum)</span><br><span class="line">                ++i;</span><br><span class="line">            </span><br><span class="line">            if(temp&#x3D;&#x3D;sum) </span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(array[i]);</span><br><span class="line">                res.push_back(array[j]);</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="43-左旋转字符串">43.左旋转字符串</h2><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p></blockquote><p>由BA=(ATBT)T计算可得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次通过代码</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string LeftRotateString(string str, int n) &#123;</span><br><span class="line">        int len&#x3D;str.size();</span><br><span class="line">        if(n&gt;&#x3D;len)</span><br><span class="line">            return str;</span><br><span class="line">        int i&#x3D;0,j&#x3D;0;</span><br><span class="line">        for(i&#x3D;0,j&#x3D;n-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</span><br><span class="line">        for(i&#x3D;n,j&#x3D;len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</span><br><span class="line">        for(i&#x3D;0,j&#x3D;len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="44-翻转单词顺序列">44.翻转单词顺序列</h2><p>//TODO:</p><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以前买的</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void ReverseSentence(string &amp;str,int begin,int end)&#123;</span><br><span class="line">        while(begin&lt;end)&#123;</span><br><span class="line">            char tmp&#x3D;str[begin];</span><br><span class="line">            str[begin]&#x3D;str[end];</span><br><span class="line">            str[end]&#x3D;tmp;</span><br><span class="line">            begin++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ReverseSentence(string str) &#123;</span><br><span class="line">        if(str.size()&lt;&#x3D;1)</span><br><span class="line">            return str;</span><br><span class="line">      </span><br><span class="line">        int begin&#x3D;0;</span><br><span class="line">        int end&#x3D;0;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;这里需要注意，考虑只有一个单词的情况</span><br><span class="line">        while(end!&#x3D;str.size())&#123;</span><br><span class="line">            if(str[end]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                ReverseSentence(str,0,str.size()-1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(end&#x3D;&#x3D;str.size()-1)</span><br><span class="line">            return str;</span><br><span class="line">            else</span><br><span class="line">                ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        end&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;开始遍历，旋转每个单词</span><br><span class="line">        while(begin!&#x3D;str.size())&#123;</span><br><span class="line">            if(str[begin]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                ++end;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(str[end]&#x3D;&#x3D;&#39; &#39;||end&#x3D;&#x3D;str.size())&#123;</span><br><span class="line">                ReverseSentence(str,begin,--end);</span><br><span class="line">                begin&#x3D;++end;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="45-扑克牌顺子">45.扑克牌顺子</h2><blockquote><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张<sup>_</sup>)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    bool IsContinuous(vector&lt;int&gt; numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        if (numbers.empty())</span><br><span class="line">            return false;</span><br><span class="line">        sort(numbers.begin(), numbers.end());</span><br><span class="line">        int sum &#x3D; 0, zero_num &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numbers.size() - 1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (numbers[i] &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                zero_num++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;考虑数字重复的情况</span><br><span class="line">            if (numbers[i + 1] &#x3D;&#x3D; numbers[i])</span><br><span class="line">                return false;</span><br><span class="line">            sum +&#x3D; numbers[i + 1] - numbers[i] - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &lt;&#x3D; zero_num; &#x2F;&#x2F;注意这里要大于等于就可以，不一定等于</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="46-孩子们的游戏-圆圈中最后剩下的数">46.孩子们的游戏(圆圈中最后剩下的数)</h2><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数…这样下去…直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!<sup>_</sup>)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p></blockquote><p>此约瑟夫环的问题。TODO:https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int LastRemaining_Solution(int n, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&lt;&#x3D;0)</span><br><span class="line">            return -1;</span><br><span class="line">        int last&#x3D;0;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;</span><br><span class="line">            last&#x3D;(last+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47-求1-2-3-n">47.求1+2+3+…+n</h2><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></blockquote><p>这个题，可以有好几种解决办法，一个容易想到的就是递归，每次都跟自己相加，直到加到0为止，判断的条件可以采用<code>&amp;&amp;</code>的短路特性：通过&amp;&amp;判断值是否为0已经到达结尾了。<br>另一种办法，可以利用类的构造函数。TODO:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        int sum&#x3D;n;</span><br><span class="line">        sum&amp;&amp;(sum+&#x3D;Sum_Solution(n-1));</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="48-不用加减乘除做加法">48.不用加减乘除做加法</h2><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p></blockquote><p>不能用加法做加法运算，可以想到的计算机中利用的二进制的加法。通过异或两个数，也就是模2加，得到的是不考虑进位的加法的结果。通过两个数异或，左移一位得到的是进位。无进位结果加上进位，一直循环知道进位为0的时候，结果即为加法的结果。<br>计算的过程中，一定要细心。方法虽然简单，但是要写对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        int res &#x3D; num1 ^ num2, temp &#x3D; num1 &amp; num2;</span><br><span class="line">        while (temp !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            temp &#x3D; temp &lt;&lt; 1;</span><br><span class="line">            int t &#x3D; res;  &#x2F;&#x2F;暂存res,以避免res的值被改变</span><br><span class="line">            res ^&#x3D; temp;</span><br><span class="line">            temp &#x3D; temp &amp; t;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="49-把字符串转换成整数">49.把字符串转换成整数</h2><blockquote><p>输入一个字符串,包括数字字母符号,可以为空.如果是合法的数值表达则返回该数字，否则返回0</p></blockquote><p>分析：主要首先要考虑正负号，这里有一个小细节，我们把flag直接置1的话，可以直接输出flag*res得到结果，而不需要进行判断，是一种省略。另外的判断就比较简单了，按照正常的思路去判断就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    int StrToInt(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        if (str.size() &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        int size &#x3D; str.size(), res &#x3D; 0;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        if (str[0] &#x3D;&#x3D; &#39;-&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            flag &#x3D; -1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (str[0] &#x3D;&#x3D; &#39;+&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (str[i] &lt;&#x3D; &#39;0&#39; || str[i] &gt;&#x3D; &#39;9&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                res &#x3D; res * 10 + (str[i] - &#39;0&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        return flag * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="50-数组中重复的数字">50.数组中重复的数字</h2><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p></blockquote><p>分析：由于规定了数组中的数字在范围为0–n内，所以可以利用当前数组的位置进行遍历，比如每次遍历到一个位置，就将该数字对应位置的值加n，这样，当再次遍历到该值时，发现如果该值已经大于n，说明已经重复了，返回即可。不过在遍历的时候，如果发现某一位置的值大于n，应该先减去n，得到该位置上原来的值，这里应该捋清楚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    &#x2F;&#x2F; Parameters:</span><br><span class="line">    &#x2F;&#x2F;        numbers:     an array of integers</span><br><span class="line">    &#x2F;&#x2F;        length:      the length of array numbers</span><br><span class="line">    &#x2F;&#x2F;        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    &#x2F;&#x2F; Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    &#x2F;&#x2F;                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int *duplication)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;length;++i)&#123;</span><br><span class="line">            int index&#x3D;numbers[i];</span><br><span class="line">            if(index&gt;&#x3D;length)</span><br><span class="line">                index&#x3D;index-length;</span><br><span class="line">            if(numbers[index]&gt;&#x3D;length)&#123;</span><br><span class="line">                *duplication&#x3D;index;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[index]+&#x3D;length;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="51-构建乘积数组">51.构建乘积数组</h2><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]。不能使用除法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt; res(A.size());</span><br><span class="line">        if(A.empty())</span><br><span class="line">            return res;</span><br><span class="line">        res[0]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;计算下三角</span><br><span class="line">        for(int i&#x3D;1;i&lt;A.size();++i)&#123;</span><br><span class="line">            res[i]&#x3D;res[i-1]*A[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        int temp&#x3D;1;</span><br><span class="line">        for(int i&#x3D;A.size()-2;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">            temp*&#x3D;A[i+1];</span><br><span class="line">            res[i]*&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="52-正则表达式匹配">52.正则表达式匹配</h2><h2 id="53-表示数值的字符串">53.表示数值的字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead&#x3D;&#x3D;nullptr)</span><br><span class="line">            return pHead;</span><br><span class="line">        ListNode* virtualHead&#x3D;new ListNode(0);</span><br><span class="line">        virtualHead-&gt;next&#x3D;pHead;</span><br><span class="line">        ListNode* prev&#x3D;virtualHead;</span><br><span class="line">        </span><br><span class="line">        while(pHead-&gt;next)&#123;</span><br><span class="line">            if(pHead-&gt;val&#x3D;&#x3D;pHead-&gt;next-&gt;val)&#123;</span><br><span class="line">                if(pHead-&gt;next-&gt;next)&#123;</span><br><span class="line">                    pHead&#x3D;pHead-&gt;next-&gt;next;</span><br><span class="line">                    prev-&gt;next&#x3D;pHead;</span><br><span class="line">                &#125;</span><br><span class="line">                else </span><br><span class="line">                    return virtualHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                pHead&#x3D;pHead-&gt;next;</span><br><span class="line">                prev&#x3D;prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return virtualHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试用例:{1,1,1,1,1,1,1}</p><p>对应输出应该为:</p><h2 id="54-字符流中第一个不重复的字符">54.字符流中第一个不重复的字符</h2><h2 id="55-链表中环的入口结点">55.链表中环的入口结点</h2><h2 id="56-删除链表中重复的结点">56.删除链表中重复的结点</h2><h2 id="57-二叉树的下一个结点">57.二叉树的下一个结点</h2><h2 id="58-对称的二叉树">58.对称的二叉树</h2><h2 id="59-按之字形顺序打印二叉树">59.按之字形顺序打印二叉树</h2><h2 id="60-把二叉树打印成多行">60.把二叉树打印成多行</h2><h2 id="61-序列化二叉树">61.序列化二叉树</h2><h2 id="62-二叉搜索树的第k个结点">62.二叉搜索树的第k个结点</h2><h2 id="63-数据流中的中位数">63.数据流中的中位数</h2><h2 id="64-滑动窗口的最大值">64.滑动窗口的最大值</h2><h2 id="65-矩阵中的路径">65.矩阵中的路径</h2><h2 id="66-机器人的运动范围">66.机器人的运动范围</h2>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-刷题总结</title>
      <link href="/2018/06/20/interview/re_sword_to_offer/"/>
      <url>/2018/06/20/interview/re_sword_to_offer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>重刷剑指offer总结</p></blockquote><div align="center" > <img src="https://blog-1252063226.cosbj.myqcloud.com/network/22547215-1_u_1.jpg" hight="200px"/> </div><br><a id="more"></a><h2 id="01-二维数组中的查找">01.二维数组中的查找</h2><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>分析：由于每一行都有递增的特性，我们可以采用类似二分搜索的方法。将数组分成行列来进行搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        if(0&#x3D;&#x3D;array.size())</span><br><span class="line">            return false;</span><br><span class="line">        int raw&#x3D;array.size();</span><br><span class="line">        int col&#x3D;array[0].size();</span><br><span class="line">        for(int i&#x3D;0;i&lt;raw;++i)&#123;</span><br><span class="line">            if(array[i][col-1]&gt;&#x3D;target)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;col;++j)&#123;</span><br><span class="line">                    if(array[i][j]&#x3D;&#x3D;target)</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="02-替换空格">02.替换空格</h2><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>考虑到是在原字符串上操作，如果遇到一个空格就替换的话，需要把后面的都要后移两位，这个复杂度就大了，所以可以先遍历第一遍，找到空格的总数，之后就可以计算替换后的字符串长度。再经过第二遍遍历，从后往前开始替换，这样就不用移动了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">         if(length&lt;&#x3D;0)</span><br><span class="line">             return;</span><br><span class="line">        int origin_length&#x3D;0,new_length&#x3D;0,space_num&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;str[i]!&#x3D;&#39;\0&#39;;++i)&#123;</span><br><span class="line">            origin_length++;</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">                space_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        new_length&#x3D;origin_length+2*space_num;</span><br><span class="line">        if(new_length&gt;length)</span><br><span class="line">            return;</span><br><span class="line">        str[new_length]&#x3D;&#39;\0&#39;;</span><br><span class="line">        while(origin_length&gt;0)&#123;</span><br><span class="line">            --origin_length;</span><br><span class="line">            if(str[origin_length]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                str[--new_length]&#x3D;&#39;0&#39;;</span><br><span class="line">                str[--new_length]&#x3D;&#39;2&#39;;</span><br><span class="line">                str[--new_length]&#x3D;&#39;%&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                str[--new_length]&#x3D;str[origin_length];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="03-从尾到头打印链表">03.从尾到头打印链表</h2><blockquote><p>输入一个链表，从尾到头打印链表每个节点的值。</p></blockquote><p>分析：由于链表我们必须从头到尾遍历才能从链表尾开始，所以直接打印的话，需要先从前往后遍历一遍找到链表尾节点，再从后往前遍历打印。能够进行的改善是，通过增加O(N)的空间复杂度，第一次遍历的时候，将数据放在一个栈中，之后再从栈中把所有的数都弹出来就好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(!head)</span><br><span class="line">            return res;</span><br><span class="line">        stack&lt;int&gt; istack;</span><br><span class="line">        while(head)&#123;</span><br><span class="line">            istack.push(head-&gt;val);</span><br><span class="line">            head&#x3D;head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!istack.empty())&#123;</span><br><span class="line">            res.push_back(istack.top());</span><br><span class="line">            istack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="04-重建二叉树">04.重建二叉树</h2><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><p>分析：首先需要知道的是前序遍历和后续遍历的特点，程序中可以维护4个子数组，当进行递归调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.empty() || pre.size()!&#x3D;vin.size())</span><br><span class="line">            return nullptr;</span><br><span class="line">        vector&lt;int&gt; pre1,pre2,vin1,vin2;</span><br><span class="line">        TreeNode* root&#x3D;new TreeNode(pre[0]);</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(;i&lt;vin.size();++i)&#123;</span><br><span class="line">            if(pre[0]&#x3D;&#x3D;vin[i])</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;不需要判断i &#x3D;&#x3D;0 或者i&#x3D;&#x3D;vin.size()-1的情况</span><br><span class="line">        for(int j&#x3D;0;j&lt;i;++j)&#123;</span><br><span class="line">            pre1.push_back(pre[1+j]);</span><br><span class="line">            vin1.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;pre.size();++j)&#123;</span><br><span class="line">            pre2.push_back(pre[j]);</span><br><span class="line">            vin2.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left&#x3D;reConstructBinaryTree(pre1,vin1);</span><br><span class="line">        root-&gt;right&#x3D;reConstructBinaryTree(pre2,vin2);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过上述的方法有个问题，虽然看起来比较好理解，但是增加了空间复杂度，其实这里可以多加一个递归函数就好了，所以觉得还是需要重新写一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* recurse(vector&lt;int&gt;&amp; pre,int begin1,int end1,vector&lt;int &gt;&amp; vin,int begin2,int end2)&#123;</span><br><span class="line">        if(begin1&gt;end1 || begin2&gt;end2)  &#x2F;&#x2F;退出条件</span><br><span class="line">            return nullptr;</span><br><span class="line">        TreeNode* root&#x3D;new TreeNode(pre[begin1]);</span><br><span class="line">        for(int i&#x3D;begin2;i&lt;&#x3D;end2;++i)&#123;</span><br><span class="line">            if(pre[begin1]&#x3D;&#x3D;vin[i])&#123;</span><br><span class="line">                root-&gt;left&#x3D;recurse(pre,begin1+1,begin1+i-begin2,vin,begin2,i-1);  &#x2F;&#x2F;递归的重点，这个要考虑清楚</span><br><span class="line">                root-&gt;right&#x3D;recurse(pre,begin1+1+i-begin2,end1,vin,1+i,end2);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.empty() || pre.size()!&#x3D;vin.size())</span><br><span class="line">            return nullptr;</span><br><span class="line">        return recurse(pre,0,pre.size()-1,vin,0,vin.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="05-用两个栈实现队列">05.用两个栈实现队列</h2><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote><p>分析：由于栈是先进后出，队列是先进先出，于是可以想到，两个栈，必然能够实现一个队列。原理就是，当push的时候就往第一个栈push，pop的时候就从第二个栈pop，当第二个栈的数为空时，从第一个栈pop再push到第二个栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int top&#x3D;stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        return top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="06-旋转数组的最小数字">06.旋转数组的最小数字</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p>分析：对于排序的数组，即使被旋转过，也能想到的是，采用二分查找。不过可能会存在的问题的是：当整个数组的值都是<code>1 0 0 1 1</code>之类的时候，就会失效了，只是非递减，但是不一定递增。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(0&#x3D;&#x3D;rotateArray.size())&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int begin&#x3D;0,end&#x3D;rotateArray.size()-1;</span><br><span class="line">        while(begin&lt;end-1)&#123;</span><br><span class="line">            int mid&#x3D;begin+(end-begin)&#x2F;2;</span><br><span class="line">            if(rotateArray[begin]&lt;rotateArray[mid])</span><br><span class="line">                begin&#x3D;mid;</span><br><span class="line">            else if(rotateArray[begin]&gt;rotateArray[mid])</span><br><span class="line">                end&#x3D;mid;</span><br><span class="line">            else&#123;</span><br><span class="line">                int res&#x3D;begin;</span><br><span class="line">                for(size_t i&#x3D;1;i&lt;rotateArray.size();++i)&#123;</span><br><span class="line">                    res&#x3D;(res&lt;rotateArray[i]?res:rotateArray[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="07-斐波那契数列">07.斐波那契数列</h2><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p></blockquote><p>分析：斐波拉契数列原理很简单，不过按照原理写的显然复杂度过高了，这里我们可以采用变量存下之前计算过的数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)</span><br><span class="line">            return 1;</span><br><span class="line">        int first&#x3D;1,second&#x3D;1,res&#x3D;0;</span><br><span class="line">        while(--n&gt;1)&#123;</span><br><span class="line">            res&#x3D;first+second;</span><br><span class="line">            first&#x3D;second;</span><br><span class="line">            second&#x3D;res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="08-跳台阶">08.跳台阶</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>分析：原理同斐波拉契数列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number&lt;&#x3D;2)</span><br><span class="line">            return number;</span><br><span class="line">        int first&#x3D;1,second&#x3D;2,res&#x3D;0;</span><br><span class="line">        while(--number&gt;1)&#123;</span><br><span class="line">            res&#x3D;first+second;</span><br><span class="line">            first&#x3D;second;</span><br><span class="line">            second&#x3D;res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="09-变态跳台阶">09.变态跳台阶</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f(n)&#x3D;f(1)+f(2)+...+f(n-1)</span><br><span class="line">f(n+1)&#x3D;f(1)+f(2)+...+f(n-1)+f(n)&#x3D;2f(n)</span><br><span class="line">&#x2F;&#x2F;代码如下：</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        if(number&lt;&#x3D;2)</span><br><span class="line">            return number;</span><br><span class="line">        int res&#x3D;2;</span><br><span class="line">        while(--number&gt;&#x3D;2)&#123;</span><br><span class="line">            res*&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-矩形覆盖-todo">10.矩形覆盖 /TODO:</h2><h2 id="11-二进制中1的个数">11.二进制中1的个数</h2><blockquote><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p></blockquote><p>分析：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int count&#x3D;0;</span><br><span class="line">         while(n)&#123;</span><br><span class="line">             count++;</span><br><span class="line">             n&#x3D;n&amp;(n-1);</span><br><span class="line">         &#125;</span><br><span class="line">         return count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="12-数值的整数次方">12.数值的整数次方</h2><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p></blockquote><p>分析：求一个数的次方，一个就是幂数是负数的处理，另一个就是，对幂的处理，连乘必然带来复杂度，可以想到的是2<sup>4可以表示为(2</sup>2)^2，想到这里，考虑的开水奇偶exponent的奇偶性了，奇数的时候直接乘以base，偶数的时候自乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        bool flag&#x3D;true;</span><br><span class="line">        if(exponent&lt;0)&#123;</span><br><span class="line">            flag&#x3D;false;</span><br><span class="line">            exponent*&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        double res&#x3D;1;</span><br><span class="line">        while(exponent)&#123;</span><br><span class="line">            if(exponent&amp;1)&#123;</span><br><span class="line">                res*&#x3D;base;</span><br><span class="line">                exponent--;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                exponent&#x3D;exponent&#x2F;2;</span><br><span class="line">                res*&#x3D;res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag?res:(1&#x2F;res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13-调整数组顺序使奇数位于偶数前面">13.调整数组顺序使奇数位于偶数前面</h2><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">if(array.empty())</span><br><span class="line">return;</span><br><span class="line">int begin&#x3D;0,end&#x3D;array.size();</span><br><span class="line">int even&#x3D;-1;</span><br><span class="line"></span><br><span class="line">while(begin&lt;end)&#123;</span><br><span class="line">while((array[begin]&amp;1) &amp;&amp; (begin&lt;end))&#123;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line">even&#x3D;begin;</span><br><span class="line">while((!(array[begin]&amp;1)))&#123;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line">if(begin&gt;&#x3D;end)</span><br><span class="line">return;</span><br><span class="line">int temp&#x3D;array[begin];</span><br><span class="line">while(even&lt;begin)&#123;</span><br><span class="line">array[begin]&#x3D;array[begin-1];</span><br><span class="line">begin--;</span><br><span class="line">&#125;</span><br><span class="line">array[even]&#x3D;temp;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14-链表中倒数第k个结点">14.链表中倒数第k个结点</h2><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><p>分析：采用两个指针一起移动是一个很好的办法，不过需要考虑是否越界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        ListNode* p1&#x3D;pListHead;</span><br><span class="line">        for(int i&#x3D;0;i&lt;k;++i)&#123;</span><br><span class="line">            if(!p1)</span><br><span class="line">               return nullptr;</span><br><span class="line">            p1&#x3D;p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p1)&#123;</span><br><span class="line">            p1&#x3D;p1-&gt;next;</span><br><span class="line">            pListHead&#x3D;pListHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-反转链表">15.反转链表</h2><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><p>分析：注意断开链表重连的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">&#x2F;&#x2F;最开始的一版代码，采用的是栈，看起来比较复杂。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        if((!pHead)||(!pHead-&gt;next))</span><br><span class="line">            return pHead;</span><br><span class="line">        stack&lt;ListNode*&gt; list_stack;</span><br><span class="line">        while(pHead-&gt;next)&#123;</span><br><span class="line">            list_stack.push(pHead);</span><br><span class="line">            pHead&#x3D;pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead&#x3D;pHead;</span><br><span class="line">        while(!list_stack.empty())&#123;</span><br><span class="line">            pHead-&gt;next&#x3D;list_stack.top();</span><br><span class="line">            pHead&#x3D;pHead-&gt;next;</span><br><span class="line">            list_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        pHead-&gt;next&#x3D;nullptr;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;采用在链表中的穿针引线。涉及到链表的断开与重连，维护三个指针，分别为：pre,cur,next</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        ListNode* pre&#x3D;nullptr;</span><br><span class="line">        ListNode* cur&#x3D;pHead;</span><br><span class="line">        while(cur)&#123;</span><br><span class="line">            ListNode* next&#x3D;cur-&gt;next;</span><br><span class="line">            cur-&gt;next&#x3D;pre;</span><br><span class="line">            pre&#x3D;cur;</span><br><span class="line">            cur&#x3D;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;采用递归实现</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        if(!pHead||!pHead-&gt;next)</span><br><span class="line">            return pHead;</span><br><span class="line">        ListNode* rHead&#x3D;ReverseList(pHead-&gt;next);</span><br><span class="line">        &#x2F;&#x2F; head-&gt;next此刻指向head后面的链表的尾节点</span><br><span class="line">        &#x2F;&#x2F; head-&gt;next-&gt;next &#x3D; head把head节点放在了尾部</span><br><span class="line">        pHead-&gt;next-&gt;next&#x3D;pHead;</span><br><span class="line">        pHead-&gt;next&#x3D;nullptr;</span><br><span class="line">        </span><br><span class="line">        return rHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="16-合并两个排序的链表">16.合并两个排序的链表</h2><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;当一个链表为空时，直接返回另一个链表</span><br><span class="line">        if(!pHead1)</span><br><span class="line">            return pHead2;</span><br><span class="line">        if(!pHead2)</span><br><span class="line">            return pHead1;</span><br><span class="line">        ListNode* vHead&#x3D;new ListNode(0);  &#x2F;&#x2F;设立虚拟的头节点</span><br><span class="line">        ListNode* vHeadHead&#x3D;vHead;</span><br><span class="line">        while(pHead1 &amp;&amp; pHead2)&#123;  &#x2F;&#x2F;一旦有一个链表为空，就退出循环</span><br><span class="line">            if(pHead1-&gt;val&lt;&#x3D;pHead2-&gt;val)&#123;</span><br><span class="line">                vHead-&gt;next&#x3D;pHead1;</span><br><span class="line">                pHead1&#x3D;pHead1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                vHead-&gt;next&#x3D;pHead2;</span><br><span class="line">                pHead2&#x3D;pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            vHead&#x3D;vHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;另一个链表不为空时，加在后面</span><br><span class="line">        if(!pHead1)</span><br><span class="line">            vHead-&gt;next&#x3D;pHead2;</span><br><span class="line">        else</span><br><span class="line">            vHead-&gt;next&#x3D;pHead1;</span><br><span class="line">        return vHeadHead-&gt;next;  &#x2F;&#x2F;返回虚拟头节点的下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;采用递归实现</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pHead1)</span><br><span class="line">            return pHead2;</span><br><span class="line">        if(!pHead2)</span><br><span class="line">            return pHead1;</span><br><span class="line">        ListNode* vHead&#x3D;nullptr;</span><br><span class="line">        if(pHead1-&gt;val&lt;&#x3D;pHead2-&gt;val)&#123;</span><br><span class="line">            vHead&#x3D;pHead1;</span><br><span class="line">            vHead-&gt;next&#x3D;Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            vHead&#x3D;pHead2;</span><br><span class="line">            vHead-&gt;next&#x3D;Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        return vHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-树的子结构">17.树的子结构</h2><blockquote><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(TreeNode* pRoot1,TreeNode* pRoot2)&#123;</span><br><span class="line">        if(!pRoot2)    &#x2F;&#x2F;注意不能先判断pRoot1再判断pRoot2，因为，只要pRoot2为空的时候，都是true了，而不管这时候pRoot1是不是为空。</span><br><span class="line">            return true;</span><br><span class="line">        if(!pRoot1)</span><br><span class="line">            return false;</span><br><span class="line">        if(pRoot1-&gt;val!&#x3D;pRoot2-&gt;val)</span><br><span class="line">            return false;</span><br><span class="line">        return dfs(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;dfs(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if((!pRoot2)||(!pRoot1))</span><br><span class="line">            return false;</span><br><span class="line">        return (dfs(pRoot1,pRoot2)||HasSubtree(pRoot1-&gt;left,pRoot2)||HasSubtree(pRoot1-&gt;right,pRoot2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="18-二叉树的镜像">18.二叉树的镜像</h2><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p></blockquote><p>分析：简单的递归解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(pRoot&#x3D;&#x3D;nullptr)</span><br><span class="line">            return;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">        swap(pRoot-&gt;left,pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-顺时针打印矩阵">19.顺时针打印矩阵</h2><h2 id="20-包含min函数的栈">20.包含min函数的栈</h2><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p></blockquote><p>分析：维护两个栈，其中一个是压入数据的栈，另一个是min栈，存储当前数据的最小的值。只有压入的数小于min栈的时候，才压入新值，否则继续压入最小值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        stk.push(value);</span><br><span class="line">        if(!stk_min.empty())&#123;</span><br><span class="line">            if(value&lt;stk_min.top())</span><br><span class="line">                stk_min.push(value);</span><br><span class="line">            else&#123;</span><br><span class="line">                int temp&#x3D;stk_min.top();</span><br><span class="line">                stk_min.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            stk_min.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        stk_min.pop();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return stk_min.top();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    stack&lt;int&gt; stk_min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="21-栈的压入-弹出序列">21.栈的压入、弹出序列</h2><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p></blockquote><p>思路：判断是否是压入弹出序列，可以直接使用一个栈进行压入，然后在压入的过程中判断是否跟弹出序列的值相同，是的话则先弹出，最后判断栈是否为空即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        stack&lt;int&gt; istack;</span><br><span class="line">        int i&#x3D;0,j&#x3D;0;</span><br><span class="line">        while(i&lt;pushV.size())&#123;</span><br><span class="line">        istack.push(pushV[i++]);</span><br><span class="line">        while(j&lt;popV.size() &amp;&amp; istack.top()&#x3D;&#x3D;popV[j])&#123;</span><br><span class="line">        istack.pop();</span><br><span class="line">        ++j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return istack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="22-从上往下打印二叉树">22.从上往下打印二叉树</h2><blockquote><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p></blockquote><p>分析：层序遍历，需要每遍历一个节点，就将他们的左右节点保存起来，当前层遍历完后，再顺序遍历他们的孩子节点。于是很容易想到先入先出的结构，队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(root&#x3D;&#x3D;nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; ique;</span><br><span class="line">        ique.push(root);</span><br><span class="line">        while(!ique.empty())&#123;</span><br><span class="line">            TreeNode* temp&#x3D;ique.front();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">            ique.pop();</span><br><span class="line">            </span><br><span class="line">            if(temp-&gt;left)</span><br><span class="line">                ique.push(temp-&gt;left);</span><br><span class="line">            if(temp-&gt;right)</span><br><span class="line">                ique.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="23-二叉搜索树的后序遍历序列">23.二叉搜索树的后序遍历序列</h2><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">return Verify(sequence,0,sequence.size());</span><br><span class="line">    &#125;</span><br><span class="line">    bool Verify(vector&lt;int&gt; sequence,int start,int end)&#123;</span><br><span class="line">        int i&#x3D;start;</span><br><span class="line">        if(start&#x3D;&#x3D;end)</span><br><span class="line">            return false;</span><br><span class="line">for(;i&lt;end-1;++i)&#123;</span><br><span class="line">if(sequence[i]&gt;sequence[end-1])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        for(int j&#x3D;i;j!&#x3D;end;++j)&#123;</span><br><span class="line">            if(sequence[j]&lt;sequence[end-1])&#123;</span><br><span class="line">                 return false;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        bool left&#x3D;true;</span><br><span class="line">        if(i&gt;start)</span><br><span class="line">            left&#x3D;Verify(sequence,start,i);</span><br><span class="line">        </span><br><span class="line">        bool right&#x3D;true;</span><br><span class="line">        if(i&lt;end-1)</span><br><span class="line">            right&#x3D;Verify(sequence,i,end-1);</span><br><span class="line">        return left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="24-二叉树中和为某一值的路径">24.二叉树中和为某一值的路径</h2><blockquote><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return res;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        if(expectNumber-root-&gt;val&#x3D;&#x3D;0 &amp;&amp; root-&gt;left&#x3D;&#x3D;nullptr &amp;&amp; root-&gt;right&#x3D;&#x3D;nullptr)</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        if(!temp.empty())</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="25-复杂链表的复制">25.复杂链表的复制</h2><p>代码问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        while(pHead-&gt;next)&#123;</span><br><span class="line">&#x2F;&#x2F;        cout&lt;&lt;pHead-&gt;label&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;            RandomListNode* pTemp&#x3D;pHead;   &#x2F;&#x2F;傻了吧</span><br><span class="line">            RandomListNode* pTemp&#x3D;new RandomListNode(pHead-&gt;label);  </span><br><span class="line">            pTemp-&gt;next&#x3D;pHead-&gt;next;</span><br><span class="line">            cout&lt;&lt;pTemp-&gt;next-&gt;label&lt;&lt;endl;</span><br><span class="line">            pHead-&gt;next&#x3D;pTemp;</span><br><span class="line">            pHead&#x3D;pTemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">                &#x2F;&#x2F;拆分</span><br><span class="line">        pNode&#x3D;pHead;</span><br><span class="line">RandomListNode* newHead&#x3D;pHead-&gt;next;</span><br><span class="line">        RandomListNode* pTemp&#x3D;pNode-&gt;next;</span><br><span class="line">while(pNode)&#123;</span><br><span class="line">pNode-&gt;next&#x3D;pTemp-&gt;next;</span><br><span class="line">pNode&#x3D;pNode-&gt;next;</span><br><span class="line">pTemp-&gt;next&#x3D;pNode?pNode-&gt;next:NULL;</span><br><span class="line">&#x2F;&#x2F;pTemp-&gt;next&#x3D;pNode-&gt;next;</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;&quot;pTemp: &quot;&lt;&lt;pTemp-&gt;label&lt;&lt;endl;</span><br><span class="line">pTemp&#x3D;pTemp-&gt;next;</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;&quot;text&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">    if(!pHead)</span><br><span class="line">    return pHead;</span><br><span class="line">    RandomListNode* pNode&#x3D;pHead;</span><br><span class="line"></span><br><span class="line">    while(pNode)&#123;</span><br><span class="line">    RandomListNode* pClone&#x3D;new RandomListNode(pNode-&gt;label);</span><br><span class="line">    pClone-&gt;next&#x3D;pNode-&gt;next;</span><br><span class="line">    pNode-&gt;next&#x3D;pClone;</span><br><span class="line">    pNode&#x3D;pClone-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNode&#x3D;pHead;</span><br><span class="line">while(pNode)&#123;</span><br><span class="line">RandomListNode* pClone&#x3D;pNode-&gt;next;</span><br><span class="line">if(pNode-&gt;random)</span><br><span class="line">pClone-&gt;random&#x3D;pNode-&gt;random-&gt;next;</span><br><span class="line">pNode&#x3D;pClone-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pNode&#x3D;pHead;</span><br><span class="line">RandomListNode* newHead&#x3D;pNode-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(pNode-&gt;next)&#123;</span><br><span class="line">RandomListNode* pTemp&#x3D;pNode-&gt;next;</span><br><span class="line">pNode-&gt;next&#x3D;pTemp-&gt;next;</span><br><span class="line">pNode&#x3D;pTemp;</span><br><span class="line">&#x2F;&#x2F;pNode&#x3D;pNode-&gt;next;                  &#x2F;&#x2F;这种不行，搞得我折腾了很久</span><br><span class="line">&#x2F;&#x2F;pTemp-&gt;next&#x3D;pNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26-二叉搜索树与双向链表">26.二叉搜索树与双向链表</h2><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。TODO:</p></blockquote><h2 id="27-字符串的排列">27.字符串的排列</h2><h2 id="28-数组中出现次数超过一半的数字">28.数组中出现次数超过一半的数字</h2><p>解决一个问题，最终输出的判断，是1，还是0。如果大于1的话，万一最后只剩下了一个呢。所以还需要再判断最后剩下的结果是不是符合条件的，即是大于一般数目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        if(numbers.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        int count&#x3D;1;</span><br><span class="line">        int num&#x3D;numbers[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;numbers.size();++i)&#123;</span><br><span class="line">            if(numbers[i]&#x3D;&#x3D;num)</span><br><span class="line">                count++;</span><br><span class="line">            else&#123;</span><br><span class="line">                if((--count)&lt;&#x3D;0)&#123;</span><br><span class="line">                    num&#x3D;numbers[i];</span><br><span class="line">                    count&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断结果是否符合条件</span><br><span class="line">        count&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;numbers.size();++i)&#123;</span><br><span class="line">            if(num&#x3D;&#x3D;numbers[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count*2&gt;numbers.size()?num:0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="29-最小的k个数">29.最小的K个数</h2><p>存在的问题，写程序的时候越界，没有判断好边界条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; min_stack;</span><br><span class="line">        if(input.empty()||(k&lt;&#x3D;0)||(k&gt;input.size()))  &#x2F;&#x2F;边界条件的判断</span><br><span class="line">            return min_stack;</span><br><span class="line">        for(int i&#x3D;0;i&lt;input.size();++i)&#123;</span><br><span class="line">            sort(min_stack.begin(),min_stack.end());</span><br><span class="line">            if(min_stack.size()&lt;k)&#123;</span><br><span class="line">                min_stack.push_back(input[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">            &#x2F;&#x2F;cout&lt;&lt;&quot;min_stack[min_stack.size()-1]: &quot;&lt;&lt;min_stack[min_stack.size()-1]&lt;&lt;endl;</span><br><span class="line">                if(input[i]&lt;min_stack[min_stack.size()-1])&#123;</span><br><span class="line">                    min_stack.pop_back();</span><br><span class="line">                    min_stack.push_back(input[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min_stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="30-连续子数组的最大和">30.连续子数组的最大和</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">    int  res&#x3D;array[0];</span><br><span class="line">    int cur&#x3D;array[0];</span><br><span class="line">    for(int i&#x3D;1;i&lt;array.size();++i)&#123;</span><br><span class="line">    cur+&#x3D;array[i];</span><br><span class="line">    if(cur&lt;array[i])</span><br><span class="line">    cur&#x3D;array[i];</span><br><span class="line">    res&#x3D;(res&gt;cur?res:cur);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="31-整数中1出现的次数-从1到n整数中1出现的次数">31.整数中1出现的次数（从1到n整数中1出现的次数）</h2><blockquote><p>求出1<sub>13的整数中1出现的次数,并算出100</sub>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p></blockquote><p>分析：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析。<br>当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)<em>100个点的百位为1<br>当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10</em>100）+(b+1)，这些点百位对应为1<br>当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）<br>综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;n&#x3D;1的情况</span><br><span class="line">        if(n&#x3D;&#x3D;1)</span><br><span class="line">            return 1;</span><br><span class="line">        &#x2F;&#x2F;考虑的边界情况，n&#x3D;10,100,1000之类的，同时循环中没有考虑n&#x3D;0的情况</span><br><span class="line">        if(n&gt;1&amp;&amp;n%10&#x3D;&#x3D;0)</span><br><span class="line">            count++;</span><br><span class="line">        &#x2F;&#x2F;没有考虑n&#x3D;1的情况</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i*&#x3D;10)&#123;</span><br><span class="line">            int a&#x3D;n&#x2F;i,b&#x3D;n%i;</span><br><span class="line">            count+&#x3D;(a+8)&#x2F;10*i+(a%10&#x3D;&#x3D;1)*(b+1);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32-把数组排成最小的数">32.把数组排成最小的数</h2><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    static bool equal(int a,int b)&#123;</span><br><span class="line">        string str1&#x3D;to_string(a)+to_string(b);</span><br><span class="line">        string str2&#x3D;to_string(b)+to_string(a);</span><br><span class="line">        return str1&lt;str2;</span><br><span class="line">    &#125;</span><br><span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        string result;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),equal);</span><br><span class="line">        for(int i&#x3D;0;i&lt;numbers.size();++i)&#123;</span><br><span class="line">            result+&#x3D;to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="33-丑数">33.丑数</h2><blockquote><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        if(index&lt;&#x3D;0)        </span><br><span class="line">            return 0;</span><br><span class="line">        vector&lt;int &gt; res(index);</span><br><span class="line">        res[0]&#x3D;1;</span><br><span class="line">        int x&#x3D;0,y&#x3D;0,z&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;index;++i)&#123;</span><br><span class="line">            res[i]&#x3D;min(2*res[x],min(3*res[y],5*res[z]));</span><br><span class="line">            if(res[i]&#x3D;&#x3D;2*res[x])</span><br><span class="line">                x++;</span><br><span class="line">            if(res[i]&#x3D;&#x3D;3*res[y])</span><br><span class="line">                y++;</span><br><span class="line">            if(res[i]&#x3D;&#x3D;5*res[z])</span><br><span class="line">                z++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[index-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34-第一个只出现一次的字符位置">34.第一个只出现一次的字符位置</h2><blockquote><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p></blockquote><p>一般对于这种字符的处理，因为字符一般都是不超过256的，所以尤其是计数之类的，我们可以首先考虑数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    int FirstNotRepeatingChar(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str.size()&lt;&#x3D;0)</span><br><span class="line">            return -1;</span><br><span class="line">        int array[256]&#x3D;&#123;0&#125;;</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.size();++i)&#123;</span><br><span class="line">            array[int(str[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.size();++i)&#123;</span><br><span class="line">            if(array[int(str[i])]&#x3D;&#x3D;1)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return str.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="35-数组中的逆序对">35.数组中的逆序对</h2><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p></blockquote><h2 id="36-两个链表的第一个公共结点">36.两个链表的第一个公共结点</h2><blockquote><p>输入两个链表，找出它们的第一个公共结点。</p></blockquote><p>需要知道的一个常识是，对于只有一个单链表，两个链表有公共节点，意味着从公共节点开始，之后两个链表都是公共的，因此他们有共同的终点。有了这个就好办了。可以将两个链表一直遍历，当遍历到链表尾的时候，就换另一个链表，当他们有公共节点时，在他们遍历到同一个节点时停止遍历，此节点即为第一个公共节点。</p><p><strong>对于这种将两个不同的长度，通过两个结合在一起，使两个长度相等的方法，其实我们用到过很多次。例如本题中的找公共节点，原因是两个链表长度不同。还有之前的一个判断两个string的大小，可以把他们放在一起，这样他们的长度就相同了，可以直接用string的方法进行比较。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">        ListNode* p1&#x3D;pHead1;</span><br><span class="line">        ListNode* p2&#x3D;pHead2;</span><br><span class="line">        while(p1!&#x3D;p2)&#123;</span><br><span class="line">            p1&#x3D;(p1&#x3D;&#x3D;nullptr?pHead2:p1-&gt;next);</span><br><span class="line">            p2&#x3D;(p2&#x3D;&#x3D;nullptr?pHead1:p2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        return p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37-数字在排序数组中出现的次数">37.数字在排序数组中出现的次数</h2><blockquote><p>统计一个数字在排序数组中出现的次数。</p></blockquote><p>显然很容易想到的是二分法,没有用函数的话，就存在一个找到没找到的问题，在这采用了一个返回值的处理。如果没找到，(end-begin-1)&lt;0，则可以判断是没有找到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">        if(data.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        int begin&#x3D;0,end&#x3D;data.size()-1;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        int mid;</span><br><span class="line">        while(begin&lt;&#x3D;end)&#123;</span><br><span class="line">        mid&#x3D;(begin+end)&#x2F;2;</span><br><span class="line">&#x2F;&#x2F;        cout&lt;&lt;&quot;dsdasads&quot;&lt;&lt;endl;</span><br><span class="line">if(data[mid]&#x3D;&#x3D;k)</span><br><span class="line">break;</span><br><span class="line">            else if(data[mid]&lt;k)&#123;</span><br><span class="line">                begin&#x3D;mid+1;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(data[mid]&gt;k)&#123;</span><br><span class="line">                end&#x3D;mid-1;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        begin&#x3D;end&#x3D;mid;</span><br><span class="line">        while(data[begin]&#x3D;&#x3D;k)</span><br><span class="line">            --begin;</span><br><span class="line">        while(data[end]&#x3D;&#x3D;k)</span><br><span class="line">            ++end;</span><br><span class="line">        count&#x3D;(end-begin-1)&gt;0?(end-begin-1):0;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="38-二叉树的深度">38.二叉树的深度</h2><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int TreeDepth(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pRoot)</span><br><span class="line">            return 0;</span><br><span class="line">        return max(1+TreeDepth(pRoot-&gt;left),1+TreeDepth(pRoot-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39-平衡二叉树">39.平衡二叉树</h2><blockquote><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p></blockquote><h2 id="40-数组中只出现一次的数字">40.数组中只出现一次的数字</h2><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p></blockquote><p>数组中只出现一次的数字，当有一个的时候，很容易利用的特性是：全部异或，最后剩下的那个就是。原因是一个数跟自身异或，结果为0.那么出现有两个的时候呢。很容易想到的还是异或，最后的结果是两个只出现一次数字异或的结果，再进行分组解决。分组的依据是：因为有两个不同的数字只出现一次，所以整个数组异或的结果必然不为0，不为0就肯定有一位为1.按该位是否为1来进行划分即可。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span><br><span class="line">        if(data.empty())</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F;第一次遍历一遍，求两个数字最后的异或</span><br><span class="line">        int res&#x3D;data[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;data.size();++i)&#123;</span><br><span class="line">            res&#x3D;res^data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(res&#x3D;&#x3D;0)</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F;由于存在两个只出现一次的数字，所以res的值为这两个数字的异或，因此肯定不为0，肯定不为0意味着肯定有一位是1.找出这一位是1的</span><br><span class="line">        int index&#x3D;0;</span><br><span class="line">        while((res&amp;1)&#x3D;&#x3D;0)&#123;</span><br><span class="line">            res&#x3D;res&gt;&gt;1;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        *num1&#x3D;*num2&#x3D;0;        </span><br><span class="line">        &#x2F;&#x2F;根据index位为不为1，将数组分为两部分。</span><br><span class="line">        int x;</span><br><span class="line">        for(int i&#x3D;0;i&lt;data.size();++i)&#123;</span><br><span class="line">            if((x&#x3D;data[i]&gt;&gt;index)&amp;1)</span><br><span class="line">                *num1^&#x3D;data[i];</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                *num2^&#x3D;data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="41-和为s的连续正数序列">41.和为S的连续正数序列</h2><blockquote><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        &#x2F;&#x2F;边界条件的判断</span><br><span class="line">        if(sum&lt;0)</span><br><span class="line">            return res;</span><br><span class="line">            </span><br><span class="line">        int end&#x3D;0;</span><br><span class="line">        int tempSum&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;遍历数组</span><br><span class="line">        while(end&lt;sum)&#123;</span><br><span class="line">            if(tempSum&#x3D;&#x3D;sum)&#123;</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                end&#x3D;temp[0];  &#x2F;&#x2F;这一句其实很重要,因为要考虑将end从最开始重新开始计算，不然可能会有所遗漏,eg:9&#x3D;2+3+4&#x3D;4+5，其中4会重复</span><br><span class="line">                temp.erase(temp.begin(),temp.end());</span><br><span class="line">                tempSum&#x3D;0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tempSum&gt;sum)&#123;</span><br><span class="line">                tempSum-&#x3D;temp[0];</span><br><span class="line">                temp.erase(temp.begin());</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(++end);</span><br><span class="line">            tempSum+&#x3D;end;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="42-和为s的两个数字">42.和为S的两个数字</h2><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p></blockquote><p>输出乘积最小的，显然距离最大的乘积就越小，所以，可以直接前后两个指针搜索，搜到的第一个就是。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int &gt; res;</span><br><span class="line">        if(array.empty())</span><br><span class="line">            return res;</span><br><span class="line">            </span><br><span class="line">        int i&#x3D;0,j&#x3D;array.size()-1;</span><br><span class="line">        while(i&lt;j)&#123;</span><br><span class="line">            int temp&#x3D;array[i]+array[j];</span><br><span class="line">            if(temp&gt;sum)</span><br><span class="line">                --j;</span><br><span class="line">            if(temp&lt;sum)</span><br><span class="line">                ++i;</span><br><span class="line">            </span><br><span class="line">            if(temp&#x3D;&#x3D;sum) </span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(array[i]);</span><br><span class="line">                res.push_back(array[j]);</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="43-左旋转字符串">43.左旋转字符串</h2><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p></blockquote><p>由BA=(ATBT)T计算可得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次通过代码</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string LeftRotateString(string str, int n) &#123;</span><br><span class="line">        int len&#x3D;str.size();</span><br><span class="line">        if(n&gt;&#x3D;len)</span><br><span class="line">            return str;</span><br><span class="line">        int i&#x3D;0,j&#x3D;0;</span><br><span class="line">        for(i&#x3D;0,j&#x3D;n-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</span><br><span class="line">        for(i&#x3D;n,j&#x3D;len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</span><br><span class="line">        for(i&#x3D;0,j&#x3D;len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="44-翻转单词顺序列">44.翻转单词顺序列</h2><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以前买的</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void ReverseSentence(string &amp;str,int begin,int end)&#123;</span><br><span class="line">        while(begin&lt;end)&#123;</span><br><span class="line">            char tmp&#x3D;str[begin];</span><br><span class="line">            str[begin]&#x3D;str[end];</span><br><span class="line">            str[end]&#x3D;tmp;</span><br><span class="line">            begin++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ReverseSentence(string str) &#123;</span><br><span class="line">        if(str.size()&lt;&#x3D;1)</span><br><span class="line">            return str;</span><br><span class="line">        int begin&#x3D;0;</span><br><span class="line">        int end&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;这里需要注意，考虑只有一个单词的情况</span><br><span class="line">        while(end!&#x3D;str.size())&#123;</span><br><span class="line">            if(str[end]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                ReverseSentence(str,0,str.size()-1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(end&#x3D;&#x3D;str.size()-1)</span><br><span class="line">            return str;</span><br><span class="line">            else</span><br><span class="line">                ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        end&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;开始遍历，旋转每个单词</span><br><span class="line">        while(begin!&#x3D;str.size())&#123;</span><br><span class="line">            if(str[begin]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                ++end;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(str[end]&#x3D;&#x3D;&#39; &#39;||end&#x3D;&#x3D;str.size())&#123;</span><br><span class="line">                ReverseSentence(str,begin,--end);</span><br><span class="line">                begin&#x3D;++end;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="45-扑克牌顺子">45.扑克牌顺子</h2><blockquote><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张<sup>_</sup>)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    bool IsContinuous(vector&lt;int&gt; numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        if (numbers.empty())</span><br><span class="line">            return false;</span><br><span class="line">        sort(numbers.begin(), numbers.end());</span><br><span class="line">        int sum &#x3D; 0, zero_num &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numbers.size() - 1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (numbers[i] &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                zero_num++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;考虑数字重复的情况</span><br><span class="line">            if (numbers[i + 1] &#x3D;&#x3D; numbers[i])</span><br><span class="line">                return false;</span><br><span class="line">            sum +&#x3D; numbers[i + 1] - numbers[i] - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &lt;&#x3D; zero_num; &#x2F;&#x2F;注意这里要大于等于就可以，不一定等于</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="46-孩子们的游戏-圆圈中最后剩下的数">46.孩子们的游戏(圆圈中最后剩下的数)</h2><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数…这样下去…直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!<sup>_</sup>)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p></blockquote><p>此约瑟夫环的问题。https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int LastRemaining_Solution(int n, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&lt;&#x3D;0)</span><br><span class="line">            return -1;</span><br><span class="line">        int last&#x3D;0;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;</span><br><span class="line">            last&#x3D;(last+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47-求1-2-3-n">47.求1+2+3+…+n</h2><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></blockquote><p>这个题，可以有好几种解决办法，一个容易想到的就是递归，每次都跟自己相加，直到加到0为止，判断的条件可以采用<code>&amp;&amp;</code>的短路特性：通过&amp;&amp;判断值是否为0已经到达结尾了。<br>另一种办法，可以利用类的构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        int sum&#x3D;n;</span><br><span class="line">        sum&amp;&amp;(sum+&#x3D;Sum_Solution(n-1));</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="48-不用加减乘除做加法">48.不用加减乘除做加法</h2><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p></blockquote><p>不能用加法做加法运算，可以想到的计算机中利用的二进制的加法。通过异或两个数，也就是模2加，得到的是不考虑进位的加法的结果。通过两个数异或，左移一位得到的是进位。无进位结果加上进位，一直循环知道进位为0的时候，结果即为加法的结果。<br>计算的过程中，一定要细心。方法虽然简单，但是要写对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        int res &#x3D; num1 ^ num2, temp &#x3D; num1 &amp; num2;</span><br><span class="line">        while (temp !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            temp &#x3D; temp &lt;&lt; 1;</span><br><span class="line">            int t &#x3D; res;  &#x2F;&#x2F;暂存res,以避免res的值被改变</span><br><span class="line">            res ^&#x3D; temp;</span><br><span class="line">            temp &#x3D; temp &amp; t;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="49-把字符串转换成整数">49.把字符串转换成整数</h2><blockquote><p>输入一个字符串,包括数字字母符号,可以为空.如果是合法的数值表达则返回该数字，否则返回0</p></blockquote><p>分析：主要首先要考虑正负号，这里有一个小细节，我们把flag直接置1的话，可以直接输出flag*res得到结果，而不需要进行判断，是一种省略。另外的判断就比较简单了，按照正常的思路去判断就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    int StrToInt(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        if (str.size() &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        int size &#x3D; str.size(), res &#x3D; 0;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        if (str[0] &#x3D;&#x3D; &#39;-&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            flag &#x3D; -1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (str[0] &#x3D;&#x3D; &#39;+&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (str[i] &lt;&#x3D; &#39;0&#39; || str[i] &gt;&#x3D; &#39;9&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                res &#x3D; res * 10 + (str[i] - &#39;0&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        return flag * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="50-数组中重复的数字">50.数组中重复的数字</h2><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p></blockquote><p>分析：由于规定了数组中的数字在范围为0–n内，所以可以利用当前数组的位置进行遍历，比如每次遍历到一个位置，就将该数字对应位置的值加n，这样，当再次遍历到该值时，发现如果该值已经大于n，说明已经重复了，返回即可。不过在遍历的时候，如果发现某一位置的值大于n，应该先减去n，得到该位置上原来的值，这里应该捋清楚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    &#x2F;&#x2F; Parameters:</span><br><span class="line">    &#x2F;&#x2F;        numbers:     an array of integers</span><br><span class="line">    &#x2F;&#x2F;        length:      the length of array numbers</span><br><span class="line">    &#x2F;&#x2F;        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    &#x2F;&#x2F; Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    &#x2F;&#x2F;                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int *duplication)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;length;++i)&#123;</span><br><span class="line">            int index&#x3D;numbers[i];</span><br><span class="line">            if(index&gt;&#x3D;length)</span><br><span class="line">                index&#x3D;index-length;</span><br><span class="line">            if(numbers[index]&gt;&#x3D;length)&#123;</span><br><span class="line">                *duplication&#x3D;index;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[index]+&#x3D;length;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="51-构建乘积数组">51.构建乘积数组</h2><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]。不能使用除法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt; res(A.size());</span><br><span class="line">        if(A.empty())</span><br><span class="line">            return res;</span><br><span class="line">        res[0]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;计算下三角</span><br><span class="line">        for(int i&#x3D;1;i&lt;A.size();++i)&#123;</span><br><span class="line">            res[i]&#x3D;res[i-1]*A[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        int temp&#x3D;1;</span><br><span class="line">        for(int i&#x3D;A.size()-2;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">            temp*&#x3D;A[i+1];</span><br><span class="line">            res[i]*&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="52-正则表达式匹配">52.正则表达式匹配</h2><h2 id="53-表示数值的字符串">53.表示数值的字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead&#x3D;&#x3D;nullptr)</span><br><span class="line">            return pHead;</span><br><span class="line">        ListNode* virtualHead&#x3D;new ListNode(0);</span><br><span class="line">        virtualHead-&gt;next&#x3D;pHead;</span><br><span class="line">        ListNode* prev&#x3D;virtualHead;</span><br><span class="line">        </span><br><span class="line">        while(pHead-&gt;next)&#123;</span><br><span class="line">            if(pHead-&gt;val&#x3D;&#x3D;pHead-&gt;next-&gt;val)&#123;</span><br><span class="line">                if(pHead-&gt;next-&gt;next)&#123;</span><br><span class="line">                    pHead&#x3D;pHead-&gt;next-&gt;next;</span><br><span class="line">                    prev-&gt;next&#x3D;pHead;</span><br><span class="line">                &#125;</span><br><span class="line">                else </span><br><span class="line">                    return virtualHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                pHead&#x3D;pHead-&gt;next;</span><br><span class="line">                prev&#x3D;prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return virtualHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试用例:{1,1,1,1,1,1,1}</p><p>对应输出应该为:</p><h2 id="54-字符流中第一个不重复的字符">54.字符流中第一个不重复的字符</h2><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。  如果当前字符流没有存在出现一次的字符，返回#字符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  &#x2F;&#x2F;Insert one char from stringstream</span><br><span class="line">    void Insert(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!array[ch])</span><br><span class="line">            ique.push(ch);</span><br><span class="line">        array[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;return the first appearence once char in current stringstream</span><br><span class="line">    char FirstAppearingOnce()</span><br><span class="line">    &#123;</span><br><span class="line">        while(!ique.empty() &amp;&amp; array[ique.front()]&gt;1)&#123;</span><br><span class="line">            ique.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        if(!ique.empty())</span><br><span class="line">            return ique.front();</span><br><span class="line">        return &#39;#&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int array[256]&#x3D;&#123;0&#125;;</span><br><span class="line">    queue&lt;char&gt; ique;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="55-链表中环的入口结点">55.链表中环的入口结点</h2><blockquote><p>一个链表中包含环，请找出该链表的环的入口结点。</p></blockquote><p>分析：http://wuchong.me/blog/2014/03/25/interview-link-questions/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pHead || !pHead-&gt;next)</span><br><span class="line">            return nullptr;</span><br><span class="line">        ListNode* fast&#x3D;pHead,*slow&#x3D;pHead;</span><br><span class="line">        while(fast-&gt;next &amp;&amp; slow)&#123;</span><br><span class="line">            fast&#x3D;fast-&gt;next-&gt;next;</span><br><span class="line">            slow&#x3D;slow-&gt;next;</span><br><span class="line">            if(fast&#x3D;&#x3D;slow)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(fast!&#x3D;slow)</span><br><span class="line">            return nullptr;</span><br><span class="line">        fast&#x3D;pHead;</span><br><span class="line">        while(fast!&#x3D;slow)&#123;</span><br><span class="line">            fast&#x3D;fast-&gt;next;</span><br><span class="line">            slow&#x3D;slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="56-删除链表中重复的结点">56.删除链表中重复的结点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一个不通过的代码</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pHead || !pHead-&gt;next)</span><br><span class="line">            return pHead;</span><br><span class="line">        ListNode* vHead&#x3D;new ListNode(0);</span><br><span class="line">        vHead-&gt;next&#x3D;pHead;</span><br><span class="line">        ListNode* pre&#x3D;vHead;</span><br><span class="line">        ListNode* cur&#x3D;pHead;</span><br><span class="line">        int temp;</span><br><span class="line">        while(cur &amp;&amp; cur-&gt;next)&#123;</span><br><span class="line">             ListNode* next&#x3D;cur-&gt;next;</span><br><span class="line">            if(cur-&gt;val&#x3D;&#x3D;next-&gt;val)&#123;   &#x2F;&#x2F;原因是这个相等的处理有问题，没有考虑一直是同一个值的处理</span><br><span class="line">                temp&#x3D;cur-&gt;val;</span><br><span class="line">                cur&#x3D;next-&gt;next;</span><br><span class="line">                pre-&gt;next&#x3D;cur;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(next-&gt;val&#x3D;&#x3D;temp)&#123;</span><br><span class="line">                cur-&gt;next&#x3D;next-&gt;next;</span><br><span class="line">                pre-&gt;next&#x3D;cur;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(next-&gt;next)&#123;</span><br><span class="line">                    pre&#x3D;cur;</span><br><span class="line">                    cur&#x3D;next;</span><br><span class="line">                  &#x2F;&#x2F;  next&#x3D;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">               else</span><br><span class="line">                    return vHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;一个通过了的代码</span><br><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pHead || !pHead-&gt;next)</span><br><span class="line">            return pHead;</span><br><span class="line">        ListNode* vHead&#x3D;new ListNode(-1);</span><br><span class="line">        vHead-&gt;next&#x3D;pHead;</span><br><span class="line">        ListNode* pre&#x3D;vHead;</span><br><span class="line">        ListNode* cur&#x3D;pHead;</span><br><span class="line">        while(cur &amp;&amp; cur-&gt;next)&#123;</span><br><span class="line">            ListNode* next&#x3D;cur-&gt;next;</span><br><span class="line">            if(cur-&gt;val&#x3D;&#x3D;next-&gt;val)&#123;</span><br><span class="line">                int val&#x3D;cur-&gt;val;</span><br><span class="line">                while(cur &amp;&amp; cur-&gt;val&#x3D;&#x3D;val)  &#x2F;&#x2F;一直遍历到不为当前值为止</span><br><span class="line">                    cur&#x3D;cur-&gt;next;</span><br><span class="line">                pre-&gt;next&#x3D;cur;</span><br><span class="line">                cur&#x3D;pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                pre&#x3D;pre-&gt;next;</span><br><span class="line">                cur&#x3D;cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;递归解决</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead&#x3D;&#x3D;nullptr || pHead-&gt;next&#x3D;&#x3D;nullptr)</span><br><span class="line">            return pHead;</span><br><span class="line">        ListNode* current&#x3D;pHead;</span><br><span class="line">        if(pHead-&gt;val&#x3D;&#x3D;pHead-&gt;next-&gt;val)&#123;</span><br><span class="line">            current&#x3D;pHead-&gt;next-&gt;next;</span><br><span class="line">            while(current!&#x3D;nullptr &amp;&amp; current-&gt;val&#x3D;&#x3D;pHead-&gt;val)</span><br><span class="line">                current&#x3D;current-&gt;next;</span><br><span class="line">            return deleteDuplication(current);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        else&#123;</span><br><span class="line">            current&#x3D;pHead-&gt;next;</span><br><span class="line">            pHead-&gt;next&#x3D;deleteDuplication(current);</span><br><span class="line">            return pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="57-二叉树的下一个结点">57.二叉树的下一个结点</h2><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></blockquote><p>分析二叉树的下一个节点，一共有以下情况：1.二叉树为空，则返回空；2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p><h2 id="58-对称的二叉树">58.对称的二叉树</h2><h2 id="59-按之字形顺序打印二叉树">59.按之字形顺序打印二叉树</h2><h2 id="60-把二叉树打印成多行">60.把二叉树打印成多行</h2><h2 id="61-序列化二叉树">61.序列化二叉树</h2><h2 id="62-二叉搜索树的第k个结点">62.二叉搜索树的第k个结点</h2><h2 id="63-数据流中的中位数">63.数据流中的中位数</h2><h2 id="64-滑动窗口的最大值">64.滑动窗口的最大值</h2><h2 id="65-矩阵中的路径">65.矩阵中的路径</h2><h2 id="66-机器人的运动范围">66.机器人的运动范围</h2>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《redis 设计与实现》--总结</title>
      <link href="/2018/06/19/interview/redis_sum/"/>
      <url>/2018/06/19/interview/redis_sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Redis设计与实现，以及关于Redis使用的总结</p></blockquote><a id="more"></a><h2 id="1-数据结构与对象">1.数据结构与对象</h2><h3 id="1-简单动态字符串">1.简单动态字符串</h3><p>Redis自己构建了简单动态字符串(Simple Dynamic String,SDS)来作为默认的字符串表示。<br>SDS的构造如下：<img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180619151556.png"/>优势是：</p><ol><li>能够在常数时间内获取字符串的长度-通过len属性</li><li>能够杜绝缓冲区溢出：记录了缓冲区的大小，在长度不够时，能够自动扩展空间</li><li>减少修改字符串时带来的内存重新分配次数：采用空间预分配和惰性空间释放</li></ol><h3 id="2-链表">2.链表</h3><p>Redis自己实现了链表。拥有以下特性：双端无环、带表头指针和表尾指针、带链表长度计数器、多态(使用void* 保存节点值)</p><h3 id="3-字典">3.字典</h3><p>Redis字典底层采用哈希表实现。采用MurmurHash2算法，解决键冲突的方式是：链地址法。<br>哈希表的扩展与收缩：以下条件满足时：</p><ol><li>服务器没有执行BGSAVE或BGREWRITEAOF命令，哈希表负载因子&gt;1</li><li>服务器在执行BGSAVE或BGREWRITEAOF命令，哈希表负载因子&gt;5</li></ol><h3 id="4-跳跃表">4.跳跃表</h3><p>Redis采用跳跃表作为有序集合键的底层数据结构，另：在集群节点中用作内部数据结构<br>跳跃表：一种有序数据结构，通过在一个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。支持平均O(logN),最差O(N)复杂度的查找。Redis中跳跃表的实现：</p><div align="center"> <img src="https://blog-1252063226.cosbj..com/network/20180619154918.png" /> </div><br>其中包括表头和表尾节点，length记录节点的数量，level用于获取跳跃表中层高最大的那个节点的层数量 （表头节点的层高不计算在内）    <h3 id="5-整数集合">5.整数集合</h3><p>Redis中集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合中元素的数量不多时，就会使用整数集合作为集合键的底层实现。<br>整数集合的升级策略：能够提高整数集合的灵活性，并且能够尽可能的节约内存。升级后不支持降级</p><h3 id="6-压缩列表">6.压缩列表</h3><p>Redis中列表键和哈希键的底层实现之一。</p><h3 id="7-对象">7.对象</h3><p>Redis使用上述的数据结构创建了一个对象系统。包括：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。其实这就是一直说的Redis五种数据结构：字符串、列表、字典、集合、有序集合。</p><h2 id="2-单机数据库的实现">2.单机数据库的实现</h2><h3 id="数据库">数据库</h3><p>Redis服务器讲所有数据库保存在一个db数组中，默认创建16个数据库。<br>切换数据库:<code>select 0 #选择0号数据库</code></p><h4 id="数据库键空间">数据库键空间</h4><p>键空间的键也是数据库的键。每个键都是一个字符串对象。<br>键空间的值也是数据库的值，每个值可以是字符串对象、列表对象、哈希对象、集合对象，有序集合对象中的任意一个Redis对象。<br>一个键空间的例子：</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180619162843.png" /> </div><br><h4 id="设置键的生存时间或过期时间">设置键的生存时间或过期时间</h4><p>原理是：过期时间是一个UNIX时间戳，当键的过期时间来临是，服务器就会自动从数据库中删除一个键。<br>命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">expire &lt;key&gt; &lt;ttl&gt;  #key的生存时间为ttl秒</span><br><span class="line">pexpire &lt;key&gt; &lt;ttl&gt;  #key的生存时间为ttl毫秒</span><br><span class="line">expireat &lt;key&gt; &lt;timestamp&gt;  #key的生存时间直到timestamp指定的时间戳s</span><br><span class="line">pexpireat &lt;key&gt; &lt;timestamp&gt;  #key的生存时间直到timestamp指定的时间戳ms</span><br><span class="line"></span><br><span class="line">persist &lt;key&gt;  #移除key的过期时间</span><br><span class="line">ttl &lt;key&gt;   #计算key的剩余生存时间</span><br></pre></td></tr></table></figure><p>setex命令可以设置一个字符串键的同时为键设置过期时间。一个带有过期字典的数据库例子：（实际中，键空间的键和过期字典中的键都指向同一个键对象）</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180619163748.png" /> </div><br><h4 id="过期键删除策略">过期键删除策略</h4><ul><li>定时删除： 内存最友好，CPU时间最不友好</li><li>惰性删除：CPU时间友好，内存不友好</li><li>定期删除：折中Redis实际使用：惰性删除和定期删除配合使用。</li></ul><h4 id="过期键的处理">过期键的处理</h4><ol><li>RDB文件：生成RDB文件：已过期的键不会保存到新创建的RDB文件中，因此对生成新的RDB文件没有影响。载入RDB文件：主服务器模式时，过期键不会被载入。从服务器模式时，都会被载入，但同步后，从服务器数据会被清空，所以也没有影响。</li><li>AOF文件：AOF写入：如果某个键已经过期，但没有被删除，AOF文件不会因为这个过期键产生任何影响。如果已经删除，AOF文件会追加一条DEL命令显式记录该键已被删除。<br>AOF重写：已过期的键不会被保存到重写的AOF文件。</li><li>复制：<br>主服务器删除一个过期键，会显示向所有的从服务器发送DEL命令，告知删除。<br>从服务器遇到过期的键也不会删除。只有接收到DEL命令后才会删除过期键。</li></ol><h3 id="rdb持久化">RDB持久化</h3><p>通过保存数据库中的键值对来记录数据库状态不同。<br>功能：将Redis在内存中的数据库状态保存到磁盘中，避免数据意外丢失。RDB文件是一个经过压缩的二进制文件，保存在硬盘中，因此Redis进程退出，只要RDB文件仍在，就可以用来还原数据库的状态。</p><h4 id="rdb文件的创建和载入">RDB文件的创建和载入</h4><p>服务器在载入RDB文件期间，会一直阻塞。<br>SAVE命令由服务器进程执行保存工作，因此会阻塞服务器。BGSAVE命令由子进程执行保存工作。</p><h4 id="自动间隔性保存">自动间隔性保存</h4><p>设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save 900 1  # 900s内发生了至少一次修改</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">满足上述一个条件，BASAVE就会执行。</span><br></pre></td></tr></table></figure><h4 id="rdb文件结构">RDB文件结构</h4><table><thead><tr><th style="text-align:center">头部</th><th style="text-align:center">数据库版本</th><th style="text-align:center">数据</th><th style="text-align:center">正文结束符</th><th style="text-align:center">校验和</th></tr></thead><tbody><tr><td style="text-align:center">REDIS</td><td style="text-align:center">db_version</td><td style="text-align:center">databases</td><td style="text-align:center">EOF</td><td style="text-align:center">check_sum</td></tr></tbody></table><h3 id="aof持久化-append-only-file">AOF持久化(Append Only File)</h3><p>通过保存Redis服务器所执行的写命令来记录数据库状态。</p><h4 id="aof持久化的实现过程">AOF持久化的实现过程</h4><p>命令追加:将内容追加到aof_buf缓冲区的末尾。<br>写入与同步：服务器每次结束一个时间循环之前，都会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区中的内容写入和保存到AOF文件中。选项值为：alwals,everysec,no<br>载入与数据还原：还原过程：创建一个不带网络连接的伪客户端；从AOF文件中分析并读取一条写命令；使用伪客户端执行被读出的写命令；循环处理。</p><h4 id="aof重写">AOF重写</h4><p>目的：解决AOF文件体积膨胀。<br>实现原理：从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。后台重写：子进程AOF重写期间，服务器进程可以继续处理命令请求。<br>后台重写问题：子进程重写期间，服务器还需要处理命令请求，可能导致服务器当前数据库状态和重写后的AOF文件所保存的数据库状态不一致。解决办法：AOF重写缓冲区。</p><h3 id="事件">事件</h3><h4 id="文件事件">文件事件</h4><p>文件事件处理器。基于Reactor模式，使用IO多路复用程序同时监听多个套接字。</p><h2 id="3-多机数据库的实现">3.多机数据库的实现</h2><h2 id="4-独立功能的实现">4.独立功能的实现</h2><h2 id="常见问题">常见问题</h2><h3 id="aof和rdb比较">AOF和RDB比较</h3><ul><li>两者区别：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li><li>优缺点：RDB：灵活设置备份频率和周期。方便灾难恢复，可以轻松的将一个单独的文件压缩再转移到其他存储介质上。性能最大化。数据集很大时，启动效率相对AOF较高。缺点：很难保证高可用，可能数据在写入磁盘之前会丢失。数据集较大时，可能导致服务器停止服务。<br>AOF：数据持久性。对日志的写入操作采用的是append模式，写入过程即使出现宕机，也不会破坏日志文件中已经存在的内容。如果日志过大，Redis可以自动启用rewrite机制。包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。缺点：RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。根据同步策略的不同，AOF在运行效率上往往会慢于RDB。</li></ul><h3 id="redis分布式锁">Redis分布式锁</h3><p>使用setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。<br>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？<br>同时把setnx和expire合成一条指令来用</p><h3 id="寻找key">寻找key</h3><p>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>用keys指令可以扫出指定模式的key列表。<br>redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="redis同步机制">Redis同步机制</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h3 id="redis相比memcached有哪些优势">redis相比memcached有哪些优势</h3><ol><li>丰富的数据类型</li><li>速度快</li><li>可以持久化<br>区别：</li><li>存储方式：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。</li><li>数据类型：Memcache对数据类型支持相对简单。Redis有复杂的数据类型,Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>底层模型：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value大小：redis最大可以达到1GB，而memcache只有1MB。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ol><h3 id="redis的lru算法">Redis的LRU算法</h3><p>最近最久未用算法。当内存达到限制时，Redis 具体的回收策略是通过 maxmemory-policy 配置项配置的。<br>no-eviction：不清除数据，只是返回错误，这样会导致浪费掉更多的内存，对大多数写命令（DEL 命令和其他的少数命令例外）allkeys-lru：从所有的数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，以供新数据使用volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰，以供新数据使用allkeys-random：从所有数据集（server.db[i].dict）中任意选择数据淘汰，以供新数据使用volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰，以供新数据使用volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，以供新数据使用</p><h3 id="redis常见的性能问题及解决">Redis常见的性能问题及解决</h3><ol><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件. 特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li><li>尽量避免在压力很大的主库上增加从库。</li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li><li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</li></ol><h3 id="适合redis的场景">适合Redis的场景</h3><ol><li>会话缓存 全页缓存   队列 排行榜/计数器  发布/订阅  会话  购物车</li></ol><h3 id="nosql和key-value数据库">Nosql和Key-Value数据库</h3><p>NoSQL，泛指非关系型的数据库，全称Not Only SQL，意即“不仅仅是SQL”。<br>NoSQL数据库的四大家族：</p><ol><li>键值（Key-Value）数据库:Redis、Memcached</li><li>面向文档（Document-Oriented）数据库:MongoDB  适用：日志、分析</li><li>列存储（Wide Column Store/Column-Family）数据库  HBase 适用:日志、博客平台</li><li>图（Graph-Oriented）数据库 适用：关系性强，推荐引擎</li></ol><h3 id="redis最大连接数">Redis最大连接数</h3><p>默认10000</p><h3 id="redis的瓶颈">redis的瓶颈</h3><h3 id="redis-主从复制">Redis 主从复制</h3><h4 id="redis-复制功能">Redis 复制功能</h4><h3 id="redis的定时机制怎么实现的-有哪些弊端-你将如何改进这个弊端">Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端</h3><h3 id="redis是单线程的-为什么这么高效-我用了对比的方式说-举例apache和nginx-一个多线程-一个io多路复用">Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用</h3><h3 id="redis的数据类型有哪些-底层怎么实现-跳跃表-哈希表-整数集合等等">Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等</h3><h3 id="redis的rehash怎么做的-为什么要渐进rehash-渐进rehash怎么实现的">Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的</h3><h3 id="redis和memcached的区别-redis为什么可以组集群">Redis和memcached的区别，Redis为什么可以组集群</h3><h2 id="reference：">Reference：</h2><p>https://www.bookstack.cn/read/note-of-interview/framework-redis.md<br>http://www.techug.com/post/nosql.html</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Redis </tag>
            
            <tag> Nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu自动push到github脚本</title>
      <link href="/2018/05/24/Tools/shell_autopush/"/>
      <url>/2018/05/24/Tools/shell_autopush/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于人比较懒，总是忘了自己提交到github上，也觉得博客好不容易写了还要打开文件夹，点一下交，这个体验有点差呀。于是就写了个Linux自动提交代码的和windows自动更新博客的。</p></blockquote><a id="more"></a><h2 id="linux编写shell脚本">Linux编写shell脚本</h2><h3 id="脚本代码">脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">path&#x3D;~&#x2F;github&#x2F;</span><br><span class="line"></span><br><span class="line">git_push()&#123;</span><br><span class="line">    echo &quot;开始push&quot;</span><br><span class="line">    modify_time&#x3D;&#96;stat -c %Y $&#123;1&#125;&#96;</span><br><span class="line">    this_time&#x3D;&#96;date +%s&#96;</span><br><span class="line"></span><br><span class="line">    cd $&#123;1&#125;</span><br><span class="line">    echo &quot;-------切换目录------&quot;</span><br><span class="line">    echo &#96;pwd&#96;</span><br><span class="line">    echo &quot;---------------------&quot;</span><br><span class="line">    if [ $[ $&#123;modify_time&#125;-$&#123;this_time&#125; ] -gt 86400 ];</span><br><span class="line">    then</span><br><span class="line">         echo &quot;$&#123;1&#125; 文件夹 有变化，正在准备push...&quot;</span><br><span class="line">        date&#x3D;&#96;date &quot;+%Y-%m-%d %H:%M:%S&quot;&#96;</span><br><span class="line">        git add .    </span><br><span class="line">        git commit -m &quot;automatic push @$(date)&quot;</span><br><span class="line">        echo &quot;git fetch origin master&quot;</span><br><span class="line">        git fetch origin master</span><br><span class="line"></span><br><span class="line">        echo &quot;git merge origin&#x2F;master&quot;</span><br><span class="line">        git merge origin&#x2F;master</span><br><span class="line"></span><br><span class="line">        echo &quot;git push origin master:master&quot;</span><br><span class="line">        git push origin master:master</span><br><span class="line">         </span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">git_push ~&#x2F;github&#x2F;Linux_pro</span><br><span class="line">git_push ~&#x2F;github&#x2F;miniweb</span><br></pre></td></tr></table></figure><h3 id="加入定时任务">加入定时任务</h3><h3 id="编辑定时任务文件">编辑定时任务文件</h3><p>(https://blog.csdn.net/xiyuan1999/article/details/8160998)<code>crontab -e</code>在文件的末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 5 * * * &#x2F;home&#x2F;mianhk&#x2F;shell&#x2F;auto_push.sh  表示在每天的 5.30执行</span><br></pre></td></tr></table></figure><h3 id="启动服务">启动服务</h3><p><code>/etc/init.d/cron start</code></p><h2 id="windows自动提交博客">Windows自动提交博客</h2><p>其实windows的也差不多，写一个bat的脚本，然后加到系统的定时任务里面</p><h3 id="代码如下">代码如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">title 同步博客到远端——余国聪</span><br><span class="line">color 16</span><br><span class="line"></span><br><span class="line">echo;</span><br><span class="line">echo;</span><br><span class="line"></span><br><span class="line">echo 切换目录到blog</span><br><span class="line">f:</span><br><span class="line">cd \github\mianhk</span><br><span class="line">cd .\blog</span><br><span class="line">echo clean</span><br><span class="line"></span><br><span class="line">hexo g -d</span><br><span class="line"></span><br><span class="line">echo 切换到GitHub备份目录</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">echo 开始提交代码到本地仓库</span><br><span class="line">echo 当前目录是：%cd%</span><br><span class="line"></span><br><span class="line">echo 开始添加变更</span><br><span class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">git add -A .</span><br><span class="line">echo 执行结束！</span><br><span class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">echo;</span><br><span class="line">echo 提交变更到本地仓库</span><br><span class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">set declation&#x3D;%date:~0,4%%date:~5,2%%date:~8,2%</span><br><span class="line">git commit -m &quot;%declation%同步博客&quot;</span><br><span class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">echo;</span><br><span class="line">echo 将变更情况提交到远程git服务器</span><br><span class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">git push origin master</span><br><span class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">echo;</span><br><span class="line">echo 批处理执行完毕！</span><br><span class="line">echo;</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="添加到自动任务">添加到自动任务</h3><p>计算机-&gt;管理-&gt;任务计划程序-&gt;添加任务即可</p><p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=174pin6hqb074</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter-notebook安装和问题解决</title>
      <link href="/2018/04/26/tools/use_of_jupyter/"/>
      <url>/2018/04/26/tools/use_of_jupyter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>jupyter notebook折腾日记</p></blockquote><a id="more"></a><h1 id="安装">安装</h1><h2 id="1-采用直接pip安装">1.采用直接pip安装</h2><p><code>pip install jupyter</code>不过可能由于是版本自带的pip有问题，而且用的Python版本也还是2.7的，反正就出现了各种问题。中间解决的有：</p><ul><li>重新升级pip，但是发现直接pip还是有问题，于是找到问题原因，可能名字有点对不上，找到bin目录下还有一个pip2，在Python里面运行，发现果然是这个，有点心酸，还是换了这个。</li><li>升级之后，会出现各种的权限问题，没事，给！</li><li>之后运行，发现没有浏览器，于是又想起服务器上没有，又加上命令试了一下，而且每次都要复制一个长长的token吗？。。</li></ul><h2 id="2-采用anaconda安装">2.采用Anaconda安装</h2><p>正好晚上在床上看到一个链接，说这个更方便，反正也是折腾嘛，就试试了。过程稍微写一写哈</p><ol><li>在清华镜像站找到采用Anaconda相应版本下载：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/<br>找到后复制链接：<code>wget 链接</code></li><li>安装Anaconda:<br><code>sh Anaconda3-5.1.0-Linux-x86_64.sh # 一路yes就装了</code></li><li>服务器管理控制台开放8888端口（当然端口可以配置，也随便换了）</li><li>运行<code>jupyter notebook --generate-config</code> 生成默认的jupyter配置文件</li><li>编辑config文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd .jupyter</span><br><span class="line">vim jupyter_notebook_config.py #编辑config文件</span><br><span class="line">c.NotebookApp.ip &#x3D; &#39;*&#39;  #允许所有的ip登录</span><br><span class="line">c.NotebookApp.open_browser &#x3D; False #打开浏览器：关闭，因为服务器没有浏览器</span><br><span class="line">c.NotebookApp.port &#x3D; 8888  #开放使用的端口</span><br></pre></td></tr></table></figure><ol start="6"><li>保存退出。运行jupyter notebook，会得到一个带token的访问地址。复制地址，将其中的localhost替换成服务器的公网IP，访问，应该可以正常进入jupyter。</li><li>每次都tocken当然有点麻烦了。设置一个密码吧：<br><code>jupyter-notebook password</code></li><li>之后就可以公网输入登录了。</li></ol><h2 id="3-安装主题和相关插件">3.安装主题和相关插件</h2><p><a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="noopener">jupyter_contrib_nbextensions</a><br>直接使用<code>conda install -c conda-forge jupyter_contrib_nbextensions</code></p><ul><li>使用注意：1.关于ubuntu的环境变量设置没有对，导致conda命令不能用的问题。当然知道应该是环境变量的问题，不过还是搞了很久。才发现是加在ubuntu的home目录下的<code>.bashrc</code>后面<code>export PATH=~/anaconda3/bin:$PATH</code>2.由于我的conda版本没有更新，所以出现了插件也只有几个的情况，所以需要先更新。之后再重启jupyter notebook。</li></ul><h4 id="参考">参考</h4><p>http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/<br>https://zhuanlan.zhihu.com/p/34289322<br>https://zhuanlan.zhihu.com/p/20226040?utm_source=qq&amp;utm_medium=social&amp;utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 工具 </tag>
            
            <tag> jupyter </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常折腾日记</title>
      <link href="/2018/04/25/tools/daily_zheteng/"/>
      <url>/2018/04/25/tools/daily_zheteng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>俗话说，生活就是不断的折腾，恰好自己是个这样的人。可能就是这样一个虽然不是很年轻了，但是心态总是年轻的，看到一些有趣的或者有意思的，总是忍不住想看看，或者试试。但是有时候又觉得自己不再年轻了，有些东西虽然当时记着了，但是后来又忘了，或者有时候记着又找起来很耽误时间。所以就在这记录一下吧。</p></blockquote><a id="more"></a><h2 id="博客相关">博客相关</h2><p><a href="https://zhuanlan.zhihu.com/p/28128674" target="_blank" rel="noopener">hexo博客插件</a><a href="http://www.yuguocong.me/10-%E5%B7%A5%E5%85%B7/%E6%88%91%E7%9A%84hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">我的博客折腾</a><a href="http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/" target="_blank" rel="noopener">自动构建博客</a><a href="https://www.cnblogs.com/tengj/p/5357879.html" target="_blank" rel="noopener">hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌）</a></p><h2 id="linux">Linux</h2><p><a href="http://www.yuguocong.me/26-%E5%B7%A5%E5%85%B7/use_of_jupyter/" target="_blank" rel="noopener">jupyter</a></p><ul><li><a href="https://www.cnblogs.com/kevingrace/p/6496899.html" target="_blank" rel="noopener">tmux的使用</a></li><li><a href="https://github.com/kxxoling/blog/blob/master/tool/tmux.md" target="_blank" rel="noopener">tmux的使用2</a></li></ul><h2 id="sublime-text">Sublime Text</h2><h2 id="娱乐">娱乐</h2><p>vip视频：https://github.com/laidefa/Flask_Web_Vip：  http://101.37.147.236:1518/</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text3使用总结</title>
      <link href="/2018/04/24/tools/use-of-sublime/"/>
      <url>/2018/04/24/tools/use-of-sublime/</url>
      
        <content type="html"><![CDATA[<p>update:</p><ul><li>2018-04-24 首次更新:突然发现Sublime Text3也还是挺好用的，之前切出去光标总是乱跳，就有点烦，以为是这样的就没管，用了网易云，没想到发现只有我的是这样，赶紧找找问题，解决一下。顺便把很多重新折腾一下。</li></ul><p>#用好sublime</p><h3 id="为sublime-text3添加插入当前时间的命令"><a href="https://www.cnblogs.com/jiafeimao-dabai/p/7238357.html" target="_blank" rel="noopener">为Sublime Text3添加插入当前时间的命令</a></h3><ol><li>创建插件：</li></ol><p>Tools → New Plugin:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">import sublime_plugin</span><br><span class="line">class AddCurrentTimeCommand(sublime_plugin.TextCommand):</span><br><span class="line">    def run(self, edit):</span><br><span class="line">        self.view.run_command(&quot;insert_snippet&quot;, </span><br><span class="line">            &#123;</span><br><span class="line">                &quot;contents&quot;: &quot;%s&quot; % datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) </span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>保存为Sublime Text3\Packages\User\addCurrentTime.py</p><ol start="2"><li>创建快捷键：</li></ol><p>Preference → Key Bindings - User:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;command&quot;: &quot;add_current_time&quot;,</span><br><span class="line">        &quot;keys&quot;: [</span><br><span class="line">            &quot;ctrl+shift+.&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="添加了一个主题https-packagecontrol-io-packages-predawn：predawn"><a href="">添加了一个主题</a>https://packagecontrol.io/packages/Predawn：Predawn</h3><h3 id="其他链接">其他链接</h3><p>小土刀博客：http://wdxtub.com/2016/03/24/sublime-guide/</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 折腾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活随笔</title>
      <link href="/2018/04/24/Random/life_random/"/>
      <url>/2018/04/24/Random/life_random/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生活有时候看的一些书，一些视频，有些想法，专门找个文件记录一下吧。</p></blockquote><a id="more"></a><h3 id="update-2018-07-17-19-22-01-周二">update:2018-07-17 19:22:01 周二</h3><p>看了个视频：https://www.youtube.com/watch?v=jbUJGkM4Ksk 成长型思维和固定型思维。虽然看名字有点鸡汤了，但是确实很久都忘了这些了。</p><p>可能已经不像很久以前那样了，什么都不怕，能够不问结果的去做很多事情，现在考虑的很多，也更想着用一些以前的思路去考虑问题，却忘了自己本来的优势了。</p><p>1.了解大脑可塑性 2.以过程为焦点 3.尝试做有挑战性的事情</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阶段性生活思考</title>
      <link href="/2018/04/24/Random/redo-mylife/"/>
      <url>/2018/04/24/Random/redo-mylife/</url>
      
        <content type="html"><![CDATA[<h2 id="why-title">why title</h2><blockquote><p>生活就是要不断的思考,不是吗?</p></blockquote><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180624112358.png" /> </div><br><a id="more"></a>### update:2018-05-13 21:15:04 周日突然觉得很久没思考自己的生活了。      - 1.做事情注意力不集中。最近虽然看起来学习态度要好一些，每天都是待在实验室，但是学习的效率却感觉没有以前高了。而且总是注意力不够集中，明明在该学习的时候，却看看这个看看那个。做这个的时候看看想起另外一件事，就去看看，结果就该做的事情没做好。看看论文就想玩玩手机，玩着又有点愧疚就去看看c++，总是三心二意的。  - 2.不太爱思考。另一个问题就是，遇到问题不求甚解。这还是以前的老问题吧，对于以前的应试教育来说，可能里面的道理也不用太深究，毕竟能最后写在试卷上就行了，看起来还能有个差不多好看的分数。但是现在处于的阶段不一样了，不管是日常的工作学习，还是平时看到一些新闻的想法，这都会有一些问题。当然，这方面可能手机因素也比较大一点，有很多的观点唾手可得，找找资料就能看到很多东西，恰好这方面自己又比较擅长，于是就又陷入了找资料不思考的陷阱。这样虽然有时候找到了很多有价值的东西，平时看到了很多，说吧，都知道，但是具体的就是不清楚，更别谈再有所新的想法了。所以这是个重要的问题。  - 3.做事情应该更有目的。就是可能现在感觉很忙，但是却没有个统一的目的，有时候花的时间是多了，但是却没有很好的效果。  <h3 id="update-2018-05-30-20-21-01-周三">update:2018-05-30 20:21:01 周三</h3><ul><li>学习方面稍微集中了一点，但是还是没有太专注。</li><li>做事情还是要抓住重点，仍然需要注意。</li><li>多多总结。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文总结计算机网络</title>
      <link href="/2018/04/10/interview/interview_network/"/>
      <url>/2018/04/10/interview/interview_network/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近一直在看网络编程的东西，不管是看书、还是一些博客，或者是自己的一些编程，都觉得写的有点乱，有点杂。虽然这也比较符合网络方面的特点，零碎的知识点，有些人觉得重要就写上了，另一些就没有写。想到将来可能跟网络编程接触很多，也觉得最近的学习就是缺少一些总结。就在这里站在大佬的肩膀上整理一下吧。</p></blockquote><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/350px-UDP_encapsulation.svg.png" /> </div><br><a id="more"></a><h1 id="计算机网络体系结构-tcp-ip四层模型">计算机网络体系结构（TCP/IP四层模型）</h1><p>一般所说的计算机体系结构分为三种，其中TCP/IP体系结构是实际应用较多的。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/001.png" width="500"/> </div><br>## 各层的作用以及协议### OSI七层协议表示层和会话层用途如下：1. 表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩；2. 会话层：不同机器上的用户之间建立及管理会话。<h3 id="五层模型">五层模型</h3><ol><li>应用层：为特定应用程序提供数据传输服务，例如 http、DNS 等。数据单位为报文。</li><li>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li>网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</li><li>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。</li><li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ol><h3 id="tcp-ip四层模型">TCP/IP四层模型</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/010.png" width="400"/> </div><br>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。<div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/011.png" width="400"/> </div><br>### 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。<div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/012.jpg" width="600"/> </div><br># 网络接口层（TCP/IP）对应OSI七层协议的数据链路层和物理层。在实际的编程中，一般对底层关注的更少，作为长期从事物理层和数据链路层相关工作的通信工程本来觉得可以稍微发挥一下的，咳咳。## 物理层* 传输数据的单位--比特* 数据传输系统：源系统（源点、发送器） --> 传输系统 --> 目的系统（接收器、终点）<p>通道：</p><ul><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li><li>双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul><p>通道复用技术：</p><ul><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul><h2 id="数据链路层">数据链路层</h2><h3 id="主要信道：">主要信道：</h3><ul><li>点对点信道</li><li>广播信道</li></ul><h4 id="点对点信道">点对点信道</h4><ul><li>数据单元–帧</li></ul><p>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</p><h4 id="广播信道">广播信道</h4><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h3 id="三个基本问题">三个基本问题</h3><h4 id="封装成帧">封装成帧</h4><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/013.jpg" width="400"/> </div><br>#### 透明传输透明表示一个实际存在的事物看起来好像不存在一样。帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符，如果出现转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。<div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/014.jpg" width="400"/> </div><br>#### 差错检测目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。# 网络层网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。网络层协议有：* IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。* ARP（Address Resolution Protocol，地址解析协议）* ICMP（Internet Control Message Protocol，网际控制报文协议）* IGMP（Internet Group Management Protocol，网际组管理协议）<h2 id="ip-网际协议">IP 网际协议</h2><h3 id="ip-地址分类：">IP 地址分类：</h3><ul><li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li></ul><table><thead><tr><th>IP 地址类别</th><th>网络号</th><th>网络范围</th><th>主机号</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A 类</td><td>8bit，第一位固定为 0</td><td>0 —— 127</td><td>24bit</td><td>1.0.0.0 —— 127.255.255.255</td></tr><tr><td>B 类</td><td>16bit，前两位固定为  10</td><td>128.0 —— 191.255</td><td>16bit</td><td>128.0.0.0 —— 191.255.255.255</td></tr><tr><td>C  类</td><td>24bit，前三位固定为  110</td><td>192.0.0 —— 223.255.255</td><td>8bit</td><td>192.0.0.0 —— 223.255.255.255</td></tr><tr><td>D  类</td><td>前四位固定为 1110，后面为多播地址</td><td></td><td></td><td></td></tr><tr><td>E  类</td><td>前五位固定为 11110，后面保留为今后所用</td><td></td><td></td><td></td></tr></tbody></table><h3 id="ip-数据报格式：">IP 数据报格式：</h3><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/015.jpg" width="500"/> </div><br>-  **版本**  : 有 4（IPv4）和 6（IPv6）两个值；-  **首部长度**  : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。-  **区分服务**  : 用来获得更好的服务，一般情况下不使用。-  **总长度**  : 包括首部长度和数据部分长度。-  **标识**  : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。-  **片偏移**  : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。<div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/016.jpg" width="500"/> </div><br>-  **生存时间**  ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。-  **协议** ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。-  **首部检验和** ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。<h3 id="arp-rarp-地址解析协议-反向地址转化协议">ARP/RARP 地址解析协议/反向地址转化协议</h3><h4 id="地址解析协议">地址解析协议:</h4><ul><li>在数据报向下一个站点传递时，负责将IP地址转换为物理地址。</li><li>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接受返回消息，以此确定目标的物理地址；接收的返回消息后将该IP地址和物理地址存入本机并保留一段时间，下次请求时直接查询ARP缓存以节约时间。（地址解析协议是IPV4中广泛使用的协议；但在IPV6中不存在该协议，使用NDP（邻居发现协议））</li><li>工作流程：当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址解析为主机B的MAC（物理）地址。ARP缓存是一个用来存储IP地址和MAC地址的一个缓冲区，其本质是一个IP地址对应一个MAC地址。当地址解析协议在查询IP时，首先在ARP缓存中查看，若存在则返回，否则发送ARP请求；地址解析协议是通过报文工作的。报文包括如下字段：硬件类型，协议类型，硬件地址长度，协议长度，操作类型。</li><li>APR缓存包含一个或多个表，他们用于存储IP地址及经过地址解析的MAC地址。ARP命令用于查询本机的ARP缓存中的IP到MAC地址的对应关系、添加或删除静态对应关系等。如果再没有参数的情况下ARP命令将显示帮助信息。</li><li>ARP-a 查看缓存中的所有项目，在Linux中命令式ARP-g;</li></ul><h4 id="反向地址转化协议">反向地址转化协议:</h4><ul><li>作用于ARP相反，负责将物理层地址转换为IP地址</li><li>反向地址转化协议，作用于ARP相反，负责将物理层地址转换为IP地址；允许局域网物理机器从网关服务器的ARP表或缓存上请求主机的IP地址；当设置一台新机器时，其RARP客户机程序需要向路由器上的RARP服务器请求相应的IP地址。</li><li>ARP是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议，假设知道自己的物理地址但不知道自己的IP地址，这种情况就该使用RARP协议。RARP工作方式与ARP相反，RARP发出需要反向解析的MAC地址，并且希望返回其对应的IP地址，应答包括由能提供信息的RARP服务器发出的IP地址。</li><li>工作流程：从网卡读取自己的MAC地址—&gt;发送RARP请求的广播数据包—&gt;RARP服务器收到请求，为其分配IP地址，并将RARP回应发送给该机器—&gt;该机器收到IP地址后，使用IP地址进行通信</li></ul><h3 id="icmp-网际控制报文协议">ICMP 网际控制报文协议</h3><p>由于IP协议提供的是一种不可靠的和无连接的数据报服务，为了对IP数据报的传送进行差错控制，对未能完成传送的数据报给出出错的原因，TCP/IP协议簇在网络连层提供了一个用于传递控制报文的ICMP协议，即网际控制报文协议。ICMP 报文格式：</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/017.jpg" width="400"/> </div><br>应用：* PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性    * TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量* Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。<h3 id="igmp-网际组管理协议">IGMP 网际组管理协议</h3><h1 id="运输层">运输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="tcp协议">TCP协议</h2><h3 id="概念：">概念：</h3><p>面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。</p><h3 id="tcp首部格式">TCP首部格式</h3><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/018.jpg" width="500"/> </div><br>- **Source Port和Destination Port**:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接- **Sequence Number**:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401；- **Acknowledgment Number**:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。主要用来解决不丢包的问题。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701；- **Offset**:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；- **TCP Flags**:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：    - URG：此标志表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；    - **确认ACK**：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1；    - PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；    - RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；    - **同步SYN**：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；    - **终止FIN**： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN=1标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。-  **窗口**  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。<h3 id="tcp三次握手和四次挥手">TCP三次握手和四次挥手</h3><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/002.jpg" width="500"/> </div><br>#### TCP三次握手* 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；* 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；* 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。  完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。<h4 id="tcp四次挥手">TCP四次挥手</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的。那对于TCP的断开连接，就是通常说的“四次挥手”。</p><ul><li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，主机1也关闭连接。</li></ul><h4 id="为什么需要三次握手">为什么需要三次握手</h4><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接，解决网络中存在延迟的分组，防止了服务器端的一直等待而浪费资源。</p><blockquote><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。</p></blockquote><h4 id="为什么要四次挥手">为什么要四次挥手</h4><p>TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p><h4 id="tcp的十一种状态">TCP的十一种状态</h4><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/008.png" width="500"/> </div><br>- CLOSED：初始状态。- LISTEN：服务器处于监听状态。- SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。- SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。- ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。- FIN_WAIT_1: 其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）- FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）- CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）- LAST_ACK: 被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）- TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）<h4 id="tcp长连接和短连接">TCP长连接和短连接</h4><h5 id="概念">概念</h5><ul><li>长连接，也叫持久连接，在TCP层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息（包括心跳）交互，直至连接的任意一方（客户端OR服务端）主动断开连接，此过程称为一次完整的长连接。HTTP 1.1相对于1.0最重要的新特性就是引入了长连接。</li><li>短连接，与长连接的区别就是，客户端收到服务端的响应后，立刻发送FIN消息，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互（发请求-收响应）之后立刻断开连接的情况都称为短连接。</li></ul><h5 id="使用场景">使用场景</h5><p>1、需要频繁交互的场景使用长连接，如即时通信工具（微信/QQ，QQ也有UDP），相反则使用短连接，比如普通的web网站，只有当浏览器发起请求时才会建立连接，服务器返回响应后，连接立即断开。2、维持长连接会有一定的系统开销，用户量少不容易看出系统瓶颈，一旦用户量上去了，就很有可能把服务器资源（内存/CPU/网卡）耗尽，所以使用需谨慎。</p><h5 id="快速区分使用的是长连接还是短连接">快速区分使用的是长连接还是短连接</h5><p>1、凡是在一次完整的消息交互（发请求-收响应）之后，立刻断开连接（有一方发送FIN消息）的情况都称为短连接；2、长连接的一个明显特征是会有心跳消息（也有没有心跳的情况），且一般心跳间隔都在30S或者1MIN左右，用wireshark抓包可以看到有规律的心跳消息交互（可能会存在毫秒级别的误差）。</p><h4 id="tcp实现可靠传输">TCP实现可靠传输</h4><ul><li>建立连接（标志位）：通信前确认通信实体存在。</li><li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li><li>数据校验（校验和）：CRC校验全部数据。</li><li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li><li>窗口机制（窗口）：提供流量控制，避免过量发送。</li><li>拥塞控制：同上。</li></ul><h5 id="超时重传">超时重传</h5><p>超时重传机制：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：发送的数据没能到达接收端，所以对方没有响应。接收端接收到数据，但是ACK报文在返回过程中丢失。接收端拒绝或丢弃数据。</p><ul><li>重传间隔(RTO)：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。<ul><li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT…</li><li>重传次数到达上限之后停止重传。</li></ul></li><li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li></ul><h5 id="tcp流量控制"><a href="https://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="noopener">TCP流量控制</a></h5><h6 id="利用滑动窗口实现流量控制">利用滑动窗口实现流量控制</h6><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/007.jpg" width="500"/> </div><br>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><h6 id="考虑传输速率">考虑传输速率</h6><p>可以用不同的机制来控制TCP报文段的发送时机。如：</p><ol><li>TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即TCP支持的推送( push )操作。</li><li>发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</li></ol><p>Nagle算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定：当到达的数据已达到 发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p><p>糊涂窗口综合证：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><h5 id="tcp拥塞控制">TCP拥塞控制</h5><p>拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。控制办法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><h6 id="慢开始和拥塞避免">慢开始和拥塞避免</h6><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/004.jpg" width="500"/> </div><br>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：当 cwnd < ssthresh 时，使用上述的慢开始算法。当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。<p>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/005.jpg" width="500"/> </div><br>1. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。2. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。3. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。<p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><h6 id="快重传和快恢复">快重传和快恢复</h6><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/006.jpg" width="500"/> </div><br>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。与快重传配合使用的还有快恢复算法，其过程有以下两个要点：1. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。2. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。<h5 id="区分流量控制和拥塞控制">区分流量控制和拥塞控制</h5><ul><li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li><li>实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</li></ul><h4 id="tcp黏包问题">TCP黏包问题</h4><ul><li>原因：TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</li><li>解决：</li></ul><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li><li>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。</li><li>使用更加复杂的应用层协议。</li></ul><h2 id="udp协议">UDP协议</h2><p>面向无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），对于一些控制需要在应用层解决。</p><h3 id="udp头部">UDP头部</h3><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/009.png" width="500"/> </div><br>## TCP和UDP的区别1. TCP 面向连接，UDP 是无连接的；2. TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付3. TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道5. 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信6. TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）7. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）8. TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节<h2 id="socket编程">socket编程</h2><h3 id="socket原理">socket原理</h3><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h3 id="建立socket连接">建立socket连接</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><ul><li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。*连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ul><h3 id="创建tcp的socket流程">创建TCP的socket流程</h3><h4 id="服务端">服务端</h4><ul><li>创建socket： <code>int socket(int domain, int type, int protocol)</code>;</li><li>将socket绑定地址和端口号：<code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</code>;</li><li>监听：<code>int listen(int sockfd, int backlog)</code>;</li><li>接受连接：<code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)</code>;</li><li>读取数据：<code>ssize_t read(int fd, void *buf, size_t count)</code>;</li><li>关闭socket:<code>int close(int fd)</code>;</li></ul><h4 id="客户端">客户端</h4><ul><li>创建socket： <code>int socket(int domain, int type, int protocol)</code>;</li><li>连接：<code>int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen)</code>;</li><li>输入数据: <code>ssize_t write(int fd, const void *buf, size_t count)</code>;</li><li>关闭socket:<code>int close(int fd)</code>;</li></ul><h1 id="应用层">应用层</h1><h2 id="域名系统-dns">域名系统 DNS</h2><p>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</p><h2 id="文件传输协议-ftp">文件传输协议 FTP</h2><p>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</p><h2 id="远程终端协议-telnet">远程终端协议 TELNET</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议">电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><h2 id="动态主机配置协议-dhcp">动态主机配置协议 DHCP</h2><p>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：</p><ol><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ol><h2 id="超文本传送协议-http">超文本传送协议 HTTP</h2><h1 id="其他问题">其他问题</h1><h2 id="从输入url到页面加载发生了什么">从输入URL到页面加载发生了什么</h2><p>https://segmentfault.com/a/1190000006879700DNS解析-&gt;TCP连接-&gt;发送HTTP请求-&gt;服务器处理请求并返回HTTP报文-&gt;浏览器解析并渲染界面-&gt;连接结束</p><h2 id="为什么time-wait状态还需要等2msl后才能返回到closed状态？">为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</h2><p>TIME_WAIT状态由两个存在的理由。</p><p>（1）可靠的实现TCP全双工链接的终止。</p><p>这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p><p>（2）允许老的重复的分节在网络中消逝。</p><p>假 设在12.106.32.254的1500端口和206.168.1.112.219的21端口之间有一个TCP连接。我们关闭这个链接，过一段时间后在 相同的IP地址和端口建立另一个连接。后一个链接成为前一个的化身。因为它们的IP地址和端口号都相同。TCP必须防止来自某一个连接的老的重复分组在连 接已经终止后再现，从而被误解成属于同一链接的某一个某一个新的化身。为做到这一点，TCP将不给处于TIME_WAIT状态的链接发起新的化身。既然 TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活msl秒即被丢弃，另一个方向上的应答最多存活msl秒也被丢弃。 通过实施这个规则，我们就能保证每成功建立一个TCP连接时。来自该链接先前化身的重复分组都已经在网络中消逝了。</p><h4 id="参考链接：">参考链接：</h4><p>https://github.com/huihut/interview#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Chttps://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82https://blog.csdn.net/yechaodechuntian/article/details/25429143http://www.cnblogs.com/maybe2030/p/4781555.html#_label3</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的fork使用</title>
      <link href="/2018/03/15/Server_dev/use_of_fork/"/>
      <url>/2018/03/15/Server_dev/use_of_fork/</url>
      
        <content type="html"><![CDATA[<h2 id="linux的fork使用">Linux的fork使用</h2><blockquote><p>fork函数可以算是Linux里有点不好明白的函数了，调用一次，返回两次，虽然在平时的写法中，有基本固定的写法，但是有时候看起来还是有些让人头疼的。这里就把关于fork函数好好整理一下</p></blockquote><h3 id="函数介绍">函数介绍</h3><p><strong>功能</strong>：fork函数是从一个已经存在的进程中创建一个新的进程，新的进程称为子进程，原来的进程称为父进程。<strong>参数</strong>：无<strong>返回值</strong>：成功：子进程中返回 0，父进程中返回子进程 ID。pid_t，为无符号整型。失败：返回 -1。</p><p>失败的两个主要原因是：1）当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN。2）系统内存不足，这时 errno 的值被设置为 ENOMEM。</p><h3 id="测试的例子">测试的例子</h3><p>下面是一个简单的创建子进程的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int pid&#x3D;1;</span><br><span class="line">    pid&#x3D;fork();</span><br><span class="line">    if(0&#x3D;&#x3D;pid)&#123; &#x2F;&#x2F;pid为0，表示为子进程</span><br><span class="line">        cout&lt;&lt;&quot;我是子进程，我的pid是：&quot;&lt;&lt;getpid()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid&gt;0)&#123; &#x2F;&#x2F;pid&gt;0表示父进程，此时返回值为子进程的pid</span><br><span class="line">        cout&lt;&lt;&quot;我是父进程，我的pid是&quot;&lt;&lt;getpid()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;  &#x2F;&#x2F;fork 失败</span><br><span class="line">        cout&lt;&lt;&quot;fork失败&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，fork函数会有两个返回值，一个是在子进程中返回0,一个是在父进程中返回子进程的pid。因此在编程过程中，需要判断这个值的返回值来判断当前是父进程还是子进程。</p><h3 id="fork进程的原理">fork进程的原理</h3><p>使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用 fork()函数的代价是很大的。<img src="https://blog-1252063226.cosbj.myqcloud.com/Linux/003001.jpg?raw=true" alt=""></p><h3 id="日常使用fork">日常使用fork</h3><p>简单来说， 一个进程调用 fork() 函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p><p>实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在<strong>需要写入的时候才会进行，在此之前，只有以只读方式共享</strong>。</p><p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。一般来说，在 fork() 之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。</p><p>因此，在实际的使用过程中，一般都需要对fork()的返回值进行判断，看我们操作的是父进程还是子进程。</p><h4 id="一般的操作：同时创建多个子进程">一般的操作：同时创建多个子进程</h4><p>不对的例子:父进程会生成 n(n+1)/2+1个子进程，N 为循环次数，本例中共有 7 个子进程， 但实际上只有 3 个是父进程产生的，其余都为子进程 fork（）出来的。父进程fork了3个进程，第一个子进程执行完之后又fork了2个进程，第2个子进程fork了1个进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    pid_t p1,p2;</span><br><span class="line">    int i;</span><br><span class="line">    int N&#x3D;100;</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;N;++i)&#123;</span><br><span class="line">        if((p1&#x3D;fork())&#x3D;&#x3D;0)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;子进程1：&quot;&lt;&lt;getpid()&lt;&lt;endl;</span><br><span class="line">            &#x2F;&#x2F;return 0;  &#x2F;&#x2F;很关键的地方，为什么需要返回呢</span><br><span class="line">        &#125;</span><br><span class="line">        wait(p1,NULL,0); &#x2F;&#x2F;父进程等待p1子进程执行后才能继续fork其他子进程</span><br><span class="line">        cout&lt;&lt;&quot;这是父进程: &quot;&lt;&lt;getpid()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的使用Linux中的用fork()由一个父进程创建同时多个子进程 的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    pid_t p1,p2;</span><br><span class="line">    int i;</span><br><span class="line">    int N&#x3D;100;</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;N;++i)&#123;</span><br><span class="line">        status&#x3D;fork();</span><br><span class="line">        if(status&#x3D;&#x3D;0||status&#x3D;&#x3D;1) break;&#x2F;&#x2F;每次循环时，如果发现是子进程就直接从创建子进程的循环中跳出来，不让你进入循环，这样就保证了每次只有父进程来做循环创建子进程的工作</span><br><span class="line">        if (status &#x3D;&#x3D; -1)</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;&#x2F;error</span><br><span class="line">        &#125;</span><br><span class="line">        else if (status &#x3D;&#x3D; 0) &#x2F;&#x2F;每个子进程都会执行的代码</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;&#x2F;sub process</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;&#x2F;parent process</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无聊的问题">无聊的问题</h3><p>1.下面的程序，不算 main这个进程自身，到底创建了多少个进程啊？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">   fork();</span><br><span class="line">   fork() &amp;&amp; fork() || fork();</span><br><span class="line">   fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每fork一次就翻倍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  fork(); &#x2F;&#x2F;2个</span><br><span class="line">   fork() &amp;&amp; fork() || fork();</span><br><span class="line">&#x2F;&#x2F;A&amp;&amp;B||C</span><br><span class="line">&#x2F;&#x2F;A为假，跳过B，判断C-----------------------2</span><br><span class="line">&#x2F;&#x2F;A为真，判断B，若B为真，跳过C-----------1</span><br><span class="line">&#x2F;&#x2F;若B为假，判断C ------------2</span><br><span class="line">   fork(); &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure><p>总共有：2*(2+1+2)*2=20不算自己的话有20-1=19个</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-60-Permutation-Sequence</title>
      <link href="/2018/02/06/Exercise/LeetCode-60-Permutation-Sequence/"/>
      <url>/2018/02/06/Exercise/LeetCode-60-Permutation-Sequence/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-60-permutation-sequence">LeetCode-60-Permutation-Sequence</h3><blockquote><p>The set [1,2,3,…,n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order,</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">We get the following sequence (ie, for n &#x3D; 3):</span><br><span class="line"></span><br><span class="line">&quot;123&quot;</span><br><span class="line">&quot;132&quot;</span><br><span class="line">&quot;213&quot;</span><br><span class="line">&quot;231&quot;</span><br><span class="line">&quot;312&quot;</span><br><span class="line">&quot;321&quot;</span><br><span class="line">Given n and k, return the kth permutation sequence.</span><br></pre></td></tr></table></figure><p>同样是排列 组合的问题，这次不需要打印所有的排列了，只需要按照排列的顺序打印出第k个，很显然，思路不会是列出所有的排列，然后找第k个打印出来是吧。</p><p>观察来看，以<code>1,2,3,4</code>为例，有<code>4*3*2*1=24</code>种排列，其中根据排列的顺序，按照第一个数字可以分为以下4种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 * * *</span><br><span class="line"></span><br><span class="line">2 * * *</span><br><span class="line"></span><br><span class="line">3 1 2 4</span><br><span class="line">3 1 4 2</span><br><span class="line">3 2 1 4</span><br><span class="line">3 2 4 1</span><br><span class="line">3 4 1 2</span><br><span class="line">3 4 2 1</span><br><span class="line"></span><br><span class="line">4 * * *</span><br><span class="line">#### 方法一</span><br></pre></td></tr></table></figure><ul><li>第一个数可以看出，当k=14时，第一个数字为3,这个是可以通过计算的。由于是从1开始的，取k=13；<code>index=k/(n-1)!=13/3!=2</code>，于是可以知道第一个数是3。那么第二个数字呢?</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1+permutation(2,4)</span><br><span class="line">2+permutation(1,4)</span><br><span class="line">4+permutation(1,2)</span><br></pre></td></tr></table></figure><ul><li>第二个数可以根据:<code>k=k-index_pre*(n-1)!=13-2*3!=1</code>;<code>index=k/(n-2)!=1/(4-2)!=0</code>于是第二个数为1。</li><li>第三个数接下来就只剩下2和4了，继续:<code>k=k-index_pre*(n-2)!=1-0*(4-2)!=1</code>,  <code>index=k/(n-3)!=1/(4-3)!=1</code>在此处表示为4.之后再确定最后一个:</li><li>第四个数<code>k=k-index_pre*(n-4)!=1-1*(4-4)=0</code>;<code>index=k/(n-4)!=0/(4-4)!=0</code> 故第四个数为2</li></ul><p>到了这里，思路就比较清晰了。我们需要做的是从第一个一直到最后一个的循环，每次选出一个数，但是还需要将该数从原来的数组中剔除掉，因为前面选过的后面就不能排列了。</p><h4 id="方法二：">方法二：</h4><p>其实原理差不多，也还是根据排列的规律。只不过算的方法不一样。</p><ol><li>j=i+k/(n-i)!;</li><li>删除s[j];</li><li>k=k%(n-i);</li><li>s[i]=s[j];代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string getPermutation(int n, int k) &#123;</span><br><span class="line">        if(n&lt;&#x3D;0)</span><br><span class="line">            return &quot; &quot;;</span><br><span class="line">        int i,j,f&#x3D;1;</span><br><span class="line">        string s(n,&#39;0&#39;);</span><br><span class="line">        for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            f*&#x3D;i;</span><br><span class="line">            s[i-1]+&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i&#x3D;0,k--;i&lt;n;++i)&#123;</span><br><span class="line">            f&#x2F;&#x3D;n-i;</span><br><span class="line">            j&#x3D;i+k&#x2F;f;</span><br><span class="line">            char c&#x3D;s[j];</span><br><span class="line">            for(;j&gt;i;j--)</span><br><span class="line">                s[j]&#x3D;s[j-1];</span><br><span class="line">            k%&#x3D;f;</span><br><span class="line">            s[i]&#x3D;c;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大型网站架构技术-架构模式</title>
      <link href="/2018/02/03/Server_dev/architecture-model-of-web-architecture/"/>
      <url>/2018/02/03/Server_dev/architecture-model-of-web-architecture/</url>
      
        <content type="html"><![CDATA[<h2 id="大型网站架构技术-架构模式">大型网站架构技术-架构模式</h2><p>模式的关键在于模式的可重复性。</p><a id="more"></a><blockquote><p>每一个模式描述了一个在我们周围不断变化重复发生的问题及该问题解决方案的核心。这样就能一次次的使用该方案而不必做重复的工作。</p></blockquote><p>这是经过很多个实践，被很多网站重复使用而逐渐形成大型网站架构模式：</p><h3 id="分层">分层</h3><p>将系统再横向维度上切成几个部分，每个部分负责一部分相对单一的职责。就好比平时一份工作比较多的时候，团队中大家各自负责自己擅长的那一部分。大型网站中一般分为三层：</p><ul><li>应用层：负责具体业务和视图展示。</li><li>服务层：为应用层提供服务支持。</li><li>数据层：提供数据存储访问服务。如数据库、缓存、文件、搜索引擎等。需要注意的是：这个分层是逻辑的，并不一定要部署在不同的服务器上，可能会根据业务调整。</li></ul><h3 id="分割">分割</h3><p>对业务进行横向切分。比如应用层：分为购物、论坛、搜索等。</p><h3 id="分布式">分布式</h3><p>一台服务器解决不了的时候，就采用分布式解决一下。分为：分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算。</p><h3 id="集群">集群</h3><p>使用分布式已经将分层和分割后的模块独立部署，但是对于用户集中访问的模块，可能还需要将独立部署的服务器集群化（多台服务器部署相同的应用构成一个集群），再通过一个负载均衡服务器对外提供服务。</p><h3 id="缓存">缓存</h3><p>缓存是改善软件性能的第一手段。</p><ul><li>CDN：讲内容部署在离用户最近的网络服务商，用户请求的时候，可以直接访问网络服务商缓存的静态资源，所以会很快。</li><li>反向代理：用户请求到网站的数据中心时，最先访问的是反向代理服务器，这里会缓存网站的静态资源。</li><li>本地缓存：应用服务器本地缓存的热点数据，可以在本机内存中直接访问，不需要访问数据库。</li><li>分布式缓存：数据量非常庞大时，需要的内存不是单机能承受的。因此还需要分布式缓存</li></ul><h3 id="异步">异步</h3><p>业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步进行协作。在单一服务器内部：采用<strong>多线程共享队列</strong>的方式实现异步。在分布式系统中：多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看做内存的分布式部署。</p><p>分布式消息队列的特性：网站扩展新功能便利，提高系统可用性，加快网站响应速度，消除并发访问高峰。</p><h3 id="冗余">冗余</h3><p>备份嘛，较少的机器可能坏的时间不长，但是小概率时间试验的次数过多的话就基本是必然事件了。</p><h3 id="自动化">自动化</h3><p>主要集中在运维方面，包括：发布过程自动化、自动化代码管理、自动化测试、自动化安全监测、自动化部署。对于运行中：自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降级、自动化分配资源。</p><h3 id="安全">安全</h3><p>密码和手机验证码；加密；网站验证码。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发 </tag>
            
            <tag> 大型网站技术 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大型网站架构技术-演化</title>
      <link href="/2018/02/03/Server_dev/evolution-of-webArchitecture/"/>
      <url>/2018/02/03/Server_dev/evolution-of-webArchitecture/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="大型网站架构技术-演化">大型网站架构技术-演化</h1><h2 id="特点">特点</h2><ul><li>高并发、大流量</li><li>高可用</li><li>海量数据</li><li>用户分布广泛、网络情况复杂</li><li>安全环境恶劣：易受攻击</li><li>需求变化快、发布频繁：为了快速适应市场</li><li>渐进式发展：逐渐进步发展</li></ul><h2 id="发展历程">发展历程</h2><h3 id="初始阶段">初始阶段</h3><p>应用程序、数据库、文件等所有资源都在一台服务器上。一般是在一台廉价的服务器上采用LAMP这种免费资源。</p><h3 id="应用服务和数据服务分离">应用服务和数据服务分离</h3><p>采用三台服务器分别承担自己的角色。</p><h3 id="使用缓存改善网站的性能">使用缓存改善网站的性能</h3><p>二八定律：80%的业务访问集中在20%的数据上，为了减少数据库的访问压力，可以将一些数据放到缓存服务器上，这样可以提高整个网站的数据访问速度。一般分为两种：</p><ul><li>缓存在应用服务器上的本地缓存：访问速度快，但缓存的数据有限；</li><li>缓存在专门的分布式缓存服务器上的远程缓存：可以采用分布式缓存。</li></ul><h3 id="采用应用服务器改善网站并发处理能力">采用应用服务器改善网站并发处理能力</h3><p>当应用服务器处理不了较多的并发请求时，可以增加一台服务器分担原有的服务器的访问，在前面加一个负载均衡服务器。</p><h3 id="数据库读写分离">数据库读写分离</h3><p>虽然采用了缓存，但有一些<strong>读操作和一部分写操作</strong>还是会落到数据库上。一般采用主从备份的数据库，写操作可以在主数据库中进行，读操作在从数据库中读取。</p><h3 id="使用反向代理和cdn加速网站响应">使用反向代理和CDN加速网站响应</h3><p>加速用户的访问。基本原理都是缓存，CDN是部署在网络提供商的机房，反向代理部署在网站的中心机房。对于反向代理，用户首先访问的是反向代理服务器，如果反向代理服务器中缓存着资源，就直接返回给用户。</p><h3 id="使用分布式文件系统和分布式数据库系统">使用分布式文件系统和分布式数据库系统</h3><p>持续增长的业务，单一的服务器满足不了要求的时候，一头牛拉不动的时候，不要企图换一头更厉害的牛，而是考虑再加一头牛一起拉。</p><h3 id="使用nosql和搜索引擎">使用NoSQL和搜索引擎</h3><p>网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，需要采用一些非关系数据库技术和非数据库查询技术如搜索引擎。</p><h3 id="业务拆分">业务拆分</h3><p>分而治之</p><h3 id="分布式服务">分布式服务</h3>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发 </tag>
            
            <tag> 大型网站技术 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-56and57-Merge-Intervals</title>
      <link href="/2018/01/30/Exercise/LeetCode-56-Merge-Intervals/"/>
      <url>/2018/01/30/Exercise/LeetCode-56-Merge-Intervals/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-56-merge-intervals">LeetCode-56-Merge-Intervals</h3><blockquote><p>Given a collection of intervals, merge all overlapping intervals.For example,</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given [1,3],[2,6],[8,10],[15,18],</span><br><span class="line">return [1,6],[8,10],[15,18].</span><br></pre></td></tr></table></figure><p>如例子中所示，每个数组的前后分别表示开始和结束，工作是合并有重叠的数组。例如，由于[1,3]和[2,6]有重叠，故直接改为[1,6]后输出。想法还是比较简单的，因为输入的并不一定是给好的按照开始，所以需要先对输入以开始的值排序。首先在结果数组中写入第一个，只有遍历进行判断，分为两种情况：</p><ol><li>如果某一interval的开始比结果数组中的结尾要大，显然不会有重叠，直接写入到结果数组中即可；</li><li>某一interval的开始比结果数组中的结尾要大，必然有重叠，此时还需要判断结束位置的大小。</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * struct Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() : start(0), end(0) &#123;&#125;</span><br><span class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;Interval&gt; res;</span><br><span class="line">        if(intervals.size()&lt;&#x3D;0)</span><br><span class="line">            return res;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),[](Interval a,Interval b)&#123;return a.start&lt;b.start;&#125;);</span><br><span class="line">        res.push_back(intervals[0]);</span><br><span class="line">        for(int i&#x3D;1;i&lt;intervals.size();++i)&#123;</span><br><span class="line">            if(res.back().end&lt;intervals[i].start) res.push_back(intervals[i]);</span><br><span class="line">            else&#123;</span><br><span class="line">                res.back().end&#x3D;max(res.back().end,intervals[i].end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="57-insert-interval">57-Insert-Interval</h3><blockquote><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).You may assume that the intervals were initially sorted according to their start times.</p></blockquote><p>题目改为向一个已经重叠的数组中加入新加入一个。需要做的是判断所处的位置，插入进去后还要删掉，值得注意的是这个删掉值的时候，vector的迭代器会发生变化，即有些会失效，所以最好的做法是，先插入，把需要的插入都插入之后再删除。</p><p>另外还有一个值得注意的是，排序搜索的谓语，使用的是<code>a.end&lt;b.start</code>，而不是之前的<code>a.start&lt;b.start</code> ，原因是需要找到一个范围，将newINterval夹在中间的一个范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * struct Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() : start(0), end(0) &#123;&#125;</span><br><span class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</span><br><span class="line">        if(intervals.size()&lt;&#x3D;0)&#123;</span><br><span class="line">            intervals.push_back(newInterval);</span><br><span class="line">            return intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        auto range&#x3D;equal_range(intervals.begin(),intervals.end(),newInterval,[](Interval a,Interval b)&#123;return a.end&lt;b.start;&#125;);</span><br><span class="line">        auto iter1&#x3D;range.first,iter2&#x3D;range.second;</span><br><span class="line">        if(iter1&#x3D;&#x3D;iter2)</span><br><span class="line">            intervals.insert(iter1,newInterval);</span><br><span class="line">        else&#123;</span><br><span class="line">            iter2--;</span><br><span class="line">            iter2-&gt;start&#x3D;min(newInterval.start,iter1-&gt;start);</span><br><span class="line">            iter2-&gt;end&#x3D;max(newInterval.end,iter2-&gt;end);</span><br><span class="line">            intervals.erase(iter1,iter2);</span><br><span class="line">        &#125;</span><br><span class="line">        return intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-55-Jump-Game</title>
      <link href="/2018/01/30/Exercise/LeetCode-55-Jump-Game/"/>
      <url>/2018/01/30/Exercise/LeetCode-55-Jump-Game/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-55-jump-game">LeetCode-55-Jump-Game</h3><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index.</p></blockquote><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [2,3,1,1,4], return true.</span><br><span class="line"></span><br><span class="line">A &#x3D; [3,2,1,0,4], return false.</span><br></pre></td></tr></table></figure><p>由题可知，数组的位置表示从该位置可以像前跳的步数，看最终能否跳到结尾。乍一看，这像是一个动态规划的问题，dp数组内存储每一个位置能够走的最远的位置，但是仔细一想，又是没有必要的，因为最终的目的不是为了判断哪一个位置能走的更远，而是能否到达最后一个位置。能到达最后一个位置的必要条件，显然一个就是能从某一位置继续往前走，而不会断。例如：<code>[3,2,1,0,4]</code>，我们都能走到第4个位置，但是却无法继续往前走，故到不了最后一个。所以代码可以做一个判断。另一个需要考虑的问题是：在从前往后遍历的过程中，维护哪一个变量？显然这个变量记录的是我们能走的最远的距离，如果这个距离走的更远就更新，直到不能继续往前走，此时判断能否到终点。</p><p>贴上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(int reach&#x3D;0;i&lt;nums.size()&amp;&amp;i&lt;&#x3D;reach;++i)</span><br><span class="line">            reach&#x3D;max(reach,i+nums[i]);</span><br><span class="line">        return i&#x3D;&#x3D;nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-53-Maximum-Subarray</title>
      <link href="/2018/01/26/Exercise/LeetCode-53-Maximum-Subarray/"/>
      <url>/2018/01/26/Exercise/LeetCode-53-Maximum-Subarray/</url>
      
        <content type="html"><![CDATA[<h2 id="leetcode-53-maximum-subarray">LeetCode-53-Maximum-Subarray</h2><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p></blockquote><p>最长子序列，又是一个动态规划的问题，关于动态规划，我们最主要的是要维护DP数组，这个问题以前还有点不理解，感觉主要的还是思想，只要知道这是一个动态规划的问题，解决动态规划的一般方法掌握了，其他的就都是细节了。</p><p>最近刷算法题，不得不想到的是以前的数学，数学是逻辑性可能更强的东西，尚且需要多做练习才行，何况算法了。当然现在慢慢的感觉就是，以前看到很多题完全没有头绪，现在很多大概是能分清是想考啥了，也会想着主动去选择相应的数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(),0);</span><br><span class="line">        dp[0]&#x3D;nums[0];</span><br><span class="line">        int res&#x3D;dp[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;nums.size();++i)&#123;</span><br><span class="line">            dp[i]&#x3D;nums[i]+(dp[i-1]&gt;0?dp[i-1]:0);</span><br><span class="line">            res&#x3D;max(dp[i],res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-52-N-Queens-II</title>
      <link href="/2018/01/26/Exercise/LeetCode-52-N-Queens-II/"/>
      <url>/2018/01/26/Exercise/LeetCode-52-N-Queens-II/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-52-n-queens-ii">LeetCode-52-N-Queens-II</h3><blockquote><p>Follow up for N-Queens problem.Now, instead outputting board configurations, return the total number of distinct solutions.</p></blockquote><p>只返回N皇后问题结果的种数。因此不需要每一个字符串置位了，只需要判断一个位置的横竖，斜45度和斜135度方向的值即可。依然采用递归的方式，这里需要注意的是，由于是对列递归，所以需要考虑的是行，斜45度，斜135度，本来是要维护一个一维数组和两个二维数组，但是想到二维数组的特征，可以改为维护三个一维数组，这两个一维数组保存的是将二维数组展开的信息。甚至是一波操作改为共维护两个一维数组也可以。接下来是代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int totalNQueens(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; rows(n),d1(2*n-1),d2(2*n-1);</span><br><span class="line">        return find(n,n,0,rows,d1,d2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int n,int left,int i,vector&lt;int&gt;&amp; rows,vector&lt;int&gt;&amp; d1,vector&lt;int&gt;&amp; d2)&#123;</span><br><span class="line">        if(left&#x3D;&#x3D;0)</span><br><span class="line">            return 1;</span><br><span class="line">        int j,sum&#x3D;0;</span><br><span class="line">        for(j&#x3D;0;j&lt;n;++j)&#123;</span><br><span class="line">            if(rows[j]||d1[i+j]||d2[n-1+i-j])</span><br><span class="line">                continue;</span><br><span class="line">            rows[j]&#x3D;d1[i+j]&#x3D;d2[n-1+i-j]&#x3D;1;</span><br><span class="line">            sum+&#x3D;find(n,left-1,i+1,rows,d1,d2);</span><br><span class="line">            rows[j]&#x3D;d1[i+j]&#x3D;d2[n-1+i-j]&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了一下别人的好像确实快一点，毕竟0ms啊，也贴一下别人的代码吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int totalNQueens(int n) &#123;</span><br><span class="line">        bool flag[5*n] &#x3D; &#123;false&#125;;</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        dfs(num,flag,0,n);</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int&amp; num, bool* flag, int row, int n)&#123;</span><br><span class="line">        if(row &#x3D;&#x3D; n)&#123;</span><br><span class="line">            ++num;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i &#x3D; 0; i&lt;n;i++)&#123;</span><br><span class="line">            if(!flag[i] &amp;&amp; !flag[row+i+n] &amp;&amp; !flag[4*n + row - i])&#123;</span><br><span class="line">                flag[i] &#x3D; 1;</span><br><span class="line">                flag[row+i+n] &#x3D; 1;</span><br><span class="line">                flag[4*n + row - i] &#x3D; 1;</span><br><span class="line">                dfs(num,flag,row+1,n);</span><br><span class="line">                flag[i] &#x3D; 0;</span><br><span class="line">                flag[row+i+n] &#x3D; 0;</span><br><span class="line">                flag[4*n + row - i] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="reference">reference:</h4><p>https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-51-N-Queens</title>
      <link href="/2018/01/26/Exercise/LeetCode-51-N-Queens/"/>
      <url>/2018/01/26/Exercise/LeetCode-51-N-Queens/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-51-n-queens">LeetCode-51-N-Queens</h3><p>经典的N皇后问题，重点是全排列的问题，但是这里由于N皇后的不重复行、列、斜的要求，在排列的过程中，比如从行开始排列，只能保证同行不重复，所以需要引入isValid函数。通过判断列，左斜、右斜是否重复。</p><p>需要注意的是：关于全排列递归的写法，要更加熟练掌握才行，并且能完全理解，能够在不同的情况中灵活运用。其基本思想还是：固定前面的某个数字，不短的对后面进行交换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(vector&lt;string&gt;&amp; queen, int row,int col,int n)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;row;++i)&#123;</span><br><span class="line">            if(queen[i][col]&#x3D;&#x3D;&#39;Q&#39;)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;row-1,j&#x3D;col-1;i&gt;&#x3D;0&amp;&amp;j&gt;&#x3D;0;--i,--j)&#123;</span><br><span class="line">            if(queen[i][j]&#x3D;&#x3D;&#39;Q&#39;)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;row-1,j&#x3D;col+1;i&gt;&#x3D;0&amp;&amp;j&lt;n;--i,++j)&#123;</span><br><span class="line">            if(queen[i][j]&#x3D;&#x3D;&#39;Q&#39;)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void recurse(vector&lt;string&gt;&amp; queen,vector&lt;vector&lt;string&gt;&gt;&amp; res,int row,int n)&#123;</span><br><span class="line">        if(row&#x3D;&#x3D;n)&#123;</span><br><span class="line">            res.push_back(queen);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int col&#x3D;0;col!&#x3D;n;++col)&#123;</span><br><span class="line">            if(isValid(queen,row,col,n))&#123;</span><br><span class="line">                queen[row][col]&#x3D;&#39;Q&#39;;</span><br><span class="line">                recurse(queen,res,row+1,n);</span><br><span class="line">                queen[row][col]&#x3D;&#39;.&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        vector&lt;string&gt; queen(n,string(n,&#39;.&#39;));</span><br><span class="line">        recurse(queen,res,0,n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-49-Group-Anagrams</title>
      <link href="/2018/01/25/Exercise/LeetCode-49-Group-Anagrams/"/>
      <url>/2018/01/25/Exercise/LeetCode-49-Group-Anagrams/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-49-group-anagrams">LeetCode-49-Group-Anagrams</h3><blockquote><p>Given an array of strings, group anagrams together.For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],</p></blockquote><p>Return:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>输入一个字符串数组，输出的是：将相同字符的字符串放在一个数组的二维数组。相同字符的处理，基本就是要对字符串排序的。然后需要考虑的就是排序好的那一个字符串怎么存的问题。用的数据结构是map，string为键，对应的值是一个set或者是一个vector，存放满足要求的string，之后再用这个初始化结果数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string,multiset&lt;string&gt;&gt; map_str;</span><br><span class="line">        for(string s:strs)&#123;</span><br><span class="line">            string t&#x3D;s;</span><br><span class="line">            sort(t.begin(),t.end());</span><br><span class="line">            map_str[t].insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        for(auto temp:map_str)&#123;</span><br><span class="line">            vector&lt;string&gt; vec_str_temp(temp.second.begin(),temp.second.end());</span><br><span class="line">            res.push_back(vec_str_temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后来发现用vector其实要好一些。只是别人这么写的，时间竟然要短一点，毕竟是用vector初始化vector？</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-48-Rotate-Image</title>
      <link href="/2018/01/25/Exercise/Leetcode-48-Rotate-Image/"/>
      <url>/2018/01/25/Exercise/Leetcode-48-Rotate-Image/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-48-rotate-image">Leetcode-48-Rotate-Image</h3><blockquote><p>ou are given an n x n 2D matrix representing an image.Rotate the image by 90 degrees (clockwise).Note:You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p></blockquote><p>Example :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given input matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个乍一看觉得不难，但是写的时候又不知道怎么回事，其实旋转，对于我们写程序来说，其实就是不停的调换位置，但是怎么调换是个问题。</p><p>观察发现，第一个矩阵，最角上的四个1,3,7,9。转完之后，还是这四个数字，只不过是位置变了，接下来这样的四个是：2,4,6,8.最后一个5.再看一下4x4的其实也差不多。</p><p>所以想法就是直接每次四个数字进行换，换三次，就能换回来，然后进行下一次调换。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if(matrix.size()&lt;&#x3D;0)</span><br><span class="line">            return;</span><br><span class="line">        int a&#x3D;0,b&#x3D;matrix.size()-1;</span><br><span class="line">        while(a&lt;b)&#123;</span><br><span class="line">            for(int i&#x3D;0;i&lt;b-a;++i)&#123;</span><br><span class="line">                swap(matrix[a][a+i],matrix[a+i][b]);</span><br><span class="line">                swap(matrix[a][a+i],matrix[b][b-i]);</span><br><span class="line">                swap(matrix[a][a+i],matrix[b-i][a]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++a;</span><br><span class="line">            --b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器-Nginx设计架构</title>
      <link href="/2018/01/25/Server_dev/Server_archtectuer_of_nginx/"/>
      <url>/2018/01/25/Server_dev/Server_archtectuer_of_nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器-nginx设计架构">服务器-Nginx设计架构</h3><h4 id="nginx服务器架构">Nginx服务器架构</h4><p>Nginx服务器启动后，产生一个主进程，主进程执行一系列工作后产生一个或多个工作进程。</p><p>如下图所示：Nginx服务器的结构大致分为主进程、工作进程、后端服务器和缓存。<img src="https://blog-1252063226.cosbj.myqcloud.com/server/003/001.png?raw=true" alt=""></p><ul><li>主进程主要进行：Nginx配置文件解析、数据结构初始化、模块配置和注册、信号处理、网络监听生成、工作进程生成和管理。</li><li>工作进程主要进行：进程初始化、模块调用和请求处理等。</li><li>缓存索引重建及管理进程：cache模块，主要由缓存索引重建和缓存索引管理两类进程完成。缓存索引重建是在Nginx服务启动一段时间后由主进程生成，在缓存元数据重建完成后自动退出。主要工作是：根据本地磁盘上的缓存文件在内存中建立索引元数据库，启动后对本地磁盘上存放缓存文件的目录结构进行扫描，检查内存中已有的缓存你数据元是否正确，并更新索引元数据库；缓存索引管理进程一般存在于主进程的整个生命周期，负责对缓存索引进行管理。主要负责对元数据是否过期做出判断。</li></ul><h4 id="进程交互">进程交互</h4><h5 id="master-worker交互">Master-worker交互</h5><p>主进程会建立一张工作进程表，存放所有未退出的，主进程通过一个单向管道向工作进程发送指令等信息。</p><h5 id="worker-worker交互">Worker-Worker交互</h5><p>工作进程之间的交互，首先要得到彼此的信息，建立管道通信。当工作进程w1需要向w2发送指令时，首先在主进程给它的其他工作进程信息中找到w2的进程ID，然后将正确的指令写入指向w2的通道。w2捕捉到管道中的时间后，解析指令并采取相应的措施。完成worker之间的交互</p><h4 id="run-loops时间处理循环模型">Run Loops时间处理循环模型</h4><p>Run Loops指的是进程内部用来不停的调配工作，对事件进行循环处理的一种模型。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器-Nginx的事件驱动模型</title>
      <link href="/2018/01/25/Server_dev/Server_model_of_nginx/"/>
      <url>/2018/01/25/Server_dev/Server_model_of_nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器-nginx的事件驱动模型">服务器-Nginx的事件驱动模型</h2><h3 id="什么是事件驱动模型">什么是事件驱动模型</h3><p>事件驱动概念：在持续的事物管理过程中，由当前时间节点上出现的事件引起的调用可用资源执行相关任务，解决问题，防止事物堆积的一种策略。一般由：事件收集器、事件发送器和事件处理器组成。</p><h3 id="事件驱动处理库">事件驱动处理库</h3><p>又称为多路IO复用方法：主要包括以下几种：</p><h4 id="select库">select库</h4><ol><li>创建所关注事件的描述符集合，每个描述符，可以关注读事件、写事件以及异常发生事件。</li><li>调用底层的select函数，等待事件发生。</li><li>轮询所有事件描述符集合中的每一个事件描述符，检查是否有相应的事件发生，如果有，就进行处理。</li></ol><h4 id="poll库">poll库</h4><p>Linux下平台的基本事件驱动模型。基本工作方式与select库相同。区别在于：select库需要为读事件、写事件和异常事件分别创建一个描述符集合，因此在最后轮询的时候，需要分别轮询三个集合。而poll库只需要创建一个集合。轮询的时候同时检查三种事件是否发生。</p><h4 id="epoll库">epoll库</h4><p>Nginx服务器支持的高性能事件驱动库。主要的改动是：把描述符列表的管理交由内核负责，一旦有某种事件发生，内核把发生的事件的描述列表通知给进程，这样就避免了轮询整个描述符列表。</p><ol><li>epoll库通过相关调用通知内核创建一个有N个描述符的事件列表。然后给这些描述符设置关注的事件，并添加到内核的事件列表中去。</li><li>完成设置之后，epoll库就开始等待内核通知事件发生。一旦发生，内核将发生事件的描述符上报给epoll库。</li></ol><h4 id="rtsig模型">rtsig模型</h4><p>Real-time signal，实时信号。使用rtsig时，工作进程会通过系统内核建立一个rtsig队列用于存放标记事件发生的信号。每个事件发生时，系统内核就会产生一个信号存放在rtsig队列中等待工作进程的处理。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器-Nginx的Web请求处理机制</title>
      <link href="/2018/01/25/Server_dev/Server_web_of_nginx/"/>
      <url>/2018/01/25/Server_dev/Server_web_of_nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器-nginx的web请求处理机制">服务器-Nginx的Web请求处理机制</h2><h3 id="并行处理请求的三种方式">并行处理请求的三种方式</h3><p>web服务器和客户端是一对多的关系，所以web服务器要能同时为多个客户端提供服务。一般有三种方式：多进程方式、多线程方式和异步方式。</p><h4 id="多进程方式">多进程方式</h4><p>服务器每接收到一个客户端时，就由服务器主进程生成一个子进程与该客户端交互 ，直到连接断开，子进程结束。</p><ul><li>优点：设计和实现相对简单、子进程之间相互独立，处理客户端请求的过程彼此不干扰，一个有问题不会影响其他的。保证了稳定性。子进程退出时，资源会被系统回收，不会留下垃圾。</li><li>缺点：每生成一个子进程，都要进行内存复制的操作，在资源和时间上会有额外的开销。Apache采用的“预生成进程”可以稍微解决大并发请求，但是本质是多进程，无法解决多并发的问题。</li></ul><h5 id="多线程方式">多线程方式</h5><p>服务器每接收到一个客户端时，会由服务器主进程派生一个线程出来和该客户端进行交互。</p><ul><li>优点：产生一个线程的开销要小于一个进程，比较规范，利于协作。</li><li>缺点：多个线程在一个内存空间中，彼此互相影响，对内存的管理增加了出错的风险。</li></ul><h4 id="异步方式">异步方式</h4><h5 id="同步-异步与阻塞-非阻塞">同步、异步与阻塞、非阻塞</h5><p><strong>同步和异步描述的是通信模式的概念</strong>同步：发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求。所有的请求在服务器端得到同步，发送方和接收方对请求的处理步调是一致的。异步：发送方发送请求后，不等待接收方响应这个请求，就继续发送下一个请求。所有来自发送方的请求形成一个队列，接收方处理完后通知发送方。</p><p><strong>阻塞和非阻塞描述的是进程处理调用的方式，在网络通信中，主要指的是网络套接字socket的阻塞和非阻塞方式，socket实质上就是IO操作</strong>阻塞：调用结果返回之前，当前的线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU继续执行。非阻塞：调用结果返回之前，线程不会被挂起，而是立即返回执行下一个周期。</p><p>所以共有四种方式：</p><ul><li>同步阻塞：发送方发送请求后，一直等待响应；接收方处理请求时不能立即等到结果的时候，就会一直等待返回结果，才响应发送方，期间不能执行任何其他工作。</li><li>同步非阻塞：发送方发送请求后，一直等待响应；接收方处理请求时不能立即等到结果的时候，就会立即返回，去做别的事情，但是由于没有得到结果，也不响应发送方，发送方一直等待。</li><li>异步阻塞：发送方发送请求后，不等待响应；接收方处理请求时不能立即等到结果的时候，就会一直等待返回结果，才响应发送方，期间不能执行任何其他工作。</li><li>异步非阻塞：发送方发送请求后，不等待响应；接收方处理请求时不能立即等到结果的时候，就会立即返回，去做别的事情，但是由于没有得到结果，也不响应发送方，发送方一直等待。</li></ul><h5 id="nginx如何处理请求">Nginx如何处理请求</h5><p>Nginx采用的是异步非阻塞的方式。采用Master-work模型（其实实际也有single的单进程模式，但是性能较差，很少使用）。每个工作进程采用异步非阻塞的方式。Nginx服务器的工作进程调用IO后，就去进行其他工作，当IO调用返回，会通知工作进程。接下来就是怎么通知给工作进程了。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器-Nginx模块化结构</title>
      <link href="/2018/01/25/Server_dev/Server_structure_of_nginx/"/>
      <url>/2018/01/25/Server_dev/Server_structure_of_nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器-nginx模块化结构">服务器-Nginx模块化结构</h3><p>习惯上将Nginx分为：核心模块、标准模块、可选HTTP模块、邮件服务模块和第三方模块五大类。</p><h4 id="核心模块">核心模块</h4><p>包含对两部分功能的支持：</p><ul><li>主体功能：进程管理、权限控制、错误日志记录、配置解析等</li><li>用于响应请求必需的功能：事件驱动机制、正则表达式解析等</li></ul><h4 id="标准http模块">标准HTTP模块</h4><p>对应基本的HTTP服务</p><h4 id="可选http模块">可选HTTP模块</h4><p>快速编译中默认不编译，需要使用的话需要自己加上–with-XXX的参数声明。</p><h4 id="邮件服务模块">邮件服务模块</h4><p>Nginx的主要服务之一，快速编译时也不会编译</p><h4 id="第三方模块">第三方模块</h4>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器-Nginx-一个简单的例子</title>
      <link href="/2018/01/24/Server_dev/Server_a_simple_sample/"/>
      <url>/2018/01/24/Server_dev/Server_a_simple_sample/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器-nginx-一个简单的例子">服务器-Nginx-一个简单的例子</h3><p>直接贴一个几经磨难的简单的例子吧，虽然简单，但是有些不理解的地方，就出了很多错，但是因为这些错误，在对nginx理解稍微深刻了那么一点点的同时，对Linux的操作好像也有了一点进步啊。才知道为什么大家的命令都那么长，而我总是一步步慢慢的来了，一方面不熟，另一方面确实操作的不够多啊。</p><h4 id="配置细节">配置细节</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">user mianhk;</span><br><span class="line">worker_processes 3;</span><br><span class="line">pid &#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    #worker_connections 768;</span><br><span class="line">    worker_connections 768;</span><br><span class="line">    # multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Basic Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line">    #tcp_nopush on;</span><br><span class="line">    #tcp_nodelay on;</span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    # server_tokens off;</span><br><span class="line"></span><br><span class="line">    # server_names_hash_bucket_size 64;</span><br><span class="line">    # server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    default_type application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # SSL Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    #ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span><br><span class="line">    #ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Logging Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log;</span><br><span class="line">    error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Gzip Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_disable &quot;msie6&quot;;</span><br><span class="line"></span><br><span class="line">    # gzip_vary on;</span><br><span class="line">    # gzip_proxied any;</span><br><span class="line">    # gzip_comp_level 6;</span><br><span class="line">    # gzip_buffers 16 8k;</span><br><span class="line">    # gzip_http_version 1.1;</span><br><span class="line">    # gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Virtual Host Configs</span><br><span class="line">    ##</span><br><span class="line">    ## 配置虚拟主机1</span><br><span class="line">    server &#123;</span><br><span class="line">        listen        8081;   #监听端口</span><br><span class="line">        server_name   myServer1;</span><br><span class="line">        access_log  var&#x2F;myweb&#x2F;server1&#x2F;log&#x2F;access_log;  #配置日志存放路径</span><br><span class="line">        error_page 404 &#x2F;404.thml;   # 错误界面</span><br><span class="line"></span><br><span class="line">        location &#x2F;server1&#x2F;location1 &#123; #配置&#x2F;server1&#x2F;location1请求的location</span><br><span class="line">            root &#x2F;var&#x2F;myweb;</span><br><span class="line">            index index.svr1-loc1.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location &#x2F;server1&#x2F;location2 &#123;  #配置&#x2F;server1&#x2F;location2请求的location</span><br><span class="line">            root &#x2F;var&#x2F;myweb;</span><br><span class="line">            index index.svr1-locl2.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;   #配置虚拟主机myServer2</span><br><span class="line">        listen     8082;</span><br><span class="line">        server_name 192.168.1.31;</span><br><span class="line">        access_log var&#x2F;myweb&#x2F;server2&#x2F;log&#x2F;access_log;</span><br><span class="line">        error_page 404 &#x2F;404.thml;  #对错误页面定向</span><br><span class="line"></span><br><span class="line">        location &#x2F;server2&#x2F;location1 &#123;</span><br><span class="line">            root &#x2F;var&#x2F;myweb;</span><br><span class="line">            index index.svr2-loc1.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location &#x2F;svr2&#x2F;loc2 &#123;</span><br><span class="line">            alias &#x2F;myweb&#x2F;server2&#x2F;location2&#x2F;;  #对location的URI进行更改</span><br><span class="line">            index index.svr2-locl2.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location &#x3D; &#x2F;404.html &#123;  #配置错误页面转向</span><br><span class="line">            root &#x2F;var&#x2F;myweb;</span><br><span class="line">            index 404.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">    #include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p>在浏览器中输入：<code>http://111.230.231.95:8081/server1/location1/</code><img src="https://blog-1252063226.cosbj.myqcloud.com/server/002001.jpg?raw=true" alt="">输入<code>http://111.230.231.95:8082/server2/location1/</code>显示：<img src="https://blog-1252063226.cosbj.myqcloud.com/server/002002.jpg?raw=true" alt=""></p><h4 id="出现的问题分析">出现的问题分析</h4><ul><li>root目录的位置：原来root的目录虽然写的是/var/myweb，但是实际发现位置是 在<code>/usr/share/nginx</code>下面，所以需要拷过去，具体这个位置是在哪里设置的，因为已经把所有其他的include都关掉了，所以可能是ubuntu下安装之后的默认目录，就像默认监听的80端口的页面其实在<code>var/www/html</code>下面一样。 导致出了各种莫名其妙的错误啊:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@VM-95-58-ubuntu:&#x2F;etc&#x2F;nginx# systemctl status nginx.service</span><br><span class="line">● nginx.service - A high performance web server and a reverse proxy server</span><br><span class="line">   Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Wed 2018-01-24 22:05:09 CST; 1s ago</span><br><span class="line">  Process: 32576 ExecStop&#x3D;&#x2F;sbin&#x2F;start-stop-daemon --quiet --stop --retry QUIT&#x2F;5 --pidfile &#x2F;run&#x2F;nginx.pid (code</span><br><span class="line">  Process: 21311 ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx -g daemon on; master_process on; (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)</span><br><span class="line">  Process: 3307 ExecStartPre&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx -t -q -g daemon on; master_process on; (code&#x3D;exited, status&#x3D;1&#x2F;FAI</span><br><span class="line"> Main PID: 21314 (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)</span><br><span class="line"></span><br><span class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: Starting A high performance web server and a reverse proxy server.</span><br><span class="line">Jan 24 22:05:09 VM-95-58-ubuntu nginx[3307]: nginx: [emerg] open() &quot;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;var&#x2F;myweb&#x2F;server1&#x2F;log&#x2F;acc</span><br><span class="line">Jan 24 22:05:09 VM-95-58-ubuntu nginx[3307]: nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test failed</span><br><span class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: nginx.service: Control process exited, code&#x3D;exited status&#x3D;1</span><br><span class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: Failed to start A high performance web server and a reverse proxy</span><br><span class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: nginx.service: Unit entered failed state.</span><br><span class="line">Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: nginx.service: Failed with result &#39;exit-code&#39;.</span><br></pre></td></tr></table></figure><ul><li>另一个就是关于config文件的格式，一定要仔细写，需要加分号，然后就是最后的<code>/</code>，对于nginx的配置来说，是意义重大的，后面可能会说到这个问题，但是现在还是要写上。</li><li>刚刚测试，好像发现这里还有其他的问题，比如我的location2好像打不开啊，尴尬，明天再看看出了什么问题。。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器-Nginx基础配置</title>
      <link href="/2018/01/24/Server_dev/Server_simple_of_nginx/"/>
      <url>/2018/01/24/Server_dev/Server_simple_of_nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器-nginx基础配置">服务器-Nginx基础配置</h3><h4 id="nginx-conf文件结构">nginx.conf文件结构</h4><p>Nginx的默认配置文件为：<code>nginx.conf</code>，文件一共由三个部分组成，分别为：<code>全局块、events块、http块</code>在<code>http块</code>中，包含http全局块，多个server块。在每个<code>server块</code>中，可以包含多个server块和location块。</p><p>同一模块中嵌套的配置块。各个之间不存在次序关系，也就是是同时生效的。另外，在高一等级的配置可能会被更内层括号内的设置覆盖，这个其实跟我们的继承或者函数中差不多。</p><ul><li>全局块：（从配置文件开始到events的一部分）主要影响Nginx服务器整体运行的配置指令 ，顾名思义，能够作用于全局。</li><li>evevts块：主要影响Nginx服务器与用户的网络连接。这部分对Nginx服务器性能影响较大。</li><li>http块：代理、缓存和日志定义等绝大部分功能和第三方模块的配置都在这部分。由于http块包括server块，这里用http全局块表示不包含server块的部分。</li><li>server块：和“虚拟主机”密切联系。利用虚拟主机技术可以避免为每一个要用运行的网站提供单独的Nginx服务器，也不需要为每个网站对应一组nginx进程。一个http块中可以包含多个server块，每个server块相当于一个虚拟主机，它内部可以有多台主机联合提供服务，一起对外提供在逻辑上的一组服务（或网站）。server全局块一般配置的是：虚拟主机的监听配置和本虚拟主机的名称和IP配置。</li><li>location块：location块其实是server块的一个指令，主要作用是：基于Nginx服务器接收到的字符串，对除虚拟主机名称外的字符串进行匹配，对特定的请求进行处理、地址定向、数据缓存和应答控制等功能。</li></ul><h4 id="详细配置分析">详细配置分析</h4><p>接下来是一个详细解释的配置的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">                                     #全局块开始</span><br><span class="line">user user [group];                       #可以开启nginx服务的用户名user和所对应的group（可选）</span><br><span class="line">#user nobody nobody;         #注释或者nobody可以表示任何人都能启动</span><br><span class="line">worker_processes number|auto;               #开启的工作进程的数量，auto则会根据系统自动</span><br><span class="line">pid &#x2F;run&#x2F;nginx.pid;                  #存储进程pid的文件，记得不止要加上路径，还要加上文件名，并且开启服务的用户需要对该文件有权限</span><br><span class="line"></span><br><span class="line">events &#123;                             #events块</span><br><span class="line">    worker_connections 768;          #每一个工作进程能开启的最大连接个数：总的连接个数total&#x3D;worker_processes*worker_connections</span><br><span class="line">    # accept_mutex on;     #设置网络连接的序列化，解决“惊群”的问题（当一个网络连接到来时，多个睡眠进程被唤醒，影响系统性能）</span><br><span class="line">    # multi_accept on;  #允许接受多个网络连接</span><br><span class="line">    #use method;  #时间驱动模型的选择:select|poll|kqueue|epoll|rtsig|&#x2F;dev&#x2F;poll|eventport</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;                               #http块</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Basic Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_timeout 65;   #连接超时时间</span><br><span class="line">    #keepalive_requests number; #单连接请求数上限</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    # server_tokens off;</span><br><span class="line"></span><br><span class="line">    # server_names_hash_bucket_size 64;</span><br><span class="line">    # server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;mime.types;   #MIME-types存储了媒体资源的类型</span><br><span class="line">    default_type application&#x2F;octet-stream; #处理前端请求的MIME类型，可在http、server、location中定义</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # SSL Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Logging Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log;  # 日志存放文件名，该指令可以在全局块、http块和server块中，作用域不同</span><br><span class="line">    error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Gzip Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_disable &quot;msie6&quot;;</span><br><span class="line"></span><br><span class="line">    # gzip_vary on;</span><br><span class="line">    # gzip_proxied any;</span><br><span class="line">    # gzip_comp_level 6;</span><br><span class="line">    # gzip_buffers 16 8k;</span><br><span class="line">    # gzip_http_version 1.1;</span><br><span class="line">    # gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Virtual Host Configs</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;   # include 引入配置文件，支持相对路径</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器-Nginx安装和基本配置</title>
      <link href="/2018/01/23/Server_dev/Server_first_of_nginx/"/>
      <url>/2018/01/23/Server_dev/Server_first_of_nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器-nginx安装和基本配置">服务器-Nginx安装和基本配置</h3><h4 id="nginx的安装">Nginx的安装</h4><p>没有看书上，直接在ubuntu输了一个nginx，大概是ubuntu的支持比较好，直接提醒可以安装，于是就毫不客气的装了一下就启动了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br></pre></td></tr></table></figure><p>接下来直接在浏览器里面打开，就能看到hello,Nginx这样欣慰 的界面了。</p><p>之后能够在文件夹<code>/etc</code>中看到我们的配置的文件：<img src="https://blog-1252063226.cosbj.myqcloud.com/server/001001.jpg?raw=true" alt="">在<code>var/www/html</code>文件夹中能看到<code>index.html</code>文件，即是我们的主页文件。**这里没有采用源码的方式安装，其实是觉得没有必要了。 **</p><h4 id="nginx的启停">Nginx的启停</h4><p>刚刚已经直接开启了Nginx了，其实关就更简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;nginx stop  #停止nginx</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;nginx restart # 重启nginx</span><br></pre></td></tr></table></figure><p>这里需要注意的是nginx的平滑重启：Nginx服务进程接受到信号后，首先读取新的Nginx的配置文件，如果新的配置文件语法正确，则启动新的Nginx服务，然后平缓的关闭旧的服务进程。否则，仍然使用旧的Nginx进程提供服务。</p><h4 id="nginx服务器的升级">Nginx服务器的升级</h4><p>平滑升级：Nginx服务接收到USR2信号后，首先将旧的nginx.pid文件（如果配置文件中更改过名字，也是相同的过程）添加后缀<code>.oldbin</code>，变为nginx.pid.oldbin文件；之后执行新版本Nginx服务器的二进制文件启动服务。如果新的服务启动成功，系统中将有新旧两个Nginx服务共同提供Web服务。之后，需要像旧的Nginx服务进程发送WINCH信号，使旧的Nginx服务平滑停止，并删除nginx.pid.oldbin文件。在发送WINCH信号之前，可以随时停止新的Nginx服务。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器-初识Nginx</title>
      <link href="/2018/01/23/Server_dev/Server_learn_nginx/"/>
      <url>/2018/01/23/Server_dev/Server_learn_nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="初识nginx">初识Nginx</h3><h4 id="nginx的历史">Nginx的历史</h4><p>Netcraft公司，1994年在英国成立。</p><h4 id="常见服务器">常见服务器</h4><ul><li>Apache服务器：目前最广泛使用的web服务器，由于使用了以“进程”为基础的结构，会消耗更多的系统开支。因此通常对Apache web进行扩容的时候，是增加服务器或者扩充集群节点而不是增加处理器。</li><li>Microsoft IIS：微软的，付费软件，部署成本较高。</li><li>Tomcat服务器：最初Sun公司开发，是官方推荐的Servlet和JSP容器，在中小型系统和并发访问用户不是很多的时候，可以作为轻量级应用服务器。一般应用中，通常作为Apache服务器的扩展部分，为运行JSP页面和Servlet提供服务，提供的Servlet容器是Tomcat的默认模式。Tomcat也具有处理HTML页面的功能，只是处理静态页面的能力不如Apache服务器。</li><li>Lighttpd服务器：德国开源的一个轻量级web服务器，它专门针对高性能网站，提供一种安全、快速、兼容性良好并且灵活的Web Server的环境。同时有非常低的内存开销、CPU占用率低、模块丰富。  但是最为轻量服务器，与Apache这种大型服务器相比还有差距。</li><li>Nginx</li></ul><h4 id="nginx的功能特性">Nginx的功能特性</h4><h5 id="基本的http服务：">基本的HTTP服务：</h5><ul><li>作为HTTP代理服务器和反向代理服务器</li><li>支持通过缓存加速访问</li><li>完成简单的负载均衡和容错</li><li>支持包过滤</li><li>支持SSL</li></ul><h5 id="高级http服务：">高级HTTP服务：</h5><ul><li>进行自定义配置</li><li>支持虚拟主机</li><li>支持URL重定向</li><li>支持网络监控</li><li>支持流媒体传输</li></ul><h5 id="邮件服务：">邮件服务：</h5><ul><li>支持IMAP/POP3代理服务</li><li>支持内部SMTP代理服务</li></ul><h4 id="常用功能">常用功能</h4><h5 id="http代理和反向代理">HTTP代理和反向代理</h5><p>在反向代理服务方面，Nginx服务器转发前端请求性能稳定，并且后端转发与业务配置相互分离，配置相当灵活。</p><h5 id="负载均衡">负载均衡</h5><p>负载均衡：一是将单一的重负载分担到多个网络节点做并行处理，每个节点处理结束后将结果汇总返回给用户；二是讲大量的前端并发访问或数据流量分担到多个后端网络节点上分别处理，有效减少前端用户等待响应的时间。Nginx服务器的负载均衡主要是对大量的前端访问和流量进行分流，以保证前端用户的访问效率。</p><p>Nginx服务器的负载均衡策略可以划分为两类：</p><ul><li>内置策略：轮询、加权轮询和IP hash</li><li>扩展策略：通过第三方模块实现，常见：url hash、fair</li></ul><h5 id="web缓存">Web缓存</h5>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云服务器Linux挖比特币</title>
      <link href="/2018/01/19/Random/tencentcloud_bitcoin/"/>
      <url>/2018/01/19/Random/tencentcloud_bitcoin/</url>
      
        <content type="html"><![CDATA[<h3 id="腾讯云服务器linux挖比特币">腾讯云服务器Linux挖比特币</h3><p>毕竟又是一个周五的下午，有点等着放假，就想起来现在的挖矿，虽然现在挖矿都是专门的矿机或者是显卡之类的。但是经过计算，好像自己挖的话连电费都不够，就想试试云服务器可不可以，虽然CPU做这种傻瓜的计算问题可能不如专门的器件是吧。</p><a id="more"></a><p>这是我的ubuntu服务器的。</p><ul><li>注册一个矿池账号，推荐https://www.f2pool.com/</li><li>通过ssh连接远程服务器</li><li>下载挖矿工具这里别人推荐的地址可能有问题，或者我这个之后也会升级，所以可以直接去官网下载最新的推荐的版本就行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;cpuminer&#x2F;pooler-cpuminer-2.5.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf ooler-cpuminer-2.5.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>nohup命令后台一直运行注意：不同的端口对应不同的币，一个用户名可以在后面例如：mianhk.001，mianhk.002代表不同的矿机。userpass后面是账户名和密码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 以下不同的地址对应的是不同的矿</span><br><span class="line">nohup .&#x2F;minerd -a scrypt -o stratum+tcp:&#x2F;&#x2F;stratum.f2pool.com:3333 --userpass&#x3D;账号:密码 &amp;</span><br><span class="line"></span><br><span class="line">nohup .&#x2F;minerd -a scrypt -o stratum+tcp:&#x2F;&#x2F;xmr.f2pool.com:13531 --userpass&#x3D;账号:密码 &amp;</span><br><span class="line"></span><br><span class="line">nohup .&#x2F;minerd -a scrypt -o stratum+tcp:&#x2F;&#x2F;zec.f2pool.com:3357 --userpass&#x3D;账号:密码 &amp;</span><br></pre></td></tr></table></figure><p>之后，就可以打开日志文件看到在挖矿了。我们还需要在网站填上自己的比特币钱包地址。但是这个挖的数目确实有点小啊<img src="https://blog-1252063226.cosbj.myqcloud.com/tools/001001.png?raw=true" alt=""></p><p>之后打开腾讯云服务器可以看到CPU已经跑满了啊。<img src="https://blog-1252063226.cosbj.myqcloud.com/tools/001002.png?raw=true" alt=""></p><p>然后之后就看到网上说云服务器跑的太满的话，会被封的，那就把CPU限制一下吧。步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cpulimit</span><br><span class="line">top  # 查看pid</span><br><span class="line">cpulimit -p pid -l n  # n是限制的值</span><br></pre></td></tr></table></figure><p><strong>下面是centos的，因为有两台服务器，但是centos放的是vpn，平时还没装过软件呢</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install cpulimit</span><br><span class="line">top  # 查看pid</span><br><span class="line">cpulimit -p pid -l n  # n是限制的值</span><br></pre></td></tr></table></figure><p>限制之后，就能明显的看到CPU占用没有满了：<img src="https://blog-1252063226.cosbj.myqcloud.com/tools/001003.jpg?raw=true" alt=""><img src="https://blog-1252063226.cosbj.myqcloud.com/tools/001004.jpg?raw=true" alt=""></p><p>哈哈，就当玩玩吧，多了解一下区块链，总得跟上节奏吧，虽然已经有点晚了的样子</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-36-Valid-Sudoku</title>
      <link href="/2018/01/14/Exercise/LeetCode-36-Valid-Sudoku/"/>
      <url>/2018/01/14/Exercise/LeetCode-36-Valid-Sudoku/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-36-valid-sudoku">LeetCode-36-Valid-Sudoku</h3><blockquote><p>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p></blockquote><div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/001.jpg" /> </div><br><p>判断一个二维数组是不是数独数组。要求是：同行同列，斜对角不能有相同的数组，这里需要定义三个数组，当然参考了一下讨论区一个大神的代码。采用行列，竖列和斜列。其中比较惊艳的是k=i/3*3+j/3;这里可以直接得到斜对角的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int used1[9][9]&#x3D;&#123;0&#125;,used2[9][9]&#x3D;&#123;0&#125;,used3[9][9]&#x3D;&#123;0&#125;;</span><br><span class="line">        for(int i&#x3D;0;i&lt;board.size();++i)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;board[i].size();++j)&#123;</span><br><span class="line">                if(board[i][j]!&#x3D;&#39;.&#39;)&#123;</span><br><span class="line">                    int num&#x3D;board[i][j]-&#39;0&#39;-1,k&#x3D;i&#x2F;3*3+j&#x2F;3;</span><br><span class="line">                    if(used1[i][num]||used2[j][num]||used3[k][num])</span><br><span class="line">                        return false;</span><br><span class="line">                    used1[i][num]&#x3D;used2[j][num]&#x3D;used3[k][num]&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="reference">reference:</h4><p>https://blog.csdn.net/u012050154/article/details/51541380</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-34-Search-for-a-Range</title>
      <link href="/2018/01/14/Exercise/LeetCode-34-Search-for-a-Range/"/>
      <url>/2018/01/14/Exercise/LeetCode-34-Search-for-a-Range/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-34-search-for-a-range">LeetCode-34-Search-for-a-Range</h3><blockquote><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].</p></blockquote><p>在一个排序的数组中找到出现这个值的起点和重点。很容易想到的是二分查找了。复杂度为<code>nlog(n)</code>。思路如下，先二分查找，找到下界，如果下界lo的值不等于target时，直接返回{-1，-1}，否则，直接将下界添加到res中。之后重置上界，同样的方法搜索上界。注意到，<strong>由于每次循环中，我们只考虑了一个界，所以只有一个界能mid+1，否则就会出现相等的也被else处理了。写的时候就是这个问题没有考虑好，折腾了很久。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; res&#x3D;&#123;-1,-1&#125;;</span><br><span class="line">        if(nums.size()&lt;&#x3D;0)</span><br><span class="line">            return res;</span><br><span class="line">        int lo&#x3D;0,hi&#x3D;nums.size()-1;</span><br><span class="line">        while(lo&lt;hi)&#123;  &#x2F;&#x2F;找下界</span><br><span class="line">            int mid&#x3D;(lo+hi)&#x2F;2;</span><br><span class="line">            if(nums[mid]&lt;target)</span><br><span class="line">                lo&#x3D;mid+1;</span><br><span class="line">            else</span><br><span class="line">                hi&#x3D;mid;</span><br><span class="line">        &#125;</span><br><span class="line">        if((nums[lo]!&#x3D;target))&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            res[0]&#x3D;lo;</span><br><span class="line">        hi&#x3D;nums.size()-1;</span><br><span class="line">        while(lo&lt;hi)&#123;  &#x2F;&#x2F;找上界</span><br><span class="line">            int mid&#x3D;(lo+hi)&#x2F;2+1;</span><br><span class="line">            if(nums[mid]&gt;target)</span><br><span class="line">                hi&#x3D;mid-1;</span><br><span class="line">            else</span><br><span class="line">                lo&#x3D;mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[1]&#x3D;hi;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然还看到有用stl的方法的，直接用lower_bound()和upper_bound()函数，速度要快一些。虽然觉得stl应该也是一样的原理写的吧。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if (nums.empty()) return&#123; -1, -1 &#125;;</span><br><span class="line"></span><br><span class="line">    auto iter1 &#x3D; lower_bound(nums.begin(), nums.end(), target);</span><br><span class="line">    auto iter2 &#x3D; upper_bound(nums.begin(), nums.end(), target);</span><br><span class="line"></span><br><span class="line">    if (iter1 &#x3D;&#x3D; nums.end()) return&#123; -1, -1 &#125;;</span><br><span class="line"></span><br><span class="line">    if ((*iter1) !&#x3D; target) return&#123; -1, -1 &#125;;</span><br><span class="line">    vector&lt;int&gt; tmp(2, 0);</span><br><span class="line">    tmp[0] &#x3D; iter1 - nums.begin();</span><br><span class="line"></span><br><span class="line">    --iter2;</span><br><span class="line">    tmp[1] &#x3D; iter2 - nums.begin();</span><br><span class="line">    return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-32-Longest-Valid-Parentheses</title>
      <link href="/2018/01/12/Exercise/LeetCode-32-Longest-Valid-Parentheses/"/>
      <url>/2018/01/12/Exercise/LeetCode-32-Longest-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-32-longest-valid-parentheses">LeetCode-32-Longest-Valid-Parentheses</h3><blockquote><p>Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.For “(()”, the longest valid parentheses substring is “()”, which has length = 2.Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p></blockquote><p>表示这是一道没有看懂题目的题，看到题目的难度是hard，但是自己的想法很简答，以为直接一个栈就可以了。。 too young啊</p><p>提交之后才知道，原来还要解决类似<code>()((()))</code>这类问题，所以这是一个动态规划的问题啊。昨天看了一下动态规划，我们首先要构建D数组，如下所示的<code>vector longest</code>，负责存下当前第i个的长度。需要考虑的情况如下。只有当s[i]为<code>)</code>时，才需要判断，如果它的左边是<code>(</code>或者<code>)</code>的情况。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestValidParentheses(string s) &#123;</span><br><span class="line">        if(s.length()&lt;&#x3D;1)</span><br><span class="line">            return 0;</span><br><span class="line">        vector&lt;int &gt; longest(s.size(),0);</span><br><span class="line">        int curMax&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;s.length();++i)&#123;</span><br><span class="line">            if(s[i]&#x3D;&#x3D;&#39;)&#39;)&#123;</span><br><span class="line">                if(s[i-1]&#x3D;&#x3D;&#39;(&#39;)&#123;</span><br><span class="line">                    longest[i]&#x3D;(i-2&gt;&#x3D;0?(longest[i-2]+2):2);</span><br><span class="line">                    curMax&#x3D;curMax&gt;longest[i]?curMax:longest[i];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if(i-longest[i-1]-1&gt;&#x3D;0&amp;&amp;s[i-longest[i-1]-1]&#x3D;&#x3D;&#39;(&#39;)&#123;</span><br><span class="line">                        longest[i]&#x3D;longest[i-1]+2+((i-longest[i-1]-2&gt;&#x3D;0)?longest[i-longest[i-1]-2]:0);</span><br><span class="line">                        curMax&#x3D;curMax&gt;longest[i]?curMax:longest[i];</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return curMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-31-Next-Permutation</title>
      <link href="/2018/01/12/Exercise/LeetCode-31-Next-Permutation/"/>
      <url>/2018/01/12/Exercise/LeetCode-31-Next-Permutation/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-31-next-permutation">LeetCode-31-Next-Permutation</h3><blockquote><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place, do not allocate extra memory.</p></blockquote><p>这个排序主要是有两种情况，一个是类似于<code>3 1 2</code>这样的情况，直接从后往前找到第一个<code>nums[i]&lt;nums[i-1]</code>的，然后把<code>i</code>记下来，再与后面第一个小于<code>i</code>的<code>k</code>调换顺序之后，对<code>i</code>后面的进行反转排序就好了。另一种情况是：已经反转成功了，类似<code>3 2 1</code>，需要直接置为最开始的状态，处理方式是，依旧从后往前找<code>i</code>,如果没有找到的话，就可以直接将序列反转即可。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int k&#x3D;-1;</span><br><span class="line">        for(int i&#x3D;nums.size()-2;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">            if(nums[i]&lt;nums[i+1])&#123;</span><br><span class="line">                k&#x3D;i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k&#x3D;&#x3D;-1)&#123;</span><br><span class="line">            reverse(nums.begin(),nums.end());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int l&#x3D;0;</span><br><span class="line">        for(int i&#x3D;nums.size()-1;i&gt;k;--i)&#123;</span><br><span class="line">            if(nums[i]&gt;nums[k])&#123;</span><br><span class="line">                l&#x3D;i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[l],nums[k]);</span><br><span class="line">        reverse(nums.begin()+k+1,nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-19-Remove-Nth-Node-From-End-of-List</title>
      <link href="/2018/01/12/Exercise/LeetCode-19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/2018/01/12/Exercise/LeetCode-19-Remove-Nth-Node-From-End-of-List/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Given a linked list, remove the nth node from the end of list and return its head.For example,</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">   After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p>这个题目之前在剑指offer上就有，记得当时的方法是：采用两个指针，首先判断n的大小是否比链表的长度要大，大的话直接返回。否则采用一前一后两个指针，两个指针相差n，当前面的指针到链表末尾时，后面的指针所在的位置就是要删除的位置了。</p><p>当然，这是个很好的方法，不过看了一下后面的答案，以及前天看到的一个有点不是很明白的一个答案，才知道大家都用的是二级指针，二级指针的好处是，可以直接记住链表的头节点，而不至于总是去判断。这样显得对指针的理解就不一样了。可以看看下面的这篇文章。</p><p><a href="http://blogread.cn/it/article/6243?f=wb" target="_blank" rel="noopener">Linus：利用二级指针删除单向链表</a></p><p>下面是代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        ListNode **t1&#x3D;&amp;head,*t2&#x3D;head; &#x2F;&#x2F;这样head一直指向的是头节点</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;++i)&#123;</span><br><span class="line">            t2&#x3D;t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(t2!&#x3D;nullptr)&#123;</span><br><span class="line">            t1&#x3D;&amp;((*t1)-&gt;next);</span><br><span class="line">            t2&#x3D;t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        *t1&#x3D;(*t1)-&gt;next; &#x2F;&#x2F;删除找到的节点</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>无奈每次提交总是有群禽兽比我的快那么多啊，我的12ms，别人的6ms。。</p><p>不过别人的代码一看好像也还好，思路都是差不多的，就是一些细节的地方注意的比较好，看来还得好好弄啊。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        int counter &#x3D; 0;</span><br><span class="line">        if(!head || !n) &#123;</span><br><span class="line">            return head;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p &#x3D; head;</span><br><span class="line">        ListNode **pp &#x3D; &amp;head;</span><br><span class="line">        while(p &amp;&amp; n) &#123;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">            pp &#x3D; &amp;((*pp)-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp &#x3D; *pp;</span><br><span class="line">        *pp &#x3D; temp-&gt;next;</span><br><span class="line">        delete(temp);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-23-Merge-k-Sorted-Lists</title>
      <link href="/2018/01/11/Exercise/LeetCode-23-Merge-k-Sorted-Lists/"/>
      <url>/2018/01/11/Exercise/LeetCode-23-Merge-k-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="23-merge-k-sorted-lists">23. Merge k Sorted Lists</h3><blockquote><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p></blockquote><p>这个题乍一看只是对链表的一个排序，因为是很多个链表，所以很简单的想法就是将整个数组里面的两个链表分别进行排序。两个两个互相排序之后就能排好。这里用的是递归。当vector中的元素大于1说明还没有排完。直接一下就AC了，但是一看detail，果然时间有点长。运行时间内93ms，看到别人的只需要20+。。还是先记一下自己的代码 吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* merge2List(ListNode* lList,ListNode* rList)&#123;</span><br><span class="line">        if(lList&#x3D;&#x3D;nullptr)</span><br><span class="line">            return rList;</span><br><span class="line">        if(rList&#x3D;&#x3D;nullptr)</span><br><span class="line">            return lList;</span><br><span class="line">        if(lList-&gt;val&lt;rList-&gt;val)&#123;</span><br><span class="line">            lList-&gt;next&#x3D;merge2List(lList-&gt;next,rList);</span><br><span class="line">            return lList;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            rList-&gt;next&#x3D;merge2List(lList,rList-&gt;next);</span><br><span class="line">            return rList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        if(lists.size()&#x3D;&#x3D;0)</span><br><span class="line">            return nullptr;</span><br><span class="line">        while(lists.size()&gt;1)&#123;</span><br><span class="line">            lists.push_back(merge2List(lists[0],lists[1]));</span><br><span class="line">            lists.erase(lists.begin());</span><br><span class="line">            lists.erase(lists.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        return lists[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了一下别人的代码，用了优先队列，进行排序，没有重新写了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    class Cmp</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        bool operator() (ListNode *a, ListNode *b) const</span><br><span class="line">        &#123;</span><br><span class="line">            return a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, Cmp&gt; pq;</span><br><span class="line">        ListNode *head &#x3D; NULL;</span><br><span class="line">        ListNode *cur &#x3D; NULL;</span><br><span class="line">        int k &#x3D; lists.size();</span><br><span class="line">        if(k &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        for(ListNode *list: lists)</span><br><span class="line">        &#123;</span><br><span class="line">            if(list !&#x3D; NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.push(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while( !pq.empty() )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *next &#x3D; pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            if(next-&gt;next !&#x3D; NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.push(next-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            next-&gt;next &#x3D; NULL;</span><br><span class="line">            if(head &#x3D;&#x3D; NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                head &#x3D; next;</span><br><span class="line">                cur &#x3D; head;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next &#x3D; next;</span><br><span class="line">                cur &#x3D; cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-15-3Sum&amp;&amp;4Sum</title>
      <link href="/2018/01/10/Exercise/LeetCode-15-3Sum/"/>
      <url>/2018/01/10/Exercise/LeetCode-15-3Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="15-3sum">15. 3Sum</h3><blockquote><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Note: The solution set must not contain duplicate triplets.</span><br><span class="line">For example, given array S &#x3D; [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>同之前的2sum差不多，计算两个的和的方式是：为了避免重复，重新用一个set容器，解决重复的问题。但是这里的情况是，重复的一个数字是可以出现的，而且是三个数字相加的和，所以我们没法用之前的处理办法。</p><p>很容易想到的办法是，先让一个指针向前走，然后对之后的数字搜索，为了减少搜索的复杂度，我们可以先将数组进行排序，先排序后搜索，可以从O(n^2)的复杂度减小到nlog(n)，所以采用先排序。</p><p>然而这里需要注意的是，需要判断数组中有相同数字的情况。虽然结果中允许有相同的数字出现，但不允许出现完全相同的两个结果，所以需要处理这种情况。具体的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(nums.size()&lt;&#x3D;0)</span><br><span class="line">            return res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.size()&amp;&amp;nums[i]&lt;&#x3D;0;++i)&#123;</span><br><span class="line">            int j&#x3D;i+1,k&#x3D;nums.size()-1;</span><br><span class="line">            while(j&lt;k)&#123;</span><br><span class="line">                    if(nums[i]+nums[j]+nums[k]&lt;0)</span><br><span class="line">                        j++;</span><br><span class="line">                    else if(nums[i]+nums[j]+nums[k]&gt;0)</span><br><span class="line">                        --k;</span><br><span class="line">                    else if(nums[i]+nums[j]+nums[k]&#x3D;&#x3D;0)&#123;</span><br><span class="line">                        vector&lt;int&gt; temp(3,0);</span><br><span class="line">                        temp[0]&#x3D;nums[i];</span><br><span class="line">                        temp[1]&#x3D;nums[j];</span><br><span class="line">                        temp[2]&#x3D;nums[k];</span><br><span class="line">                        res.push_back(temp);</span><br><span class="line">                        while(k&gt;j&amp;&amp;nums[k]&#x3D;&#x3D;temp[2]) &#x2F;&#x2F;去除k的重复</span><br><span class="line">                            k--;</span><br><span class="line">                        while(k&gt;j&amp;&amp;nums[j]&#x3D;&#x3D;temp[1]) &#x2F;&#x2F;去除j的重复</span><br><span class="line">                            j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                while(i+1&lt;nums.size()&amp;&amp;nums[i+1]&#x3D;&#x3D;nums[i])  &#x2F;&#x2F;去除i的重复</span><br><span class="line">                    i++;</span><br><span class="line">            &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="18-4sum">18. 4Sum</h3><blockquote><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p></blockquote><p>**Note **: The solution set must not contain duplicate quadruplets.</p><p>其实跟前面的3sum解决的办法是一样的，无非这里为了减少一点复杂度，借用了一下大家使用的方法。，在每次遍历的时候进行一点判断，以减少循环的次数。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int n&#x3D;nums.size();</span><br><span class="line">        if(n&lt;4)</span><br><span class="line">            return res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for(int i&#x3D;0;i&lt;n-3;++i)&#123;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;</span><br><span class="line">            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break;</span><br><span class="line">            if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3]&lt;target) continue;</span><br><span class="line">            for(int j&#x3D;i+1;j&lt;nums.size()-2;++j)&#123;</span><br><span class="line">                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]) continue;</span><br><span class="line">                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break;</span><br><span class="line">                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue;</span><br><span class="line">                int begin&#x3D;j+1,end&#x3D;n-1;</span><br><span class="line">                while(begin&lt;end)&#123;</span><br><span class="line">                    int sum&#x3D;nums[i]+nums[j]+nums[begin]+nums[end];</span><br><span class="line">                    if(sum&gt;target)</span><br><span class="line">                        --end;</span><br><span class="line">                    else if(sum&lt;target)</span><br><span class="line">                        ++begin;</span><br><span class="line">                    if(sum&#x3D;&#x3D;target)&#123;</span><br><span class="line">                        vector&lt;int&gt; temp(4,0);</span><br><span class="line">                        temp[0]&#x3D;nums[i];</span><br><span class="line">                        temp[1]&#x3D;nums[j];</span><br><span class="line">                        temp[2]&#x3D;nums[begin];</span><br><span class="line">                        temp[3]&#x3D;nums[end];</span><br><span class="line">                        res.push_back(temp);</span><br><span class="line">                        while(begin&lt;end&amp;&amp;temp[2]&#x3D;&#x3D;nums[begin])</span><br><span class="line">                            ++begin;</span><br><span class="line">                        while(begin&lt;end&amp;&amp;temp[3]&#x3D;&#x3D;nums[end])</span><br><span class="line">                            --end;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-8-String to Integer (atoi)</title>
      <link href="/2018/01/09/Exercise/LeetCode-8-String-to-Integer-atoi/"/>
      <url>/2018/01/09/Exercise/LeetCode-8-String-to-Integer-atoi/</url>
      
        <content type="html"><![CDATA[<h3 id="8-string-to-integer-atoi">8.String to Integer (atoi)</h3><blockquote><p>Implement atoi to convert a string to an integer.</p></blockquote><p>讲字符串转化为整型。当然过程很简单，但是需要考虑的乱七八糟的情况很多，空格和正负号之类的。提交了一百次，终于过了，但是看到别人的代码还是很气呀，还是得多写才行，但是起码写的慢慢有感觉了是吧。总体思路基本都是差不多的：1.循环字符串，从第一个开始不为空的字符开始判断，如果是正负号，则只能有一个正负号，进行标记，数字开始。2.数字开始之后，出现空格或者字母，返回已经生成的整型。3.当数字大于最大的整数或者小于最小的整数的时候，应该将其置为最大或者最小。所以这里应该将结果定义为long long int ，不然当加到INT_MAX的时候，会自动+1，置为INT_MIN，应该避免这样的情况。这里贴一下自己改的乱七八糟的代码吧，实在很气呀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int myAtoi(string str) &#123;</span><br><span class="line">        int flag&#x3D;1;</span><br><span class="line">        long long int res&#x3D;0;</span><br><span class="line">        int begin&#x3D;-1;</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.size();++i)&#123;</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39;-&#39;||str[i]&#x3D;&#x3D;&#39;+&#39;)&#123;</span><br><span class="line">                if(begin!&#x3D;-1)</span><br><span class="line">                    return 0;</span><br><span class="line">                begin&#x3D;i;</span><br><span class="line">                flag&#x3D;str[i]&#x3D;&#x3D;&#39;-&#39;?-1:1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(str[i]&gt;&#x3D;&#39;0&#39;&amp;&amp;str[i]&lt;&#x3D;&#39;9&#39;)&#123;</span><br><span class="line">                begin&#x3D;i;</span><br><span class="line">                res&#x3D;res*10+str[i]-48;</span><br><span class="line">                if(res*flag&gt;INT_MAX)</span><br><span class="line">                    return INT_MAX;</span><br><span class="line">                if(res*flag&lt;INT_MIN)</span><br><span class="line">                    return INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(str[i]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                if(begin!&#x3D;-1)</span><br><span class="line">                    return res*flag;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return res*flag;</span><br><span class="line">        &#125;</span><br><span class="line">        return res*flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交一看，这个时间还有点问题，就懒得自己再改了，思路都是一样的吧，就直接贴过来学习一下了，即使我觉得写的也一般呀。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int myAtoi(string str) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        long long res &#x3D; 0;</span><br><span class="line">        if(str.size() &#x3D;&#x3D; 0)</span><br><span class="line">            return res;</span><br><span class="line"></span><br><span class="line">        while(i &lt; str.size() &amp;&amp; str[i] &#x3D;&#x3D; &#39; &#39;)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        if(str[i] &#x3D;&#x3D; &#39;+&#39;)</span><br><span class="line">            i++;</span><br><span class="line">        else if(str[i] &#x3D;&#x3D; &#39;-&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            flag &#x3D; -1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(str[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;9&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            res &#x3D; res * 10 + str[i] - &#39;0&#39;;</span><br><span class="line">            i++;</span><br><span class="line">        if(res * flag &gt;&#x3D; INT_MAX)</span><br><span class="line">            return INT_MAX;</span><br><span class="line">        if(res * flag &lt;&#x3D; INT_MIN)</span><br><span class="line">            return INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return res * flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精剪生活</title>
      <link href="/2017/12/10/Random/cut-life/"/>
      <url>/2017/12/10/Random/cut-life/</url>
      
        <content type="html"><![CDATA[<p>好像从小的时候开始，拥有各种感兴趣的事情或者不只是好好学习就像一种美德一样充斥于我们与同龄人的自己的生活中。就像小时候打的弹珠和后面看的小说乒乓球和dota一样。哦，对，应该说是合群，或者是接地气，就是所有与同龄人正常社交所需的娱乐活动吧。所以作为一个老师口中活泼开朗的学生，这些我基本都有，可能玩的不一定好，但是so what，只要不是像“那些只爱学习的同学”一样，好像都够了。</p><a id="more"></a><p>于是，也不知道什么时候就慢慢形成了广泛的娱乐活动了。直到现在，想起自己好像啥都能参与，就像篮球里能够从1打到5的那种全能型选手，不一定有机会上场，但总是差不多合格一样。想一下现在自己的娱乐：</p><ul><li>打球？篮球、羽毛球、乒乓球，都可以打一些。虽然现在打篮球确实少了很多了，一个是宿舍就我一个人去，这样就很多时候懒得去了。羽毛球呢，总觉得要是四个人比较好，但是又对天气有些要求。还有乒乓球，需要有个水平不是很厉害还愿意跟我 打的了。。。</li><li>打麻将？这个简直是好约啊，四个人可以动脑或者不动脑的室内活动，主动或者三缺一的要求，都是相当的容易，这种活动还一般安排在吃饭的后边，就像你有时候也没法拒绝吃饱之后某个茶楼的茶一样，因为即使回去也还是睡觉是吧，而且自己总是告诉自己不要把生命浪费在床上。</li><li>各种吃饭？是的，忘了多少个睡到十点的周末，大家在一边互相催着起床一边讨论中午吃什么，于是由简单的黄焖鸡变成了鸡公煲，自助、火锅。。然后就是一个白天很快就过去了。</li><li>打游戏？简直是不可或缺的一部分啊。好像之前一年已经很少玩了。直到暑假开始玩的一个垃圾手游，轩辕传奇，几乎每天要花一个多小时的时间吧，想了一下，占据了我基本每天吃完午饭到睡觉之前和晚上回到宿舍到上床的一段时间。这段时间本来就不是很长，但是却被我用的看起来更紧张了。还有偶尔同学们约的王者荣耀，我基本自己都没有打过。还有最近的荒野行动，也是周末晚上或者正好十点多的上午才会有的娱乐。</li><li>看书？当然，我还是愿意把这个算进去。毕竟看的一些闲书，不能说没用，但确实是一种娱乐了吧。占据了上床到睡觉之前的不玩手机的时间，这个时间可能更短了。</li><li>然后，实验室玩手机？这个就不多说了，想想每天的手机电量吧。</li><li>乱七八糟的折腾？额，年轻的特征吗。。没意思的东西还是少弄点了吧</li></ul><p>这样看的话其实生活好像也很正常的，但是却是感觉每天，或者周末都很忙，忙了还不知道自己干了啥。有些难受。而且这好像也是自己写的第二篇这种苦恼了，上一次也是觉得这样的周末，但是两周过去了，好像还没有好多少，可能周末确实适合这么过，但是显然不是现在。接下来需要做的，就是精简生活了，不是什么活动都需要参加的是吧，也不是什么都需要自己关注的是吧，也不用总是活在一个中心。** 先专注做好自己现在该做的事情，或者先想想？**</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂想 </tag>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网-剑指offer-11</title>
      <link href="/2017/12/03/Exercise/nowcoder-sword-to-offer11/"/>
      <url>/2017/12/03/Exercise/nowcoder-sword-to-offer11/</url>
      
        <content type="html"><![CDATA[<h4 id="t31：把数组排成最小的数">T31：把数组排成最小的数</h4><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p></blockquote><p>这里想到的是，要对数组里面的所有数进行一个排序：不只是排长度，还要排最高位的大小。于是可以通过c++的STL的排序，通过自己定义的一个谓语比较函数。在这个比较函数里，把整数转成string进行比较，但是想到string的长度不一样的话也没法比较字符的大小了。所以分别将两个数加在一起，前后顺序不同，这样string的长度就一样了，比较的就是顺序了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        string result;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),cmp);</span><br><span class="line">        for(int i&#x3D;0;i!&#x3D;numbers.size();++i)&#123;</span><br><span class="line">            result+&#x3D;to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static bool cmp(int a,int b)&#123;</span><br><span class="line">        string A&#x3D;to_string(a)+to_string(b);</span><br><span class="line">        string B&#x3D;to_string(b)+to_string(a);</span><br><span class="line">        return A&lt;B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t32：丑数">T32：丑数</h4><blockquote><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p></blockquote><p>要求出第N个丑数，显然就要求到这N个，所以就要把所有的找出来嘛。简单的办法，就是2,3，5的倍数，但是这些倍数出来的丑数的顺序，这时候需要排序。显然不能直接对所有的都排序，那复杂度就太大了。这里一种考虑就是：比如，对于一次倍数的计算，如果2的倍数比原来的都大，那么3和5的倍数显然只会更大了。所以可以通过记录下此时分别为2,3,5倍数三个值，这样就可以减少比较的次数了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        if(index&#x3D;&#x3D;0)</span><br><span class="line">            return 0;  &#x2F;&#x2F;解决边界条件</span><br><span class="line">        vector&lt;int&gt; result(index);</span><br><span class="line">        result[0]&#x3D;1;</span><br><span class="line">        int x&#x3D;0,y&#x3D;0,z&#x3D;0,i;</span><br><span class="line">        for(i&#x3D;1;i&lt;index;i++)&#123;</span><br><span class="line">            result[i]&#x3D;min(result[x]*2,min(result[y]*3,result[z]*5));</span><br><span class="line">            if(result[i]&#x3D;&#x3D;result[x]*2)</span><br><span class="line">                x++;</span><br><span class="line">            if(result[i]&#x3D;&#x3D;result[y]*3)</span><br><span class="line">                y++;</span><br><span class="line">            if(result[i]&#x3D;&#x3D;result[z]*5)</span><br><span class="line">                z++;</span><br><span class="line">        &#125;</span><br><span class="line">        return result[index-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t33：第一个只出现一次的字符">T33：第一个只出现一次的字符</h4><blockquote><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p></blockquote><p>很容易想到的一种复杂度为O(n)的算法是采用哈希表，遍历一次，将出现的字符放在键中，出现一次即在值中加1。第二次遍历，直接查找该键对应的值，第一个为1的输出即可。当然，这里由于是字符，所以可以直接采用数组的形式。** 一定要记得对数组进行初始化**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FirstNotRepeatingChar(string str) &#123;</span><br><span class="line">        if(str.size()&#x3D;&#x3D;0)</span><br><span class="line">            return -1;        &#x2F;&#x2F;处理边界条件</span><br><span class="line">        int res[256]&#x3D;&#123;0&#125;;  &#x2F;&#x2F;局部变量，一定要初始化啊</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(;i!&#x3D;str.size();++i)&#123;</span><br><span class="line">            res[(int)str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i&#x3D;0;i!&#x3D;str.size();++i)&#123;</span><br><span class="line">            if(res[(int)str[i]]&#x3D;&#x3D;1)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return str.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网-剑指offer-10</title>
      <link href="/2017/12/01/Exercise/nowcoder-sword-to-offer10/"/>
      <url>/2017/12/01/Exercise/nowcoder-sword-to-offer10/</url>
      
        <content type="html"><![CDATA[<h4 id="t28：最小的k个数">T28：最小的K个数</h4><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p></blockquote><ul><li>解法一：剑指offer上给的有两种办法，一种是对数组进行排序，类似于快速排序的方式，假设基于第k个数来调整，就可以将比k小的数全放在左边，比k大的数都放在右边，于是，最后k左边的数即为最小的k个数。优点：平均时间复杂度：O(n)，思路较快缺点：需要修改数组</li><li>解法二：算法复杂度O(nlogk)，适合海量的数据。需要我们一个能存储k个数的容器，当容器中的数不足k个的时候，直接装进容器，当超过的时候，需要拿容器中最大的数与新的数进行比较，新数小的时候，替换已有的最大。如此，每一个新的数都需要判断，这样会增加复杂度，但是在海量数据处理的时候比较适合，因为无法一次把所有的数据都载入内存。下面是解法二的代码：（没有采用multiset，直接用的vector排序的，原理一样，但是我的stl确实没有用好，下次再改吧）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F;没有考虑复杂度的情况，都是直接写的</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        &#x2F;&#x2F;判断输入为空，或者k大于input的个数的情况</span><br><span class="line">        if(input.size()&lt;&#x3D;0||k&#x3D;&#x3D;0||k&gt;input.size())</span><br><span class="line">            return result;</span><br><span class="line">        vector&lt;int&gt;::iterator iter&#x3D;input.begin();</span><br><span class="line">        for(;iter!&#x3D;input.end();++iter)&#123;</span><br><span class="line">            sort(result.begin(),result.end());</span><br><span class="line">            if(result.size()&lt;k)</span><br><span class="line">                result.push_back(*iter);</span><br><span class="line">            else if(*iter&lt;*(result.end()-1))&#123;</span><br><span class="line">                result.pop_back();</span><br><span class="line">                result.push_back(*iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t29：连续子数组的最大和">T29：连续子数组的最大和</h4><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><p>主要是想为什么会有最大的和，一个情况是，新加上的数比原来的数都要大，就要开始考虑需不需要原来的数了。所以我们需要两个数，一个保存最大的和，用来返回，一个 保存当前的和，可以在适当的时候丢掉。  另一种情况，加入的数都比原来的小，即都是负数的时候，可能最大和只是一个最小的数；另外，当都是正数的时候也比较好解决。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        if(array.size()&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        int curSum&#x3D;array[0];&#x2F;&#x2F;注意这里不能用0，因为会出现数组值全小于0的情况</span><br><span class="line">        int maxSum&#x3D;array[0];</span><br><span class="line">        for(int i&#x3D;1;i!&#x3D;array.size();++i)&#123;</span><br><span class="line">            curSum+&#x3D;array[i];</span><br><span class="line">            if(curSum&lt;array[i])</span><br><span class="line">                curSum&#x3D;array[i];</span><br><span class="line">            if(maxSum&lt;curSum)</span><br><span class="line">                maxSum&#x3D;curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t30-整数中1出现的个数-从1到n整数中1出现的个数">T30:整数中1出现的个数(从1到n整数中1出现的个数)</h4><blockquote><p>题目描述：求出1<sub>13的整数中1出现的次数,并算出100</sub>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数</p></blockquote><p>显然，最简单的思路，从1遍历到n是吧，因为要找到每个数中1的个数。先不说这个，问题的重点是，这个1的个数怎么找。于是想到的是关于1存在的规律。比如很简单的就个位数而言，从0–9，只会出现一个1。由此想到，我们可以把n分成很多段进行计算。具体怎么分段，《剑指offer》上有个方法，不过确实有点难看明白了，就没有看，自己觉得可以按照从按10的倍数来分，1,10,100之类的，不过又有点问题，每个段内1的个数不一样，因为这样的话1的个数就不好算了。不过牛客网厉害的还是多啊，思路清晰，代码简洁。自己真的需要学习的有点多。不过后来又回头看了一下《剑指offer》上其实也是这样的。那就直接复述一遍具体的思路吧：根据设定的整数位置，对n进行分割。这里就直接选10了，高位是a=n/10，低位是b=n%10，循环条件直接就是n*10了，这样就可以从最后一位到最高位的遍历了。这里需要考虑的就是，a的最后一位，就是高位对应的最低位。</p><ul><li>当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1。</li><li>当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1。</li><li>当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）。代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;n&#x3D;1的情况</span><br><span class="line">        if(n&#x3D;&#x3D;1)</span><br><span class="line">            return 1;</span><br><span class="line">        &#x2F;&#x2F;考虑的边界情况，n&#x3D;10,100,1000之类的，同时循环中没有考虑n&#x3D;0的情况</span><br><span class="line">        if(n&gt;1&amp;&amp;n%10&#x3D;&#x3D;0)</span><br><span class="line">            count++;</span><br><span class="line">        &#x2F;&#x2F;没有考虑n&#x3D;1的情况</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i*&#x3D;10)&#123;</span><br><span class="line">            int a&#x3D;n&#x2F;i,b&#x3D;n%i;</span><br><span class="line">            &#x2F;&#x2F;补8的效果：当百位为0，则a&#x2F;10&#x3D;&#x3D;(a+8)&#x2F;10，</span><br><span class="line">            &#x2F;&#x2F;当百位&gt;&#x3D;2，补8会产生进位位，效果等同于(a&#x2F;10+1)</span><br><span class="line">            count+&#x3D;(a+8)&#x2F;10*i+(a%10&#x3D;&#x3D;1)*(b+1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个可能很熟悉的周末</title>
      <link href="/2017/11/26/Random/random-life-1/"/>
      <url>/2017/11/26/Random/random-life-1/</url>
      
        <content type="html"><![CDATA[<h3 id="2017-11-26-记录一个可能很熟悉的周末">2017-11-26 记录一个可能很熟悉的周末</h3><p>这周又过去了，时间依旧是这么快啊，待在实验室跟上一周的感觉差不多，还是周日的下午，晚上才想起来来一下实验室，还是本来想周末搞个学习，却还是没有一不小心就休息过去了，非常单纯的尊重了一下周末。</p><a id="more"></a><p>先记个心里活动加流水吧，很无聊，但是还是想写一下，看一下自己的周末重播是怎样的。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">本来周五晚上就没有睡很晚，所以生物钟还是个好东西，一到周末就提醒我不要起的太早，于是醒</span><br><span class="line">来还是十点多了，躺在床上玩了一会游戏觉得有点罪过，就起床搞搞学习，嗯，十点多，算是个相</span><br><span class="line">对还不错的时间了，如果不是上周立了flag说是周末要学习一天的话，即使以前的我好像可以不分</span><br><span class="line">周末一样。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">没错，起床了就学习啊，还是先看一下游戏吧，刚刚打开就看到有人说，游戏现在可以电脑端挂着</span><br><span class="line">了，一想，这样就不用耽误我时间看平板了，直接电脑上从代码切过来很快的样子，毕竟这么多年</span><br><span class="line">的单身。于是开始准备下。想一下，这个流量。。赶紧查一查，还有一个多G，，算一下还有几天，</span><br><span class="line">今天才25，好像有点不够呀，还是不下了吧。不过仔细一想，下一个电脑端，多省事啊，毕竟我不</span><br><span class="line">是一个轻易被困难打倒的人，于是看了一下手机，还有3G流量，好像也有点不够用了啊。又想起来</span><br><span class="line">上个月月末的两个活动送的2G流量，看看能不能，于是赶紧一顿操作，我靠，竟然还有啊。只能不</span><br><span class="line">好意思安心开始下游戏了。</span><br><span class="line"></span><br><span class="line">哇，搞学习的时间终于开始了啊，额，这个宿舍环境，好像更适合看视频一点，打开教学视频，习</span><br><span class="line">惯的1.5倍速，连上云服务器，先操作一顿，看看上周用的vim的操作忘了没有。然后切到视频，额</span><br><span class="line">，这讲的也太慢了吧，完全不把我的基础当回事啊，这也讲。。 算了，切一下看看游戏下的怎么样</span><br><span class="line">了，19%，才这么点啊。切回去，切过来，25%，再切过来，咦，怎么不动了，难道热点断了，看一</span><br><span class="line">下手机，额，没有啊，&#x3D;&#x3D;看，额，怎么错误了，怎么说。切回去把视频停一下，百度看看怎么回事。</span><br><span class="line">额，这垃圾游戏，百度都搜不到，额，这是啥啊，就是一个模拟器嘛，还下不下来。唉，算了，重试</span><br><span class="line">一遍吧。</span><br><span class="line"></span><br><span class="line">接下来是有点忧心忡忡的看着视频，一边心疼着流量啊，一边看。忍不了，切回去看看，2%,5%。。。</span><br><span class="line">额，40%，又不动了，又出错了。垃圾游戏，删掉。重新网上找一个。看一下手机，我靠，1G流量已经</span><br><span class="line">没了啊。算了，我去找个别的模拟器吧，还得搞学习呢，耽误我时间，分分钟搜到一个，赶紧下。 额</span><br><span class="line">，这次好像很顺利的样子，（百次切换后的十分钟。。）额，这个怎么有点不对的样子啊，头上怎么一</span><br><span class="line">个安卓的机器人啊，难道是只有安卓的才能用吗？这波就傻逼了。还先装的引擎，再下的游戏，额，这</span><br><span class="line">游戏都下了一半了，现在我是停不停啊，不会坑我吧。算了，中国有句古话说的好，来都来了是吧。。</span><br><span class="line">等等下完吧。</span><br><span class="line"></span><br><span class="line">终于下完了，我手机也提示2G的流量也没了。赶紧隆重的停一下视屏，装上看一看，额，怎么一个不是</span><br><span class="line">很熟悉的模拟器一样，上面就装了一个游戏，有点虚呀，兄弟。还是试试吧，擦，果然不可以啊，这下</span><br><span class="line">傻逼了。怎么说，哎，难道我老了，连这点都解决不了了。关机重启重下吧。</span><br><span class="line"></span><br><span class="line">重启！可是我的校园网没流量了啊，管他呢，先下了再说吧，出去吃饭了。。。。。。回来，赶紧看一</span><br><span class="line">下，哇，竟然下完了，看来西电的校园网还是有一点靠谱的嘛，装上试试，等等，这好像有点卡啊，这</span><br><span class="line">个，半天进不去啊。怎么他们说的可以啊，赶紧微信私聊一个人问一下，靠，他也很卡，刚刚自己还说</span><br><span class="line">可以的，擦。</span><br><span class="line"></span><br><span class="line">嗯，游戏总是很坑，但生活还得继续啊，周末的好天气也不忍心待在室内，难得在这个时间没有雾霾，</span><br><span class="line">已经快一点了，约的羽毛球和洗澡吃饭一条龙还没确定呢。赶紧找人啊，随便问一个，怎么不去？这也</span><br><span class="line">不去，只剩下我和这个破峰了？两个人怎么玩到四点去洗澡啊。额，再想想，于是看到师兄约篮球，要</span><br><span class="line">不怂恿看看？可是破峰竟然抛弃我准备先去洗澡了，但是这么好的天气，作为有点欠太阳的我是必须要</span><br><span class="line">出去运动一下的，那就去打篮球吧。。</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line">打完球四点多，打的有点累啊，回来休息一波，也没啥事干，要不休息一下带这个破峰玩一局吧，结果</span><br><span class="line">洗澡就是五点多了，自己去洗个澡，买点吃的，回来还是用平板玩会游戏，吃个饭，给家里打个电话，</span><br><span class="line">已经七点多了，想起游戏有活动啊，上来看看，顺便看看视频，额，完全看不进去啊，还有点累啊。算</span><br><span class="line">了，随便看看视频之类的吧，反正不想学习。额，我的校园网没了，要不用免费网下个游戏吧，试试看</span><br><span class="line">怎么样，就荒野行动吧，反正最近这么火是吧，这个速度有点快啊，确定是我自己的网吗？看一下，是</span><br><span class="line">我的，放心不是书记的。下完了，再更新，额，怎么一兆多啊，不对啊，再看一下，果然是书记的，我</span><br><span class="line">靠，这就尴尬了 。。于是结果就是半个小时陪着这个破书记去搞了吃的额</span><br><span class="line"></span><br><span class="line">回来已经十点多了，游戏终于下好了，怂恿破峰下一个吧。我先去床上玩一把。于是玩到了12点了。该</span><br><span class="line">睡觉了，好困啊，睡吧。</span><br><span class="line"></span><br><span class="line">星期天到了，看来睡的早还是可以啊，八点多就醒了，简直是像上帝多要了两个多小时的生命啊，赶紧</span><br><span class="line">玩会游戏浪费一下，玩到九点，额，怎么有点困啊，算了，睡吧，昨天打球确实有点累啊，年纪大了，</span><br><span class="line">不能拉杆了啊。休息休息。。。已经11点了啊，赶紧起来看看，随便一收拾，又要吃饭了，唉，赶紧收</span><br><span class="line">拾一下衣服扔下去，然后吃个饭，去个超市回来正好收衣服，我真会过日子啊，哈哈。</span><br><span class="line"></span><br><span class="line">回来又是一点，挂好衣服，干啥了，听听歌，洗洗东西。额，快两点了啊，赶紧休息一下，三点了，想</span><br><span class="line">起来周末好像完全没学习啊，关键是还是入党的东西很多没填啊，还是去一下实验室吧。。</span><br></pre></td></tr></table></figure><p>终于差不多记完了，真的有点无聊，但是确实好像又好像拜托不了的周末啊，除了周内每天按时上班让人周末不想好好起床以外，还有一些确实需要做的事情，比如锻炼和洗刷，时间好像也就那些。或者再稍微加点娱乐，再加点别的赖床，晚上再睡晚一点，时间就更短了啊。</p><p>显然，时间当然没法安排的这么满，但是确实也不是一点留给该做事的时间都没有的。为什么别人都有了，而我只是看似想着学习却实际上啥都没干呢？分析一下周末的时间：</p><ul><li>** 晚上的晚睡**：没有理由的晚睡当然是透支了第二天的白天的时间，晚睡的一两个小时，直接一个上午几乎没了，然后下午再随便一玩，就觉得一天啥都没干。</li><li>** 无聊的折腾**：有的时候很多的爱好并不是一件很好的事情，看看比赛的情况，刷个新闻，刷个朋友圈，看看游戏，再玩会游戏，直接学习时间就没了，直接体现就是在进度上。还会觉得很烦躁</li><li>** 当然还是有点懒啊**： 谁都有不想做啥的时候，但是生活就是这样，这就不多说了。</li></ul><p>直到晚上写个人自传的时候，才想起来很多没得啥写，生活就像游戏一样，你玩的多爽杀了多少人，能给你带来的快乐，除了当时的快乐，还有之后你回头看过来，自己有多少收获，有的时候不功利是一种美德，但有时候那只能证明你太年轻了，换句话说就是傻逼了，快乐的生活还是要建立在将来看起来也仍然是快乐的不是吗。</p><h3 id="希望以后换种方式的周末吧">希望以后换种方式的周末吧</h3>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网-剑指offer-3</title>
      <link href="/2017/11/17/Exercise/nowcoder-sword-to-offer3/"/>
      <url>/2017/11/17/Exercise/nowcoder-sword-to-offer3/</url>
      
        <content type="html"><![CDATA[<h4 id="t7：斐波那契数列">T7：斐波那契数列</h4><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p></blockquote><p>斐波那契数列是很常用的数列，也是很简单的递归能够解决的，但是当n稍微大一点的时候，复杂度都让人无法接受。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long long Fi(int n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(n&#x3D;&#x3D;1)</span><br><span class="line">        return 1;</span><br><span class="line">    return Fi(n-1)+Fi(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样出现的问题主要是在递归的过程中会出现很多重复的计算，比如我们每次计算第n个的时候，都需要重新计算前面的n-1和n-2，这样每个值其实都会被计算两遍。简单的处理是：从下往上开始算，从第0个一直算到第n个。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n&lt;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)</span><br><span class="line">            return 1;</span><br><span class="line">        int newNum&#x3D;1;</span><br><span class="line">        int oneNum&#x3D;1,twoNum&#x3D;1;</span><br><span class="line">        for(int i&#x3D;3;i&lt;&#x3D;n;++i)&#123;</span><br><span class="line">            newNum&#x3D;oneNum+twoNum;</span><br><span class="line">            oneNum&#x3D;twoNum;</span><br><span class="line">            twoNum&#x3D;newNum;</span><br><span class="line">        &#125;</span><br><span class="line">        return newNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t8：跳台阶">T8：跳台阶</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>该类问题其实就是斐波那契数列的应用：考虑第一次跳的情况，如果第一跳1级，那么后面就是n种情况，如果第一次跳2级，后面就是n-2种，于是：<code>f(n)=f(n-1)+f(n-2)</code>；同理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number&lt;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        int result&#x3D;0;</span><br><span class="line">        if(number&#x3D;&#x3D;1)</span><br><span class="line">            return 1;</span><br><span class="line">        int first_step&#x3D;1;</span><br><span class="line">        int second_step&#x3D;1;</span><br><span class="line">        while(number&gt;&#x3D;2)&#123;</span><br><span class="line">            --number;</span><br><span class="line">            result&#x3D;first_step+second_step;</span><br><span class="line">            first_step&#x3D;second_step;</span><br><span class="line">            second_step&#x3D;result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t9：变态跳台阶">T9：变态跳台阶</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>同样的分析：1.把第n级和第n-1级看成一级，则有：f(n-1)种；2.把第n级和第n-1级分开，则到n-1级有：f(n-1)，n-1级到第n级只有一种，所以加起来是：2*f(n-1)代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        if(number&lt;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        int result&#x3D;1;</span><br><span class="line">        if(number&#x3D;&#x3D;1)</span><br><span class="line">            return 1;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;number-1;++i)&#123;</span><br><span class="line">            result*&#x3D;2;</span><br><span class="line">            &#125;</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的专业书阅读</title>
      <link href="/2017/11/12/Random/books/"/>
      <url>/2017/11/12/Random/books/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="专业书">专业书</h1><ul><li>《Python核心编程》 ed2</li><li>《C++　Primer 》ed5</li><li>《STL 源码剖析》</li><li>《Effective C++》</li><li>《Unix 网络编程》卷一</li><li>《Unix 网络编程》卷二</li><li>《Unix 环境高级编程》</li><li>《Linux多线程服务端编程》陈硕</li><li>《TCP/IP详解》卷一</li></ul><h1 id="其他">其他</h1><h5 id="2017要看完的书-生活总得有一些flag是吧">2017要看完的书，生活总得有一些flag是吧</h5><p><a href="http://item.jd.com/12125924.html" target="_blank" rel="noopener">《人类简史》尤瓦尔·赫拉利</a><a href="http://item.jd.com/12099462.html" target="_blank" rel="noopener">《未来简史》尤瓦尔·赫拉利</a></p><hr><h5 id="2015-2016看的书：">2015-2016看的书：</h5><p><a href="http://item.jd.com/12125924.html" target="_blank" rel="noopener">经济学通识</a><a href="">霍乱时期的爱情</a><a href="">围城</a><a href="">雅库玛的诅咒</a><a href="">今天你真好看</a><a href="">鬼吹灯1</a><a href="">北京折叠</a><a href="">百年孤独</a><a href="">活着</a></p><hr><h5 id="东野圭吾专场"><strong>东野圭吾</strong>专场</h5><p><a href="">白夜行</a><a href="">嫌疑人X的现身</a><a href="">秘密</a><a href="">信</a><a href="">恶意</a><a href="">假面饭店</a><a href="">放学后</a><a href="">解忧杂货店</a><a href="">彷徨之刃</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我看的电影</title>
      <link href="/2017/11/12/Random/moives/"/>
      <url>/2017/11/12/Random/moives/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="记录我看的电影">记录我看的电影</h1><hr><h2 id="2018年">2018年–</h2><h3 id="目击者之追凶豆瓣8-1分"><a href="https://movie.douban.com/subject/11600078/" target="_blank" rel="noopener">目击者之追凶</a>豆瓣8.1分</h3><p>看的时候主要是看评分这么高，而且还是台湾的，觉得应该就是个剧情比较好看的电影，慢慢看着都不觉得有多好看，只不过到后面越来越觉得剧情不简单了。尺度很大，不到最后一刻不知道结果的那种，但是从每个人的角度来理解这个剧情，又觉得每个人的特点都塑造的让人感叹。</p><h3 id="三块广告牌-豆瓣8-7分"><a href="https://movie.douban.com/subject/26611804/" target="_blank" rel="noopener">三块广告牌</a> 豆瓣8.7分</h3><p>毕竟是拿了奥斯卡最佳女主的。。</p><h3 id="前任3：再见前任-豆瓣5-7分"><a href="https://movie.douban.com/subject/26662193/" target="_blank" rel="noopener">前任3：再见前任</a> 豆瓣5.7分</h3><p>闲着 没事就看看了==</p><h3 id="非常嫌疑犯-豆瓣8-6分"><a href="https://movie.douban.com/subject/1292214/" target="_blank" rel="noopener">非常嫌疑犯</a> 豆瓣8.6分</h3><p><img src="https://blog-1252063226.cosbj.myqcloud.com/movie/001/001.jpg?raw=true" alt="">觉得自己一开始就猜中了大坏蛋，但是中间仍然起伏，差点以为自己猜错了，不过结果还是差不多。对于这样的悬疑片，突然觉得有了一点经验了，那种你算的很好的逻辑，很大程度是别人给你写好的逻辑圈套让你钻进去。所以对于逻辑，还是要像马克思说的啊，从正反两面考虑。不管是狼人杀这种游戏，还是生活中的决定。说回这个电影吧，剧情就不说了，还有整个电影的叙事方式，刚刚开始觉得有点乱，还是对美帝主义的一些情况不太了解。不过后面就觉得清晰了。而且电影里出现了很多干扰的东西，比如像医院里出现的那些人，总觉得会有所错觉，还有警局里的一些，可能是年代有点久远还是自己要求有点高了？。。</p><h3 id="穆赫兰道"><a href="">穆赫兰道</a></h3><h3 id="银翼杀手2049">银翼杀手2049</h3><p>可能我们无法想象30年后地球上会发生什么，会不会真的连一点真的木头都变得很珍贵？会不会真的有一群复制人帮我们做着一些我们不太愿意做的事情，但是我们仍然在歧视他们？不过有些东西是我们能想象的，就比如现在所说的科技发展的界限，就像很多所提的，那就是伦理，那就是以人为本。从一方面来说，所有的发明和创造都是为了让人的生活变的更好，而不是给人类带来麻烦，另一方面，如果我们人类的创作也跟人一样有思想，我们应不应该像人一样尊重他们。</p><h3 id="羞羞的铁拳">羞羞的铁拳</h3><p>真的，感觉是个啥，为了搞笑就在搞笑。。</p><hr><h2 id="2017年">2017年–</h2><h3 id="嘉年华">嘉年华</h3><p><img src="https://blog-1252063226.cosbj.myqcloud.com/Linux/0009999999.jpg?raw=true" alt="">值得一看的电影。如鲠在喉</p><h3 id="机器之血">机器之血</h3><p>估计可能是成龙演的吧，毕竟61岁了，还这么拼，总让人觉得有点厉害了。但是电影从剧情到演员到画面，真的没有一点合格的吧，浪费时间了啊。</p><h3 id="无证之罪-1957">无证之罪（1957）</h3><h3 id="缝纫机乐队-2017">缝纫机乐队（2017）</h3><p>毕竟睿思一周热门啊，还是忍不住下下来看了一下。记得之前大鹏各种微博之类的请大家去看看，不过评分依然很低。所以看的时候本来也没有那么期待。看完之后觉得也没有那么烂吧，想起之前看的大鹏的煎饼侠，也不知道除了搞笑之外还记起来什么了。不过这个好像好了很多，因为我想以后可能不会记得这个有多搞笑，但应该会记得讲了个什么故事。虽然电影对于大鹏来说可能有着特别的意义或者怎样，但是我看的时候还是觉得一如很多的国产电影，剧情不够瞎搞笑凑，然后就为了搞笑又加了很多无聊的东西，让剧情更烂了。所以这个也是这样，但是在最后强催的泪点环节，还是能够感觉到大鹏想告诉大家的东西，或者说是他对生活，对他自己的生活的一个理解？但是不重要是吗？电影可以就像一个人，但应该是我们发自肺腑的感叹，而不是要你用电影之外的话来告诉我们。就好像你做了一道菜，一定要在我们吃的时候加上旁白告诉我们现在吃的是什么，那可能不一定难吃，但一定不优秀。</p><h3 id="寻梦环游记-2017-date：2017-12-2">寻梦环游记（2017） date：2017-12-2</h3><p>额，要不是评分实在太高了，我也不会去看个说是动画片的电影吧，很少见出来一周的电影还9.5分的，但是确实值得高分。</p><p>不愧是迪士尼啊，效果非常棒不说了。整个剧情，跟一些非常优秀的电影一样，塑造了一个存在于人们想象中有可能很合理的新世界，在那里，有很多匪夷所思却又言之合理的事情。然后在这个世界里出现了与现实有联系的矛盾。当然最后问题的解决，又给人现实很简单纯粹的思考。比如在这里，塑造了亡灵的世界，如果死了的人真的被人遗忘，就会真的死亡。你在现实里追逐梦想最终被人记住的，在亡灵的世界也可以活的风光，就像梦想可能不被理解，但是实现了一定很值得一样。最后的大反转又让人回归，家人是最重要的，即使你有梦想，也没必要去牺牲这些。简单的道理，但是如果像我这么说就很没意思了，所以，这就是我们为什么会喜欢优秀的电影了吧。</p><h3 id="天才枪手-2017">天才枪手(2017)</h3><p><a href="http://www.imdb.com/title/tt6788942/" target="_blank" rel="noopener">IMDI 8.2分</a> ** /**<a href="https://movie.douban.com/subject/27024903/" target="_blank" rel="noopener">豆瓣 8.3分</a>好吧，8分多纯粹就是看了个热闹啊。简直就像告诉你，优秀的人作弊都比人优秀啊，即使感觉满屏幕的bug也依然很没文化的wokaowokao了。。</p><h3 id="东方快车谋杀案-1974">东方快车谋杀案(1974)</h3><p><a href="http://www.imdb.com/title/tt0071877/" target="_blank" rel="noopener">IMDI 7.3分</a> ** /**<a href="https://movie.douban.com/subject/1292699/" target="_blank" rel="noopener">豆瓣 8.3分</a>能拿奥斯卡的一般特性，就像一般艺术到最后所反映的，除了一个完整的故事，精彩的剧情，还有整个电影对人物、风情、地域以及社会环境等的刻画，传达人性或这个世界我们需要的思考。这种深度，国产电影离别人几十年前的电影都相差甚远。想起冯小刚说的，中国电影拍不好，是因为中国的观众不行，我觉得观众始终是很少的一部分，因为更多的时候、其实观众不知道他们喜欢的究竟是什么，因为更好看的永远在后面，这就是电影行业的责任了。再说这个电影吧，剧情的丰富就不必说了，从开头的各种铺垫，让我们在看到各种人物性格，国家的特点等，产生各种怀疑的时候，案件就开始了，于是现在看起来有点搞笑的主人公就开始了表演，整个审问和查找线索的过程让人敬佩，直到慢慢开始跟着他产生新的怀疑。。在主人公宣布结果之前，我也似乎猜到了一点，他最后给了大家选择，这是大家都希望的，看到大家开始香槟庆祝的时候，我不禁在想，这样的结果，究竟是应该的吗？如果这样的谋杀也可以，法律又怎么会进步。说到这里，又不禁想起来最近的江歌的事件，我只是在新闻上看到了，对此也表示很遗憾。不过在网上却各种签名投票之类的沸沸扬扬，诚然，在这种时候我们需要帮助受害者的家人，也想让罪人得到应有的报应，但这样可能真的不是最好的办法。就像规则可能有时候会有缺陷，但是如果每次都因为特殊事件让它临时违背，那跟没有也没区别。</p><h3 id="幸福终点站-2004">幸福终点站(2004)</h3><p><a href="http://www.imdb.com/title/tt0362227/" target="_blank" rel="noopener">IMDI 7.3分</a> ** /**<a href="https://movie.douban.com/subject/1292274/" target="_blank" rel="noopener">豆瓣 8.6分</a></p><h3 id="加勒比海盗5：死无对证">加勒比海盗5：死无对证</h3><p><a href="http://www.imdb.com/title/tt1790809/" target="_blank" rel="noopener">IMDI 6.7分</a> ** /**<a href="https://movie.douban.com/subject/6311303/" target="_blank" rel="noopener">豆瓣 7.2分</a></p><h3 id="速度与激情8">速度与激情8</h3><p><a href="http://www.imdb.com/title/tt0362227/" target="_blank" rel="noopener">IMDI 6.8分</a> ** /**<a href="https://movie.douban.com/subject/26260853/" target="_blank" rel="noopener">豆瓣 7.1分</a></p><h3 id="百万美元宝贝-million-dollor-baby">百万美元宝贝( Million Dollor baby)</h3><h3 id="陪安东尼度过漫长岁月">陪安东尼度过漫长岁月</h3><h3 id="看不见的客人">看不见的客人</h3><p><a href="http://www.imdb.com/title/tt4857264/" target="_blank" rel="noopener">IMDI 8.1分</a> ** /**<a href="https://movie.douban.com/subject/26580232/" target="_blank" rel="noopener">豆瓣 8.7分</a></p><h3 id="致命id">致命ID</h3><h3 id="雷神3">雷神3</h3><h3 id="罗生门-日本">罗生门（日本）</h3><h3 id="心迷宫">心迷宫</h3><h3 id="情遇曼哈顿">情遇曼哈顿</h3><h3 id="复仇者联盟">复仇者联盟</h3><h2 id="记录看的电视剧">记录看的电视剧</h2><blockquote><p>电视剧看的不多，但是一看就要看完啊。等不了啊</p></blockquote><h3 id="琅琊榜之风起长林">琅琊榜之风起长林</h3><p>自认为超过了1的水平。</p><ul><li>超级正的家国情怀和三观，虽然在这个人人都想买房买车的年代显得有点。。但是梦想总还是要有的是吧</li><li>将在其位谋其事，什么样的环境造就什么样的人演绎的很彻底。我第一次很理解所有的反派的行为。。</li></ul><h3 id="猎场">猎场</h3><p>就当是看胡歌了啊</p><h3 id="权力的游戏s7">权力的游戏s7<a href=""></a></h3><h3 id="白夜追凶">白夜追凶<a href=""></a></h3><h3 id="无证之罪">无证之罪<a href=""></a></h3><h3 id="激战玄武门-纪录片">激战玄武门（纪录片）<a href=""></a></h3><h3 id="justice-公开课">Justice（公开课）<a href=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> 娱乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网-剑指offer-2</title>
      <link href="/2017/10/27/Exercise/nowcoder-sword-to-offer2/"/>
      <url>/2017/10/27/Exercise/nowcoder-sword-to-offer2/</url>
      
        <content type="html"><![CDATA[<h4 id="t4：重建二叉树">T4：重建二叉树</h4><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><p>二叉树是觉得很烦的东西了，比链表复杂很多，看着头都有点疼啊，但是没办法，生活就是这样，只有把不会的会了才会进步，怕的变得不怕才能越来越厉害。常规的理解一下：二叉树的遍历序列分为三种：前序遍历、中序遍历和后序遍历。这样叫是根据根节点相对于其左右子节点而言的。所以很容易知道三种遍历序列的特点，比如对于前序遍历而言，第一个就是根节点，对于中序遍历，根节点的左边必然是左子树，右边为右子树。所以首先可以根据两个序列确定根节点，然后把两个序列都分别分为两个序列，两个左右子树的前序遍历和两个左右子树的后序遍历。于是便可以采用递归的方式分别对左右子树进行处理了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.size()&#x3D;&#x3D;0||vin.size()&#x3D;&#x3D;0||pre.size()!&#x3D;vin.size())</span><br><span class="line">            return nullptr;</span><br><span class="line">        TreeNode *root&#x3D;new TreeNode(pre[0]);</span><br><span class="line">        vector&lt;int&gt; pre1,pre2,vin1,vin2;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(;i!&#x3D;vin.size();++i)&#123;</span><br><span class="line">            if(root-&gt;val&#x3D;&#x3D;vin[i])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;if(i&#x3D;&#x3D;0)</span><br><span class="line">            &#x2F;&#x2F;root-&gt;left&#x3D;nullptr;</span><br><span class="line">        &#x2F;&#x2F;else if(i&#x3D;&#x3D;vin.size()-1)</span><br><span class="line">            &#x2F;&#x2F;root-&gt;right&#x3D;nullptr;</span><br><span class="line">        &#x2F;&#x2F;else&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;i;++j)&#123;</span><br><span class="line">            pre1.push_back(pre[1+j]);</span><br><span class="line">            vin1.push_back(vin[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;vin.size();++j)&#123;</span><br><span class="line">            pre2.push_back(pre[j]);</span><br><span class="line">            vin2.push_back(vin[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        root-&gt;left&#x3D;reConstructBinaryTree(pre1,vin1);</span><br><span class="line">        root-&gt;right&#x3D;reConstructBinaryTree(pre2,vin2);</span><br><span class="line">        &#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t5-用两个栈实现队列">T5:用两个栈实现队列</h4><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote><p>对于这种简单的结构，实现起来可能还是比较简单一点，主要还是思考的过程，通过队列和栈的特点进行分析。队列是一个先进先出的结构，而栈是一个先进后出的结构。显然当我们把数据push到第一个栈，每次数据pop都把第一个栈的全部数据先放到第二个栈当中，然后再pop，肯定就达到了先入先出的目的了。另外需要的是代码的编写。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.size()&lt;&#x3D;0)&#123;</span><br><span class="line">            while(stack1.size()&gt;0)&#123;</span><br><span class="line">                int temp&#x3D;stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int result&#x3D;stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t6：旋转数组的最小数字">T6：旋转数组的最小数字</h4><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p>对于数组或者双链表的问题，很多时候我们都可以采用** 双指针**的方法来解决，这通常能减小难度，就像这题，首先我们需要注意的是，旋转数组的特点，旋转之前是一个非递减排序，所以旋转之后必然是前面一个非递减排序加上后半部分的一个非递增排序。很容易想到的是，采用前后两个指针，根据两个指针中间的点的值，可以确定这个数组中最小的值在前半部分还是后半部分，然后移动某一指针到中间节点，知道两个指针之间相差1，就可以确定最小值。然而，看题目还存在一个问题，就是题目所说的是一个非递减排序，而并非递增序列。（这就需要我们认真审题了），可以想到，如果出现了特殊的情况，例如存在几个相等值，导致左右两个指针和中间值都相同的时候，我们只能通过最原始的办法一个个进行判断了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(rotateArray.size()&lt;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        int index1&#x3D;0;</span><br><span class="line">        int index2&#x3D;rotateArray.size()-1;</span><br><span class="line">        int indexMid&#x3D;index1;</span><br><span class="line">        while(rotateArray[index1]&gt;&#x3D;rotateArray[index2])&#123;</span><br><span class="line">            if(index2-index1&#x3D;&#x3D;1)&#123;</span><br><span class="line">                indexMid&#x3D;index2;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            indexMid&#x3D;index1+(index2-index1)&#x2F;2;</span><br><span class="line">            if(rotateArray[index1]&#x3D;&#x3D;rotateArray[indexMid]&amp;&amp;</span><br><span class="line">               rotateArray[indexMid]&#x3D;&#x3D;rotateArray[index2])</span><br><span class="line">                return MinInorder(rotateArray);</span><br><span class="line">            if(rotateArray[indexMid]&gt;&#x3D;rotateArray[index1])</span><br><span class="line">                index1&#x3D;indexMid;</span><br><span class="line">            else if(rotateArray[indexMid]&lt;&#x3D;rotateArray[index2])</span><br><span class="line">                index2&#x3D;indexMid;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[indexMid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int MinInorder(vector&lt;int&gt; rotateArray)&#123;</span><br><span class="line">        int result&#x3D;rotateArray[0];</span><br><span class="line">        int index2&#x3D;rotateArray[1];</span><br><span class="line">        while(index2!&#x3D;rotateArray.size())&#123;</span><br><span class="line">            if(result&gt;rotateArray[index2])</span><br><span class="line">                result&#x3D;rotateArray[index2++];</span><br><span class="line">            else</span><br><span class="line">               ++index2;</span><br><span class="line">               &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win7下安装Ubuntu双系统</title>
      <link href="/2017/10/22/Tools/installation_of_two_system_on_win7/"/>
      <url>/2017/10/22/Tools/installation_of_two_system_on_win7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学(xian)习(de)所(dan)需(teng)，觉得一个虚拟机确实装的Ubuntu确实有点烦了，除了没有一个系统那样直接用起来爽以外，总觉得感受不到一个纯正的系统。而且虚拟机有时候懒得开了就算了。但是又舍不得直接把我换了固态之后就没有换过的系统直接换掉，毕竟我已经不是那个年轻的爱折腾的22岁的小伙子了，我23了。。于是就看着教程和xjbg装了双系统。同时的难度是，我的固态硬盘里放的系统，但是又不想把系统直接放在固态硬盘，只是希望通过固态启动一下，然后把其他的目录放在机械硬盘中</p></blockquote><a id="more"></a><h5 id="win7准备">Win7准备</h5><p>双系统的准备主要就是硬盘了，毕竟这么多学习资料是吧。。总还是要谨慎一点的。因为win7和linux系统的磁盘格式不一样，所以我们不能直接在win7里面分好磁盘。这里的工作是：将固态硬盘压缩300MB空间，作为Ubuntu的<code>/boot</code>分区，以供系统启动用。另外在机械硬盘中分出80GB空间，作为其他的<code>/</code>和<code>swap</code>分区。</p><h5 id="通过u盘做系统盘">通过U盘做系统盘</h5><p>使用工具UtralISO，将下载好的Ubuntu系统，通过正常的模式写入到U盘中(这个随便百度一下就有了，经常装系统的这个就差不多知道了)</p><h5 id="重启装系统">重启装系统</h5><p>首先还是熟悉的修改bios，按一下各种类似<code>F2</code>之类的键，进入BIOS设置，将启动项第一位改成U盘，然后重启。。之后就是进去装系统了，主要是选磁盘的时候，把 固态硬盘中的未分配空间格式化为<code>/boot</code>，然后其他的机械硬盘中的，按照需要格式化为<code>/</code>和<code>/swap</code>,之后等着装完就好了。</p><h5 id="修改启动选项">修改启动选项</h5><p>系统装完之后就要重启进入新系统了，这是惊喜而又刺激的发现，Ubuntu真好看，但是我的Win7去哪儿了。不过装了一百遍系统的我知道肯定还是个引导的问题，在网上找到了解决办法。在Ubuntu中输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;default&#x2F;grub</span><br><span class="line">#修改</span><br><span class="line">GRUB_DEFAULT&#x3D;0 为：GRUB_DEFAULT&#x3D;4</span><br><span class="line">#更新grub</span><br><span class="line">sudo update-grub</span><br><span class="line">在终端中找到：</span><br><span class="line">found win7...</span><br><span class="line">就说明win7引导被找到了，重启可以开始愉快的用了</span><br></pre></td></tr></table></figure><h6 id="reference">Reference:</h6><p>http://m.jb51.net/article/110288.htmhttps://jingyan.baidu.com/article/e4d08ffdace06e0fd2f60d39.htmlhttp://www.jianshu.com/p/c6750e459a94</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网刷题总结-剑指offer(1)</title>
      <link href="/2017/10/15/Exercise/nowcoder-sword-to-offer1/"/>
      <url>/2017/10/15/Exercise/nowcoder-sword-to-offer1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说在前面：刷题真的是一件残酷的事情，就好比以前大学的时候只剩两天就考试了，刚刚看了一遍就开始先做题一样的感觉，面对无数的套路，幸运的时候还能庆幸自己能发现他们的套路。。刷题的开始总是艰难的，希望有一天我能以上帝视角看清这些芸芸众生的时候，还能想起来当年我不止一次的一道题怼了一晚上照样白怼。</p></blockquote><h4 id="t1：二维数组的查找">T1：二维数组的查找</h4><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>这里一般的思路肯定是，从行或者列开始找，根据递增的顺序，找到行或者列之后再判断列或者行，知道找到为止。最好的方法是，从左下角或者右上角开始找。原因是：这样的一行和一列的顺序是不一样的，这样我们找一行的时候没有就可以直接找下一行，充分利用递增的顺序，减少循环的次数。其他的就是循环的写法了，关于数组，一定注意的是不要越界，这真的是我的痛啊，日常越界一百遍。<em><sup>_</sup></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        bool found&#x3D;false;</span><br><span class="line">        if(array.size()&#x3D;&#x3D;0 ||array[0].size()&#x3D;&#x3D;0)</span><br><span class="line">            return found;</span><br><span class="line">        for(int i&#x3D;array[0].size()-1;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">            if(target&gt;&#x3D;array[0][i])&#123;</span><br><span class="line">                for(int j&#x3D;0;j!&#x3D;array.size();++j)&#123;</span><br><span class="line">                    if(target&#x3D;&#x3D;array[j][i])</span><br><span class="line">                        found&#x3D;true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">        return found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t2：替换空格">T2：替换空格</h4><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>替换的过程是，先找到这个空格，正常想法是，从前往后找，然后遇到就开始替换。但是注意到<em>对于一般题目，最直观的解法总不是最好的</em>，都是需要多从<strong>时间复杂度和空间复杂度想一想</strong>。就这个题目而言，直接从前往后替换，因为替换后的字符比原来多2个，所以每次替换我们都需要将后面的字符串向后移2个，这无疑会增加复杂度。一个很好的办法是：先统计空格的个数，计算出替换后的字符串长度，然后从后往前开始替换，这样就减少了移动的复杂度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        if(length&lt;&#x3D;0)</span><br><span class="line">            return;</span><br><span class="line">        int move_length&#x3D;0;</span><br><span class="line">        int original_length&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;str[i]!&#x3D;&#39;\0&#39;;++i)&#123;</span><br><span class="line">            ++original_length;</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">                ++move_length;</span><br><span class="line">        &#125;</span><br><span class="line">        int new_length&#x3D;original_length+2*move_length;</span><br><span class="line">        if(new_length&gt;length)</span><br><span class="line">            return;</span><br><span class="line">        str[new_length]&#x3D;&#39;\0&#39;;</span><br><span class="line">        while(original_length&gt;0)&#123;</span><br><span class="line">            --original_length;</span><br><span class="line">            if(str[original_length]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                str[--new_length]&#x3D;&#39;0&#39;;</span><br><span class="line">                str[--new_length]&#x3D;&#39;2&#39;;</span><br><span class="line">                str[--new_length]&#x3D;&#39;%&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                str[--new_length]&#x3D;str[original_length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="t3-从尾到头打印链表">T3:从尾到头打印链表</h4><blockquote><p>输入一个链表，从尾到头打印链表每个节点的值。</p></blockquote><p>链表我们一般都是从头到尾处理的，要从尾到头打印，这里想到一个数据结构：<strong>栈</strong>，后入先出的特点。从头到尾遍历链表，并把节点的值存入栈中，再从栈一一弹出即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        stack&lt;int&gt; stack;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        while(head!&#x3D;nullptr)&#123;</span><br><span class="line">            stack.push(head-&gt;val);</span><br><span class="line">            head&#x3D;head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(stack.size()!&#x3D;0)&#123;</span><br><span class="line">            result.push_back(stack.top());</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 牛客网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《effective C++》from line 1 to line 12</title>
      <link href="/2017/10/09/cpp/effective-cpp-1/"/>
      <url>/2017/10/09/cpp/effective-cpp-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面两章的内容主要是习惯使用c++，大部分都是《C++ primer》中的需要注意的一些东西，由于刚刚看完前面一本，所以有些还是有些印象的。这里大体总结一下。</p></blockquote><h4 id="l1-c-是一个语言联邦">L1:C++是一个语言联邦。</h4><p>包含着最初的以c语言为基础的C，面向对象的C++，C++的泛型编程，以及STL。在我们使用的过程中，可能会穿插，但是我们需要根据不同的情况使用不同的策略。</p><h4 id="l2：代替-define">L2：代替#define</h4><p><code>#define</code>是在编译之前，也就是预处理的阶段就会被替换，这样我们在调试程序的时候看到的就是被替换的数字，会给别人甚至是之后调试的我们自己带来理解上的困难。另外，预处理器的工作是，直接把define的内容进行替换，当我们在define中写的表达式，并且在接下来使用的时候，可能产生无法理解的结果。所以当我们使用不想改变的常量时，使用<code>const</code>代替<code>#define</code>。我们还可以使用<code>enum</code>来代替<code>#define</code>。这样显得会更接近一些，因为<code>enum</code>和<code>#define</code>一样，同时也不会被pointer或reference指向。使用<code>inline</code>函数。</p><h4 id="l3-尽量使用const">L3:尽量使用const</h4><p>这是一个很好理解的问题，就像你把东西给别人用，不想让别人动的地方就加一个<code>const</code>不让别人动一样。。。具体的体现为：指针，不想被改变的变量，迭代器，成员函数等等。我们可能还会为一个函数定义<code>const</code>和<code>非const</code>版本。</p><h4 id="l4：在使用对象前先初始化">L4：在使用对象前先初始化</h4><p>嗯，记住。</p><h4 id="l5：了解c-会默认编写并调用哪些函数">L5：了解c++会默认编写并调用哪些函数</h4><p>在面向对象编程时，记住三五法则。构造函数、拷贝构造函数、拷贝赋值运算符、移动赋值运算符、析构函数。记住这几个函数的作用，其在什么时候会被使用，如果没有的时候，系统会不会为我们生成。我们需不需要系统为我们生成。</p><h4 id="l6：不想编译器默认生成的函数-应该明确拒绝">L6：不想编译器默认生成的函数，应该明确拒绝</h4><p>比如我们不希望编译器为我们生成默认的函数，我们应该将其定义为删除的或者定义为<code>private</code>的，也可以定义类似于uncopyable类似的base class。</p><h4 id="l7：为多态的基类声明virtual析构函数">L7：为多态的基类声明virtual析构函数</h4><p>通常我们希望派生类覆盖或重写的函数，定义为virtual函数。析构函数作为对象被销毁时调用的函数，如果不是虚函数，那么可能在销毁的时候只会销毁基类的部分，局部销毁，造成资源泄露。</p><h4 id="l8：不要让异常逃离析构函数">L8：不要让异常逃离析构函数</h4><p>析构函数绝对不要吐出异常，当遇到异常的时候应该捕捉任何异常，然后吞下或结束程序。如果需要对某个操作函数运行期间抛出的异常做出反应，应该提供一个普通的函数执行操作，而不是在析构函数中。</p><h4 id="l9：绝不在构造和析构过程中调用virtual函数">L9：绝不在构造和析构过程中调用virtual函数</h4><p>构造和析构过程中，调用virtual函数的对象可能还没有产生，也就是派生类的对象，此时会产生未定义的行为。</p><h4 id="l10：另operator-返回一个reference-to-this">L10：另operator=返回一个reference to *this</h4><p>并不强制，只是为了防止一些调皮的调用者使用：<code>x=y=z=15</code>这样的操作。</p><h4 id="l11：在operator-中处理自赋值的情况">L11：在operator=中处理自赋值的情况</h4><p>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，行为仍然正确。</p><h4 id="l12：复制对象时不忘每一个成分">L12：复制对象时不忘每一个成分</h4><p>Copying函数应该确保复制对象内的所有成员变量和所有base class成分。不要使用一个copying函数实现另一个copying函数，而是创建一个新的函数避免代码重复。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不知道怎么开的船？</title>
      <link href="/2017/09/25/Random/how_to_sail/"/>
      <url>/2017/09/25/Random/how_to_sail/</url>
      
        <content type="html"><![CDATA[<h3 id="2017-9-25-记录学习">2017-9-25 记录学习</h3><h4 id="额-打开sublime-打出来第一个-号-下意识的想打include-笑了自己两秒钟-好像这几天看来-就这句写的最熟练吧">额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。</h4><p>最近开始再一次准备看数据结构和算法，再一次，是不能再跟闹着玩的一次了。看着实验室最近找工作的师兄师姐，一边心疼他们，一边更心疼明年的自己。所以我也想到了也许很好的办法，不如抓紧时间现在先好好学习，头疼起来了，心就不疼了吧。断断续续看完了c++ primer，加上之前看过一些数据结构，但是当我打开牛客网第一题的时候还是觉得自己像个傻逼，于是按照我通常的习惯，换了第二题，觉得更傻逼了。于是还是先打开书看看了。。看看书啊，又刷刷题啊，自己还是经常在骂自己和夸自己和强行夸自己这几种有限状态中跳来跳去。晚上，刷到那个链表翻转的题目，又是好久没搞出来，各种数组越界。明明只是就那么几个指针而已，反复看了好几遍。当方法论出了问题的时候，有的时候会忍不住怀疑世界观。作为一个还是对这个世界充满疑惑和兴趣的青年，我好奇地又在网上搜了一遍：C<ins>学什么，C</ins>怎么学，C++学习路线。。于是一晚上又没了，留下一份写有听过好多遍名字的书的TXT文档，一如一个多月前的某一个晚上。。可能距离我们找工作也有快一年吧，时间说长不长，说短不短吧。其实我觉得能担心的可能一直不是时间，而是利用时间。先写一下接下来一段时间的任务吧，不要又乱跑了：</p><ul><li>《Effictive C++》认真看，主线</li><li>有空看数据结构，刷题，不随便放弃题目。搞懂会写，写好了为止</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++primer》ch16 模板与泛型编程</title>
      <link href="/2017/09/19/Cpp/cpp-primer/cpp_primer_ch16/"/>
      <url>/2017/09/19/Cpp/cpp-primer/cpp_primer_ch16/</url>
      
        <content type="html"><![CDATA[<p>泛型编程与面向对象编程的区别是：面向对象编程能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。</p><h4 id="16-1-定义模板">16.1 定义模板</h4><p>模板程序应该尽量减少对实参类型的要求。模板的头文件通常包括声明和定义。模板直到实例化时才生成代码。泛型编程的一个目标就是另算法是“通用的”-适合于不同类型。所有标准库容器都定义了<code>==</code>和<code>!=</code>，但只有少数定义了<code>&lt;</code>运算符。因此尽量使用<code>!=</code>而不是<code>&lt;</code>。** 类模板<strong>用来生成类的蓝图，一个类模板的每个实例都形成一个独立的类。默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。在类模板的作用域类，我们可以直接使用模板名而不必指定模板实参。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给 所有友元模板实例，也可以只授权给特定实例。当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。** 成员模板</strong>：一个类（不管是模板类还是普通类）可以包含本身是模板的成员函数。这些成员函数被称为成员模板。成员模板不能是虚函数。控制实例化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern template class Blob&lt;string&gt;;  &#x2F;&#x2F;声明，遇到extern模板声明时，编译器不会在本文件中生成实例化代码。，对于一个给定的实例化版本，可以有多个extern声明，但只能有一个定义。</span><br><span class="line">template int compare(const int&amp;,const int&amp;); &#x2F;&#x2F;定义</span><br></pre></td></tr></table></figure><h4 id="16-2-模板实参推断">16.2 模板实参推断</h4><p>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果函数参数类型不是模板参数，则可以进行正常的类型转换。** 显式模板实参**按由左至右的顺序与对应的模板参数匹配。</p><h4 id="16-3-重载与模板">16.3 重载与模板</h4><h4 id="16-4-可变参数模板">16.4 可变参数模板</h4><h4 id="16-5-模板特例化">16.5 模板特例化</h4>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++primer》ch15-面向对象程序设计</title>
      <link href="/2017/09/19/Cpp/cpp-primer/cpp_primer_ch15/"/>
      <url>/2017/09/19/Cpp/cpp-primer/cpp_primer_ch15/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面向对象三个基本概念：数据抽象、继承和动态绑定（java里说的多态）。这章主要内容是继承和动态绑定。</p></blockquote><h4 id="15-1-oop：概述">15.1 OOP：概述</h4><h4 id="15-2-定义基类和派生类">15.2 定义基类和派生类</h4><p>基类希望派生类进行覆盖的函数，通常将其定义为** 虚函数**，另一种是基类希望派生类继承但不要改变的函数。<code>protected</code>访问运算符：派生类可以访问，但是其他用户无法访问。定义派生类：通过访问说明符控制派生类从基类继承而来的成员是否对派生类可见。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为跟其他类一样，派生类会直接继承其在基类中的版本。派生类到基类的转换。这可以让我们把派生类对象或者派生类对象的引用用在需要基类引用的地方，也可以把派生类指针用在需要基类指针的地方。但是，这里会出现一个问题，当我们使用基类的指针或者引用时，就不知道这个所绑定的对象到底是基类还是派生类了。派生类构造函数。必须使用基类的构造函数初始化。（每个类控制自己的初始化过程。）每个类定义各自的接口，派生类要遵循基类的接口。如果基类中定义了静态成员，则在整个继承体系中只存在唯一的定义，不管定义了多少遍，都只存在唯一的实例。对派生类的声明，不需要包含派生列表。当我们不想让类被继承的时候，可以使用<code>final</code>关键字，跟在类名之后。表达式的** 静态类型<strong>在编译时是已知的，是变量声明时或者表达式生成式生成的类型。</strong> 动态类型**则是变量或表达式表示的内存中的对象的类型。因此，基类的指针或引用的静态类型可能与动态类型不一致。派生类向基类的自动类型转换只对指针和引用有效，在类型之间不存在这样的转换。当我们用一个派生类对象初始化或给一个基类对象赋值时，只有该派生类的对象中的基类部分会被拷贝、移动或赋值，派生类部分则会被忽略掉。</p><h4 id="15-3-虚函数">15.3 虚函数</h4><p>我们必须为每一个虚函数提供定义，因为连编译器也无法确定到底使用的是哪一个虚函数。如果我们在派生类中覆盖了某个虚函数时，可以再次使用<code>virtual</code>指出该函数的性质，但实际上并不一定要这么做。因为某个函数被声明成虚函数，则在所有的派生类中都是虚函数。</p><h4 id="15-4-抽象基类">15.4 抽象基类</h4><p>在函数体声明的语句的分号前使用<code>=0</code>可以将一个函数声明为纯虚函数。含有纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类负责覆盖该接口。我们不能直接创建一个抽象基类的对象。GCC的编译器中可能前面还是要加上<code>virtual</code>** 重构**：重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。</p><h4 id="15-5-访问控制与继承">15.5 访问控制与继承</h4><p>protected:对于类的用户来说是不可访问的，对于派生类的成员和友元来说是可访问的。但是只能通过** 派生类对象<strong>来访问，</strong> 派生类<strong>对于一个基类中受保护的成员是无法访问的。派生类向基类的转换：只有当D公有的继承B时，</strong> 用户代码**才能使用基类向派生类的转换。无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换。如果D继承B的方式是公有的或受保护的，则D的派生类可以使用D向B的类型转换。友元关系不能继承。基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员。派生类可以使用<code>using</code>为那些可以访问的名字提供声明，以改变这些名字在它的派生类中的可访问性。</p><h4 id="15-6-继承中的类作用域">15.6 继承中的类作用域</h4><p>每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。当名字相同时，派生类的成员将隐藏基类的成员。基类可以通过** 作用域运算符<strong>来使用隐藏的成员。一般情况下，我们应该不会这么使用，所以，平时继承类尽量不要覆盖继承而来的虚函数以外的基类的名字。** 名字查找先于类型检查</strong>：如果派生类的成员与基类中的某个成员同名，则派生类将在其作用域内隐藏该基类成员。一旦编译器查找到名字后，不管形参列表是否相同，都不会再继续查找，这也是我们需要在覆盖虚函数时，保证形参列表是相同的。<code>using</code>声明语句指定一个名字而不是形参列表，所以我们在基类中使用一个<code>using</code>就可以把该函数的所有重载实例添加到派生类作用域中，派生类只需要定义特有的函数即可。</p><h4 id="15-7-构造函数与拷贝控制">15.7 构造函数与拷贝控制</h4><p>位于继承体系中的类也需要控制当其对象执行一系列操作时发生怎样的行为：包括创建、移动、拷贝、赋值和销毁。一般讲基类中的析构函数定义为虚函数，这样，继承体系中的派生类都会是虚析构函数，否则，若基类中的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。虚析构函数将组织合成移动操作。和普通成员的using声明不同，构造函数的using声明不会改变该构造函数的访问级别。using声明语句不能指定explicit或constexpr。当一个基类构造函数含有默认实参时，这些实参并不会被继承。派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p><h4 id="15-8-容器与继承">15.8 容器与继承</h4><p>容器不能直接存放继承体系中的对象，通常采用间接存储的方式。因为当我们把基类存储到一个容器中，当存入派生类对象，实际存入的只是派生类中基类的部分，显然不符合我们的需要。所以我们希望在具有继承关系的对象时，实际上存储的是基类的指针。（最好使用智能指针）</p><h4 id="15-9-文本查询程序再探">15.9 文本查询程序再探</h4>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++primer》ch13 拷贝控制</title>
      <link href="/2017/09/14/Cpp/cpp-primer/cpp_primer_ch13/"/>
      <url>/2017/09/14/Cpp/cpp-primer/cpp_primer_ch13/</url>
      
        <content type="html"><![CDATA[<p>通过定义的五种特殊的成员函数，控制类的对象在拷贝。赋值、移动或销毁时做什么。包括：拷贝构造函数、拷贝赋值运算符、拷贝赋值运算符、移动赋值运算符以及析构函数。</p><h4 id="13-1-拷贝-赋值-销毁">13.1 拷贝、赋值、销毁</h4><h4 id="13-6-对象移动">13.6 对象移动</h4><p>在旧标准的标准库中，容器中所保存的类必须是可以拷贝的，新标准中，可以在容器中保存不可拷贝的类型，只要他们能够被移动就可以。</p><h5 id="13-6-1-右值引用">13.6.1 右值引用</h5><p>通过&amp;&amp;来获得右值引用，意为绑定到右值的引用。** 重要性质：只能绑定到一个将要销毁的对象。**** 所引用的对象将要被销毁，该对象没有其他用户**– 左值引用：返回左值引用的函数，赋值、下标、解引用、前置递增/递减运算符。– 右值引用：返回非引用的函数，算数、关系、位以及后置递增/递减运算符。区分的方法：一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。<a href="http://blog.csdn.net/yapian8/article/details/42341307" target="_blank" rel="noopener">右值引用比较</a></p><p>** move函数(utility头文件中)**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp;rr3&#x3D;std::move(rr1);  &#x2F;&#x2F;相当于告诉编译器，我们希望像处理右值一样处理左值rr1。</span><br><span class="line">                           &#x2F;&#x2F;调用move后，除了赋值和销毁rr1外不会再使用它</span><br><span class="line">                           &#x2F;&#x2F;使用move直接用std::move</span><br></pre></td></tr></table></figure><h6 id="移动构造函数和移动赋值运算符">移动构造函数和移动赋值运算符</h6><p>目的：让类支持移动操作。移动构造函数：第一个参数是一个该类类型的右值引用，任何其他额外的参数都要有默认实参。不需要分配新内存，直接接管原来的内存。不会跑异常，不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。（原因是标准库很多对于存在异常的处理方式，例如vector）移动赋值运算符：首先要处理自赋值的情况。（为什么检查自赋值？因为右值可能是move调用返回的结果，不能在使用右侧运算符对象之前释放左侧运算对象的资源。）** 如果类有拷贝构造函数和拷贝赋值运算符，没有定义移动操作时，编译器不会为其分配默认的移动操作，而是会采用对应的拷贝进行代替。如果没有定义任何的拷贝操作，才会为其合成移动构造函数或移动赋值运算符。**移动操作不会被隐式的定义为删除的操作,定义为删除元素的原则：</p><ul><li>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或有类成员未定义自己的拷贝构造函数且编译器不能为其合成默认移动构造函数</li><li>有类成员的移动构造函数或移动赋值运算符被定义为删除的或不可访问的</li><li>类的析构函数被定义为删除的</li><li>有类成员是const的或是引用</li></ul><p>** 三/五法则 **：通常，拥有一个资源的类，必须定义拷贝构造函数、拷贝赋值运算符、析构函数才能工作，而由于大量的拷贝会影响资源的额外开销，定义移动构造函数和移动赋值运算符可以避免此类问题。</p><h5 id="13-6-1-右值引用和成员函数">13.6.1 右值引用和成员函数</h5><p>区分移动和拷贝的重载函数通常有一个版本接受<code>const T&amp;</code>，另一个版本接受一个<code>T&amp;&amp;</code>。很多时候它们看起来调用的是一个函数，通常它们内部的构造也很接近，有一点差别。我们可以根据实参的类型进行判断，我们用的是左值和右值区分调用的版本。有的时候我们想要避免对右值进行赋值（在旧的标准中是有可能发生的，并且新的标准为了向后兼容没有禁止），可以在参数列表后放置一个** 引用限定符**。还可以通过使用<code>&amp;</code>或者<code>&amp;&amp;</code>指出指向一个左值或者一个右值。eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    public:</span><br><span class="line">        Foo &amp;operator&#x3D;(const Foo&amp;) &amp;; &#x2F;&#x2F;只能向可修改的左值赋值。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用限定符可以区分重载版本，如同const可以用来区分一个成员函数的重载版本。一般当我们定义两个或两个以上的具有相同名字和相同参数列表的成员函数，就必须对所有函数加上引用限定符，或者都不加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    public:</span><br><span class="line">        Foo sorted() &amp;&amp;;</span><br><span class="line">        Foo sorted() const; &#x2F;&#x2F;错误，需要加上引用限定符</span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">        Foo sorted(Comp*);</span><br><span class="line">        Foo sorted(Comp*) const; &#x2F;&#x2F;正确，两个版本都没有引用限定符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++primer》ch14 重载运算符和类型转换</title>
      <link href="/2017/09/14/Cpp/cpp-primer/cpp_primer_ch14/"/>
      <url>/2017/09/14/Cpp/cpp-primer/cpp_primer_ch14/</url>
      
        <content type="html"><![CDATA[<h3 id="ch14-重载运算与类型转化">ch14 重载运算与类型转化</h3><blockquote><p>当运算符作用于类的对象的时，通过重载运算符，使不同的运算符对于不同的类有着特定的含义，一方面能够简化类的使用者的逻辑，另一方面也能是程序更易于编写和阅读，而不至于编写更多的函数。</p></blockquote><a id="more"></a><h4 id="14-1-基本概念">14.1 基本概念</h4><p>重载的运算符是特殊的函数：由operator关键字加上要定义的运算符号共同组成。作为函数，也包含返回类型、参数列表和函数体。参数列表个数与该运算符作用的算数对象数量一样多。不应该被重载的运算符：逻辑与、逻辑或、逗号运算符、取地址运算符。定义成成员还是非成员的判断：</p><ul><li>赋值、下标、调用、成员访问箭头等运算符必须是类的成员。</li><li>复合赋值运算符一般是类的成员</li><li>递增、递减、解引用等运算符。通常是类的成员</li><li>具有对称性的运算符可能转换任意一端的运算对象。如算数、相等性、关系、位运算符，通常应该是普通的成员函数。</li></ul><h4 id="14-2-输入输出运算符">14.2 输入输出运算符</h4><p>输出的运算符尽量减少格式化操作，只需要打印信息就可以了。输入输出运算符必须是非成员函数。输入时可能会发生错误，例如：当流含有错误类型的数据时读取可能失败，当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。所以在输入操作中，输入运算符应该负责读取错误发生时，从错误中恢复。</p><h4 id="14-3-算术和关系运算符">14.3 算术和关系运算符</h4><p>代码的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data</span><br><span class="line">operator-(const Sales_data &amp;lhs,const Sales_data &amp;rhs)&#123;</span><br><span class="line">    Sales_data item&#x3D;lhs;</span><br><span class="line">    item-&#x3D;rhs;  &#x2F;&#x2F;调用重载的-&#x3D;运算符来定义。性能相同，只是增加代码的 复用，增加可读性</span><br><span class="line">    return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 相等运算符<strong>的定义：如果定义了<code>==</code>，那么这个类也要定义<code>!=</code>（因为对于用户来说，当他们使用了<code>==</code>时，他们应该也希望能使用<code>!=</code>），并且相等运算符和不相等运算符的一个应该把工作委托给另外一个，这样一个预算负责实际比较，另外一个负责调用。** 关系运算符</strong>:一般定义了相等运算符后，也会定义关系运算符，特别是<code>&lt;</code>运算符。关系运算符的原则：如果存在唯一逻辑可靠的<code>&lt;</code>定义，就考虑定义<code>&lt;</code>运算符。如果该类同时包含<code>==</code>运算符，则当且仅当<code>&lt;</code>的定义与<code>==</code>产生一致的结果时才定义<code>&lt;</code>运算符。</p><h4 id="14-4-赋值运算符">14.4 赋值运算符</h4><p>赋值运算符<code>=</code>和符合赋值运算符<code>+=</code>，通常都定义为类的成员，并且都应该返回左侧运算对象的引用。</p><h4 id="14-5-下标运算符">14.5 下标运算符</h4><p>当我们需要按元素在容器中的位置访问元素时，通常定义一个下标运算符<code>operator[]</code>，必须是成员函数。通常会定义两个版本，一个返回普通引用，一个返回常量引用。</p><h4 id="14-6-递增和递减运算符">14.6 递增和递减运算符</h4><p>后置运算符接受一个额外的（不被使用）int类型的形参，当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。前置运算符返回递增或者递减后的对象的引用，后置运算符返回对象的原值（即递增或递减之前的原值），返回的是一个值而非引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr&#123;</span><br><span class="line">    public:</span><br><span class="line">        StrBlobPtr&amp; operator++();  &#x2F;&#x2F;前置递增运算符</span><br><span class="line">        StrBlobPtr&amp; operator++(int); &#x2F;&#x2F;后置递增运算符</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">p.operator++(0); &#x2F;&#x2F;显式的调用后置递增运算符</span><br><span class="line">p.operator++(); &#x2F;&#x2F; 显式的调用前置递增运算符</span><br></pre></td></tr></table></figure><h4 id="14-7-成员访问运算符">14.7 成员访问运算符</h4><p>箭头运算符必须是类的成员，解引用运算符通常也是类的成员，即使并非必须这么做。箭头运算符永远不能丢掉成员访问的这个基本含义，当我们重载箭头运算符时，可以改变的是从哪个对象中获取成员，而获取成员这一事实永远不变。重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p><h4 id="14-8-函数调用运算符">14.8 函数调用运算符</h4><p>如果类重载了函数调用运算符，我们就可以像调用函数一样使用该类的对象。函数调用运算符必须是成员函数，一个类可以定义多个函数运算符，之间用参数的数量和类型进行区分。函数对象通常作为泛型算法的实参lambda表达式：当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在这个类中，含有一个重载的函数调用运算符。捕获的对象相当于类内含有数据成员。是否含有默认/移动构造函数通常视捕获的对象而定。标准库定义了一组表示算数运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。标准库规定其函数对象对于指针同样适用。eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string *&gt; nameTable;</span><br><span class="line">sort(nameTable.begin(),nameTable.end(),</span><br><span class="line">[](string *a,string *b)&#123;return a&lt;b&#125;);   &#x2F;&#x2F;错误，nameTable中的指针之间没有关系，所以&lt;将产生未定义的行为</span><br><span class="line"></span><br><span class="line">sort(nameTable.begin(),nameTable.end(),less&lt;string* &gt;()); &#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure><p>C++中的**  可调用对象**：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。可调用的对象也有类型。不同类型可能具有相同的调用形式，可以定义一个** 函数表<strong>用于存储指向这些可调用对象的“指针”。** 标准库function类型</strong>：是一个模板，当创建具体的function类型时，需要我们提供额外的信息。eg：<code>function&lt;int (int,int)&gt;</code>表示接受2个int、返回1个int的可调用对象。不能直接将重载函数的名字存入function类型的对象中，可存储函数指针而不是函数的名字。</p><h4 id="14-9-重载-类型转换与运算符">14.9 重载、类型转换与运算符</h4><p>** 转换构造函数和类型转换运算符<strong>共同定义了类类型转换，有时也被称作用户定义的类型转换。<code>operator type() const; //type表示某种类型</code>因为类型转换运算符是隐式执行的，所以无法传递实参，也不能定义形参。为了避免具有误导性的类型转换，在不存在明显映射关系的时候，应不适用。显式的类型转换运算符。eg:<code>explicit operator int() const;</code>当类型转换运算符是显式的，必须通过显式的强制类型转换才可以。</strong> 如果表达式被用作条件，编译器会显式的自动转换。**无论我们什么时候在条件中使用了流对象，都会使用为IO类型定义operator bool。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Integral&#123;</span><br><span class="line">    operator const int(); &#x2F;&#x2F;将对象转换成 const int</span><br><span class="line">    operator int() const; &#x2F;&#x2F;将对象转换成 int，用的相对较多</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该避免使用二义性的类型转换，总体原则：除了显式的向bool类型的转换外，应该尽量避免定义类型转换函数，并且尽可能限制某些看起来显然正确的显式构造函数。错误eg：定义了两种将B类转换为A类的方法，一种使用B的类型转换运算符，一种使用A的以B为参数的构造函数。</p><ul><li>不要另两个类执行相同的类型转换。</li><li>避免转换目标是内置算数类型的类型转换。函数重载的类型匹配：当调用重载函数时，如果两个或多个用户定义的类型转换都提供了可行的匹配，那么这些类型转换被认为一样好。这意味着我们设计的不足。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++primer》ch7 类</title>
      <link href="/2017/06/27/Cpp/cpp-primer/cpp_primer_ch7/"/>
      <url>/2017/06/27/Cpp/cpp-primer/cpp_primer_ch7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>类是面向对象编程的基础，使用类定义自己的数据类型，可以更方便的解决问题中的各种概念，使我们更容易编写、调试和修改程序。</p></blockquote><a id="more"></a><h3 id="7-1-定义抽象的数据类型">7.1 定义抽象的数据类型</h3><ul><li>定义在类内部的函数时隐式的inline函数。</li><li>类的所有成员都必须在类的内部声明，但是成员函数体可以定义在类的内部或外部。</li><li>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。</li><li>成员函数体可以随意使用类中的其他成员而不需要在意这些成员出现的次序。</li></ul><h4 id="构造函数">构造函数</h4><p>编译器创建的构造函数又被称为合成的默认构造函数，合成的默认构造函数初始化类的数据成员规则为：存在类内初始值的时候，用它来初始化成员；否则，默认初始化该成员。对于一个普通的类，一般要定义自己的默认构造函数：</p><ol><li>编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</li><li>对于某些类来说，合成的默认构造函数可能执行错误的操作。</li><li>有的时候编译器不能为某些类合成默认的构造函数。</li></ol><ul><li>构造函数没有返回类型。</li></ul><h4 id="拷贝-赋值和析构">拷贝。赋值和析构</h4><p>除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象的时候发生的行为。当我们不主动定义这些操作的的时候，编译器将替我们合成他们。但是有些类不能依赖于合成的版本。当类需要分配类对象之外的资源时，合成的版本常常会失效。</p><h3 id="7-2-访问控制与封装">7.2 访问控制与封装</h3><p>在类的定义中，可以包含0个或多个访问说明符，每个访问说明符指定接下来的成员访问级别，一般来说，作为接口的一部分，构造函数和一部分成员函数应该定义在public说明符之后，而数据成员和作为实现部分的函数跟在private说明符之后。class和struct唯一的区别是默认访问权限不同。</p><h3 id="7-3-类的其他特性">7.3 类的其他特性</h3><p>类型成员、类的成员的类内初始值、可变数据成员、内联数据成员、从成员函数返回*this、关于如何定义类类型及友元类等。</p><h4 id="类成员">类成员</h4><p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制。</p><h4 id="令成员作为内联函数">令成员作为内联函数</h4><p>在类中，一些规模较小的函数常被定义为内联函数两种方式：1、直接把函数定义放在类的内部2、把函数定义放在类的外部，显式的使用inline</p><ul><li>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</li><li>在实践中，设计良好的代码常常包含很多的小函数，通过调用这些小函数，可以完成其他一组函数的“实际”工作。</li></ul><h4 id="类类型">类类型</h4><ul><li>对于一个类来说，它的成员和其他任何类的成员都不是一回事。</li><li>类的声明：不完全类型的使用：可以定义指向这种类型的指针或引用，也可以声明（但不能完全定义）以不完全类型作为参数或者返回类型的函数。</li></ul><h4 id="友元">友元</h4><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类中包括非公有成员在内的所有成员。</p><ul><li>还可以另一个类的成员函数为自己的友元。</li><li>如果一个类想把一组重载函数声明称它的友元，需要对每一个分别声明。</li><li>友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。</li></ul><h3 id="类的作用域">类的作用域</h3><ul><li>一个类就是一个作用域</li><li>函数的返回类型通常出现在函数名之前，所以返回类型是在类的作用域外的。</li><li>名字查找规则：首先名字所在快寻找声明语句；查找外层作用；报错。</li></ul><h4 id="构造函数再探">构造函数再探</h4><ul><li>如果成员是const或引用的话，必须进行初始化；当成员属于某种类类型且该类没有定义构造函数时，也必须初始化。</li><li>使用构造函数初始值：不仅仅是底层效率的问题。另有一些数据成员必须被初始化。</li><li>成员初始化顺序：构造函数初始化列表值说明用于初始化成员的值，而不限定初始化的具体执行顺序。（尽量按照顺序初始化，并且避免使用某些成员初始化其他成员）</li><li>委托构造函数：</li><li>默认构造函数的作用：当对象被默认初始化或值初始化时自动执行默认构造函数</li><li>默认初始化发生:</li></ul><ol><li>块作用域内不适用任何初始值定义一个非静态变量或数组时。</li><li>一个类本身含有类类型的成员且使用合成的默认构造函数。</li><li>类类型的成员没有在构造函数初始值列表中显式的初始化。</li></ol><ul><li>值初始化发生：</li></ul><ol><li>数组初始化时提供的初始值数量小于数组的大小</li><li>不使用初始值定义一个局部的静态变量</li><li>书写形如T()的表达式显式的请求值初始化</li></ol><ul><li>隐式的类类型转换：能通过一个实参调用的构造函数定义一条从构造函数的参数类型向类类型隐式转换的规则：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string null_book&#x3D;&quot;2132321&quot;;</span><br><span class="line">item.combine(null_book);&#x2F;&#x2F;将一个string的实参传递给了combine成员。</span><br></pre></td></tr></table></figure><ul><li>隐式类型转换只能一步，可以使用explicit阻止隐式类型转换。</li><li>字面值常量类至少提供一个constexpr构造函数</li></ul><h3 id="类的静态成员">类的静态成员</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++primer》ch4 表达式</title>
      <link href="/2017/06/05/Cpp/cpp-primer/cpp_primer_ch4/"/>
      <url>/2017/06/05/Cpp/cpp-primer/cpp_primer_ch4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不管学习什么语言都会有这么一章，不管是c、java、Python，这都是会经历的一章，唉，无奈当时年少无知不止梦想是什么的我每每看到这些的时候都觉得很烦。当再一次翻开c++的这一章的时候，也有这样的感觉，似曾相识燕归来，却又无可奈何花落去。我认为这一章的很多都不是需要太多的去深究，只需要有个大概的概念，然后更多的是在今后的编程过程中，不断的实践自然就知道了，是怎样写的。而且累死一些优先级的问题，更多的时候就像书里建议的那样，一个括号来的简单粗暴实用的多，所以，这章，就记一下实在有违常规的理解的内容吧。</p></blockquote><a id="more"></a><h3 id="4-1-基础">4.1 基础</h3><ul><li>运算对象转换：小整数类型（如bool、char、short等）通常会被提升为较大的整数类型，主要是int。</li><li>左值和右值：一个左值表达式的求值结果时一个对象或者一个函数，以常量对象为代表的某些左值不能作为赋值语句的左侧运算对象。** 简单归纳：当对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置） **</li><li>左值右值使用原则：需要右值的地方可以用左值代替，但是不能把右值当成左值使用。当一个左值被当成一个右值使用的时候，实际上使用的是它的内容（值  ）</li><li>需要用到左值的地方：1.赋值运算符。需要左值作为其左值运算对象，得到结果仍然是一个左值2.取地址符。返回一个指向该运算对象的指针，这个指针是一个右值3.内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值4.内置类型和迭代器的递增递减运算符作用于左值运算对象，得到的结果是左值。</li><li>关键字decltype中左值和右值的不同</li><li>处理复合表达式的经验：使用括号；如果改变了某个运算对象的值，就不要在表达式的其它地方再使用这个运算对象</li></ul><h3 id="4-2-算数运算符">4.2 算数运算符</h3><p>溢出的情况，值会发生“环绕”</p><h3 id="4-3-逻辑和关系运算符">4.3 逻辑和关系运算符</h3><p>进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值作为运算对象</p><h3 id="4-4-赋值运算符">4.4 赋值运算符</h3><p>赋值运算满足右结合律参与连续赋值的变量必须是相同的类型</p><h3 id="4-5-递增和递减运算符">4.5 递增和递减运算符</h3><h3 id="4-6-成员访问运算符">4.6 成员访问运算符</h3><p>解应用运算符的优先级低于点运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cond?expr1:expr2;</span><br><span class="line">&#x2F;&#x2F;输出表达式中使用条件运算符</span><br><span class="line">cout&lt;&lt;((grade&lt;60)?&quot;fail&quot;:&quot;pass&quot;); &#x2F;&#x2F;输出pass或者fail</span><br></pre></td></tr></table></figure><p>条件运算符可以嵌套，一般为了代码的可读性，嵌套不要超过三层。</p><h3 id="4-7-sizeof运算符">4.7 sizeof运算符</h3><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得值是一个size_t类型的常量表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof(type)</span><br><span class="line">sizeof expr</span><br></pre></td></tr></table></figure><h3 id="4-10-逗号运算符">4.10 逗号运算符</h3><p>首先对左侧表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。</p><h3 id="4-11-类型转换">4.11 类型转换</h3><h4 id="发生隐式类型转换">发生隐式类型转换</h4><ul><li>比int小的整形值首先提升为较大的整数类型</li><li>条件中，非bool值转为bool值。</li><li>初始化过程中，初始值转化为变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型</li><li>如果算数预算或关系运算对象有多种类型，需要转换成同一种类型。</li><li>函数调用时，也可能发生类型转换</li></ul><h4 id="显示转换">显示转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cast-name&lt;type&gt;(expression)</span><br><span class="line">cast-name:static_cast,dynamic_cast,const_cast,reinterpret_cast</span><br></pre></td></tr></table></figure><p>static_cast:任何具有明确定义的类型转换，只要不包含底层const都可以使用。const_cast:只能改变运算对象的底层constdynamic_cast：支持运行时类型识别reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释。（使用起来非常危险）</p><p>** 尽量避免强制类型转换 **</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++primer》ch6 函数</title>
      <link href="/2017/06/05/Cpp/cpp-primer/cpp_primer_ch6/"/>
      <url>/2017/06/05/Cpp/cpp-primer/cpp_primer_ch6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。</p></blockquote><a id="more"></a><h1 id="6-1-函数基础">6.1 函数基础</h1><h2 id="形参和实参：">形参和实参：</h2><p>实参是形参的初始值，函数的形参列表可以为空。局部静态对象，定义成static类型，在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><h1 id="6-2-参数传递">6.2 参数传递</h1><p>如果形参是引用类型，它将绑定到对应的实参上，称为引用传递；否则，将实参的值拷贝后赋给形参，称为值传递。</p><h2 id="6-2-1-传值参数">6.2.1 传值参数</h2><p>将实参的值拷贝给形参。当是指针形参时，指针的行为和其他非引用类型一样，执行指针拷贝类型时，拷贝的是指针的值。拷贝之后是不同的指针，但是指向的是相同的值，我们可以在函数中修改指针所指对象的值。在C++中，建议使用引用类型的形参替代指针。</p><h2 id="6-2-2-传引用参数">6.2.2 传引用参数</h2><p>** 1.使用引用避免拷贝。 **因为有的类类型是不能拷贝的，或者在拷贝一些大的类类型对象或者容器对象比较低效。如果函数不需要改变引用参数的值，最好将其声明为常量引用。** 2.使用引用形参返回额外信息。**由于函数不能有多个返回值，在我们需要返回多个值的时候，可以额外传一个引用参数。** 3.可以直接操作引用形参所引的对象。 **</p><h2 id="6-2-3-const形参和实参">6.2.3 const形参和实参</h2><p>和其它初始化一样，当用实参初始化形参时会忽略掉顶层const。也就是，形参的顶层const会被忽略掉。（这个可以思考一下，我们可以通过形参的const在参数中控制是否需要改变形参，以及对应的实参，这样更方便我们传参数。当然有了这个我们就不能重载有无const的两个函数了，因为会被编译器相同对待。）尽量使用常量引用，除了在使用的时候，无法把常量引用初始化为引用（很简单的道理），另外，也会给调用者一种误导。</p><h2 id="6-2-4-数组形参">6.2.4 数组形参</h2><p>无法以值传递的方式使用数组参数。数组的特点：不允许拷贝、使用数组会将其转化为指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void print(const int*);</span><br><span class="line">void print(const int[]);</span><br><span class="line">void print(const int[10]);  &#x2F;&#x2F;这里的维度表示我们期望数组含有多少个元素，实际不一定</span><br></pre></td></tr></table></figure><h3 id="关于数组长度">关于数组长度</h3><p>由于传递数组引用的时候，只是数组的首元素指针，所以有时候我们需要在形参定义的时候，就将数组大小传递给形参。这里有几种方式。</p><h2 id="6-2-5-mian处理命令行选项">6.2.5 mian处理命令行选项</h2><p>当使用argv[]中的实参时，第一个实参保存的是程序名，所以应该从第二个开始。</p><h2 id="6-2-6-含有可变形参的函数">6.2.6 含有可变形参的函数</h2><p>有时候我们预先不知道向函数传递几个实参。1.如果所有的实参类型相同，可以传递名为initializee_list的标准库类型；2.如果实参类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。</p><h1 id="6-3-返回类型和return语句">6.3 返回类型和return语句</h1><p>return语句终止当前执行的函数，并将控制权返回到调用该函数的地方。return语句不要返回局部对象的引用或引用（因为局部对象会在函数调用完成后删除，会产生未定义的结果）。c++11新标准中函数可以返回花括号包围的值列表，主函数main的返回值，非0的返回值由机器决定。</p><h1 id="6-4-函数重载">6.4 函数重载</h1><p>拥有顶层const不影响传入函数的对象。另外，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。不能仅仅通过函数的返回值区分两个同名的函数</p><h2 id="重载与作用域">重载与作用域</h2><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。在不同的作用域中无法重载函数名。在c++中，名字查找发生在类型检查之前。</p><h1 id="6-5-特殊用途语言特性">6.5 特殊用途语言特性</h1><p>大多数程序都有用的特性：默认实参、内联函数、constexpr函数。</p><h2 id="默认实参">默认实参</h2><p>一旦某个形参赋予了默认值，后面的所有形参必须有默认值。函数调用时，实参按其位置进行解析，只能省略尾部的实参。一个函数被声明多次的时候，在给定的作用域中一个形参只能被赋予一次默认实参，也就是函数的后续声明。</p><h2 id="内联函数inline">内联函数inline</h2><p>将它在每个调用点上“内联的”展开，一般来说用于优化规模较小、流程直接、频繁调用的函数。</p><h2 id="constexpr函数">constexpr函数</h2><p>constexpr函数指能用于常量表达式的函数。函数的返回值及所有形参的类型都得是字面值类型，并且函数体中必须有且只有一条return语句。编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式的指定 为内联函数.内联函数和constexpr函数通常定义在头文件中.</p><h2 id="调试帮助">调试帮助</h2><p>assert预处理宏,以一个表达式作为条件.我们可以使用一个#define 语句定义NDEBUG，关闭调试状态</p><h1 id="6-6-函数匹配">6.6 函数匹配</h1><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换得来时。</p><h2 id="确定候选函数和可行函数">确定候选函数和可行函数</h2><p>函数匹配第一步：选定本次调用对应的重载函数集。候选函数的两个特征：与被调用的函数同名，其声明在调用点可见。第二步考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数。</p><h2 id="实参类型转换">实参类型转换</h2><p>确定最佳匹配的排序：</p><ul><li>1.精确匹配：实参形参类型相同，实参从数组或函数类型转化为对应的指针类型，实参添加顶层const或者从实参中删除顶层const。</li><li>2.通过const转换实现的匹配。</li><li>3.通过类型提升实现的匹配。</li><li>4.通过算术类型转换或指针转换实现的匹配。</li><li>5.通过类类型转换实现的匹配。</li></ul><h1 id="6-7-函数指针">6.7 函数指针</h1><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p><h2 id="重载函数的指针">重载函数的指针</h2><p>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。</p><h2 id="函数指针形参">函数指针形参</h2><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上是被当成指针使用。可以直接把函数当成实参使用，会自动转换成指针。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++primer》ch2 变量和基本类型</title>
      <link href="/2017/06/04/Cpp/cpp-primer/cpp_primer_ch2/"/>
      <url>/2017/06/04/Cpp/cpp-primer/cpp_primer_ch2/</url>
      
        <content type="html"><![CDATA[<p>数据类型决定了程序中数据和操作的意义。</p><a id="more"></a><h1 id="2-1-基本内置类型">2.1 基本内置类型</h1><p>基本数据类型：** 算数类型  空类型（void） **,其中算数类型包括：字符、正整数、布尔值、浮点数。空类型不对应具体的值，用于一些特殊的场合。</p><h2 id="2-1-1-算数类型">2.1.1 算数类型</h2><p>分为整形和浮点型。</p><h3 id="整形：">整形：</h3><ul><li>bool:取值为true或者false。</li><li>char：基本的字符类型，一个char的大小与一个机器字节一样。</li><li>wchar_t,char16_t,char32_t** rules: **一个int至少和一个short一样大，一个long至少跟一个int一样大，一个long long至少跟一个long一样大。</li></ul><h3 id="浮点型：">浮点型：</h3><ul><li>float：一般一个字，32bit</li><li>double：2个字，64bit</li><li>long double：3或4个字，96或128bit</li></ul><h3 id="带符号类型和无符号类型">带符号类型和无符号类型</h3><h2 id="2-1-2-类型转换">2.1.2 类型转换</h2><h3 id="转换过程：">转换过程：</h3><ul><li>非bool到bool：初始为0则为false，其他为true</li><li>bool到非bool：初始值为false则为0，初始值为true为1</li><li>浮点数到整型：仅保留浮点数中的** 小数点部分 **</li><li>整数到浮点数：小数部分记为0，如果整数所占的空间超过浮点类型的容量，会报错。</li><li>赋给无符号类型，当超出它表示范围的时候，转换为该无符号类型表示数值总数取模后的余数。</li><li>给带符号的数输出超过范围的值是，结果时** 未定义的 **</li></ul><p>tips:一般不在算数表达式中使用bool值</p><h3 id="含有无符号类型的表达式">含有无符号类型的表达式</h3><p>一般不要混用无符号和有符号的类型，当无符号超过范围时，可能会出现取模的情况，放在循环中，或者计算结果中，会产生无法预计的结果</p><h2 id="2-1-3-字面值常量">2.1.3 字面值常量</h2><p>顾名思义，字面值常量一望而知。每个字面值常量对应一种数据类型，字面量常量得形式和值决定了它的数据类型。</p><h3 id="整型和浮点型字面值">整型和浮点型字面值</h3><p>严格来说，十进制字面值不会是负数，通常，负号并不在字面值内，它的作用仅仅是对字面值取负值而已。</p><h3 id="字符和字符串字面值">字符和字符串字面值</h3><ul><li>char型字面值：由单引号括起来的一个字符</li><li>字符串字面值：由双引号括起来的零个或多个字符** Note：字符串字面值的类型实际上是由常量字符组成的数组，编译器在每个字符串的结尾处添加一个空字符（’\0’），字符串的字面值的实际长度比它的内容多1。 **</li></ul><h3 id="转义序列">转义序列</h3><p>有两类不能直接使用的字符。不可打印的和特殊含义的字符（单引号，双引号，问号，反斜线），这些情况下需要使用转义字符。</p><h3 id="指定字面值类型">指定字面值类型</h3><p>添加一定的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。前缀有：u（Unicode16）、U（Unicode32）、L（宽字符）、u8（UTF-8）。后缀有：u或者U（unsigned）、l或者L（ling）、ll或者LL（long long），f或者F（float）、l或者L（long double）。</p><h3 id="布尔字面值和指针字面值">布尔字面值和指针字面值</h3><p>bool：true、false指针：nullptr</p><h1 id="2-2-变量">2.2 变量</h1><p>对于c++来说，一般“变量”和“对象”可以互换使用。对象时具有某种数据类型的内存空间。</p><h2 id="2-2-1-变量定义">2.2.1 变量定义</h2><p>基本形式：类型说明符+一个或多个变量名组成的列表（变量名以逗号分隔）+分号</p><h3 id="初始值">初始值</h3><p>当对象在创建时获得了一个特定的值，称为被初始化了。** 初始化和复制是两个完全不同的操作，注意这个概念很重要 **初始化：在创建变量是赋予其一个初始值。复制：把对象的当前值擦除，以一个新的值代替。</p><h3 id="列表初始化">列表初始化</h3><p>无论是初始化对象还是某些时候为对象赋新值，都可以使用一组又花括号括起来的初始值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int units_sold&#x3D;0;</span><br><span class="line">int units_sold&#x3D;&#123;0&#125;;</span><br><span class="line">int units_sold&#123;0&#125;;</span><br><span class="line">int units_sold(0);</span><br></pre></td></tr></table></figure><h3 id="默认初始化">默认初始化</h3><p>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式的初始化，则其值由类确定。。建议初始化每一个内置类型的变量。</p><h2 id="2-2-2-变量声明与定义的关系">2.2.2 变量声明与定义的关系</h2><p>声明使得名字为程序所知，定义负责创建与名字关联的实体。** extern **关键字：如果想声明一个变量而不是定义它，就在变量名前添加extern，而不显示的初始化变量。如果在函数体内部试图初始化一个有extern关键字标记的变量，会引发错误。</p><h2 id="2-2-3-标识符">2.2.3 标识符</h2><p>用户自定义的标识符中不能出现两个连续的下划线，也不能以下划线紧连大写字母开头。定义在函数体内的标识符不能以下划线开头。</p><h3 id="变量命名规范">变量命名规范</h3><ul><li>标识符要能体现实际含义</li><li>变量名一般小写字母</li><li>自定义的类名一般大写字母开头</li><li>标识符由多个单词组成时，单词应有明显区分，使用下划线</li></ul><h2 id="2-2-4-名字的作用域">2.2.4 名字的作用域</h2><p>当内层出现与外层相同的名字时，使用内层定义的名字。</p><h1 id="2-3-复合类型">2.3 复合类型</h1><p>复合类型指的是基于其他类型定义的类型。这里介绍两种：引用和指针。</p><h2 id="2-3-1-引用">2.3.1 引用</h2><p>引用为对象起了另外一个名字，引用；类型引用另外一种类型。通过将生命符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用必须初始化。</p><h3 id="引用即别名">引用即别名</h3><p>引用并不是对象，只是一个已经存在的对象起的另外一个名字。定义了一个引用之后，对其做的所有操作都是在与之绑定的对象上进行的。因为引用本身只是一个别名，不是一个对象，所以不能定义引用的引用。</p><h3 id="引用的定义">引用的定义</h3><p>除了两种例外的情况，其他所有的引用类型都要与之绑定的对象严格比配。引用只能绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。</p><h2 id="2-3-2-指针">2.3.2 指针</h2><p>指针是“指向point to”的另外一种类型的复合引用。指针也实现了对其他对象的间接访问。两者的不同点：</p><ul><li>1.指针本身就是一个对象，允许对指针赋值和拷贝，而且指针的生命周期内可以指向多个不同的对象。</li><li>2.指针无需在定义时赋初值。</li></ul><h3 id="获取对象的地址">获取对象的地址</h3><p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）不能定义指向引用的指针（因为引用不是一个对象）。除了两种例外的情况，所有指针的类型都要和它指向的对象严格匹配。</p><h3 id="指针值">指针值</h3><p>指针的值（即地址）应该属于下面四种状态之一：</p><ul><li>1.指向一个对象</li><li>2.指向紧邻对象所占空间的下一个位置</li><li>3.空指针，表示没有指向任何对象。</li><li>4.无效指针，上述之外的其他值。</li></ul><h3 id="利用指针访问对象">利用指针访问对象</h3><p>如果指针指向了一个对象，允许使用解引用符（操作符*）来访问对象。</p><h3 id="空指针">空指针</h3><p>空指针不指向任何对象，得到空指针的办法：直接用字面值nullptr初始化指针或者将指针初始化为字面值0来生成空指针。** 建议 **：初始化所有指针</p><h3 id="赋值和指针">赋值和指针</h3><p>记住赋值永远改变的是等号左侧的对象。</p><h3 id="其他指针操作">其他指针操作</h3><p>只要一个指针拥有合法值，就能将它用在条件表达式中，只要不为空，条件都为true。</p><h3 id="void-指针">void* 指针</h3><p>void* 是一种特殊的指针类型，可用于存放任意对象的地址。</p><h2 id="2-3-3-理解复合类型的声明">2.3.3 理解复合类型的声明</h2><p>变量的定义包括：一个基本数据类型+一组声明符。基本数据类型只有一个，但是声明符的形式可以不同。</p><h3 id="指向指针的指针">指向指针的指针</h3><p>当有多个修饰符连写在一起的时候，按照逻辑关系解释。</p><h3 id="指向指针的引用">指向指针的引用</h3><p>引用本身不是对象，但是指针是对象，所以可以对指针引用。面对一条复杂的指针或引用的声明语句时，从右向左阅读有助于弄清真实含义。</p><h1 id="2-4-const限定符">2.4 const限定符</h1><h3 id="初始化和const">初始化和const</h3><p>const与非const对象的区别就是，const类型的对象执行不改变起内容的操作。如：const int也能像int一样参与算术运算，也能转化为bool值。</p><h3 id="默认状态下-const对象仅在文件内有效">默认状态下，const对象仅在文件内有效</h3><p>如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字。</p><h2 id="2-4-1-const的引用">2.4.1 const的引用</h2><p>可以把引用绑定到const对象上，就像绑定到其他对象上一样，称为对常量引用，对常量的引用不能修改它所绑定的对象。** 术语：常量引用是对const的引用 **：并不存在常量引用，是对const的引用。</p><h3 id="初始化和对const的引用">初始化和对const的引用</h3><p>引用情况的例外：第一种是，在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。</p><h3 id="对const的引用可能引用一个非const的对象">对const的引用可能引用一个非const的对象</h3><p>此种行为是合法的，但是不能通过对const的引用改变对象的值，兑现可以通过其他的方式改变值。</p><h2 id="2-4-2-指针和const">2.4.2 指针和const</h2><p>指向常量的指针不能改变其所指对象的值，要想存放常量对象的地址，只能只用指向常量的指针。所谓指向常量的指针和引用，只是自以为指向了一个常量，所以自觉不去改变所指对象的值。</p><h3 id="const指针">const指针</h3><p>*const：不变的是指针的值而不是指向的那个值。采用从右向左的方式阅读，看离最近的符号。</p><h3 id="顶层const">顶层const</h3><p>顶层const表示指针本身是个常量，底层const表示指针指的对象是一个常量。当对象执行拷贝操作时，顶层const不受影响，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转化。</p><h2 id="2-4-4-constexpr和常量表达式">2.4.4 constexpr和常量表达式</h2><p>常量表达式指：值不会改变且在编译过程就能得到计算结果的表达式。（字面值、用常量表达式初始化的const对象）</p><h3 id="constexpr变量">constexpr变量</h3><p>声明为constexpr的变量一定是一个变量，且必须用常量表达式初始化。</p><h3 id="字面值类型">字面值类型</h3><h3 id="指针和constexpr">指针和constexpr</h3><p>在constexpr如果定义了一个指针，则constexpr只对指针有效，与指针所指的对象无关。</p><h1 id="2-5-处理类型">2.5 处理类型</h1><h2 id="2-5-1-类型别名">2.5.1 类型别名</h2><p>类型别名是一个名字，是某种类型的同义词。使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages  &#x2F;&#x2F;wages 是double的别名</span><br><span class="line">typedef wages base,*p</span><br><span class="line"></span><br><span class="line">#别名声明</span><br><span class="line">using SI&#x3D;Scales_item;</span><br></pre></td></tr></table></figure><h3 id="指针-常量和类型别名">指针、常量和类型别名</h3><h2 id="2-5-2-auto类型说明符">2.5.2 auto类型说明符</h2><h3 id="复合类型-常量和auto">复合类型、常量和auto</h3><ul><li>引用时的auto，以引用对象的类型作为auto的类型</li><li>auto一般会忽略掉顶层const，底层const会保留下来。</li><li>可以将引用的类型设为auto</li></ul><h2 id="2-5-3-decltype类型指示符">2.5.3 decltype类型指示符</h2><p>选择并返回操作数的类型，编译器分析表达式并得到类型，但并不实际计算值</p><h3 id="decltype和引用">decltype和引用</h3><p>有些表达式将向decltype返回一个引用类型。如果表达式的内容是解引用操作，则decltype将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。decltype和auto的重要区别：decltype的结果类型与表达式形式密切相关。** 如果给变量加上一层或多层括号，decltype就会得到引用类型。decltype((val))的结果永远是引用，decltype(val)只有当val本身是一个引用时才是引用。另外，赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型 **</p><h1 id="2-6-自定义数据结构">2.6 自定义数据结构</h1><h2 id="定义自己的数据结构">定义自己的数据结构</h2><h2 id="定义自己的头文件">定义自己的头文件</h2><h2 id="预处理器">预处理器</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++primer》ch3 字符串、向量和数组</title>
      <link href="/2017/06/04/Cpp/cpp-primer/cpp_primer_ch3/"/>
      <url>/2017/06/04/Cpp/cpp-primer/cpp_primer_ch3/</url>
      
        <content type="html"><![CDATA[<h1 id="第3章-字符串-向量和数组">第3章 字符串、向量和数组</h1><h2 id="3-1-命名空间的using声明">3.1 命名空间的using声明</h2><h3 id="每个名字都需要独立的using声明">每个名字都需要独立的using声明</h3><h3 id="头文件中不应该包含using声明">头文件中不应该包含using声明</h3><p>因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。</p><h2 id="3-2-标准库类型string">3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象">3.2.1 定义和初始化string对象</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1;   &#x2F;&#x2F;默认初始化</span><br><span class="line">string s2&#x3D;s1;  &#x2F;&#x2F;s2是s1的副本</span><br><span class="line">string s2(s1); &#x2F;&#x2F;等价于string s2&#x3D;s1,s2是s1的副本</span><br><span class="line">string s3&#x3D;&quot;hiya&quot;;  &#x2F;&#x2F;s3是字面值的副本，但是不包含字面值最后的那个空字符</span><br><span class="line">string s3(&quot;hiya&quot;);  &#x2F;&#x2F;等价于string s3&#x3D;&quot;hiya&quot;</span><br><span class="line">string s4(n,&#39;c&#39;);  &#x2F;&#x2F;把s4初始化为连续n个字符c组成的字符串</span><br></pre></td></tr></table></figure><h3 id="3-2-2-string对象上的操作">3.2.2 string对象上的操作</h3><ul><li>读写string对象</li><li>读取未知数量的string对象</li><li>使用getline读取一整行</li><li>string的empty和size操作</li></ul><h3 id="string-size-type类型">string:size_type类型</h3><p>size_type是一种无符号整形数，如果在表达式中混用了带符号数和无符号数会产生意想不到的后果。</p><h3 id="比较string对象">比较string对象</h3><p>按字典顺序</p><h3 id="字面值和string类型相加">字面值和string类型相加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;错误的方式</span><br><span class="line">string s&#x3D;&quot;hello&quot;+&quot;,&quot; &#x2F;&#x2F;错误，因为两个运算对象都不是string，不能把两个字面值直接相加</span><br><span class="line">string s1&#x3D;&quot;hello&quot;+s1+&quot;,&quot; &#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure><p>** 字符串字面值与string是不同的类型 **</p><h3 id="ex3-3-string类的输入运算和getline函数分别如何处理字符串">ex3.3 string类的输入运算和getline函数分别如何处理字符串</h3><p>string的标准输入：自动忽略字符串开头的空白，从第一个真正的字符开始读取，直到下一个空白为止getline函数：从给定的输入流中读取，直到遇到换行符为止。</p><h2 id="3-3-标准库类型vector">3.3 标准库类型vector</h2><p>vector是一种类模板，需要后加一堆尖括号，在括号内放上信息。</p><h3 id="3-3-1-定义和初始化vector对象">3.3.1 定义和初始化vector对象</h3><ul><li>1.使用拷贝初始化</li><li>2.如果提供一个类内的初始值，只能使用拷贝初始化或者花括号形式初始化</li><li>3.如果提供的是初始值元素值的列表，则只能使用花括号初始化，而不能使用圆括号</li><li>4.创建指定数量的元素：采用圆括号</li></ul><h3 id="3-3-2-像vector中添加元素">3.3.2 像vector中添加元素</h3><p>push_back：像一个值添加到vector的尾部。（如果开始不知道有多少元素，c++中，一般先创建一个空的vector然后像其中添加元素最好）不能使用下标形式添加元素，只能对确知已存在的元素执行下标操作。</p><h2 id="3-4-迭代器介绍">3.4 迭代器介绍</h2><p>迭代器这个名词可能有三种不同的含义：可能是迭代器概念本身，可能是容器定义的类型，还可能指某个迭代器对象。某些对Vector对象的操作回事迭代器失效：一个是不能在范围for循环内向vector中添加元素，另一个是任何一种可能改变vector对象容量的操作，都有可能是vector对象的迭代器失效。</p><h3 id="迭代器的算数运算">迭代器的算数运算</h3><p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。迭代器之间的比较：参与比较的迭代器必须合法且指向同一个容器的元素（或者尾元素的下一个位置）</p><h2 id="3-5-数组">3.5 数组</h2><p>数组与vector的区别：数组的大小确定不变，不能随意像数组中添加元素。性能很好，但是损失了灵活性。</p><h3 id="3-5-1-定义和初始化数组">3.5.1 定义和初始化数组</h3><p>数组是一种复合类型，数组的维度必须是一个常量表达式。定义数组的时候必须指定数组的类型。同时，数组的元素应该为对象，不存在引用的数组。</p><h4 id="字符数组的特殊性">字符数组的特殊性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a1[]&#x3D;&#123;&#39;C&#39;,&#39;+&#39;,&#39;+&#39;&#125;;  &#x2F;&#x2F;列表初始化，没有空字符</span><br><span class="line">char a2[]&#x3D;&#123;&#39;C&#39;,&#39;+&#39;,&#39;+&#39;&#125;;  &#x2F;&#x2F;列表初始化，含有显式的空字符</span><br><span class="line">char a3[]&#x3D;&quot;C++&quot;;   &#x2F;&#x2F;自动添加表示字符串结束的空字符</span><br></pre></td></tr></table></figure><h4 id="不允许拷贝和赋值">不允许拷贝和赋值</h4><h4 id="复杂的数组声明">复杂的数组声明</h4><p>** 要想理解数组的声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int &amp;refs[10]&#x3D;...  &#x2F;&#x2F;  错误！不存在数组的引用</span><br><span class="line">int (*Parray)[10]&#x3D;&amp;arr; &#x2F;&#x2F;Parray指向一个含有10个整数的数组</span><br><span class="line">int (&amp;arrRef)[10]&#x3D;arr   &#x2F;&#x2F;arrRef引用一个含有10个整数的数组</span><br><span class="line">int *ptrs[10];  &#x2F;&#x2F;ptrs是一个含有10个整型指针的数组</span><br></pre></td></tr></table></figure><h3 id="3-5-2-访问数组元素">3.5.2 访问数组元素</h3><ul><li>数组下标为** size_t类型 **，是一种机器相关的无符号类型。</li></ul><h3 id="3-5-3-指针和数组">3.5.3 指针和数组</h3><p>使用数组的时候编译器一般会把它转化成指针</p><h4 id="指针也是迭代器">指针也是迭代器</h4><p>允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上</p><h4 id="标准库函数begin和end">标准库函数begin和end</h4><h3 id="3-5-4-c风格字符串">3.5.4 C风格字符串</h3><p>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。C风格字符串和字符数组的关系，尤其需要考虑串尾是否含有空字符。** 问题：为什么没有指针相加？ **指着也是一个对象，与指针有关的属性有三个，分别是指针的值（是一个内存地址值）、指针所指的对象、指针本身在内存中的存储位置。显然把两个地址加在一起是没有意义的。</p><h3 id="3-5-5-与旧代码的接口">3.5.5 与旧代码的接口</h3><h4 id="混用string对象和c风格字符串">混用string对象和C风格字符串</h4><ul><li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</li><li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（但不能两个都是）；在string对象的赋值运算中允许以空字符串结束的字符数组作为右侧的运算对象。</li></ul><h4 id="使用数组初始化vector对象">使用数组初始化vector对象</h4><p>允许使用数组初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址即可。但不能使用一个数组为另一个内置类型的数组赋初值，也不能使用vector对象初始化数组。</p><h2 id="3-6-多维数组">3.6 多维数组</h2><p>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ia[3][4] &#x2F;&#x2F;大小为3的数组，每个元素是含有4个整数的数组</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gitpage+Hexo搭建自己的博客</title>
      <link href="/2017/05/31/tools/hexo+gitpage/"/>
      <url>/2017/05/31/tools/hexo+gitpage/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="如今-各种博客网站都可以让我们随意的写作-但是很多的选择也让我们有时候不知道该怎么选择-而且作为喜欢折腾的程序员来说-自己搭建属于自己的博客当然是一个很好的选择了-可以将文件保存在本地-随时换自己的风格-备份-做一些diy的调整">如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。</h2><a id="more"></a><p>**摘自：https://xuanwo.org/2015/03/26/hexo-intor/ **写的很详细了，就不仔细写一遍了，就当个记录吧，以后出问题了好解决一点。</p><h2 id="一-准备工作-准备需要准备好以下软件：">一、准备工作，准备需要准备好以下软件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node.js环境</span><br><span class="line">Git</span><br></pre></td></tr></table></figure><h3 id="1-windows配置node-js环境下载node-js安装文件：">1.Windows配置Node.js环境下载Node.js安装文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows Installer 32-bit</span><br><span class="line">Windows Installer 64-bit</span><br></pre></td></tr></table></figure><ul><li><p>根据自己的Windows版本选择相应的安装文件。<img src="https://xuanwo.org/imgs/opinion/Nodejs-install.png" alt=""></p></li><li><p>保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口：<img src="http://upload-images.jianshu.io/upload_images/6054281-bc2e6deb5f394f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~） 在打开的命令行界面中，输入</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。(https://xuanwo.org/imgs/opinion/Nodejs-test.png)</p><h3 id="2-配置git环境下载git安装文件：">2.配置Git环境下载Git安装文件：</h3><p><a href="https://github.com/git-for-windows/git/releases/download/v2.6.3.windows.1/Git-2.6.3-64-bit.exe" target="_blank" rel="noopener">Git-2.6.3-64-bit.exe</a></p><p>然后就进入了Git的安装界面，如图：<img src="https://xuanwo.org/imgs/opinion/Git-install.png" alt="">和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择：<img src="https://xuanwo.org/imgs/opinion/Git-path-setting.png" alt=""></p><blockquote><p>这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。</p></blockquote><p>一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。<img src="https://xuanwo.org/imgs/opinion/Git-test.png" alt=""></p><h2 id="二-新建仓库">二、新建仓库</h2><h3 id="1-打开https-github-com-在下图的框中-分别输入自己的用户名-邮箱-密码">1.打开https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。</h3><h3 id="2-创建代码库登陆之后-点击页面右上角的加号-选择new-repository：">2.创建代码库登陆之后，点击页面右上角的加号，选择New repository：</h3><p>进入代码库创建页面：在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示：<img src="https://xuanwo.org/imgs/opinion/Github-new-repo-setting.png" alt="">正确创建之后，你将会看到如下界面：<img src="https://xuanwo.org/imgs/opinion/Github-new-repo-look-like.png" alt="">开启gh-pages功能点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图：<img src="https://xuanwo.org/imgs/opinion/Github-pages.png" alt="">点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。配置Hexo安装Hexo在自己认为合适的地方创建一个文件夹，然后在文件夹空白处按住Shift+鼠标右键，然后点击在此处打开命令行窗口。（同样要记住啦，下文中会使用在当前目录打开命令行来代指上述的操作）在命令行中输入：<code>npm install hexo-cli -g</code>然后你将会看到:<img src="https://xuanwo.org/imgs/opinion/npm-install-hexo-cli.png" alt="">可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入<code>npm install hexo --save</code></p><p>然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入：<code>hexo -v</code></p><p>如果你看到了如图文字，则说明已经安装成功了。<img src="https://xuanwo.org/imgs/opinion/hexo-v.png" alt="">初始化Hexo接着上面的操作，输入：<code>hexo init</code></p><p>如图：<img src="https://xuanwo.org/imgs/opinion/hexo-init.png" alt="">然后输入：<code>npm install</code></p><p>之后npm将会自动安装你需要的组件，只需要等待npm操作即可。</p><h2 id="首次体验hexo">首次体验Hexo</h2><p>继续操作，同样是在命令行中，输入：<code>hexo g</code></p><p>如图：<img src="https://xuanwo.org/imgs/opinion/hexo-g.png" alt="">然后输入：<code>hexo s</code></p><p>然后会提示：<code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p><p>在浏览器中打开<code>http://localhost:4000/</code>，你将会看到：<img src="https://xuanwo.org/imgs/opinion/hexo-first-time.png" alt="">到目前为止，Hexo在本地的配置已经全都结束了。</p><h2 id="使用hexo">使用Hexo</h2><blockquote><p>在配置过程中请使用yamllint来保证自己的yaml语法正确修改全局配置文件此段落引用自<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo官方文档</a>您可以在 _config.yml 中修改大部份的配置。</p></blockquote><h3 id="网站">网站</h3><p>参数 | 描述title | 网站标题subtitle | 网站副标题description | 网站描述author | 您的名字language | 网站使用的语言timezone | 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</p><h3 id="网址">网址</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>url</td><td>网址</td><td></td></tr><tr><td>root</td><td>网站根目录</td><td>permalink文章的 永久链接 格式:year/:month/:day/:title/permalink_default永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</td></tr></tbody></table><p>目录参数描述默认值source_dir资源文件夹，这个文件夹用来存放内容。sourcepublic_dir公共文件夹，这个文件夹用于存放生成的站点文件。publictag_dir标签文件夹tagsarchive_dir归档文件夹archivescategory_dir分类文件夹categoriescode_dirInclude code 文件夹`downloads/codei18n_dir国际化（i18n）文件夹:langskip_render跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 文章参数描述默认值new_post_name新文章的文件名称:title.mddefault_layout预设布局postauto_spacing在中文和英文之间加入空格falsetitlecase把标题转换为 title casefalseexternal_link在新标签中打开链接truefilename_case把文件名称转换为 (1) 小写或 (2) 大写0render_drafts显示草稿falsepost_asset_folder启动 Asset 文件夹falserelative_link把链接改为与根目录的相对位址falsefuture显示未来的文章truehighlight代码块的设置 分类 &amp; 标签参数描述默认值default_category默认分类uncategorizedcategory_map分类别名 tag_map标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。参数描述默认值date_format日期格式MMM D YYYYtime_format时间格式H:mm:ss分页参数描述默认值per_page每页显示的文章量 (0 = 关闭分页功能)10pagination_dir分页目录page扩展参数描述theme当前主题名称。值为false时禁用主题deploy部署部分的设置配置Deployment首先，你需要为自己配置身份信息，打开命令行，然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>同样在_config.yml文件中，找到Deployment，然后按照如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname&#x2F;yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>如果使用git方式进行部署，执行npm install hexo-deployer-git --save来安装所需的插件然后在当前目录打开命令行，输入：<code>hexo d</code></p><p>随后按照提示，分别输入自己的Github账号用户名和密码，开始上传。 然后通过http://yourname.github.io/来访问自己刚刚上传的网站。添加新文章打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就能在执行hexo g的时候被渲染。 新建的文章头需要添加一些yml信息，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: hello-world   &#x2F;&#x2F;在此处添加你的标题。</span><br><span class="line">date: 2017-5-11 08:55:29   &#x2F;&#x2F;在此处输入你编辑这篇文章的时间。</span><br><span class="line">categories: Exercise   &#x2F;&#x2F;在此处输入这篇文章的分类。</span><br><span class="line">toc: true    &#x2F;&#x2F;在此处设定是否开启目录，需要主题支持。</span><br></pre></td></tr></table></figure><h2 id="进阶">进阶</h2><p>如果成功完成了上述的全部步骤，恭喜你，你已经搭建了一个最为简单且基础的博客。但是这个博客还非常简单， 没有个人的定制，操作也比较复杂，下面的进阶技巧将会让你获得对Hexo更为深入的了解。更换主题可以在此处寻找自己喜欢的主题 下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改：</p><h3 id="extensions">Extensions</h3><h4 id="plugins-http-hexo-io-plugins">Plugins: http://hexo.io/plugins/</h4><h4 id="themes-http-hexo-io-themes">Themes: http://hexo.io/themes/</h4><p>theme: landscape //themes文件夹中对应文件夹的名称</p><p>然后先执行<code>hexo clean</code>，然后重新<code>hexo g</code>，并且<code>hexo d</code>，很快就能看到新主题的效果了~</p><p><s>更换域名首先，需要注册一个域名。在中国的话，.cn全都需要进行备案，如果不想备案的话，请注册别的顶级域名，可以使用godaddy或新网或万网中的任意一家，自己权衡价格即可。 然后，我们需要配置一下域名解析。推荐使用DNSPod的服务，比较稳定，解析速度比较快。在域名注册商出修改NS服务器地址为：</s><s>f1g1ns1.dnspod.net</s><s>f1g1ns2.dnspod.net</s></p><p><s>以新网为例，首先点击域名管理进入管理页面：</s></p><p><s>然后点击域名后面的管理：</s></p><p><s>进入域名管理的操作界面，点击域名管理，来到域名管理界面：</s></p><p><s>点击修改域名DNS，然后选择填写具体信息，在下面的空框中填入DNSPod的NS服务器：</s></p><p><s>然后我们进入DNSPod的界面，开始真正进入域名解析的配置= =。在DNSPod中，首先添加域名，然后分别添加如下条目：</s></p><p><s>最后，我们对Github进行一下配置。</s><s>在自己本地的hexo目录下的source文件夹中，新建一个CNAME文件（注意，没有后缀名。），内容为yourdomin.xxx。然后再执行一下hexo d -g，重新上传自己的博客。 在github中打开你自己的库，进入库的setting界面，如果看到了如下提示，说明配置成功了。</s></p><p><s>在这一系列的操作中，包括修改NS服务器，设置A解析等等，都需要一定的时间。短则10分钟，长则24小时，最长不会超过72小时。如果超过72小时，请检查自己的配置过程，或者修改自己本地的DNS服务器。</s></p><p>##绑定域名：有一个简单的办法，当然只是现在作为拥有GitHub学生包才可以用的，打开<a href="https://education.github.com/" target="_blank" rel="noopener">学生包</a>，通过教育邮箱申请之后，可以在package中找到那么namecheap，注册通过GitHub进入，可以直接申请域名，会自动绑定到我们的gitpage，不过还需要一点点修改，就是把cname的www改成我们的gitpage页面，就可以了。。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我为什么写博客？</title>
      <link href="/2017/05/15/Random/why_blog/"/>
      <url>/2017/05/15/Random/why_blog/</url>
      
        <content type="html"><![CDATA[<h1 id="开博客的第一天-谈学习与博客">开博客的第一天–谈学习与博客</h1><hr><h4 id="作为一个不是总能坚持一些事情的人-在这个碎片化的时代-每个人都有着自己的事情-学习-工作-生活-吃-玩-也正是很多乱七八糟的包围着我们-作为一个通信工程的学生-我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验-但是-就像你以为你发现了一个有意思的东西-其实是你被他让你发现了-你是被绑架的可怜的那个-我想说的是-不管是你认真理解的生活-还是学习-是真的能够好好思考才能有自己的东西">作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。</h4><h3 id="none"></h3><a id="more"></a><h4 id="那么-怎么才能好好思考呢-首先是要有足够的知识-才能减少信息不对称-才能在看到什么能够知道更多的什么-才能够举一反三-但是你每天还要刷微博-还要看新闻-还要看编程-还要忙老板的事情-想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难-因为它们大部分都不是在你学习的时候已经打好了标签-写着-一年后的某个中午会用到它-如果真的可以那样倒也还好-我们无非是在学习的时候加个备忘录就好了">那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。</h4><h3 id="none-v2"></h3><h4 id="然后-事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了-至少更深刻吧-长达十几年学渣生涯告诉我-就是做笔记-可能大学的时候确实太渣了-只能在快要考试的时候再抄一下笔记-或者整理出一份重点才行-那就是多年后翻起来仍然能让你想起来那门课学了什么-在那个时间段学了什么的-更具体的学了什么-而不是模电学过-数电学过-甚至爱装逼的话还能记起来某门专业课考了99-可是这样就算拿出去装逼自己都不记得是什么课-更何况是学了什么呢？">然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99.可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？</h4><h3 id="none-v3"></h3><h4 id="今天-是我最喜欢的球队-圣安东尼奥马刺队西部总决赛第一场-早上五点多起来看球的时候-发现莱昂纳德受伤了-很伤心-看到网上各种互怼-有那么一瞬间就觉得-当事人都觉得打球比这个更重要-不管能不能上场-接下来的比赛都更重要-何况是我这个只是连个腾讯体育会员都没买的支持者呢">今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。</h4><h3 id="none-v4"></h3><h4 id="所谓开始-我总不觉得需要有什么原因-这个不重要-重要的是永远是以后-最后以马刺队更衣室的一段话开始吧：">所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧：</h4><blockquote><p>When nothing seems to help,I go and look at a stonecutter hammering away at his rock perhaps a hundred times without as much as a crack showing in it.Yet at the hundred and first blow it will split in two,and I know it was not that blow that did it——but all that had gone before.——Jacob Riis</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20天学习Java视频笔记</title>
      <link href="/2017/03/09/Java/20days_java/"/>
      <url>/2017/03/09/Java/20days_java/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程-二">面向对象编程(二)</h1><ul><li><p>封装（private）匿名对象使用的方式：只调用一次注意，封装只是私有的一种表现形式。不私有也能封装。</p></li><li><p>构造函数构造函数和一般函数在写法上有不同构造函数在对象一建立就运行，而一般方法是在对象调用的时候才运行，是给对象添加对象具备的功能。一个对象建立，构造方法运行</p></li><li><p>构造代码块作用：给对象初始化，对象一建立就运行，而且优先于构造函数执行。和构造函数的区别：构造代码块是给所有的对象初始化，构造函数是给特定的对象初始化。构造代码块 中定义的是不同对象共性的特性.</p></li><li><p>this关键字</p></li></ul><ol><li>变量名起的没有意义，可读性非常差</li><li>局部变量和成员变量一样了，局部中有就在局部中使用，没有的话就在成员变量中找,将局部的值赋给成员变量，引出了this关键字</li><li>this:看上去，是用于区分局部变量和成员变量同名的情况</li><li>this到底代表的是什么this：就代表本类的对象，到底代表哪一个呢？this代表它所在函数所在对象的引用简单说：哪个对象在调用this所在的函数，this就代表哪个对象</li></ol><ul><li>this关键字在构造函数间的调用this语句：用于构造函数间互相调用this语句只能放在构造函数的第一行。因为初始化动作要先执行不允许死循环调用</li></ul><h1 id="面向对象-3">面向对象（3）</h1><h1 id="继承-final-抽象类-接口"><em>（继承，final，抽象类，接口）</em></h1><hr><h2 id="1-继承-概述">1.继承（概述）</h2><ul><li><strong>继承：</strong></li></ul><p>1.提高了代码的复用性</p><p>2.继承让类与类之间有了关系，有了关系才有了多态的特性。</p><p>注意：千万不要为了获取其他类的功能，简化代码而继承。必须是类与类之间有所属关系才可以继承，所属关系 is a。</p><p><strong>java语言中：java只支持单继承，不支持多继承。</strong></p><p>因为多继承容易带来安全隐患：当多个父类中定义了相同的功能，当功能内容不同时，子类对象不确定要运行哪一个。但是java保留了这种机制，并用另一种体现形式来完成表示，多实现。</p><ul><li><strong>java支持多层继承。</strong></li></ul><ul><li><strong>如何使用一个继承体系中的功能？</strong></li></ul><p>想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系的共性功能。</p><p>通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了那么在具体调用时，要创建最子类的对象。因为：1.可能父类不能创建对象 2.创建子类可以使用更多的功能，包括基本的也包括特有的简单的说，就是查阅父类，创建子类</p><h2 id="2-聚集关系">2.聚集关系</h2><p>聚集：has a聚合：组合：</p><p>子父类出现后，类成员的特点类成员：1.变量2.函数3.构造函数</p><h2 id="3-1-子父类中的变量的特点">3.1.子父类中的变量的特点</h2><p>如果子类中出现非私有的同名成员变量时，子类要访问本类中的变量，用thissuper代表的是父类对象的引用</p><h2 id="3-2-子父类中的函数的特点">3.2.子父类中的函数的特点</h2><p>当子类和父类中出现一样的函数时，当子类对象调用该函数，会运行子类函数的内容。如同父类的函数被覆盖一样。这种情况是函数的另一个特性：重写（覆盖）当子类继承父类，沿袭了父类的功能，但是功能的内容却和父类不一致。这时没有必要定义新功能，而是使用覆盖特殊，保留父类的功能定义，并重写功能内容。</p><p>覆盖：1.子类覆盖父类，必须保证子类权限大于父类权限，否则编译失败2.静态只能覆盖静态。</p><h2 id="3-3-子父类中构造函数的特点-子类的实例化过程">3.3.子父类中构造函数的特点–子类的实例化过程</h2><p>重载：只看重名函数的参数列表。重写：子类父类方法要一模一样。</p><p>子父类中的构造函数：在对子类对象进行初始化 时，弗父类的构造函数也会运行，那是因为子类的构造函数第一行默认有一条隐式语句super()；super()：会访问父类中空参数的构造函数。而且子类中所有的构造函数默认第一行都是super()为什么子类一定要访问父类中的构造函数？因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要先查看父类如何对这些数据进行初始化的，所以子类在对象进行初始化时，要先访问一下父类中的构造函数如果要访问父类中指定的构造函数，可以用super语句来指定。</p><p>注意：super语句一定定义在子类构造函数的第一行。</p><ul><li>子类的实例化过程：</li></ul><p>结论：子类所有的构造函数默认都会访问父类中空参数的构造函数，因为子类每一个构造函数的第一行都有一句隐式的super()当父类中没有空的构造函数时，子类必须手动通过super或者this语句形式来指定要访问父类中的构造函数。当然：子类中的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数</p><h2 id="4-final关键字">4.final关键字</h2><p>final：最终，作为一个修饰符</p><ol><li>可以修饰类，函数，变量</li><li>被final修饰的类不可以被继承,为了避免被继承，被子类复写功能</li><li>被final修饰的方法不可以被复写</li><li>被final修饰的变量是一个常量只能赋值一次，既可以修饰局部变量，也可以修饰成员变量。在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这值起个名字，方便于阅读，而这个值不需要改变，所以加个final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成，单词间通过_连接。</li><li>内部类定义在类中的局部位置时，只能访问该局部被final修饰的局部变量。</li></ol><h2 id="5-抽象类">5.抽象类</h2><p>当多个类中出现相同功能，但是功能的主体不同，这时可以向上抽取，这时只能抽取功能定义，而不抽取功能主题抽象：看不懂抽象类的特点：</p><ol><li>抽象方法一定在抽象类中。</li><li>抽象方法和抽象类都必须被abstract关键字修饰。</li><li>抽象类不可以用new创建对象，因为调用抽象方法没意义。</li><li>抽象类中的方法要被使用，必须由子类复写起所有的抽象方法之后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。</li></ol><p>抽象类和一般类没有太大的不同。该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。</p><p>抽象类比一般类多了个抽象函数。就是在类中可以定义抽象方法。抽象类不可以实例化。特殊：抽象类中可以不定义抽象方法，这样做仅仅是为了不让该类建立对象。</p><h2 id="6-模板方法设计模式">6.模板方法设计模式</h2><p>在定义功能时，功能的一部分是确定的，但是有一部分功能时不确定的，而确定的部分在使用不确定的部分，就将不确定的部分暴露出去，</p><h2 id="7-接口">7.接口</h2><ul><li><strong>接口</strong>：初期理解，可以认为是一个特殊的抽象类当抽象类中的方法都是抽象的，那么该类可以通过接口的形式实现class 用于定义类interface 用于定义接口接口定义时，格式特点：</li></ul><ol><li>接口中常见定义：常量，抽象方法。</li><li>接口中的成员都有固定的修饰符。常量：public static final方法：public abstract记住，接口中的成员都是public的接口是不可以创建对象的，因为有抽象方法。需要被子类实现，子类对接口中的抽象方法全部覆盖后，子类才可以实例化。否则子类是一个抽象类</li></ol><ul><li><strong>接口可以被类多实现</strong><strong>接口与接口之间可以多继承</strong></li></ul><h2 id="8-接口的特点">8.接口的特点</h2><ol><li>接口是对外暴露的规则</li><li>接口是程序的程序扩展</li><li>接口可以用来多实现</li><li>类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口</li><li>接口与接口之间可以有继承关系</li></ol><h1 id="面向对象-4-多态">面向对象（4）–多态</h1><hr><h2 id="多态概念">多态概念</h2><p>多态：可以理解为事物存在的多种体现形态</p><h2 id="多态的扩展性">多态的扩展性</h2><ol><li>多态的体现父类的引用指向了自己的子类对象父类的引用也可以接收自己的子类对象</li><li>多态的前提必须是类与类之间有关系，要么继承，要么实现。通常还有一个前提：存在覆盖</li><li>多态的好处多态的出现大大的提高程序的扩展性</li><li>多态的弊端：提高了扩展性，但是只能用父类的引用访问父类中的成员</li><li>多态的应用</li></ol><h2 id="多态-转型">多态–转型</h2><p>向上转型，向上转型千万不要出现这样的操作，就是将父类对象转换成子类类型。我们能转换的是父类应用指向了自己的子类对象时，该引用可以被提升，也可以被强制转换。多态自始至终都是子类对象在做着变化</p><h2 id="多态成员的特点">多态成员的特点</h2><p>在多态中成员函数的特点：在编译时期：参阅引用型变量所属的类中是否有调用的方法，如果有，编译通过，如果没有，编译失败。在运行时期：参阅对象所属的类中是否有调用的方法。简单总结就是：成员函数在多态调用时，编译看左边，运行看右边。在多态中，成员变量的特点：无论编译还是运行，都参考左边（引用型变量所属的类）。在多态中，静态成员函数的特点：无论编译还是运行，都参考左边（引用型变量所属的类）。</p><h2 id="多态的实例">多态的实例</h2><h2 id="object类">Object类</h2><h1 id="内部类">内部类</h1><hr><h2 id="内部类访问规则">内部类访问规则</h2><ol><li>内部类可以直接访问外部类中的成员，包括私有之所以可以直接访问外部类中的成员，是因为内部类中持有了 一个外部类的引用，格式：外部类名.this</li><li>外部类要访问内部类，必须建立内部类对象。直接访问内部类中的成员访问格式：当内部类定义在外部类的成员位置上，就可以被成员修饰符所修饰。比如，private：将内部类在外部类中进行封装。static：内部类就具备static的特性。当内部类被static修饰后，只能直接访问外部类中的static成员，出现了访问局限。在外部其他类中，如何访问内部类的非静态成员呢？</li></ol><h2 id="内部类定义的原则">内部类定义的原则</h2><p>当描述事物时，事物的内部还有事物，该事物用内部类来描述。因为内部事物在使用外部事物的内容。</p><p>内部类定义在局部时，</p><ol><li>不可以被成员修饰符修饰</li><li>可以直接访问外部类中的成员，因为还持有外部类中的引用。但是不可以访问它所在的局部中的变量，只能访问被final修饰的局部变量  、</li></ol><h2 id="匿名内部类">匿名内部类</h2><ol><li>匿名内部类其实就是内部类的简写格式</li><li>定义匿名内部类的前提：内部类必须是继承一个类或者实现接口。</li><li>匿名内部类的格式：new 父类或者接口（）{定义子类的内容}</li><li>其实匿名内部类就是一个匿名子类对象，而且这个对象有点胖。可以理解为带内容的对象</li><li>匿名内部类中定义的方法最多不要超过三个</li></ol><h2 id="异常概述">异常概述</h2><p>异常：就是程序在运行时出现不正常的情况。异常的由来：问题也是现实生活中一个具体的事物，也可以通过java的类的形式进行描述。并封装成对象。其实就是java对不正常情况进行描述后的对象体现对于问题的划分：两种：一种是严重的问题，一种是不严重的问题</p><p>对于严重的，java通过Error类进行描述。对于Error，一般不编写针对性的代码进行处理对于非严重的，java通过Exception类进行描述。（可以使用针对性的处理方式进行处理 ）</p><h2 id="异常try-catch">异常try-catch</h2><p>异常的处理：java提供了特有的语句进行处理对捕获到的异常对象进行常见的方法操作。String getMessage</p><h2 id="异常声明throws">异常声明throws</h2><h2 id="多异常处理">多异常处理</h2><p>对多异常的处理。</p><ol><li>声明异常时，建议声明更为具体的异常。这样处理的可以更具体。</li><li>对方声明几个异常，就对应有几个catch块。不要定义多余的catch块如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面建立在进行catch处理时，catch中一定要具体的处理方式。不要简单的定义一句e.peintStackTrace()，也不要简单的就书写一条输出语句。</li></ol><h2 id="自定义异常">自定义异常</h2><p>项目中会出现特有的问题，而这些问题并未被java所描述并封装对象。所以对于这些特有的问题可以按照java对问题封装的思想。将特有的问题。进行自定义的异常封装。当在函数内部出现了throw抛出异常对象，那么就必须要给对应的处理动作。要么在内部try catch处理，要么在函数上声明让调用者处理。发现打印的结果中只有异常的名称，缺没有异常的信息。因为自定义的异常并未定义信息。父类中已经把异常信息的操作都完成了。所以子类只要在构造时，将异常信息传递给父类通过super语句。那么直接就可以通过getMessage方法获取自定义的异常。</p><hr><p>自定义异常：必须是自定义类继承Exception。原因是：异常体系有一个特点：因为异常类和异常对象都被抛出。他们都具备可抛性。这个可抛性是Throwable这个体系中的独有特点。只有这个体系中的类和对象才可以被throw和throws操作。</p><h2 id="throws-和throw的区别：throws使用在函数上-throw使用在函数内">throws 和throw的区别：throws使用在函数上。throw使用在函数内。</h2><p>throws后面跟的异常类，可以跟多个。用逗号隔开。throw后面跟的是异常对象。</p><h2 id="runtimeexception运行时异常">RuntimeException运行时异常。</h2><p>如果在函数内抛出该异常，函数上可以不用声明，编译一样通过。如果在函数上声明了该异常。调用者可以不用进行处理。编译一样通过。之所以不用在函数声明，是因为不需要让调用者处理，当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，对代码尽心修正。自定义异常时，如果该异常的发生，无法再继续进行运算，就让自定义异常继承RuntimeException对于异常分两种：</p><ol><li>编译时被检测的异常。</li><li>编译时不被检测的异常（运行时异常。RuntimeException以及其子类）</li></ol><h1 id="异常">异常</h1><h2 id="异常-finally">异常-finally</h2><h2 id="异常-处理语句其他格式">异常-处理语句其他格式</h2><h2 id="异常-覆盖时的异常特点">异常-覆盖时的异常特点</h2><p>异常在子父类覆盖中的特点：</p><ol><li>子类在覆盖父类时，如果父类的方法抛出异常，子类的覆盖方法，只能抛出父类的异常或该异常的子类。</li><li>如果父类方法抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集。</li><li>如果父类或接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常。如果子类方法发生了异常。那么就必须要进行try处理，绝对不能抛。##　异常练习</li></ol><h2 id="异常-总结">异常–总结</h2><p>是什么：是对问题的描述。将问题进行对象的封装</p><hr><p>异常体系：Throwable     |–Eroor|–Exception|–RuntimeException异常体系的特点：在异常体系中的所有类以及建立的对象都具备可抛性。也就是说可以被throw和throws关键字所操作。只有异常体系具备这个特点。</p><hr><p>throw和throws的用法：throw：定义在函数内，用于抛出异常对象throws：定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开当函数内有throw抛出异常对象，并未进行try处理。必须要在函数上声明，都在编译失败。注意：除了RuntimeException除外，函数内如果声明的是RuntimeException异常，函数上可以不用声明。</p><hr><p>如果函数声明了异常，调用者需要处理。处理方法可以throws可以try异常有两种：</p><ol><li>编译时被检测异常：该异常在编译时，如果没有处理（没有抛出也没try），编译失败。该异常被标识，代表这可以被处理。</li><li>运行时异常（编译时不检测）：在编译时不需要检测，编译器不检查。该异常的发生，建议不处理，让程序停止。需要对代码进行修正。</li></ol><hr><p>注意：finally中定义的通常是：关闭资源代码。因为资源必须释放。finally只有一种情况不被执行。当执行到System.exit(0)；finally不被执行</p><hr><p>自定义异常：定义类继承Exception或者RuntimeException</p><ol><li>为了让该自定义类具备可抛性</li><li>让该类具备异常操作的共性方法</li></ol><hr><p>自定义异常好处：按照java面向对象的思想，将程序中出现的特有问题进行封装。</p><ol><li>将问题进行封装</li><li>将问题和代码进行分离，方便于阅读异常处理的原则：</li><li>处理方式有两种：try或者throws</li><li>调用到抛出异常的功能时，抛出几个，就处理几个</li><li>多个catch，父类的catch放在最下面</li><li>catch内，需要定义针对性的处理方式。不要简单的定义printStackTrace输出语句，也不要不写。当捕捉到的异常，本功能处理不了时，可以继续在catch中抛出。  如果该异常处理不了，但并不属于该功能出现的异常。也可以将异常转换后再抛出和该功能相关的异常。  或者异常可以处理，当需要将异常产生的和本功能相关的问题提供出去，让调用者知道，并处理。也可以捕获异常处理后，转换新的异常。</li><li></li></ol><hr><p>异常的注意事项：在子类覆盖时：</p><ol><li>子类抛出的异常必须是父类异常的子类或者子集</li><li>如果父类或者接口没有异常抛出时，子类覆盖出现异常，只能try不能抛</li></ol><h1 id="多线程">多线程</h1><hr><p>进程：是一个正在执行中的程序。每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制单元。线程：就是进程中的一个独立的控制单元。  线程在控制着进程的执行。一个进程中至少有一个线程。java VM启动的时候会有一个进程jav.exe。该进程中至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main方法中。该线程称之为主线程。扩展：其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。</p><hr><h1 id="创建线程">创建线程</h1><ol><li>如何在自定义的代码中，自定义一个线程？通过对API的查找，java已经提供了对线程这类事物的描述，就Thread类。创建线程的第一种方式：继承Thread类。步骤：定义类继承Thread；复写Thread类中的run方法；调用线程的start方法。发现运行结果每次都不同。因为多个线程都获取cpu的执行权，CPU执行到谁，谁就运行。（多核除外），cpu在做着快速的切换，以达到看上去是同时运行的效果</li></ol><hr><h1 id="创建线程-run和start的特点">创建线程-run和start的特点</h1><p>为什么要覆盖run方法？Thread类用于描述线程。该类定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法。也就是说Thread类中的run方法，用于存储线程要运行的代码。</p><h1 id="线程运行状态">线程运行状态</h1><p>原来线程都有自己默认的名称。Thread-编号，该编号从0开始。static Thread currentThread()：获取当前线程对象。getName()：获取线程名称设置线程名称：setName或者构造函数。</p><hr><h1 id="创建线程-runable接口">创建线程-runable接口</h1><p>创建线程的第二种方式：实现Runable接口步骤：</p><ol><li>定义类实现Runable接口</li><li>覆盖Runable接口中的run方法。  （将线程要运行的代码存放到该run方法中）</li><li>通过Thread类建立线程对象。</li><li>将Runable接口的子类对象作为实际参数传递给Thread类的构造函数。（自定义的run方法所属的对象时Runable接口的子类对象。所以要让线程去指定对象的run方法，就必须明确该run方法所属的对象）</li><li>调用Thread类的start方法开启线程并调用Runable接口子类的run方法。</li></ol><hr><p>实现方式和继承方式有什么区别呢？实现方式：避免了单继承的局限性。在定义线程时，建议使用实现方式。两种方式的区别：继承Thread：线程代码存放在Thread子类的run方法中。实现Runable：线程 代码存在接口的子类的run方法中。</p><hr><h1 id="多线程的安全问题">多线程的安全问题</h1><p>多线程运行出现安全问题的原因：当多条语句在操作同一个线程共享数据时，一个线程对多条语句值执行了一部分，还没有执行完，另一个线程参与执行。导致共享数据的错误。解决办法：对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中，其他线程不可以参与执行。java对于多线程的安全问题提供了专业的解决方式。同步代码块。synchronized（对象）{需要被同步的代码}对象如同锁。持有锁的线程可以在同步中执行。没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有获取锁。同步的前提：</p><ol><li>必须要有两个或两个以上的线程。</li><li>必须是多个线程使用同一个锁3必须保证同步中只能有一个线程在运行。好处：解决了多线程的安全问题。弊端：多个线程需要判断锁，较为消耗资源。</li></ol><hr><h1 id="多线程-同步函数">多线程-同步函数</h1><p><strong>同步函数的锁用的是this。静态同步函数的锁是Class对象</strong></p><hr><h1 id="多线程-死锁">多线程-死锁</h1><p>#多进程（二）</p><hr><h2 id="1线程间通信">1线程间通信</h2><p>线程间通讯：其实就是多个线程在操作同一个资源，但是操作的动作不同。</p><p>##2解决安全问题</p><h2 id="3等待唤醒机制">3等待唤醒机制</h2><p>wait  notify notifyAll 都使用在同步中，因为要对持有监视器（锁）的线程操作。所以要使用在同步中，以为只有同步才具有锁。为什么这些操作线程的方法要定义在Object类中呢？因为这些方法在操作同步中线程时，都必须要标识他们所操作线程只有的锁。只有同一个锁上的等待线程，可以被同一个锁上的notify唤醒。不可以对不同锁中的线程进行唤醒。也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法定义在Object类中。</p><h1 id="stringbuffer">StringBuffer</h1><hr><h2 id="stringbuffer-是字符串缓冲区-是一个容器">StringBuffer 是字符串缓冲区。是一个容器，</h2><ol><li>而且长度是可变化的。</li><li>可以操作多个数据类型。</li><li>最终会通过toString方法变成字符串C（create）U（update）R（read）D（delete）1.存储StringBuffer append（）：将指定的数据作为参数添加到到已有数据的结尾处StringBuffer insert（index，数据）：可以将数据 插入到数据指定index位置2.删除String3.获取4.修改</li></ol><h2 id="stringbuilder">StringBuilder</h2><p>java升级的三个因素：1.提高效率2.简化书写3.安全性</p><h2 id="基本数据类型对象包装类">基本数据类型对象包装类</h2><p>byte   Byteshort  shortint Integerlong  Longboolean Booleanfloat Floatdouble  Doublechar  Character基本数据类型对象包装类的最常见作用：就是用于基本数据类型和字符串类型之间做转换。基本数据类型转成字符串。  基本数据类型+“”或者 基本数据类型.toString(基本数据类型值)字符串转基本类型。基本数据类型包装类 a=Xxx.parseXxx(String)</p><h1 id="集合类">集合类</h1><hr><h2 id="集合框架-体系概述">集合框架（体系概述）</h2><p>为什么出现集合类？数组是固定长度的，集合是可变长度的。为什么出现这么多的容器？因为每一个容器对数据的存储方式都有不同。这个存储方式称之为：数据结构。##集合框架（共性方法）</p><h2 id="迭代器">迭代器</h2><p>什么是迭代器？其实就是集合中元素的取出方式。把取出方式定义在集合的内部，这样取出方式就可以直接访问集合内容的元素。那么取出方式就被定义成了内部类。而每一个容器的结构数据不同，所以取出的动作细节也不一样。但是都有共性内容：判断和取出。那么可以将这些共性抽取。</p><h2 id="list">List</h2><h3 id="list集合共性方法">List集合共性方法</h3><p>List：元素是有序的，元素可以重复，因为该集合体系有索引。Set：元素是无序的，不能重复。List：特有方法：凡是可以操作角标的方法都是该体系特有的方法。增：add addAll删： remove改：set查：get subList listIterator</p><h3 id="listiterator">ListIterator</h3><p>在迭代器时，只能用迭代器的方法操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。该接口只能通过List集合的ListIterator方法获取。</p><h3 id="list集合具体对象的特点">List集合具体对象的特点</h3><p>List：ArrayList：底层的数据结构使用的是数组，查找很快，但是增删稍慢 （可变长度的）Linkedlist：底层使用的是链表数据结构。特点是增删速度很快，查询稍慢Vector：底层是数组数据结构。线程同步，被ArrayList替代了 ，现在一般不用了。枚举是Vector特有的取出方式。发现枚举和迭代器很像。其实枚举和迭代是一样的。因为枚举的名称以及方法的名称都过长。所以被迭代器取代了。</p><h3 id="linkedlist">LinkedList</h3><p>LinkedList特有方法：addFirst(),addLast(),getFirst(),getLast(),removeFirst(),removeLast()JDK1.6出现了替代方法。offerFriest  peekFirst poolFirst堆栈：先进后出队列： 先进先出 FIFOList集合判断元素是否相同，依据的是元素的equals方法。##setset：元素是无序（存入和取出的顺序不一定一致）set集合的功能和collection是一致的。HashSet：底层数据结构是哈希表。HashSet是如何保证元素的唯一性的呢？是通过元素的两个方法。hashCode和equals来完成。如果元素的HashCode值相同，才会判断equals是否为true，如果元素的hashCode不同，不会判断equals。注意：对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashcode和equals方法。</p><h1 id="集合框架2">集合框架2</h1><hr><p>##setset：无序，不可以重复元素。hashset：数据结构是哈希表，线程非同步的，保证元素唯一性的原理，判断元素的hashCode值是否相同。如果相同，判断equalsTreeSet：可以对set集合中的元素进行排序。底层数据结构是二叉树。保证元素唯一性的依据：compareTo return 0往TreeSet集合中存储自定义对象学生。想按照学生的年龄进行排序。记住：排序时，当主要条件相同时，一定判断一下次要条件。</p><h2 id="二叉树">二叉树</h2><p>TreeSet排序的第一种方式：让元素自身具备比较性。元素需要事项compareable接口，覆盖compareTo方法。这种方式也称为元素的自然顺序，或者叫做默认顺序。TreeSet排序的第二种方式：当元素自身不具备比较性时，或者具备的比较性不是锁需要的。这时就需要让集合自身具备比较性。在集合初始化时，就有了比较方式。当元素自身不具备比较性，或者具备的比较性不是所需要的。这时需要让容器自身具备比较性，定义了比较器，将比较器对象作为参数传递给TreeSet集合的构造函数。当两种排序都存在时，以比较器为主。定义一个类实现Comparator接口，覆盖compare方法。</p><h2 id="泛型">泛型</h2><p>JDK1.5之后出现的新特性，用于解决安全问题，是一个安全机制。好处：</p><ol><li>将运行时期出现问题转移到编译时期，便于程序员解决。</li><li>避免了强制转换的麻烦。泛型格式：通过&lt;&gt;来定义要操作的引用数据类型在使用java提供的对象时，什么时候写泛型？通常在集合框架中很常见，只要见到&lt;&gt;就要定义泛型。其实&lt;&gt;就是用来接收类型的。当使用集合时，将集合中的要存储的数据类型放到&lt;&gt;中即可。</li></ol><h2 id="泛型类">泛型类</h2><p>泛型类：带泛型的类。当类中要操作的引用数据类型不确定的时候，早期定义Object来完成扩展，现在定义泛型完成扩展。</p><h2 id="泛型方法">泛型方法</h2><p>泛型类定义的泛型，在整个类中有效，如果被方法使用，那么泛型类的对象没明确要操作的具体类型后，所有要操作的类型就已经固定了。为了让不同方法可以操作不同类型，而且类型还不确定，那么可以将泛型定义到方法上。</p><h2 id="静态方法泛型">静态方法泛型</h2><p>特殊之处是：静态方法不可以访问类上定义的泛型，如果静态方法操作的引用数据类型不确定，可以将泛型定义在方法上。</p><h2 id="泛型接口">泛型接口</h2><h2 id="泛型限定">泛型限定</h2><p>？： 通配符，也可以理解为占位符。泛型的限定： ？ extends E：可以接收E类型或者E的子类型。上限     ？ super E：可以接收E类型或者E的父类型。下限</p><h1 id="集合-map">集合(MAP)</h1><h2 id="map集合：该集合存储键值对-一对一对往里存-而且要保证键的唯一性">Map集合：该集合存储键值对。一对一对往里存。而且要保证键的唯一性。</h2><ol><li>添加。</li><li>删除。clear()</li><li>判断。</li><li>获取。Map：Hashtable：底层是哈希表数据结构，不能存入null键null值，是线程同步的。HashMap:底层是哈希表数据结构，允许使用null键null值，该集合是不同步的。TreeMap：底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。–和Set很像，其实Set底层就是使用了Map集合。</li></ol><h2 id="map子类对象的特点">Map子类对象的特点</h2><h2 id="map共性方法">Map共性方法</h2><h2 id="map-keyset">Map-keySet</h2><p>map集合的两种取出方式：</p><ol><li>keySet：将map中所有的键存入到set集合。因为set具备迭代器。所有可以迭代方式取出所有的键，在根据get方法。获取每一个键对应的值。</li><li>entrySetSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet:将Map集合中的映射关系存入了set集合中，而这个关系的数据类型就是：Map.entry。其实Entry也是一个借口，它是Map接口中的一个内部接口。</li></ol><h2 id="map练习">Map练习</h2><p>当发现有映射关系时，可以选择map集合。因为map集合中存放的就是映射关系。什么时候使用map集合？当数据之间存在映射关系时，就要先想map集合##map扩展知识map集合被使用是因为具备映射关系。</p><h1 id="集合-工具类">集合（工具类）</h1><hr><h2 id="sort">sort</h2><h2 id="max">max</h2><h2 id="binaryserch">binarySerch</h2><h2 id="替换反转">替换反转</h2><h2 id="reserveorder">reserveOrder</h2><h2 id="synlist">Synlist</h2><h2 id="arrays">Arrays</h2><p>用于操作数组的工具类，里面都是静态方法。</p><h2 id="集合变数组">集合变数组</h2><p>1.指定类型的数组到底要定义多长呢？当指定类型的数组长度小于集合的size，那么该方法会创建一个新的数组，长度为集合的size。当指定类型的数组长度小于了集合的size，就不会创建新数组，而是使用传递进来的数组，所以创建一个刚刚好的数组最优。2.为什么要将集合变数组？为了限定对元素的操作。##增强for循环##可变参数方法的可变参数注意：可变参数一定要定义在参数列表的最后面。##静态导入当类名方法重名时，需要指定具体的包名。当方法重名时，指定具备所属的对象或者类</p><p>#其他对象</p><hr><h2 id="system">System</h2><p>可不可以在jvm启动时，动态加载一些属性信息。##Runtime对象该类并没有提供构造函数。说明不可以new 对象，那么会直接想到该类中的方法都是静态的，发现该类中海油非静态方法。说明该类肯定会提供了方法获取本类对象，而且该方法是静态的，并返回值类型是本类类型。由这个特点可以看出该类使用了单例设计模式执行。##Date</p><h2 id="math">Math</h2><p>#IO流</p><hr><h2 id="bufferedwriter">BufferedWriter</h2><p>缓冲区的出现是为了提高流的操作效率而出现的。所以在创建缓冲区之前，必须要先有流对象。为了 提高字符写入流效率，加入了缓冲技术,只要将需要提高效率的流对象作为参数传递给缓冲区的构造函数即可。记住只要用到缓冲区，就要记得刷新。其实关闭缓冲区，其实就是在关闭缓冲区的流对象。该缓冲区中提供了一个跨平台的newLine（）</p><h2 id="bufferedreader">BufferedReader</h2><p>为了提高效率，加入缓冲技术。将字符读取流对象作为参数传进缓冲对象的构造函数。readLine方法返回的时候只返回回车符之前的数据内容，并不返回回车符。readLine方法的原理：无论是读取一行，还是读取多个字符，其实最终都是在硬盘上一个个读取。所以最终使用的还是read方法一次读一个的方法。</p><h2 id="mybufferedreader">MyBufferedReader</h2><h2 id="装饰设计模式">装饰设计模式</h2><p>定义：当想要对已有的对象进行功能增强时，可以定义一个类，将已有对象传入，基于已有的功能，并提供加强功能。那么自定义的该类称为装饰类。装饰类通常会通过构造方法接收被装饰的对象。并基于被装饰的对象的功能，提供更强的功能。</p><h2 id="装饰和继承的区别">装饰和继承的区别</h2><p>装饰模式比继承要灵活，避免了继承体系臃肿。而且降低了类与类之间的关系。装饰类因为增强已有对象，具备的功能和已有的是相同的，只不过提供了更强的功能。所以装饰类和被装饰类通常都属于一个体系中的。</p><h2 id="linenumberreader">LineNumberReader</h2><h2 id="字符流和字节流">字符流和字节流</h2><p>FileReader:FileWriter:字节流：InputStream：OutputStream:</p><h2 id="复制一个图片">复制一个图片</h2><p>思路：1.用字节读取流对象和图片关联。2.用字节写入流对象创建一个图片文件，用于存储获取到的图片数据。</p><ol start="3"><li>通过循环读写，完成数据的存储。</li><li>关闭资源</li></ol><h2 id="读取转换流">读取转换流</h2><h2 id="写入转换流">写入转换流</h2><h2 id="流操作的基本规律">流操作的基本规律</h2><p>最痛苦的就是流对象有很多，不知道该用哪一个。通过两个明确来完成。1.明确源和目的。源：输入流。InputStream   Reader目的：输出流。OutputStream Writer2.操作的数据是否是纯文本。是：字符流。否：字节流。3.当体系明确后，再明确要使用哪个具体的对象。通过设备来进行区分：源设备：内存，硬盘，键盘目的设备：内存，硬盘，控制台。</p><h2 id="file类">File类</h2><p>用来将文件或文件夹封装成对象。方便对文件与文件夹的属性信息进行操作。File对象可以作为参数传递给</p><h2 id="file类的常见方法">File类的常见方法</h2><p>1.创建boolean createNewFile()boolean mkdir()boolean mkdirs()</p><p>2.删除boolean delete()  删除失败返回falsevoid deleteOnExit()  在程序退出时删除文件</p><p>3.判断boolean exists() 文件或目录是否存在。记住在判断文件对象是否是文件或者目录时，必须要先判断该文件对象封装的内容是否存在，通过exists判断。boolean isFile()boolean isDirectory()</p><p>4.获取信息。String getName()String getParent()  该方法返回的是绝对路径中的父目录，如果获取的是相对路径，则返回null。String getPath()File getAbsoluteFile()long lastModified()long length()</p><h2 id="文件列表">文件列表</h2><p>static File[] listRoots()String[] list() 调用list方法的必须是封装的一个目录。该目录还必须存在。</p><h2 id="列出目录下所有的内容">列出目录下所有的内容</h2><p>递归递归要注意：1.限定条件。2.要注意递归的次数，尽量避免内存溢出。</p><h2 id="删除一个带内容的目录">删除一个带内容的目录</h2><p>删除原理：在Windows中，删除目录从里面往外删除的。既然是从里往外删除，就需要用到递归。</p><h2 id="创建java文件列表">创建java文件列表</h2><h2 id="properties">properties</h2><p>properties是hashtables的子类，也就是说它具备map集合的特点。而且它里面存储的键值对都是字符串。是集合中和IO技术相结合的集合容器。该对象的特点：可以用于键值对形式的配置文件。##IO包中的其他类打印流：该流提供了打印方法，可以将各种数据类型的数据都原样打印。字节打印流PrintStream构造函数可以接收的参数类型。</p><ol><li>file对象。File</li><li>字符串路径</li><li>字节输出流字符打印流PrintWrite</li><li>file对象。File</li><li>字符串路径</li><li>字节输出流</li></ol><h2 id="合并流和切割文件">合并流和切割文件</h2><h2 id="对象的序列化">对象的序列化</h2><h2 id="管道流">管道流</h2><h2 id="randomaccessfile">RandomAccessFile</h2><p>该类不是算是IO体系中子类，而是继承自Object。但是它是IO包中的成员，因为它具备读和写功能。颞部封装了一个数组，而且通过指针对数组的元素进行操作。可以通过getFilePointer获取指针位置。同时可以通过seek改变指针位置。其实完成读写的原理就是内部封装了字节输入流和输出流。通过构造函数可以看出，该类只能操作文件。而且操作文件还有模式。该对象的构造函数要操作的文件不存在，会自动创建。如果存在不会覆盖。</p><h2 id="bytearraystream">ByteArrayStream</h2><hr><h1 id="gui-图形用户界面">GUI(图形用户界面)</h1><hr><h2 id="gui">GUI</h2><h3 id="awt与-swing">Awt与 Swing</h3><p>java.Awt： Abstract Window ToolKit (抽象窗口工具包)，需要调用本地系统方法实现功能。属重量级控件。javax.Swing：在AWT的基础上，建立的一套图形界面系统，其中提供了更多的组件，而且完全由Java实现。增强了移植性，属轻量级控件。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
