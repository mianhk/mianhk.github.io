<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="剑指offer-刷题总结"/><meta name="keywords" content="C++, LeetCode, 剑指offer, mianhk" /><link rel="alternate" href="/atom.xml" title="mianhk"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://www.yuguocong.cn/2018/06/20/Exercise/re_sword_to_offer/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>剑指offer-刷题总结 - mianhk</title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">mianhk</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">mianhk</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">剑指offer-刷题总结
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-20
        </span><span class="post-category">
            <a href="/categories/%E5%88%B7%E9%A2%98/">刷题</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-二维数组中的查找"><span class="toc-text">01.二维数组中的查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-替换空格"><span class="toc-text">02.替换空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-从尾到头打印链表"><span class="toc-text">03.从尾到头打印链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-重建二叉树"><span class="toc-text">04.重建二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-用两个栈实现队列"><span class="toc-text">05.用两个栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-旋转数组的最小数字"><span class="toc-text">06.旋转数组的最小数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-斐波那契数列"><span class="toc-text">07.斐波那契数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-跳台阶"><span class="toc-text">08.跳台阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-变态跳台阶"><span class="toc-text">09.变态跳台阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-矩形覆盖-todo"><span class="toc-text">10.矩形覆盖 &#x2F;TODO:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-二进制中1的个数"><span class="toc-text">11.二进制中1的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-数值的整数次方"><span class="toc-text">12.数值的整数次方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-调整数组顺序使奇数位于偶数前面"><span class="toc-text">13.调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-链表中倒数第k个结点"><span class="toc-text">14.链表中倒数第k个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-反转链表"><span class="toc-text">15.反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-合并两个排序的链表"><span class="toc-text">16.合并两个排序的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-树的子结构"><span class="toc-text">17.树的子结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-二叉树的镜像"><span class="toc-text">18.二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-顺时针打印矩阵"><span class="toc-text">19.顺时针打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-包含min函数的栈"><span class="toc-text">20.包含min函数的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-栈的压入-弹出序列"><span class="toc-text">21.栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-从上往下打印二叉树"><span class="toc-text">22.从上往下打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-二叉搜索树的后序遍历序列"><span class="toc-text">23.二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-二叉树中和为某一值的路径"><span class="toc-text">24.二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-复杂链表的复制"><span class="toc-text">25.复杂链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-二叉搜索树与双向链表"><span class="toc-text">26.二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-字符串的排列"><span class="toc-text">27.字符串的排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-数组中出现次数超过一半的数字"><span class="toc-text">28.数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-最小的k个数"><span class="toc-text">29.最小的K个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-连续子数组的最大和"><span class="toc-text">30.连续子数组的最大和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-整数中1出现的次数-从1到n整数中1出现的次数"><span class="toc-text">31.整数中1出现的次数（从1到n整数中1出现的次数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-把数组排成最小的数"><span class="toc-text">32.把数组排成最小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-丑数"><span class="toc-text">33.丑数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-第一个只出现一次的字符位置"><span class="toc-text">34.第一个只出现一次的字符位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-数组中的逆序对"><span class="toc-text">35.数组中的逆序对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-两个链表的第一个公共结点"><span class="toc-text">36.两个链表的第一个公共结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-数字在排序数组中出现的次数"><span class="toc-text">37.数字在排序数组中出现的次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-二叉树的深度"><span class="toc-text">38.二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-平衡二叉树"><span class="toc-text">39.平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-数组中只出现一次的数字"><span class="toc-text">40.数组中只出现一次的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-和为s的连续正数序列"><span class="toc-text">41.和为S的连续正数序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-和为s的两个数字"><span class="toc-text">42.和为S的两个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-左旋转字符串"><span class="toc-text">43.左旋转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-翻转单词顺序列"><span class="toc-text">44.翻转单词顺序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-扑克牌顺子"><span class="toc-text">45.扑克牌顺子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-孩子们的游戏-圆圈中最后剩下的数"><span class="toc-text">46.孩子们的游戏(圆圈中最后剩下的数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-求1-2-3-n"><span class="toc-text">47.求1+2+3+…+n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-不用加减乘除做加法"><span class="toc-text">48.不用加减乘除做加法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-把字符串转换成整数"><span class="toc-text">49.把字符串转换成整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-数组中重复的数字"><span class="toc-text">50.数组中重复的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-构建乘积数组"><span class="toc-text">51.构建乘积数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-正则表达式匹配"><span class="toc-text">52.正则表达式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-表示数值的字符串"><span class="toc-text">53.表示数值的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-字符流中第一个不重复的字符"><span class="toc-text">54.字符流中第一个不重复的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-链表中环的入口结点"><span class="toc-text">55.链表中环的入口结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-删除链表中重复的结点"><span class="toc-text">56.删除链表中重复的结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-二叉树的下一个结点"><span class="toc-text">57.二叉树的下一个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-对称的二叉树"><span class="toc-text">58.对称的二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-按之字形顺序打印二叉树"><span class="toc-text">59.按之字形顺序打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-把二叉树打印成多行"><span class="toc-text">60.把二叉树打印成多行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-序列化二叉树"><span class="toc-text">61.序列化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-二叉搜索树的第k个结点"><span class="toc-text">62.二叉搜索树的第k个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-数据流中的中位数"><span class="toc-text">63.数据流中的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-滑动窗口的最大值"><span class="toc-text">64.滑动窗口的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-矩阵中的路径"><span class="toc-text">65.矩阵中的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-机器人的运动范围"><span class="toc-text">66.机器人的运动范围</span></a></li></ol>
    </div>
  </div><div class="post-content"><h2 id="01-二维数组中的查找">01.二维数组中的查找</h2>
<blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p>分析：由于每一行都有递增的特性，我们可以采用类似二分搜索的方法。将数组分成行列来进行搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        if(0&#x3D;&#x3D;array.size())</span><br><span class="line">            return false;</span><br><span class="line">        int raw&#x3D;array.size();</span><br><span class="line">        int col&#x3D;array[0].size();</span><br><span class="line">        for(int i&#x3D;0;i&lt;raw;++i)&#123;</span><br><span class="line">            if(array[i][col-1]&gt;&#x3D;target)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;col;++j)&#123;</span><br><span class="line">                    if(array[i][j]&#x3D;&#x3D;target)</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="02-替换空格">02.替换空格</h2>
<blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>考虑到是在原字符串上操作，如果遇到一个空格就替换的话，需要把后面的都要后移两位，这个复杂度就大了，所以可以先遍历第一遍，找到空格的总数，之后就可以计算替换后的字符串长度。再经过第二遍遍历，从后往前开始替换，这样就不用移动了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	void replaceSpace(char *str,int length) &#123;</span><br><span class="line">         if(length&lt;&#x3D;0)</span><br><span class="line">             return;</span><br><span class="line">        int origin_length&#x3D;0,new_length&#x3D;0,space_num&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;str[i]!&#x3D;&#39;\0&#39;;++i)&#123;</span><br><span class="line">            origin_length++;</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">                space_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        new_length&#x3D;origin_length+2*space_num;</span><br><span class="line">        if(new_length&gt;length)</span><br><span class="line">            return;</span><br><span class="line">        str[new_length]&#x3D;&#39;\0&#39;;</span><br><span class="line">        while(origin_length&gt;0)&#123;</span><br><span class="line">            --origin_length;</span><br><span class="line">            if(str[origin_length]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                str[--new_length]&#x3D;&#39;0&#39;;</span><br><span class="line">                str[--new_length]&#x3D;&#39;2&#39;;</span><br><span class="line">                str[--new_length]&#x3D;&#39;%&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                str[--new_length]&#x3D;str[origin_length];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="03-从尾到头打印链表">03.从尾到头打印链表</h2>
<blockquote>
<p>输入一个链表，从尾到头打印链表每个节点的值。</p>
</blockquote>
<p>分析：由于链表我们必须从头到尾遍历才能从链表尾开始，所以直接打印的话，需要先从前往后遍历一遍找到链表尾节点，再从后往前遍历打印。能够进行的改善是，通过增加O(N)的空间复杂度，第一次遍历的时候，将数据放在一个栈中，之后再从栈中把所有的数都弹出来就好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(!head)</span><br><span class="line">            return res;</span><br><span class="line">        stack&lt;int&gt; istack;</span><br><span class="line">        while(head)&#123;</span><br><span class="line">            istack.push(head-&gt;val);</span><br><span class="line">            head&#x3D;head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!istack.empty())&#123;</span><br><span class="line">            res.push_back(istack.top());</span><br><span class="line">            istack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="04-重建二叉树">04.重建二叉树</h2>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<p>分析：首先需要知道的是前序遍历和后续遍历的特点，程序中可以维护4个子数组，当进行递归调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.empty() || pre.size()!&#x3D;vin.size())</span><br><span class="line">            return nullptr;</span><br><span class="line">        vector&lt;int&gt; pre1,pre2,vin1,vin2;</span><br><span class="line">        TreeNode* root&#x3D;new TreeNode(pre[0]);</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(;i&lt;vin.size();++i)&#123;</span><br><span class="line">            if(pre[0]&#x3D;&#x3D;vin[i])</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;不需要判断i &#x3D;&#x3D;0 或者i&#x3D;&#x3D;vin.size()-1的情况</span><br><span class="line">        for(int j&#x3D;0;j&lt;i;++j)&#123;</span><br><span class="line">            pre1.push_back(pre[1+j]);</span><br><span class="line">            vin1.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;pre.size();++j)&#123;</span><br><span class="line">            pre2.push_back(pre[j]);</span><br><span class="line">            vin2.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left&#x3D;reConstructBinaryTree(pre1,vin1);</span><br><span class="line">        root-&gt;right&#x3D;reConstructBinaryTree(pre2,vin2);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过上述的方法有个问题，虽然看起来比较好理解，但是增加了空间复杂度，其实这里可以多加一个递归函数就好了，所以觉得还是需要重新写一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* recurse(vector&lt;int&gt;&amp; pre,int begin1,int end1,vector&lt;int &gt;&amp; vin,int begin2,int end2)&#123;</span><br><span class="line">        if(begin1&gt;end1 || begin2&gt;end2)  &#x2F;&#x2F;退出条件</span><br><span class="line">            return nullptr;</span><br><span class="line">        TreeNode* root&#x3D;new TreeNode(pre[begin1]);</span><br><span class="line">        for(int i&#x3D;begin2;i&lt;&#x3D;end2;++i)&#123;</span><br><span class="line">            if(pre[begin1]&#x3D;&#x3D;vin[i])&#123;</span><br><span class="line">                root-&gt;left&#x3D;recurse(pre,begin1+1,begin1+i-begin2,vin,begin2,i-1);  &#x2F;&#x2F;递归的重点，这个要考虑清楚</span><br><span class="line">                root-&gt;right&#x3D;recurse(pre,begin1+1+i-begin2,end1,vin,1+i,end2);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.empty() || pre.size()!&#x3D;vin.size())</span><br><span class="line">            return nullptr;</span><br><span class="line">        return recurse(pre,0,pre.size()-1,vin,0,vin.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="05-用两个栈实现队列">05.用两个栈实现队列</h2>
<blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<p>分析：由于栈是先进后出，队列是先进先出，于是可以想到，两个栈，必然能够实现一个队列。原理就是，当push的时候就往第一个栈push，pop的时候就从第二个栈pop，当第二个栈的数为空时，从第一个栈pop再push到第二个栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int top&#x3D;stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        return top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="06-旋转数组的最小数字">06.旋转数组的最小数字</h2>
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<p>分析：对于排序的数组，即使被旋转过，也能想到的是，采用二分查找。不过可能会存在的问题的是：当整个数组的值都是<code>1 0 0 1 1</code>之类的时候，就会失效了，只是非递减，但是不一定递增。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(0&#x3D;&#x3D;rotateArray.size())&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int begin&#x3D;0,end&#x3D;rotateArray.size()-1;</span><br><span class="line">        while(begin&lt;end-1)&#123;</span><br><span class="line">            int mid&#x3D;begin+(end-begin)&#x2F;2;</span><br><span class="line">            if(rotateArray[begin]&lt;rotateArray[mid])</span><br><span class="line">                begin&#x3D;mid;</span><br><span class="line">            else if(rotateArray[begin]&gt;rotateArray[mid])</span><br><span class="line">                end&#x3D;mid;</span><br><span class="line">            else&#123;</span><br><span class="line">                int res&#x3D;begin;</span><br><span class="line">                for(size_t i&#x3D;1;i&lt;rotateArray.size();++i)&#123;</span><br><span class="line">                    res&#x3D;(res&lt;rotateArray[i]?res:rotateArray[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="07-斐波那契数列">07.斐波那契数列</h2>
<blockquote>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p>
</blockquote>
<p>分析：斐波拉契数列原理很简单，不过按照原理写的显然复杂度过高了，这里我们可以采用变量存下之前计算过的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)</span><br><span class="line">            return 1;</span><br><span class="line">        int first&#x3D;1,second&#x3D;1,res&#x3D;0;</span><br><span class="line">        while(--n&gt;1)&#123;</span><br><span class="line">            res&#x3D;first+second;</span><br><span class="line">            first&#x3D;second;</span><br><span class="line">            second&#x3D;res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="08-跳台阶">08.跳台阶</h2>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>分析：原理同斐波拉契数列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number&lt;&#x3D;2)</span><br><span class="line">            return number;</span><br><span class="line">        int first&#x3D;1,second&#x3D;2,res&#x3D;0;</span><br><span class="line">        while(--number&gt;1)&#123;</span><br><span class="line">            res&#x3D;first+second;</span><br><span class="line">            first&#x3D;second;</span><br><span class="line">            second&#x3D;res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="09-变态跳台阶">09.变态跳台阶</h2>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f(n)&#x3D;f(1)+f(2)+...+f(n-1)</span><br><span class="line">f(n+1)&#x3D;f(1)+f(2)+...+f(n-1)+f(n)&#x3D;2f(n)</span><br><span class="line">&#x2F;&#x2F;代码如下：</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        if(number&lt;&#x3D;2)</span><br><span class="line">            return number;</span><br><span class="line">        int res&#x3D;2;</span><br><span class="line">        while(--number&gt;&#x3D;2)&#123;</span><br><span class="line">            res*&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="10-矩形覆盖-todo">10.矩形覆盖 /TODO:</h2>
<h2 id="11-二进制中1的个数">11.二进制中1的个数</h2>
<blockquote>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p>分析：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int count&#x3D;0;</span><br><span class="line">         while(n)&#123;</span><br><span class="line">             count++;</span><br><span class="line">             n&#x3D;n&amp;(n-1);</span><br><span class="line">         &#125;</span><br><span class="line">         return count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="12-数值的整数次方">12.数值的整数次方</h2>
<blockquote>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
</blockquote>
<p>分析：求一个数的次方，一个就是幂数是负数的处理，另一个就是，对幂的处理，连乘必然带来复杂度，可以想到的是2<sup>4可以表示为(2</sup>2)^2，想到这里，考虑的开水奇偶exponent的奇偶性了，奇数的时候直接乘以base，偶数的时候自乘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        bool flag&#x3D;true;</span><br><span class="line">        if(exponent&lt;0)&#123;</span><br><span class="line">            flag&#x3D;false;</span><br><span class="line">            exponent*&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        double res&#x3D;1;</span><br><span class="line">        while(exponent)&#123;</span><br><span class="line">            if(exponent&amp;1)&#123;</span><br><span class="line">                res*&#x3D;base;</span><br><span class="line">                exponent--;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                exponent&#x3D;exponent&#x2F;2;</span><br><span class="line">                res*&#x3D;res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag?res:(1&#x2F;res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="13-调整数组顺序使奇数位于偶数前面">13.调整数组顺序使奇数位于偶数前面</h2>
<blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">		if(array.empty())</span><br><span class="line">			return;</span><br><span class="line">		int begin&#x3D;0,end&#x3D;array.size();</span><br><span class="line">		int even&#x3D;-1;</span><br><span class="line">		</span><br><span class="line">		while(begin&lt;end)&#123;</span><br><span class="line">			while((array[begin]&amp;1) &amp;&amp; (begin&lt;end))&#123;</span><br><span class="line">				begin++;</span><br><span class="line">			&#125;</span><br><span class="line">			even&#x3D;begin;</span><br><span class="line">			while((!(array[begin]&amp;1)))&#123;</span><br><span class="line">				begin++;</span><br><span class="line">			&#125;</span><br><span class="line">			if(begin&gt;&#x3D;end)</span><br><span class="line">				return;</span><br><span class="line">			int temp&#x3D;array[begin];</span><br><span class="line">			while(even&lt;begin)&#123;</span><br><span class="line">				array[begin]&#x3D;array[begin-1];</span><br><span class="line">				begin--;</span><br><span class="line">			&#125;</span><br><span class="line">			array[even]&#x3D;temp;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="14-链表中倒数第k个结点">14.链表中倒数第k个结点</h2>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>分析：采用两个指针一起移动是一个很好的办法，不过需要考虑是否越界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        ListNode* p1&#x3D;pListHead;</span><br><span class="line">        for(int i&#x3D;0;i&lt;k;++i)&#123;</span><br><span class="line">            if(!p1)</span><br><span class="line">               return nullptr;</span><br><span class="line">            p1&#x3D;p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p1)&#123;</span><br><span class="line">            p1&#x3D;p1-&gt;next;</span><br><span class="line">            pListHead&#x3D;pListHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="15-反转链表">15.反转链表</h2>
<blockquote>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
</blockquote>
<p>分析：注意断开链表重连的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">&#x2F;&#x2F;最开始的一版代码，采用的是栈，看起来比较复杂。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        if((!pHead)||(!pHead-&gt;next))</span><br><span class="line">            return pHead;</span><br><span class="line">        stack&lt;ListNode*&gt; list_stack;</span><br><span class="line">        while(pHead-&gt;next)&#123;</span><br><span class="line">            list_stack.push(pHead);</span><br><span class="line">            pHead&#x3D;pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead&#x3D;pHead;</span><br><span class="line">        while(!list_stack.empty())&#123;</span><br><span class="line">            pHead-&gt;next&#x3D;list_stack.top();</span><br><span class="line">            pHead&#x3D;pHead-&gt;next;</span><br><span class="line">            list_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        pHead-&gt;next&#x3D;nullptr;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;采用在链表中的穿针引线。涉及到链表的断开与重连，维护三个指针，分别为：pre,cur,next</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        ListNode* pre&#x3D;nullptr;</span><br><span class="line">        ListNode* cur&#x3D;pHead;</span><br><span class="line">        while(cur)&#123;</span><br><span class="line">            ListNode* next&#x3D;cur-&gt;next;</span><br><span class="line">            cur-&gt;next&#x3D;pre;</span><br><span class="line">            pre&#x3D;cur;</span><br><span class="line">            cur&#x3D;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;采用递归实现</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        if(!pHead||!pHead-&gt;next)</span><br><span class="line">            return pHead;</span><br><span class="line">        ListNode* rHead&#x3D;ReverseList(pHead-&gt;next);</span><br><span class="line">        &#x2F;&#x2F; head-&gt;next此刻指向head后面的链表的尾节点</span><br><span class="line">        &#x2F;&#x2F; head-&gt;next-&gt;next &#x3D; head把head节点放在了尾部</span><br><span class="line">        pHead-&gt;next-&gt;next&#x3D;pHead;</span><br><span class="line">        pHead-&gt;next&#x3D;nullptr;</span><br><span class="line">        </span><br><span class="line">        return rHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="16-合并两个排序的链表">16.合并两个排序的链表</h2>
<blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;当一个链表为空时，直接返回另一个链表</span><br><span class="line">        if(!pHead1)</span><br><span class="line">            return pHead2;</span><br><span class="line">        if(!pHead2)</span><br><span class="line">            return pHead1;</span><br><span class="line">        ListNode* vHead&#x3D;new ListNode(0);  &#x2F;&#x2F;设立虚拟的头节点</span><br><span class="line">        ListNode* vHeadHead&#x3D;vHead;</span><br><span class="line">        while(pHead1 &amp;&amp; pHead2)&#123;  &#x2F;&#x2F;一旦有一个链表为空，就退出循环</span><br><span class="line">            if(pHead1-&gt;val&lt;&#x3D;pHead2-&gt;val)&#123;</span><br><span class="line">                vHead-&gt;next&#x3D;pHead1;</span><br><span class="line">                pHead1&#x3D;pHead1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                vHead-&gt;next&#x3D;pHead2;</span><br><span class="line">                pHead2&#x3D;pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            vHead&#x3D;vHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;另一个链表不为空时，加在后面</span><br><span class="line">        if(!pHead1)</span><br><span class="line">            vHead-&gt;next&#x3D;pHead2;</span><br><span class="line">        else</span><br><span class="line">            vHead-&gt;next&#x3D;pHead1;</span><br><span class="line">        return vHeadHead-&gt;next;  &#x2F;&#x2F;返回虚拟头节点的下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;采用递归实现</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pHead1)</span><br><span class="line">            return pHead2;</span><br><span class="line">        if(!pHead2)</span><br><span class="line">            return pHead1;</span><br><span class="line">        ListNode* vHead&#x3D;nullptr;</span><br><span class="line">        if(pHead1-&gt;val&lt;&#x3D;pHead2-&gt;val)&#123;</span><br><span class="line">            vHead&#x3D;pHead1;</span><br><span class="line">            vHead-&gt;next&#x3D;Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            vHead&#x3D;pHead2;</span><br><span class="line">            vHead-&gt;next&#x3D;Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        return vHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="17-树的子结构">17.树的子结构</h2>
<blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(TreeNode* pRoot1,TreeNode* pRoot2)&#123;</span><br><span class="line">        if(!pRoot2)    &#x2F;&#x2F;注意不能先判断pRoot1再判断pRoot2，因为，只要pRoot2为空的时候，都是true了，而不管这时候pRoot1是不是为空。</span><br><span class="line">            return true;</span><br><span class="line">        if(!pRoot1)</span><br><span class="line">            return false;</span><br><span class="line">        if(pRoot1-&gt;val!&#x3D;pRoot2-&gt;val)</span><br><span class="line">            return false;</span><br><span class="line">        return dfs(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;dfs(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if((!pRoot2)||(!pRoot1))</span><br><span class="line">            return false;</span><br><span class="line">        return (dfs(pRoot1,pRoot2)||HasSubtree(pRoot1-&gt;left,pRoot2)||HasSubtree(pRoot1-&gt;right,pRoot2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="18-二叉树的镜像">18.二叉树的镜像</h2>
<blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
</blockquote>
<p>分析：简单的递归解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(pRoot&#x3D;&#x3D;nullptr)</span><br><span class="line">            return;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">        swap(pRoot-&gt;left,pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="19-顺时针打印矩阵">19.顺时针打印矩阵</h2>
<h2 id="20-包含min函数的栈">20.包含min函数的栈</h2>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
</blockquote>
<p>分析：维护两个栈，其中一个是压入数据的栈，另一个是min栈，存储当前数据的最小的值。只有压入的数小于min栈的时候，才压入新值，否则继续压入最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        stk.push(value);</span><br><span class="line">        if(!stk_min.empty())&#123;</span><br><span class="line">            if(value&lt;stk_min.top())</span><br><span class="line">                stk_min.push(value);</span><br><span class="line">            else&#123;</span><br><span class="line">                int temp&#x3D;stk_min.top();</span><br><span class="line">                stk_min.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            stk_min.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        stk_min.pop();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return stk_min.top();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    stack&lt;int&gt; stk_min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="21-栈的压入-弹出序列">21.栈的压入、弹出序列</h2>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<p>思路：判断是否是压入弹出序列，可以直接使用一个栈进行压入，然后在压入的过程中判断是否跟弹出序列的值相同，是的话则先弹出，最后判断栈是否为空即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        stack&lt;int&gt; istack;</span><br><span class="line">        int i&#x3D;0,j&#x3D;0;</span><br><span class="line">        while(i&lt;pushV.size())&#123;</span><br><span class="line">        	istack.push(pushV[i++]);</span><br><span class="line">        	while(j&lt;popV.size() &amp;&amp; istack.top()&#x3D;&#x3D;popV[j])&#123;</span><br><span class="line">        		istack.pop();</span><br><span class="line">        		++j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return istack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="22-从上往下打印二叉树">22.从上往下打印二叉树</h2>
<blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<p>分析：层序遍历，需要每遍历一个节点，就将他们的左右节点保存起来，当前层遍历完后，再顺序遍历他们的孩子节点。于是很容易想到先入先出的结构，队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(root&#x3D;&#x3D;nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; ique;</span><br><span class="line">        ique.push(root);</span><br><span class="line">        while(!ique.empty())&#123;</span><br><span class="line">            TreeNode* temp&#x3D;ique.front();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">            ique.pop();</span><br><span class="line">            </span><br><span class="line">            if(temp-&gt;left)</span><br><span class="line">                ique.push(temp-&gt;left);</span><br><span class="line">            if(temp-&gt;right)</span><br><span class="line">                ique.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="23-二叉搜索树的后序遍历序列">23.二叉搜索树的后序遍历序列</h2>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">		return Verify(sequence,0,sequence.size());</span><br><span class="line">    &#125;</span><br><span class="line">    bool Verify(vector&lt;int&gt; sequence,int start,int end)&#123;</span><br><span class="line">        int i&#x3D;start;</span><br><span class="line">        if(start&#x3D;&#x3D;end)</span><br><span class="line">            return false;</span><br><span class="line">		for(;i&lt;end-1;++i)&#123;</span><br><span class="line">			if(sequence[i]&gt;sequence[end-1])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        for(int j&#x3D;i;j!&#x3D;end;++j)&#123;</span><br><span class="line">            if(sequence[j]&lt;sequence[end-1])&#123;</span><br><span class="line">                 return false;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        bool left&#x3D;true;</span><br><span class="line">        if(i&gt;start)</span><br><span class="line">            left&#x3D;Verify(sequence,start,i);</span><br><span class="line">        </span><br><span class="line">        bool right&#x3D;true;</span><br><span class="line">        if(i&lt;end-1)</span><br><span class="line">            right&#x3D;Verify(sequence,i,end-1);</span><br><span class="line">        return left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="24-二叉树中和为某一值的路径">24.二叉树中和为某一值的路径</h2>
<blockquote>
<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return res;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        if(expectNumber-root-&gt;val&#x3D;&#x3D;0 &amp;&amp; root-&gt;left&#x3D;&#x3D;nullptr &amp;&amp; root-&gt;right&#x3D;&#x3D;nullptr)</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        if(!temp.empty())</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="25-复杂链表的复制">25.复杂链表的复制</h2>
<p>代码问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        while(pHead-&gt;next)&#123;</span><br><span class="line">&#x2F;&#x2F;        	cout&lt;&lt;pHead-&gt;label&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;            RandomListNode* pTemp&#x3D;pHead;   &#x2F;&#x2F;傻了吧</span><br><span class="line">            RandomListNode* pTemp&#x3D;new RandomListNode(pHead-&gt;label);  </span><br><span class="line">            pTemp-&gt;next&#x3D;pHead-&gt;next;</span><br><span class="line">            cout&lt;&lt;pTemp-&gt;next-&gt;label&lt;&lt;endl;</span><br><span class="line">            pHead-&gt;next&#x3D;pTemp;</span><br><span class="line">            pHead&#x3D;pTemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">                &#x2F;&#x2F;拆分</span><br><span class="line">        pNode&#x3D;pHead;</span><br><span class="line">		RandomListNode* newHead&#x3D;pHead-&gt;next;</span><br><span class="line">        RandomListNode* pTemp&#x3D;pNode-&gt;next;</span><br><span class="line">		while(pNode)&#123;</span><br><span class="line">			pNode-&gt;next&#x3D;pTemp-&gt;next;</span><br><span class="line">			pNode&#x3D;pNode-&gt;next;</span><br><span class="line">			pTemp-&gt;next&#x3D;pNode?pNode-&gt;next:NULL;</span><br><span class="line">			&#x2F;&#x2F;pTemp-&gt;next&#x3D;pNode-&gt;next;</span><br><span class="line">			&#x2F;&#x2F;cout&lt;&lt;&quot;pTemp: &quot;&lt;&lt;pTemp-&gt;label&lt;&lt;endl;</span><br><span class="line">			pTemp&#x3D;pTemp-&gt;next;</span><br><span class="line">			&#x2F;&#x2F;cout&lt;&lt;&quot;text&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(!pHead)</span><br><span class="line">    		return pHead;</span><br><span class="line">    	RandomListNode* pNode&#x3D;pHead;</span><br><span class="line"></span><br><span class="line">    	while(pNode)&#123;</span><br><span class="line">    		RandomListNode* pClone&#x3D;new RandomListNode(pNode-&gt;label);</span><br><span class="line">    		pClone-&gt;next&#x3D;pNode-&gt;next;</span><br><span class="line">    		pNode-&gt;next&#x3D;pClone;</span><br><span class="line">    		pNode&#x3D;pClone-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pNode&#x3D;pHead;</span><br><span class="line">		while(pNode)&#123;</span><br><span class="line">			RandomListNode* pClone&#x3D;pNode-&gt;next;</span><br><span class="line">			if(pNode-&gt;random)</span><br><span class="line">				pClone-&gt;random&#x3D;pNode-&gt;random-&gt;next;</span><br><span class="line">			pNode&#x3D;pClone-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		pNode&#x3D;pHead;</span><br><span class="line">		RandomListNode* newHead&#x3D;pNode-&gt;next;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		while(pNode-&gt;next)&#123;</span><br><span class="line">			RandomListNode* pTemp&#x3D;pNode-&gt;next;</span><br><span class="line">			pNode-&gt;next&#x3D;pTemp-&gt;next;</span><br><span class="line">			pNode&#x3D;pTemp;</span><br><span class="line">&#x2F;&#x2F;			pNode&#x3D;pNode-&gt;next;                  &#x2F;&#x2F;这种不行，搞得我折腾了很久</span><br><span class="line">&#x2F;&#x2F;			pTemp-&gt;next&#x3D;pNode-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="26-二叉搜索树与双向链表">26.二叉搜索树与双向链表</h2>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
TODO:</p>
</blockquote>
<h2 id="27-字符串的排列">27.字符串的排列</h2>
<h2 id="28-数组中出现次数超过一半的数字">28.数组中出现次数超过一半的数字</h2>
<p>解决一个问题，最终输出的判断，是1，还是0。如果大于1的话，万一最后只剩下了一个呢。所以还需要再判断最后剩下的结果是不是符合条件的，即是大于一般数目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        if(numbers.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        int count&#x3D;1;</span><br><span class="line">        int num&#x3D;numbers[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;numbers.size();++i)&#123;</span><br><span class="line">            if(numbers[i]&#x3D;&#x3D;num)</span><br><span class="line">                count++;</span><br><span class="line">            else&#123;</span><br><span class="line">                if((--count)&lt;&#x3D;0)&#123;</span><br><span class="line">                    num&#x3D;numbers[i];</span><br><span class="line">                    count&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断结果是否符合条件</span><br><span class="line">        count&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;numbers.size();++i)&#123;</span><br><span class="line">            if(num&#x3D;&#x3D;numbers[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count*2&gt;numbers.size()?num:0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="29-最小的k个数">29.最小的K个数</h2>
<p>存在的问题，写程序的时候越界，没有判断好边界条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; min_stack;</span><br><span class="line">        if(input.empty()||(k&lt;&#x3D;0)||(k&gt;input.size()))  &#x2F;&#x2F;边界条件的判断</span><br><span class="line">            return min_stack;</span><br><span class="line">        for(int i&#x3D;0;i&lt;input.size();++i)&#123;</span><br><span class="line">            sort(min_stack.begin(),min_stack.end());</span><br><span class="line">            if(min_stack.size()&lt;k)&#123;</span><br><span class="line">                min_stack.push_back(input[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">            	&#x2F;&#x2F;cout&lt;&lt;&quot;min_stack[min_stack.size()-1]: &quot;&lt;&lt;min_stack[min_stack.size()-1]&lt;&lt;endl;</span><br><span class="line">                if(input[i]&lt;min_stack[min_stack.size()-1])&#123;</span><br><span class="line">                    min_stack.pop_back();</span><br><span class="line">                    min_stack.push_back(input[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min_stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="30-连续子数组的最大和">30.连续子数组的最大和</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">    	int  res&#x3D;array[0];</span><br><span class="line">    	int cur&#x3D;array[0];</span><br><span class="line">    	for(int i&#x3D;1;i&lt;array.size();++i)&#123;</span><br><span class="line">    		cur+&#x3D;array[i];</span><br><span class="line">    		if(cur&lt;array[i])</span><br><span class="line">    			cur&#x3D;array[i];</span><br><span class="line">    		res&#x3D;(res&gt;cur?res:cur);</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="31-整数中1出现的次数-从1到n整数中1出现的次数">31.整数中1出现的次数（从1到n整数中1出现的次数）</h2>
<h2 id="32-把数组排成最小的数">32.把数组排成最小的数</h2>
<blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    static bool equal(int a,int b)&#123;</span><br><span class="line">        string str1&#x3D;to_string(a)+to_string(b);</span><br><span class="line">        string str2&#x3D;to_string(b)+to_string(a);</span><br><span class="line">        return str1&lt;str2;</span><br><span class="line">    &#125;</span><br><span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        string result;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),equal);</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;0;i&lt;numbers.size();++i)&#123;</span><br><span class="line">            result+&#x3D;to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="33-丑数">33.丑数</h2>
<blockquote>
<p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        if(index&lt;&#x3D;0)        </span><br><span class="line">            return 0;</span><br><span class="line">        vector&lt;int &gt; res(index);</span><br><span class="line">        res[0]&#x3D;1;</span><br><span class="line">        int x&#x3D;0,y&#x3D;0,z&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;index;++i)&#123;</span><br><span class="line">            res[i]&#x3D;min(2*res[x],min(3*res[y],5*res[z]));</span><br><span class="line">            if(res[i]&#x3D;&#x3D;2*res[x])</span><br><span class="line">                x++;</span><br><span class="line">            if(res[i]&#x3D;&#x3D;3*res[y])</span><br><span class="line">                y++;</span><br><span class="line">            if(res[i]&#x3D;&#x3D;5*res[z])</span><br><span class="line">                z++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[index-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="34-第一个只出现一次的字符位置">34.第一个只出现一次的字符位置</h2>
<blockquote>
<p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
</blockquote>
<p>一般对于这种字符的处理，因为字符一般都是不超过256的，所以尤其是计数之类的，我们可以首先考虑数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    int FirstNotRepeatingChar(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str.size()&lt;&#x3D;0)</span><br><span class="line">            return -1;</span><br><span class="line">        int array[256]&#x3D;&#123;0&#125;;</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.size();++i)&#123;</span><br><span class="line">            array[int(str[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.size();++i)&#123;</span><br><span class="line">            if(array[int(str[i])]&#x3D;&#x3D;1)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return str.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="35-数组中的逆序对">35.数组中的逆序对</h2>
<blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>
//TODO:</p>
</blockquote>
<h2 id="36-两个链表的第一个公共结点">36.两个链表的第一个公共结点</h2>
<blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<p>需要知道的一个常识是，对于只有一个单链表，两个链表有公共节点，意味着从公共节点开始，之后两个链表都是公共的，因此他们有共同的终点。有了这个就好办了。可以将两个链表一直遍历，当遍历到链表尾的时候，就换另一个链表，当他们有公共节点时，在他们遍历到同一个节点时停止遍历，此节点即为第一个公共节点。</p>
<p><strong>对于这种将两个不同的长度，通过两个结合在一起，使两个长度相等的方法，其实我们用到过很多次。例如本题中的找公共节点，原因是两个链表长度不同。还有之前的一个判断两个string的大小，可以把他们放在一起，这样他们的长度就相同了，可以直接用string的方法进行比较。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">        ListNode* p1&#x3D;pHead1;</span><br><span class="line">        ListNode* p2&#x3D;pHead2;</span><br><span class="line">        while(p1!&#x3D;p2)&#123;</span><br><span class="line">            p1&#x3D;(p1&#x3D;&#x3D;nullptr?pHead2:p1-&gt;next);</span><br><span class="line">            p2&#x3D;(p2&#x3D;&#x3D;nullptr?pHead1:p2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="37-数字在排序数组中出现的次数">37.数字在排序数组中出现的次数</h2>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<p>显然很容易想到的是二分法,没有用函数的话，就存在一个找到没找到的问题，在这采用了一个返回值的处理。如果没找到，(end-begin-1)&lt;0，则可以判断是没有找到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">        if(data.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        int begin&#x3D;0,end&#x3D;data.size()-1;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        int mid;</span><br><span class="line">        while(begin&lt;&#x3D;end)&#123;</span><br><span class="line">        	mid&#x3D;(begin+end)&#x2F;2;</span><br><span class="line">&#x2F;&#x2F;        	cout&lt;&lt;&quot;dsdasads&quot;&lt;&lt;endl;</span><br><span class="line">			if(data[mid]&#x3D;&#x3D;k)</span><br><span class="line">				break;</span><br><span class="line">            else if(data[mid]&lt;k)&#123;</span><br><span class="line">                begin&#x3D;mid+1;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(data[mid]&gt;k)&#123;</span><br><span class="line">                end&#x3D;mid-1;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        begin&#x3D;end&#x3D;mid;</span><br><span class="line">        while(data[begin]&#x3D;&#x3D;k)</span><br><span class="line">            --begin;</span><br><span class="line">        while(data[end]&#x3D;&#x3D;k)</span><br><span class="line">            ++end;</span><br><span class="line">        count&#x3D;(end-begin-1)&gt;0?(end-begin-1):0;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="38-二叉树的深度">38.二叉树的深度</h2>
<h2 id="39-平衡二叉树">39.平衡二叉树</h2>
<h2 id="40-数组中只出现一次的数字">40.数组中只出现一次的数字</h2>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<p>数组中只出现一次的数字，当有一个的时候，很容易利用的特性是：全部异或，最后剩下的那个就是。原因是一个数跟自身异或，结果为0.那么出现有两个的时候呢。很容易想到的还是异或，最后的结果是两个只出现一次数字异或的结果，再进行分组解决。分组的依据是：因为有两个不同的数字只出现一次，所以整个数组异或的结果必然不为0，不为0就肯定有一位为1.按该位是否为1来进行划分即可。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span><br><span class="line">        if(data.empty())</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F;第一次遍历一遍，求两个数字最后的异或</span><br><span class="line">        int res&#x3D;data[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;data.size();++i)&#123;</span><br><span class="line">            res&#x3D;res^data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(res&#x3D;&#x3D;0)</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F;由于存在两个只出现一次的数字，所以res的值为这两个数字的异或，因此肯定不为0，肯定不为0意味着肯定有一位是1.找出这一位是1的</span><br><span class="line">        int index&#x3D;0;</span><br><span class="line">        while((res&amp;1)&#x3D;&#x3D;0)&#123;</span><br><span class="line">            res&#x3D;res&gt;&gt;1;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        *num1&#x3D;*num2&#x3D;0;        </span><br><span class="line">        &#x2F;&#x2F;根据index位为不为1，将数组分为两部分。</span><br><span class="line">        int x;</span><br><span class="line">        for(int i&#x3D;0;i&lt;data.size();++i)&#123;</span><br><span class="line">            if((x&#x3D;data[i]&gt;&gt;index)&amp;1)</span><br><span class="line">                *num1^&#x3D;data[i];</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                *num2^&#x3D;data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="41-和为s的连续正数序列">41.和为S的连续正数序列</h2>
<blockquote>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        &#x2F;&#x2F;边界条件的判断</span><br><span class="line">        if(sum&lt;0)</span><br><span class="line">            return res;</span><br><span class="line">            </span><br><span class="line">        int end&#x3D;0;</span><br><span class="line">        int tempSum&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;遍历数组</span><br><span class="line">        while(end&lt;sum)&#123;</span><br><span class="line">            if(tempSum&#x3D;&#x3D;sum)&#123;</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                end&#x3D;temp[0];  &#x2F;&#x2F;这一句其实很重要,因为要考虑将end从最开始重新开始计算，不然可能会有所遗漏,eg:9&#x3D;2+3+4&#x3D;4+5，其中4会重复</span><br><span class="line">                temp.erase(temp.begin(),temp.end());</span><br><span class="line">                tempSum&#x3D;0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tempSum&gt;sum)&#123;</span><br><span class="line">                tempSum-&#x3D;temp[0];</span><br><span class="line">                temp.erase(temp.begin());</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(++end);</span><br><span class="line">            tempSum+&#x3D;end;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="42-和为s的两个数字">42.和为S的两个数字</h2>
<blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
</blockquote>
<p>输出乘积最小的，显然距离最大的乘积就越小，所以，可以直接前后两个指针搜索，搜到的第一个就是。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int &gt; res;</span><br><span class="line">        if(array.empty())</span><br><span class="line">            return res;</span><br><span class="line">            </span><br><span class="line">        int i&#x3D;0,j&#x3D;array.size()-1;</span><br><span class="line">        while(i&lt;j)&#123;</span><br><span class="line">            int temp&#x3D;array[i]+array[j];</span><br><span class="line">            if(temp&gt;sum)</span><br><span class="line">                --j;</span><br><span class="line">            if(temp&lt;sum)</span><br><span class="line">                ++i;</span><br><span class="line">            </span><br><span class="line">            if(temp&#x3D;&#x3D;sum) </span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(array[i]);</span><br><span class="line">                res.push_back(array[j]);</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="43-左旋转字符串">43.左旋转字符串</h2>
<blockquote>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
</blockquote>
<p>由BA=(ATBT)T计算可得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次通过代码</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string LeftRotateString(string str, int n) &#123;</span><br><span class="line">        int len&#x3D;str.size();</span><br><span class="line">        if(n&gt;&#x3D;len)</span><br><span class="line">            return str;</span><br><span class="line">        int i&#x3D;0,j&#x3D;0;</span><br><span class="line">        for(i&#x3D;0,j&#x3D;n-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</span><br><span class="line">        for(i&#x3D;n,j&#x3D;len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</span><br><span class="line">        for(i&#x3D;0,j&#x3D;len-1;i&lt;j;++i,--j)&#123;swap(str[i],str[j]);&#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="44-翻转单词顺序列">44.翻转单词顺序列</h2>
<p>//TODO:</p>
<blockquote>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以前买的</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void ReverseSentence(string &amp;str,int begin,int end)&#123;</span><br><span class="line">        while(begin&lt;end)&#123;</span><br><span class="line">            char tmp&#x3D;str[begin];</span><br><span class="line">            str[begin]&#x3D;str[end];</span><br><span class="line">            str[end]&#x3D;tmp;</span><br><span class="line">            begin++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ReverseSentence(string str) &#123;</span><br><span class="line">        if(str.size()&lt;&#x3D;1)</span><br><span class="line">            return str;</span><br><span class="line">      	</span><br><span class="line">        int begin&#x3D;0;</span><br><span class="line">        int end&#x3D;0;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;这里需要注意，考虑只有一个单词的情况</span><br><span class="line">        while(end!&#x3D;str.size())&#123;</span><br><span class="line">            if(str[end]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                ReverseSentence(str,0,str.size()-1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(end&#x3D;&#x3D;str.size()-1)</span><br><span class="line">            	return str;</span><br><span class="line">            else</span><br><span class="line">                ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        end&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;开始遍历，旋转每个单词</span><br><span class="line">        while(begin!&#x3D;str.size())&#123;</span><br><span class="line">            if(str[begin]&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">                ++end;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(str[end]&#x3D;&#x3D;&#39; &#39;||end&#x3D;&#x3D;str.size())&#123;</span><br><span class="line">                ReverseSentence(str,begin,--end);</span><br><span class="line">                begin&#x3D;++end;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="45-扑克牌顺子">45.扑克牌顺子</h2>
<blockquote>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张<sup>_</sup>)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    bool IsContinuous(vector&lt;int&gt; numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        if (numbers.empty())</span><br><span class="line">            return false;</span><br><span class="line">        sort(numbers.begin(), numbers.end());</span><br><span class="line">        int sum &#x3D; 0, zero_num &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numbers.size() - 1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (numbers[i] &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                zero_num++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;考虑数字重复的情况</span><br><span class="line">            if (numbers[i + 1] &#x3D;&#x3D; numbers[i])</span><br><span class="line">                return false;</span><br><span class="line">            sum +&#x3D; numbers[i + 1] - numbers[i] - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &lt;&#x3D; zero_num; &#x2F;&#x2F;注意这里要大于等于就可以，不一定等于</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="46-孩子们的游戏-圆圈中最后剩下的数">46.孩子们的游戏(圆圈中最后剩下的数)</h2>
<blockquote>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数…这样下去…直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!<sup>_</sup>)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
</blockquote>
<p>此约瑟夫环的问题。TODO:https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int LastRemaining_Solution(int n, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&lt;&#x3D;0)</span><br><span class="line">            return -1;</span><br><span class="line">        int last&#x3D;0;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;</span><br><span class="line">            last&#x3D;(last+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="47-求1-2-3-n">47.求1+2+3+…+n</h2>
<blockquote>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</blockquote>
<p>这个题，可以有好几种解决办法，一个容易想到的就是递归，每次都跟自己相加，直到加到0为止，判断的条件可以采用<code>&amp;&amp;</code>的短路特性：通过&amp;&amp;判断值是否为0已经到达结尾了。<br>
另一种办法，可以利用类的构造函数。TODO:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        int sum&#x3D;n;</span><br><span class="line">        sum&amp;&amp;(sum+&#x3D;Sum_Solution(n-1));</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="48-不用加减乘除做加法">48.不用加减乘除做加法</h2>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<p>不能用加法做加法运算，可以想到的计算机中利用的二进制的加法。通过异或两个数，也就是模2加，得到的是不考虑进位的加法的结果。通过两个数异或，左移一位得到的是进位。无进位结果加上进位，一直循环知道进位为0的时候，结果即为加法的结果。<br>
计算的过程中，一定要细心。方法虽然简单，但是要写对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        int res &#x3D; num1 ^ num2, temp &#x3D; num1 &amp; num2;</span><br><span class="line">        while (temp !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            temp &#x3D; temp &lt;&lt; 1;</span><br><span class="line">            int t &#x3D; res;  &#x2F;&#x2F;暂存res,以避免res的值被改变</span><br><span class="line">            res ^&#x3D; temp;</span><br><span class="line">            temp &#x3D; temp &amp; t;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="49-把字符串转换成整数">49.把字符串转换成整数</h2>
<blockquote>
<p>输入一个字符串,包括数字字母符号,可以为空.如果是合法的数值表达则返回该数字，否则返回0</p>
</blockquote>
<p>分析：主要首先要考虑正负号，这里有一个小细节，我们把flag直接置1的话，可以直接输出flag*res得到结果，而不需要进行判断，是一种省略。另外的判断就比较简单了，按照正常的思路去判断就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    int StrToInt(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        if (str.size() &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        int size &#x3D; str.size(), res &#x3D; 0;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        if (str[0] &#x3D;&#x3D; &#39;-&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            flag &#x3D; -1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (str[0] &#x3D;&#x3D; &#39;+&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (str[i] &lt;&#x3D; &#39;0&#39; || str[i] &gt;&#x3D; &#39;9&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                res &#x3D; res * 10 + (str[i] - &#39;0&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        return flag * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="50-数组中重复的数字">50.数组中重复的数字</h2>
<blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p>分析：由于规定了数组中的数字在范围为0–n内，所以可以利用当前数组的位置进行遍历，比如每次遍历到一个位置，就将该数字对应位置的值加n，这样，当再次遍历到该值时，发现如果该值已经大于n，说明已经重复了，返回即可。不过在遍历的时候，如果发现某一位置的值大于n，应该先减去n，得到该位置上原来的值，这里应该捋清楚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    &#x2F;&#x2F; Parameters:</span><br><span class="line">    &#x2F;&#x2F;        numbers:     an array of integers</span><br><span class="line">    &#x2F;&#x2F;        length:      the length of array numbers</span><br><span class="line">    &#x2F;&#x2F;        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    &#x2F;&#x2F; Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    &#x2F;&#x2F;                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int *duplication)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;length;++i)&#123;</span><br><span class="line">            int index&#x3D;numbers[i];</span><br><span class="line">            if(index&gt;&#x3D;length)</span><br><span class="line">                index&#x3D;index-length;</span><br><span class="line">            if(numbers[index]&gt;&#x3D;length)&#123;</span><br><span class="line">                *duplication&#x3D;index;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[index]+&#x3D;length;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="51-构建乘积数组">51.构建乘积数组</h2>
<blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]。不能使用除法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt; res(A.size());</span><br><span class="line">        if(A.empty())</span><br><span class="line">            return res;</span><br><span class="line">        res[0]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;计算下三角</span><br><span class="line">        for(int i&#x3D;1;i&lt;A.size();++i)&#123;</span><br><span class="line">            res[i]&#x3D;res[i-1]*A[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        int temp&#x3D;1;</span><br><span class="line">        for(int i&#x3D;A.size()-2;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">            temp*&#x3D;A[i+1];</span><br><span class="line">            res[i]*&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="52-正则表达式匹配">52.正则表达式匹配</h2>
<h2 id="53-表示数值的字符串">53.表示数值的字符串</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead&#x3D;&#x3D;nullptr)</span><br><span class="line">            return pHead;</span><br><span class="line">        ListNode* virtualHead&#x3D;new ListNode(0);</span><br><span class="line">        virtualHead-&gt;next&#x3D;pHead;</span><br><span class="line">        ListNode* prev&#x3D;virtualHead;</span><br><span class="line">        </span><br><span class="line">        while(pHead-&gt;next)&#123;</span><br><span class="line">            if(pHead-&gt;val&#x3D;&#x3D;pHead-&gt;next-&gt;val)&#123;</span><br><span class="line">                if(pHead-&gt;next-&gt;next)&#123;</span><br><span class="line">                    pHead&#x3D;pHead-&gt;next-&gt;next;</span><br><span class="line">                    prev-&gt;next&#x3D;pHead;</span><br><span class="line">                &#125;</span><br><span class="line">                else </span><br><span class="line">                    return virtualHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                pHead&#x3D;pHead-&gt;next;</span><br><span class="line">                prev&#x3D;prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return virtualHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试用例:
{1,1,1,1,1,1,1}</p>
<p>对应输出应该为:</p>
<h2 id="54-字符流中第一个不重复的字符">54.字符流中第一个不重复的字符</h2>
<h2 id="55-链表中环的入口结点">55.链表中环的入口结点</h2>
<h2 id="56-删除链表中重复的结点">56.删除链表中重复的结点</h2>
<h2 id="57-二叉树的下一个结点">57.二叉树的下一个结点</h2>
<h2 id="58-对称的二叉树">58.对称的二叉树</h2>
<h2 id="59-按之字形顺序打印二叉树">59.按之字形顺序打印二叉树</h2>
<h2 id="60-把二叉树打印成多行">60.把二叉树打印成多行</h2>
<h2 id="61-序列化二叉树">61.序列化二叉树</h2>
<h2 id="62-二叉搜索树的第k个结点">62.二叉搜索树的第k个结点</h2>
<h2 id="63-数据流中的中位数">63.数据流中的中位数</h2>
<h2 id="64-滑动窗口的最大值">64.滑动窗口的最大值</h2>
<h2 id="65-矩阵中的路径">65.矩阵中的路径</h2>
<h2 id="66-机器人的运动范围">66.机器人的运动范围</h2>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://www.yuguocong.cn">mianhk</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://www.yuguocong.cn/2018/06/20/Exercise/re_sword_to_offer/">http://www.yuguocong.cn/2018/06/20/Exercise/re_sword_to_offer/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/C/">C++</a>
            <a href="/tags/LeetCode/">LeetCode</a>
            <a href="/tags/%E5%89%91%E6%8C%87offer/">剑指offer</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2018/06/24/interview/interview_cpp/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">面试总结-C++</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2018/06/20/interview/re_sword_to_offer/">
        <span class="next-text nav-default">剑指offer-刷题总结</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:gcyu25@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/mianhk" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">mianhk</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
