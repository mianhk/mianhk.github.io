<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="面试总结-操作系统"/><meta name="keywords" content="Linux, 面试, 工作, 操作系统, mianhk" /><link rel="alternate" href="/atom.xml" title="mianhk"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://www.yuguocong.cn/2018/06/24/interview/interview_operation/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>面试总结-操作系统 - mianhk</title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">mianhk</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">mianhk</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">面试总结-操作系统
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-24
        </span><span class="post-category">
            <a href="/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/">面试经验</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统的分页分段"><span class="toc-text">操作系统的分页分段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分页存储"><span class="toc-text">分页存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分段存储"><span class="toc-text">分段存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分页存储和分段存储的区别"><span class="toc-text">分页存储和分段存储的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段页存储"><span class="toc-text">段页存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux自旋锁"><span class="toc-text">Linux自旋锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程同步"><span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程间通信"><span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#select-poll-epoll的区别"><span class="toc-text">select、poll、epoll的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#死锁"><span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁避免"><span class="toc-text">死锁避免</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁解除"><span class="toc-text">死锁解除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程有哪几种状态？"><span class="toc-text">进程有哪几种状态？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统中进程调度策略有哪几种？"><span class="toc-text">操作系统中进程调度策略有哪几种？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#虚拟内存"><span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程中栈与堆是公有的还是私有的"><span class="toc-text">多线程中栈与堆是公有的还是私有的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程是资源分配的最小单位-线程是cpu调度的最小单位"><span class="toc-text">进程是资源分配的最小单位，线程是CPU调度的最小单位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和线程的区别"><span class="toc-text">进程和线程的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的基本状态"><span class="toc-text">进程的基本状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-进程管理-cpu"><span class="toc-text">1.进程管理-&gt;CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#任务调度算法"><span class="toc-text">任务调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程与线程"><span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#进程间通信方式"><span class="toc-text">进程间通信方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux-的启动流程"><span class="toc-text">Linux 的启动流程</span></a></li></ol></li></ol></li></ol>
    </div>
  </div><div class="post-content"><h1 id="操作系统的分页分段">操作系统的分页分段</h1>
<p><a href="https://www.cnblogs.com/onepeace/p/5066736.html" target="_blank" rel="noopener">操作系统之分页分段介绍</a></p>
<h2 id="分页存储">分页存储</h2>
<ul>
<li>思想：将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)或物理块，每个物理块的大小一般取2的整数幂。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）。</li>
<li>逻辑地址道物理地址变化原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。</li>
<li>优点：没有外碎片，提高内存的利用率。一个程序不必连续存放。便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。</li>
<li>缺点：无论数据有多少，都只能按照页面大小分配，容易产生内部碎片。无法体现程序逻辑。页长与程序的逻辑大小不相关。不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。</li>
</ul>
<h2 id="分段存储">分段存储</h2>
<ul>
<li>思想：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中（写c程序时会用到），并且每个程序可以有多个相同类型的段。段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。<br>
在为某个段分配物理内存时，可以采用<strong>首先适配法、下次适配法、最佳适配法</strong>等方法。在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。</li>
<li>地址映射: 在分段存储中，整个进程的地址空间是<strong>二维</strong>的，即其逻辑地址由段号和段内地址两部分组成。</li>
<li>优点：分段对程序员可见。段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。方便编程，分段共享，分段保护，动态链接，动态增长。</li>
<li>缺点：主存空间分配比较麻烦。外部碎片。由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚拟地址和实存地址的最低若干二进制位作为段内地址，并与段号进行直接拼接，必须用加法操作通过段起址与段内地址的求和运算得到物理地址。</li>
</ul>
<h2 id="分页存储和分段存储的区别">分页存储和分段存储的区别</h2>
<ol>
<li>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；段则是信息的逻辑单位，它含有一组其意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。</li>
<li>页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li>
<li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址是，即需给出段名，又需给出段内地址。</li>
<li>分页信息很难保护和共享、分段存储按逻辑存储所以容易实现对段的保存和共享。</li>
</ol>
<h2 id="段页存储">段页存储</h2>
<p>程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。</p>
<div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180622105842.png" /> </div><br>  
为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块
<p>它首先将程序按其逻辑结构划分为若干个大小不等的逻辑段，然后再将每个逻辑段划分为若干个大小相等的逻辑页。主存空间也划分为若干个同样大小的物理页。辅存和主存之间的信息调度以页为基本传送单位，每个程序段对应一个段表，每页对应一个页表。</p>
<p>段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量</p>
<p>CPU访问时，段表指示每段对应的页表地址，每一段的页表确定页所在的主存空间的位置，最后与页表内地址拼接，确定CPU要访问单元的物理地址。</p>
<p>段页存储管理方式综合了段式管理和页式管理的优点，但需要经过两级查表才能完成地址转换，消耗时间多。</p>
<ul>
<li>过程：检查是否越界。利用段表始址和段号来求出该段所对应的段表项在段表中的位置，得到该段的页表始址。读出该页所在的物理块号b。构建物理地址。</li>
<li>优点：提供了大量的虚拟存储空间。有效地利用主存，为组织多道程序运行提供了方便。</li>
<li>缺点：增加了硬件成本、系统的复杂性和管理上的开销。存在系统抖动的风险。存在内碎片。各种表占用更多的空间。</li>
</ul>
<h1 id="linux自旋锁">Linux自旋锁</h1>
<h1 id="线程同步">线程同步</h1>
<p>http://bestmind.space/posts/%E5%B8%B8%E8%A7%81C-%E9%9D%A2%E8%AF%95%E9%A2%98/<br>
线程同步和线程互斥的区别
线程同步的方式:互斥锁、读写锁(共享-独占锁)、条件变量和信号量</p>
<h1 id="进程间通信">进程间通信</h1>
<p>进程间的通信方式
管道、有名管道、信号、共享内存、消息队列、信号量、套接字、文件.
(1)管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。  管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的首端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。分为普通管道、流管道、命名管道。<br>
(2)命名管道(named pipe):命名管道也是半双工的通信方式，它克服了管道没有名字的限制，并且它允许无亲缘关系进程间的通信。命令管道在文件系统中有对应的文件名，命名管道通过命令mkfifo或系统调用mkfifo来创建。<br>
(3)信号:信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。除了用于进程通信外，进程还可以发送信号给进程本身。<br>
(4)消息队列：克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小的限制。由消息链表的结构实现。<br>
(5)信号量(semophore):信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br>
(6)共享内存：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<br>
(7)套接字: 与其他通信机制不同的是，它可用于不同机器间的进程通信。但是将通信转移到了应用层。</p>
<h1 id="select-poll-epoll的区别">select、poll、epoll的区别</h1>
<h1 id="死锁">死锁</h1>
<p>指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p>
<p>死锁产生的四个必要条件:
互斥条件:一个资源每次只能被一个进程使用
不可剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系.</p>
<h2 id="死锁避免">死锁避免</h2>
<p>银行家算法：检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。</p>
<h2 id="死锁解除">死锁解除</h2>
<ol>
<li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li>
<li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li>
<li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ol>
<h1 id="进程有哪几种状态？">进程有哪几种状态？</h1>
<p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；
运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；
阻塞状态： 进程等待某种条件，在条件满足之前无法执行；</p>
<h1 id="操作系统中进程调度策略有哪几种？">操作系统中进程调度策略有哪几种？</h1>
<p>FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU</p>
<p>SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度</p>
<p>优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化</p>
<p>时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</p>
<p>多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</p>
<p>多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p>
<h1 id="虚拟内存">虚拟内存</h1>
<p>为什么有虚拟内存：对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上
缺页：如果虚拟内存的页并不存在于物理内存中，会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。</p>
<p>页面置换算法：
FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p>
<p>LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；</p>
<p>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</p>
<p>OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p>
<h2 id="多线程中栈与堆是公有的还是私有的">多线程中栈与堆是公有的还是私有的</h2>
<p>一般来说栈是私有的，堆是公有的。
但是在多线程中，可以为特定的线程创建私有的堆。</p>
<h2 id="进程是资源分配的最小单位-线程是cpu调度的最小单位">进程是资源分配的最小单位，线程是CPU调度的最小单位</h2>
<p>进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。<br>
与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。<br>
线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。<br>
因此一个简单的解释就是：进程拥有PCB，而多个线程共享一个进程的PCB。</p>
<h3 id="进程和线程的区别">进程和线程的区别</h3>
<p><a href="https://segmentfault.com/a/1190000005884656" target="_blank" rel="noopener">进程与线程的一个简单解释</a>
地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。<br>
通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。<br>
调度和切换：线程上下文切换比进程上下文切换要快得多。<br>
在多线程OS中，进程不是一个可执行的实体。</p>
<div align="center"> <img src="http://blog-1252063226.cosbj.myqcloud.com/network/20180622095406.png" /> </div><br>
<h2 id="进程的基本状态">进程的基本状态</h2>
<p>状态：运行、阻塞、挂起阻塞、就绪、挂起就绪<br>
状态之间的转换：
准备就绪的进程，被CPU调度执行，变成运行态；<br>
运行中的进程，进行I/O请求或者不能得到所请求的资源，变成阻塞态；<br>
运行中的进程，进程执行完毕（或时间片已到），变成就绪态；<br>
将阻塞态的进程挂起，变成挂起阻塞态，当导致进程阻塞的I/O操作在用户重启进程前完成（称之为唤醒），挂起阻塞态变成挂起就绪态，当用户在I/O操作结束之前重启进程，挂起阻塞态变成阻塞态；<br>
将就绪（或运行）中的进程挂起，变成挂起就绪态，当该进程恢复之后，挂起就绪态变成就绪态；</p>
<figure class="highlight plain"><figcaption><span>const char * const task_state_array[] </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &quot;R (running)&quot;,        &#x2F;*   0 *&#x2F;</span><br><span class="line">  &quot;S (sleeping)&quot;,        &#x2F;*   1 *&#x2F;</span><br><span class="line">  &quot;D (disk sleep)&quot;,    &#x2F;*   2 *&#x2F;</span><br><span class="line">  &quot;T (stopped)&quot;,        &#x2F;*   4 *&#x2F;</span><br><span class="line">  &quot;t (tracing stop)&quot;,    &#x2F;*   8 *&#x2F;</span><br><span class="line">  &quot;X (dead)&quot;,        &#x2F;*  16 *&#x2F;</span><br><span class="line">  &quot;Z (zombie)&quot;,        &#x2F;*  32 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180622100813.png" /> </div><br>         
<h3 id="1-进程管理-cpu">1.进程管理-&gt;CPU</h3>
<h4 id="任务调度算法">任务调度算法</h4>
<p>1.先来先服务算法
优点：简单，易于理解和实现。
缺点：一批任务的平均周转时间取决于各个任务到达的顺序，如果短任务位于长任务之后，那么将增大平均周转时间。<br>
2.短作业优先算法<br>
SJF算法的基本思路是：各个任务在开始执行之前，必须事先预计好它的执行时间，然后调度器将根据这些时间，从中选择用时较短的任务优先执行。
SJF算法有两种：不可抢占方式和可抢占方式。其中可抢占方式又叫最短剩余时间优先算法（Shortest Remaining Time First，SRTF）。<br>
3.时间片轮转算法
时间片轮转算法（Round Robin，RR）的基本思路是：把系统当中的所有就绪任务按照先来先服务的原则，排成一个队列，然后再每次调度的时候，把处理器分派给队列当中的第一个任务，让它去执行一小段CPU时间（即时间片，time slice）。当这个时间片结束时，如果任务还没有执行完成的话，将会发生时钟中断，在时钟中断里面，调度器将会暂停当前任务的执行，并把它送到就绪队列的末尾，然后执行当前的队首任务。反之，如果一个任务在它的时间片用完之前就已经结束了或者阻塞了，那么它就会立即让出CPU给其他任务。<br>
优点：公平性，各个就绪任务能得到相同的时间片；活动性，每个就绪任务能一直保持活动。<br>
缺点：时间片的大小q要适当选取，如果选择不当，将会影响到系统的性能和效率。如果q太大，每个任务都在一个时间片内完成，这就退化为先来先服务算法了。如果q太小，每个任务需要更多的时间片才能运行结束，这就使任务之间的切换次数增加，从而增大了系统的管理开销，降低了CPU的使用效率。一般来说，q值选取在20ms~50ms比较合适。<br>
4.优先级算法<br>
优先级调度算法（priority）的基本思路是：给每个任务都设置一个优先级，然后在任务调度的时候，在所有处于就绪状态的任务中选择优先级最高的任务去运行。上文提到的短作业优先算法其实也是一种优先级算法，每个任务的优先级就是它的运行时间，运行时间越短，优先级越高。</p>
<h4 id="进程与线程">进程与线程</h4>
<p>简单的一句话：进程是资源分配的基本单位、线程是资源调度的基本单位。这句话看起来很简单，但是核心却不仅仅如此。</p>
<h4 id="进程">进程</h4>
<h5 id="进程间通信方式">进程间通信方式</h5>
<ul>
<li>管道（pipe）,流管道(s_pipe)和有名管道（FIFO）<br>
管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。<br>
有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。</li>
<li>信号（signal）<br>
信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</li>
<li>消息队列
消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存
共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li>
<li>信号量
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
</ul>
<h3 id="linux-的启动流程">Linux 的启动流程</h3>
<p>BIOS-&gt;主引导记录-&gt;操作系统-&gt;<strong>加载内核(/boot)</strong>:载入内核文件-&gt;<strong>启动初始化进程</strong>：运行第一个程序 /sbin/init，初始化系统环境。-&gt;<strong>确定运行级别</strong>:运行这些开机启动的程序。-&gt;<strong>加载开机启动程序</strong>-&gt;<strong>用户登录</strong>-&gt;<strong>进入 login shell</strong>-&gt;打开 non-login shell</p>
<div align="center"> <img src="https://blog-1252063226.cosbj.myqcloud.com/network/20180622222745.png" /> </div><br>
[Linux 的启动流程-阮一峰](https://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html)

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://www.yuguocong.cn">mianhk</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://www.yuguocong.cn/2018/06/24/interview/interview_operation/">http://www.yuguocong.cn/2018/06/24/interview/interview_operation/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/Linux/">Linux</a>
            <a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
            <a href="/tags/%E5%B7%A5%E4%BD%9C/">工作</a>
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2018/10/26/tools/hexo_travis-ci/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Travis CI 自动部署博客</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2018/06/24/interview/interview_cpp/">
        <span class="next-text nav-default">面试总结-C++</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:gcyu25@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/mianhk" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">mianhk</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
