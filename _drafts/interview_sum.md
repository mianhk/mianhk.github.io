# 操作系统
1.生产者消费者 代码实现
2.进程、线程、区别、线程的几个状态（）、进程的几个状态（）


# 编程
auto_ptr能作为vector的元素吗？为什么？
不可以。
当复制一个auto_ptr时，它所指向的对象的所有权被交到复制的auto_ptr上面，而它自身将被设置为null。复制一个auto_ptr意味着改变它的值。https://blog.csdn.net/diaolingle/article/details/51372013 


# 用shell实现从文件取出某个列并且去重
`cat a.txt | awk '{print $2}' | uniq`  

# mysql和redis的区别和使用场景

# 一个数组有一万个数据，只有10个是没有排序的（分布均匀），进行排序。
插入排序？

# c++11完美转发
[C++11新特性之 std::forward(完美转发)](https://blog.csdn.net/wangshubo1989/article/details/50485951)
转发通常用在模板编程中，假设有一个函数F(a1, a2, ..., an)，如果存在另一个函数G(a1, a2, ..., an)，调用G相当于调用了F，则我们说函数G将a1, a2, ..., an等参数正确地转发给了函数F。  
这里会存在不同引用的问题，不管是T&&、左值引用、右值引用，std::forward都会按照原来的类型完美转发。  

# malloc的原理
void *malloc(long NumBytes)：该函数分配了NumBytes个字节，并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。  
malloc()从堆里面获得空间。函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。   
```
void Function(void) 
       { 
        char *p = (char *)malloc(100 * sizeof(char)); 
    }   函数返回后，函数所在的栈被销毁，指针也被销毁，但是申请的内存在堆上，还是要记得自己释放。  
```
[C语言的malloc()和free()函数原理【整理】](https://blog.csdn.net/llhyy17/article/details/5375298)  

# 标准库 STL ：Allocator能做什么？
allocator的最重要的事实是它们只是为了一个目的：封装STL容器在内存管理上的低层细节。  

# 哈希表的桶个数为什么是质数，合数有何不妥？
设有一个哈希函数
H( c ) = c % N;
当N取一个合数时，最简单的例子是取2^n，比如说取2^3=8,这时候
```
H( 11100(二进制） ) = H( 28 ) = 4
H( 10100(二进制) ) = H( 20 ）= 4    //导致两个
```
取其他合数时，都会不同程度的导致c的某些位”失效”，从而在一些常见应用中导致冲突．
但是取质数，基本可以保证c的每一位都参与H( c )的运算，从而在常见应用中减小冲突几率  

# 如何把一个文件快速下发到100万个服务器
p2p:下发的服务器仍然可以作为下发的服务器，一层层处理

