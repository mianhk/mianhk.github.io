[{"categories":["life"],"content":" 年更继续 今年好像比之前更想要总结一下，从快到元旦的时候就开始看去年的相册，大概做了哪些事情。想着可能一个是今年的经历让我觉得需要更多的总结，一个可能是年近 30 了，年纪大了，一年感觉过的太快了。每天都感觉很忙，但是一周都感觉没干啥，一年也是，更需要总结了。 ","date":"2024-01-07","objectID":"/posts/daily/2023-summary/:0:0","tags":["sumary"],"title":"2023年终总结","uri":"/posts/daily/2023-summary/"},{"categories":["life"],"content":"年度回顾 ","date":"2024-01-07","objectID":"/posts/daily/2023-summary/:1:0","tags":["sumary"],"title":"2023年终总结","uri":"/posts/daily/2023-summary/"},{"categories":["life"],"content":"学习 学习上今年几乎没太完整的看过技术书籍，买的零散的书也都没看完。 但是无关的书倒是看了好几本，印象最深刻的还是桥水基金老头子的《原则》，一条条的人生规则，确实有很多需要学习的。比如两个最喜欢的点： 维护自己人生的机器，让很多东西可以量化。按照这个去做，节省做一些事情的成本。比如怎样把车开在马路的正中间，这一定有个确定的可以量化的操作或者技巧，而不是完全凭感觉。 需要极致的现实。其实也可以说是客观，就是任何事情不要抱有幻想，而是是啥样就是啥样，然后按照这个客观事实去做事。比如我的周末，每周都是打一天游戏的话，就不该觉得周末能学多少东西，我的计划都应该基于这个事实。 另外是马伯庸的两本，《长安的荔枝》和《太白金星有点烦》，底层打工人的痛苦描述的很详细，一如看到了自己。 ","date":"2024-01-07","objectID":"/posts/daily/2023-summary/:1:1","tags":["sumary"],"title":"2023年终总结","uri":"/posts/daily/2023-summary/"},{"categories":["life"],"content":"工作 今年工作的重心主要在数据库中间件的开发与维护上，开发中主要是中间件的迁移。说实话这个工作还挺大的，主要有几个方面： 中间件的兼容开发。 一些遗留问题的处理。由于很长时间没专人维护的遗留问题，现在作为专人维护了，也需要跟进了。 迁移工作：我们在用 9% 的中间件，替换 60% 以上的中间件，包括迁移流程、迁移操作、迁移效率等。 迁移问题处理：由于之前的中间件线上实例太少，很多问题没有暴露，而且已有的服务迁移过来，业务肯定不愿意看到。而且一旦遇到问题，就需要快速跟进，不然已知问题也影响接下来迁移的信心。 还有另外一部分大的工作，也是数据库运维平台和其他体系的融合，以及在这个过程中带新人。带新人算是收获比较大的，看到了他们的成长，自己也学到了不少，怎么样去沟通。但是说实话，感觉做的还不是太好，比如在任务的跟进上，很多时候跟进不及时，导致产出与预期的有点不一致，又需要花时间处理。有一部分客观原因是自己的时间本来没有那么多，主观原因还是没有把这个常态化的去关注。 说到今年工作的收获，也算是达到预期了，完成了晋升，涨薪幅度在这个环境下也觉得还行了。另外超出预期的是，作为武汉的优秀应届生代表，去北京参加训练营，得以参加雷总的演讲，并且参加了雷总的座谈会并和雷总合照。参加座谈会的最大的感受，就是雷总也是一个普通人，但是真的太努力了，座谈会的发言内容，就在最开始准备了几分钟，就把我们听的澎湃了。 ","date":"2024-01-07","objectID":"/posts/daily/2023-summary/:1:2","tags":["sumary"],"title":"2023年终总结","uri":"/posts/daily/2023-summary/"},{"categories":["life"],"content":"生活 生活上今年最大的事情应该就是装修了，装修花了时间挺多，从最开始的心累，各种纠结，到后面慢慢符合预期的样子，直到现在住进来，还是很舒服的。 另外买了一辆二手车，这是在当时装修的时候买的，源于一个最痛的点。因为新房现在有点偏，那天送家具的师傅过来正好下了小雨还有点冷，回去的时候不好打车，我们让师傅把我们带一脚，前面只有一个副驾，我只能做在后面的敞篷里。当时躲在后面敞篷里的几公里，就想着得先买车。后来各种看，觉得现在电车不成熟，油车又像是入国军，于是选了让我堂哥帮忙看的二手车，开到目前为止，很满意，也开了快 5K 公里了。 ","date":"2024-01-07","objectID":"/posts/daily/2023-summary/:1:3","tags":["sumary"],"title":"2023年终总结","uri":"/posts/daily/2023-summary/"},{"categories":["life"],"content":"做的好的 开始慢慢的客观的看一些事情了，也不纠结很多事情。 在今年目标的达成上，做的还不错 ","date":"2024-01-07","objectID":"/posts/daily/2023-summary/:2:0","tags":["sumary"],"title":"2023年终总结","uri":"/posts/daily/2023-summary/"},{"categories":["life"],"content":"待提高的 还是需要更客观，更现实，以及持续的努力，执行力要更强。承认自己的不足。 眼光放的更长远，目标也是。 ","date":"2024-01-07","objectID":"/posts/daily/2023-summary/:3:0","tags":["sumary"],"title":"2023年终总结","uri":"/posts/daily/2023-summary/"},{"categories":["life"],"content":"新年展望 在学习上。技术书籍，课外书籍。每月一本吧。 在工作上。一定要提升个人技术水平，不要盲目只顾着需求。 在生活上。热爱生活，找个可以量化的标准吧，今年学会游泳，体重到 130 斤。 ","date":"2024-01-07","objectID":"/posts/daily/2023-summary/:4:0","tags":["sumary"],"title":"2023年终总结","uri":"/posts/daily/2023-summary/"},{"categories":["life"],"content":" 难得有这么准时的一次年终总结了吧 当熟悉的周五，发现这个周末是元旦假期的时候，才想起今年真的已经过完了。也顺便发现了每年都过的很快了，今年大概是由于疫情，感觉留下来的记忆好像更少了。但是好在今天回来也不知道做啥，就狠下心先把总结写一下吧。 每月回顾 1月。19年之后就没专门离开武汉玩过了，想着这次跨年一定要出去玩一下，正好厚比也在长沙，就匆匆决定去了。新年前最后一天我们很早就到了长沙开始喝茶颜，晚上撸着串就过完了这一年。这次玩除了吃喝都还可以外，还有个也是跟老婆学习到的，真正放松的去玩，别在玩的时候也给自己定目标，所以就感觉很轻松。 2月。最重要的事情就是结婚了，又正好担心疫情，结婚前两天还有点担心能不能上高速，需不需要Plan B，不过最后圆满办完了。尤其是那天睡了一个好觉，第二天起床外面就下雪的时候，真就想起了天公作美😆。 3月4月。3月领证了，虽然对于我们两个人来说仪式感好像没有那么强，走路去隔壁政务中心就搞完了。另外这两个月好像最主要的就是工作调整了，从 TiDB -\u003e Redis -\u003e MySQL，属实是变动比较大了。当然在这期间还有一点收获，就是晋升和青工都拿到了，虽然钱涨的不多，但是起码算是达成点工作目标了。 5月。年后第一次回家，参加了兽博的婚礼。老婆也离职了准备考试了。 6月。带爸妈体检了一次。 7月。工作又有大的变动，但是干的活又变化不太大，这个后面细说。 8月。无 9月。主要就是堂弟来我这找工作了，快一个月了，当时确实有点替他着急，也对我们生活有点小影响。幸好最后还找到了个不错的工作。 10月。国庆节回了趟老家，今年第二次回去了，跟基友们聚了个餐。 11月12月。好像也没啥很重要的事情。 ","date":"2022-12-30","objectID":"/posts/daily/2022-summary/:0:0","tags":null,"title":"2022年终总结","uri":"/posts/daily/2022-summary/"},{"categories":["life"],"content":"年度回顾 ","date":"2022-12-30","objectID":"/posts/daily/2022-summary/:1:0","tags":null,"title":"2022年终总结","uri":"/posts/daily/2022-summary/"},{"categories":["life"],"content":"学习 学习上好像也没有系统去准备，都是断断续续，不过今年看的书要多了一些， 在技术方面： 《数据密集型应用系统设计》。神书果然有点东西，最大的感触是从更上层说了为什么会有这么多数据库，以及为什么会这么设计。 《Go语言圣经》。后面会主要在Go语言开发，重温了一遍基础。接下来还是要把进阶的内容看一看。 在非技术方面，看了好几本个人管理方面的书，觉得虽然生活了快30年，但是很多简单的道理还是总做不到。 《精力管理》。之前上课的时候老师推荐的书，很快过了一遍，很多看起来很简单，但是还是很难做到。 《置身事内》。熟悉了下我国经济发展和一些政治上的关系，怎么说呢，就是看的很爽，竟然还有这些关联。 《态度》。吴军博士的书，一起买了三本，因为老婆在看其他的，就先看了这本。但是主要是给吴军博士给女儿写的信，对我这个年龄段不太适用，就很快过了。 《掌控习惯》。以为很简单的书，实际上不太简单。一个深刻的印象就是，不要去挑战人类的本性，而是让自己处于更容易养成习惯的环境，让自己的习惯养成的顺利成章。 《富爸爸穷爸爸》。关于理财方面的，但是对于现在的我来说收益很小，只能先记住一些理念吧。 在其他方面，好像没有学到什么新的东西。 ","date":"2022-12-30","objectID":"/posts/daily/2022-summary/:1:1","tags":null,"title":"2022年终总结","uri":"/posts/daily/2022-summary/"},{"categories":["life"],"content":"工作 工作上今年说变化大：从年初的 TiDB 数据库容器化到后面说要搞 Redis ，又到后面的 MySQL 运维，中间还因为经历了米家的故障，导致后续做了一系列质量相关的工作，运维上占用了较多的时间。到后来的开发，主要集中在中间件，又花了很多时间跟各个团队讨论。 说变化不大，我做的事情又还是一直围绕数据库。 今年在工作上的收获，是有晋升和青工了，在团队各种调整下，绩效也还行，算是完成了今年的工作目标。但是放眼望去明年，感觉晋升希望比较小，中间也在调整过程中做了一些操作，现在不知道对不对，还是留给时间吧。 不过工作上现在也有了一些新的想法，就是还是尽量去做有意义的事情，对公司有意义，也对自己有意义。这个需要后面一直能考虑到。 ","date":"2022-12-30","objectID":"/posts/daily/2022-summary/:1:2","tags":null,"title":"2022年终总结","uri":"/posts/daily/2022-summary/"},{"categories":["life"],"content":"生活 今年生活整体因为疫情，还是比较平淡的，后面也没怎么出去玩过，回老家都比较少。跟老婆的婚后生活也是默契越来越多了，不过感觉生活哲学自己还是需要多领悟领悟，生活还是需要让自己轻松些，但是有时候又要有紧迫感。 今年买的比较满意的两件东西，一个是 switch，朋友折扣的时候买的，让生活多了一些娱乐；一个是 iPhone14，之前因为自己的工作，一直没考虑 Iphone，这次老婆极力劝说，换了后感觉确实还可以。 ","date":"2022-12-30","objectID":"/posts/daily/2022-summary/:1:3","tags":null,"title":"2022年终总结","uri":"/posts/daily/2022-summary/"},{"categories":["life"],"content":"做的好的 今年后面慢慢养成了看书的习惯，觉得是一件轻松的事情了，希望后面继续保持。 工作上至少结果做的还可以。 ","date":"2022-12-30","objectID":"/posts/daily/2022-summary/:2:0","tags":null,"title":"2022年终总结","uri":"/posts/daily/2022-summary/"},{"categories":["life"],"content":"待提高的 目标的可持续性还有待加强，还有战略上需要更加勤奋，而不是让战术上的勤奋代替战略上的懒惰。 做计划有时候太满，没有很好的理解自己做事情的时间，导致很多计划没有做到。 ","date":"2022-12-30","objectID":"/posts/daily/2022-summary/:3:0","tags":null,"title":"2022年终总结","uri":"/posts/daily/2022-summary/"},{"categories":["life"],"content":"新年展望 在学习上。技术书籍起码看个5本吧，且都是有笔记的那种。其他的书籍至少看5本，也是要能有收获。 在工作上。注重个人能力的提升，且有计划。 在生活上。热爱生活。 ","date":"2022-12-30","objectID":"/posts/daily/2022-summary/:4:0","tags":null,"title":"2022年终总结","uri":"/posts/daily/2022-summary/"},{"categories":["tool"],"content":"初衷 说到笔记的使用，从大学开始到现在工作，也用了很久了，目的除了记录一些学习的内容，工作需要，还会记一些乱七八糟的东西。工具也一直有些变动，这里就从工作开始后开始记一下。整个历程经历了：Quiver -\u003e Evernote -\u003e Typora -\u003e Notion -\u003e Obsidian。 ","date":"2022-12-02","objectID":"/draft/way-to-notes/:0:0","tags":null,"title":"我的笔记折腾之路","uri":"/draft/way-to-notes/"},{"categories":["tool"],"content":"Quiver 最开始是刚开始工作的时候用的 Quiver，当时好像找不到缺点： 完全离线 轻量 Block 模式 ","date":"2022-12-02","objectID":"/draft/way-to-notes/:1:0","tags":null,"title":"我的笔记折腾之路","uri":"/draft/way-to-notes/"},{"categories":["MySQL"],"content":" SQL Modes 在使用的过程中一般不会有问题，因为写入一般都是在主库上。但是如果由于新部署的从库，默认设置与旧主库不一样，在发生主库切换后，业务可能就会有问题了。 以下仅分析 MySQL 5.7 版本。 什么是SQL Modes MySQL server 可以工作在不同的 SQL 模式下，不同的模式对客户端可能有不同的表现。具体取决于系统变量 sql_mode. mysql\u003e SHOW VARIABLES LIKE \"sql_mode\"; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | sql_mode | | +---------------+-------+ 设置SQL Modes MySQL 5.7 有以下SQL modes： ONLY_FULL_GROUP_BY：对于 group by 聚合操作，如果在 select 中出现的列没有在 group by 中出现，那么这种 SQL 是不合法的。 mysql\u003e CREATE TABLE mytable ( id INT UNSIGNED NOT NULL PRIMARY KEY, a VARCHAR(10), b VARCHAR(10), c INT); mysql\u003e set sql_mode=\"ONLY_FULL_GROUP_BY\"; Query OK, 0 rows affected (0.03 sec) mysql\u003e select a,b,max(c) from mytable group by a; ERROR 1055 (42000): Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'ygc_test.mytable.b' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by mysql\u003e select a,b,max(c) from mytable group by a,b; Empty set (0.02 sec) STRICT_TRANS_TABLES: Strict mode控制着 MySQL 在 update/insert 时候对于 invalid 或 missing 数据的处理。插入或更新的值 invalid 有多种原因，比如数据类型错误、值越界等；值缺失是因为向 NOT NULL 列插入数据的时候没有显示的指定 DEFAULT 语句。Strict mode 也会影响到 create table 语句。而对于 strict mode 下的 select 语句，只会生成一个 warning，不会报错。 NO_ZERO_IN_DATE：在严格模式下,不允许日期和月份为零。（即将被废弃） NO_ZERO_DATE：不允许插入零日期。 ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中,如果数据被零除,则产生错误而非警告。如 果未给出该模式,那么数据被零除时MySQL返回NULL。 NO_AUTO_CREATE_USER：禁止GRANT创建密码为空的用户。 NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译,那么抛出错误。不设置此值时,用默认的存储引擎替代,并抛出一个异常。 ANSI_QUOTES：启用 ANSI_QUOTES 后，不能用双引号来引用字符串，因为它被解释为识别符。 PIPES_AS_CONCAT：将 || 视为字符串的连接操作符而非 或 运算符，和Oracle数据库一样，也和字符串的拼接函数 CONCAT() 相类似。 值得说明的是，sql_mode 是一个系统变量，因此改完可以直接对新连接生效。在启动文件中也有默认的配置： # my.cnf sql_mode = 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION' 几个小问题记录 设置了SQL Modes 后，会在新连接才生效。尤其是当 MySQL 前端有代理时，可能需要重启代理。 尤其现在使用 innodb 表的时候，还需要关注 innodb_strict_mode 系统变量，该变量会对 innodb 表进行额外的错误检查。 参考 https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html https://www.modb.pro/db/97536 ","date":"2022-05-12","objectID":"/posts/database/mysql-sqlmodes/:0:0","tags":["MySQL"],"title":"MySQL-SQL Mode详解","uri":"/posts/database/mysql-sqlmodes/"},{"categories":["MySQL"],"content":"last_insert_id() 注意要写在一个session里，不然没有意义。 ","date":"2022-04-01","objectID":"/posts/database/mysql-statement/:1:1","tags":["MySQL"],"title":"【MySQL】语句注意事项","uri":"/posts/database/mysql-statement/"},{"categories":["MySQL"],"content":"参数解析 ","date":"2022-03-31","objectID":"/posts/database/mysql-parameters/:1:0","tags":["MySQL"],"title":"[WIP]MySQL-参数和配置解析","uri":"/posts/database/mysql-parameters/"},{"categories":["MySQL"],"content":"性能相关 eq_range_index_dive_limit 当in（数据量较大时），将该参数配置成3，将会提高该语句的查询性能。 ","date":"2022-03-31","objectID":"/posts/database/mysql-parameters/:1:1","tags":["MySQL"],"title":"[WIP]MySQL-参数和配置解析","uri":"/posts/database/mysql-parameters/"},{"categories":["MySQL"],"content":"数据相关 lower_case_table_names 说明 0： 区分大小写 1：不区分大小写 另外，MySQL在Linux中的大小写规则如下： 数据库名和表名是严格区分大小写的。这个很好理解，可以看到库名和表名在data目录中实际表现为文件夹名和文件名，而Linux本身也是区分大小写的。 表的别名是严格区分大小写的。 列名与列的别名默认不区分大小写。 变量名也是严格区分大小写的。 详见官方解释： 0表示，表在文件系统存储的时候，对应的文件名是按建表时指定的大小写存的，MySQL 内部对表名的比较也是区分大小写的 1表示，表在文件系统存储的时候，对应的文件名都小写的，MySQL 内部对表名的比较是转成小写的，即不区分大小写； 2表示，表在文件系统存储的时候，对应的文件名是按建表时指定的大小写存的，但是 MySQL 内部对表名的比较是转成小写的，即不区分大小写。 0适用于区分大小写的系统，1都适用，2适用于不区分大小写的系统。 举例 最佳实践 最好是在一开始统一设置好此参数。操作过程中，不要修改此参数，如果真要改，要先检查下已有的表是否存在大小写问题。 业务方不要依赖MySQL 的大小转换机制，应用内SQL的表名应该跟MySQL中的一致。 max_allowed_packet 说明 限制 MySQL Server接收数据包的大小，线上默认为 64M。 slave_max_allowed_packet 说明 限制从库插入的数据包大小，默认设置为1G，太小可能会造成主从复制断开。 max_binlog_cache_size 说明 最大推荐值为 4GB，因为MySQL当前无法处理大于4GB的的二进制文件。该值必须是 4096 的倍数。 max_binlog_size 如果对二进制日志的写入导致当前日志文件大小超过此变量的值，则服务器会轮换二进制日志（关闭当前文件并打开下一个文件）。最小值为 4096 字节。最大值和默认值为 1GB。加密的二进制日志文件有一个额外的 512 字节标头，包含在 max_binlog_size. sql_mode ","date":"2022-03-31","objectID":"/posts/database/mysql-parameters/:1:2","tags":["MySQL"],"title":"[WIP]MySQL-参数和配置解析","uri":"/posts/database/mysql-parameters/"},{"categories":["MySQL"],"content":"存储引擎相关 ","date":"2022-03-31","objectID":"/posts/database/mysql-parameters/:1:3","tags":["MySQL"],"title":"[WIP]MySQL-参数和配置解析","uri":"/posts/database/mysql-parameters/"},{"categories":["MySQL"],"content":"超时相关 connect_timeout：默认为10S wait_timeout：默认是8小时，即28800秒 interactive_timeout：默认是8小时，即28800秒 net_read_timeout：默认是30S net_write_timeout：默认是60S https://www.cnblogs.com/igoodful/p/12470021.html ","date":"2022-03-31","objectID":"/posts/database/mysql-parameters/:1:4","tags":["MySQL"],"title":"[WIP]MySQL-参数和配置解析","uri":"/posts/database/mysql-parameters/"},{"categories":["MySQL"],"content":"配置解析 # 如果系统总内存为128G，如果设置为100G以上，则容易出现内存溢出，out of memory，导致mysqld被系统重启，日志在/var/log/message中;90G最佳，设置为70到80G，则更安全 innodb_buffer_pool_size = 90G # 这两个参数在主库设置双1，但从库设置为双0性能最佳，极为重要的性能参数 innodb_flush_log_at_trx_commit = 0 sync_binlog = 0 # 连接数限制 max_connections = 10240 max_user_connections = 4000 # 慢查询阈值，锁等待超时阈值 long_query_time = 0.5 lock_wait_timeout = 120 # 从库开启基于LOGICAL_CLOCK的并行复制 stop slave sql_thread; set global slave_parallel_type='LOGICAL_CLOCK'; set global slave_parallel_workers=16; start slave sql_thread; ","date":"2022-03-31","objectID":"/posts/database/mysql-parameters/:2:0","tags":["MySQL"],"title":"[WIP]MySQL-参数和配置解析","uri":"/posts/database/mysql-parameters/"},{"categories":["MySQL"],"content":"skip-slave-start # 实例启动的时候跳过建立主从关系，即禁止启动io线程和sql线程。 # 添加此参数可以避免启动的时候破坏从库数据。 skip-slave-start ","date":"2022-03-31","objectID":"/posts/database/mysql-parameters/:2:1","tags":["MySQL"],"title":"[WIP]MySQL-参数和配置解析","uri":"/posts/database/mysql-parameters/"},{"categories":["MySQL"],"content":"MySQL磁盘占用分析 MySQL作为存储，很容易想到的磁盘占用主要分为以下几种： 日志文件 数据文件 临时文件 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:1:0","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"日志文件 众所周知，MySQL 的 binlog （二进制日志） 会记录数据库的操作，一般线上会存储至少7天。当线上业务增删改请求太频繁，或者修改的行数过多时（因为为了线上数据安全，默认会使用row格式的binlog），会导致binlog文件增长很快 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:1:1","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"磁盘清理方式 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:2:0","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"日志文件清理 清理 binlog 文件 # 将binlog删除到mysql-bin.001174 mysql\u003e purge binary logs to 'mysql-bin.001174'; # 删除 2021-06-06 22:46:26 之前的binlog mysql\u003e purge binary logs before '2021-06-06 22:46:26'; # 将binlog自动保存时间从7天改为3天 mysql\u003e mysql\u003e set global expire_logs_days=3; ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:2:1","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"数据文件清理 一般数据文件清理需要业务方的配合，毕竟是业务方的数据。这里需要注意的是，仅仅删除数据可能不会直接释放空间。此时有两种方案： 机器磁盘还有较大空间。此时仅仅删除数据即可，新写入的数据会填补未使用的页。 机器磁盘空间已经不足。需要执行重建表操作，具体操作步骤为： # 1. 从库停止复制 mysql\u003e stop slave; # 2. 从库重建表 mysql\u003e alter table xx engine=innodb; # 3. 执行主库切换操作 # 具体见切库流程 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:2:2","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"大表清理 为了减小删除大文件引起数据库服务器 IO 抖动，可以对大文件进行shrink，减小删除数据对IO的影响。 # 待删除表：dest_table_del # 1.创建硬链接 $ln dest_table_del.ibd /home/work/data_bak/dest_table_del.ibd.hdlk # 2.删除表: $drop table dest_table_del; # 3.删除文件 # 从233 开始每次递减2 $for i in `seq 233 -2 2 `; do echo $i; sleep 2; /usr/bin/truncate -s ${i}G /home/work/data_bak/dest_table_del.ibd.hdlk;done ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:2:3","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"临时文件清理 从临时文件的原理可以看到，一般是由大 SQL 引起，所以直接找到大 SQL ，与业务方沟通完后杀掉即可。 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:3:0","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"其他解决方式 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:4:0","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"1. 联系业务删除数据 可能是最快的方式。 甚至可以让业务写定时删除数据的脚本，但是注意一次不要删除大量的数据，避免引起主从延迟。 当业务删除完数据后，去掉从库业务流量，并在从库执行释放空间操作 mysql\u003e stop slave; mysql\u003e alter table xx engine=innodb; 此处不用 optimize table的原因，其实optimize table实际上是 recreate + analyze 的步骤。 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:4:1","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"2. 大库迁移 当某个库数据量很大，且 QPS 不低，足以作为单独的集群时，可以进行迁移操作。具体的迁移步骤： 扩容从库 该库读流量打入新的从库，同业务共同观察业务 与业务沟通时间并进行写流量迁移 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:4:2","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"3. 申请大磁盘空间机器替换 具体操作步骤： 替换从库机器 主库切换 下线旧机器 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:4:3","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"总结 其实数据库的磁盘空间在日常运维工作中就是应该持续关注的事情。可行的策略是： 在磁盘占用还不是太高的时候（60%-80%）：增加日常巡检处理提醒，此时可以开始关注，如有大表，需联系业务开始处理，不至于在后面的改表或者磁盘空间快满时陷入被动。 磁盘已经告警时：参考解决方法。 最重要的还是主动解决，避免被动。 ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:5:0","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":["MySQL"],"content":"参考 大表删除操作：http://blog.itpub.net/22664653/viewspace-750408/ ","date":"2022-03-30","objectID":"/posts/database/mysql-disk/:6:0","tags":["MySQL"],"title":"MySQL-磁盘空间释放","uri":"/posts/database/mysql-disk/"},{"categories":null,"content":"test ","date":"2021-09-25","objectID":"/posts/kubernets/1-k8s-webhook/:1:0","tags":null,"title":"kubernetes之webhook","uri":"/posts/kubernets/1-k8s-webhook/"},{"categories":["生活"],"content":" 2020，仿佛还是刚刚开始，不过已经快要过完了。三月份一到周末就跟家人一起去爬山的日子感觉就在不久前，现在也已12月了，口罩从冬天戴到了冬天，感觉都已经记不起原来从没戴过口罩的生活是什么样的了。疫情影响着生活的大小方面，不过在此还是总结自己吧。 工作 首先在工作上，整体给自己打个70分吧。在整体完成方面觉得还不错了，做的事情也算是比较多了： 前端：由于去年用Python写了个系统，需要一些前端的展示，但是组内唯一的前端同学又排期不过来，于是就直接撸起了vue。甚至在Q2的时候，昨晚本身系统的前端后，还帮忙做了很多其他的需求。从最开始还没接触过js到后面开始已经踩了很多坑了，但是在写代码方面还不是很熟练，后续如果有时间希望还是能整体补一补。 日常项目：主要是围绕MySQL数据库的一些项目，来保证备份的数据、系统的高可用、数据传输等方面，技术栈用的go，不过因为项目数量比较多，虽然能够完成项目的任务，但是在项目的深层理解上还不够。在数据传输项目中，基本是由自己一个人主导，目前进展也相对比较顺利。 MySQL运维： 从年初接了100个实例的MySQL运维，到年底前又因为开发任务比较重把MySQL集群交接给新人。从开始接触时候的啥都不会，到把90%实例完成版本升级，交接后带着新人处理日常问题。这一点还是想给自己点个赞的，毕竟虽然这一年时间都有运维工作，但是在其他方面也都没落下过。 TiDB：由于很多业务量的增长，对TiDB的需求也有增加，下半年开始也有一部分工作重心在TiDB。目前主要工作是接入到内部系统中，在这一部分也基本是自己主导。也一直在学习TiDB相关的内容，中间还参加了一个TiDB的性能竞赛，拿了第三名。 回头看这些，工作量还是很饱满，以及在日常的工作中，也发现了自己的一些问题： 专注：工作量比较饱满，但是工作深度不够。不管是作为工具写了一两个月的前端，还是搭着做了一年的MySQL运维，在深度方面都有些欠缺，对于前端来说，可能后面也不一定会用到，但是基础是可以看看的。而对于MySQL，是很多工作的基础，需要随时补。另外后面也应该在多项工作中，找到专注的点，把这些点优先做好。 沟通表达能力： 其实以前并没有觉得自己表达的不好，可能是以前上学的时候也没往这上面说。现在工作期间，沟通交流基本上是每天都有，如何能够更好的表达自己，更有效的沟通来提高工作效率，是重要的技能。 学习 学习方面，今年真的是有点惭愧了。 读书：真的是一本都没有完整的读完，一本《经济学原理》教材看了一半，觉得讲的很好，但就是没看完。 编程方面： 主要还是在学在用Go，前端方面也没有系统的去学习，其实是学习了一点吧，但是又因为其他事情落下了。 生活 ","date":"2020-12-26","objectID":"/posts/daily/2020_summary/:0:0","tags":["生活","日常总结"],"title":"2020年总结","uri":"/posts/daily/2020_summary/"},{"categories":["生活"],"content":"重要事件 今年最重要的事情就是新冠疫情了，而且已经持续了一年，现在到了年底，又开始蠢蠢欲动了。不知道什么时候能开始成为大家的回忆了。 买房。从毕业开始就在酝酿，今年来上班已经是五月了，来之后开始关注，到7月底买，算是一件大事了。 娱乐：能算是娱乐的比较多了。 旅游：除了年初去北京出差学习回来后，都没出过省了 体重： 继续保重中 Hello，2021 ","date":"2020-12-26","objectID":"/posts/daily/2020_summary/:1:0","tags":["生活","日常总结"],"title":"2020年总结","uri":"/posts/daily/2020_summary/"},{"categories":["生活"],"content":"工作 专注、增加深度：在把事情做好的同时，能够更多的思考，而不是停留在表面。 提高沟通表达能力： 说话慢一点；说话是为了让别人听明白，而不是自己明白；时常注重梳理好逻辑，不至于在讨论问题时被带偏 ","date":"2020-12-26","objectID":"/posts/daily/2020_summary/:2:0","tags":["生活","日常总结"],"title":"2020年总结","uri":"/posts/daily/2020_summary/"},{"categories":["生活"],"content":"学习 技术能力： 没啥可说的，一直都是最重要的。但是毕竟时间有限，优先做好什么。 看书：每年都给自己一点目标，但是好像都没有完成，今年还是继续定一下，继续看自己的脸皮：12本吧，一个月一本了。 博客：坚持，每月一篇；重在输出，而不是记录。学习过的内容，能够按照自己的想法写出来，这样才是更好的掌握。 ","date":"2020-12-26","objectID":"/posts/daily/2020_summary/:3:0","tags":["生活","日常总结"],"title":"2020年总结","uri":"/posts/daily/2020_summary/"},{"categories":["生活"],"content":"生活 慢一点：关注身边有趣有意义的事情，记录一些重要的事情和节点。 体重：减重10%？ 旅游：疫情如果允许就出去玩一次。 娱乐：注重半衰期更长的娱乐（运动、电影、纪录片之类），杜绝无营养的短视频和无聊的游戏（浪费时间又无法从中体验到该有的愉悦感，比如最近开始捡起来玩的dota2。。） 其他折腾： 功利的对待自己的时间。 最后，2021年，继续加油，最后附上一张小豆的照片吧。 ","date":"2020-12-26","objectID":"/posts/daily/2020_summary/:4:0","tags":["生活","日常总结"],"title":"2020年总结","uri":"/posts/daily/2020_summary/"},{"categories":["MySQL"],"content":"Binlog作为MySQL重要的灵魂之一，在MySQL的主从同步、问题定位、数据恢复、增量备份等都发挥着重要的作用。也是MySQL多年来被大家信任的原因之一，同时Binlog也随着MySQL的流行被大家熟知，不过对于很多人来说，只是知道Binlog记录MySQL操作的功能，以及做过简单的解析查看操作SQL，却并没有深入。最近与Binlog交流比较多，就正好梳理下。 什么是Binlog Binlog是MySQL server层的日志，记录MySQL的数据更新或潜在更新的SQL语句。Binlog是与innodb引擎中的undo log和redo log不一样的 ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:0:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"Binlog作用 binlog的作用主要包括： 主从同步：在一个MySQL集群中，从库通过拉取主库的Binlog，在本地进行回放执行，从而同步主库的数据更新，达到主从同步的目的。主从同步也是一般生产环境MySQL服务高可用的必要保障。 数据恢复：作为一个数据存储工具，可能存在写错数据的情况，需要回滚到某一时间点，可以通过解析Binlog，通过binlog2sql等工具，来闪回到指定的时间点。 增量备份：一般生产环境都会对MySQL数据进行定期的备份，以应对MySQL集群的快速扩容、版本升级等需求，全量备份耗时较长，且占用空间较多，因此一般采用全量备份+增量备份的方式对集群数据进行备份，其中增量备份备份的就是Binlog。 问题定位：由于所有的数据更新都会记录在Binlog中，所以Binlog也是解决问题的一把好手，通过分析Binlog，有时是快速解决问题的途径。 ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:1:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"Binlog格式 Binlog格式分为三种：statement、row、mixed statement：记录数据更新的SQL。意思是binlog记录数据更新的语句，优点是节省binlog日志量，减少磁盘占用（只是在部分时候）。这种方式很简单，但是会存在问题，比如SQL中出现了now()等函数，还需要保存语句执行时候的一些信息，才能使语句在回放的时候不至于数据不一致。但是仍然有一些函数无法被复制。 row：记录数据变更的行记录。记录每一行被更改的记录，这样就能保证函数的执行也能被完全的记录，问题是，如果某条语句更新的行数较多（如变更表结构），会产生较多的Binlog，日志量增长很大。 mixed：是statement和row格式的一种折中，结合了两者的优点。会自动切换采用row还是statement格式，但是还是会存在数据不一致的问题。级联复制在特殊情况下会binlog丢失。 在实际生产环境中，为了保证数据完全一致，还是会采用row格式的binlog，毕竟作为底层软件，首先应该保证正确，其次才是节省。 ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:2:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"Binlog何时写入 Binlog在事务commit前才会写入（由于innodb的两阶段提交，会先写Binlog再写redo log）。 同时binlog的写入会通过参数sync_binlog 控制，如果设置为0，则表示不会主动控制Binlog的刷新，由文件系统控制缓存的刷新，设为0安全，当MySQL异常重启会丢失缓存中的事务。一般生产环境主库会设置为1，保证每次事务都能被写到磁盘。 ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:3:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"与其他日志的区别 使用Binlog ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:4:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"MySQL配置 Binlog的配置有一下几个参数 log_bin = on # 开启binlog binlog_format = row # binlog格式为row log_bin = /home/work/mysql/log/mysql-bin.log # binlog 位置 expire_logs_days = 7 # binlog清理周期7天 max_binlog_size = 1G # binlog文件大小 sync_binlog = 1 # binlog刷盘控制，为1表示每次事务都会刷盘 max_binlog_cache_size = 2147483648 # 最大binlog缓存大小，如果一个事务的binlog超过此大小，会报错 binlog_rows_query_log_events = on # 展示SQL ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:5:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"查看Binlog ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:6:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"查看Binlog信息 # 查看现有的binlog文件 mysql\u003e show binary logs; +------------------+-----------+ | Log_name | File_size | +------------------+-----------+ | mysql-bin.000001 | 142554153 | +------------------+-----------+ # 查看当前binlog位点 mysql\u003e show master status\\G *************************** 1. row *************************** File: mysql-bin.000001 Position: 142556517 Binlog_Do_DB: Binlog_Ignore_DB: Executed_Gtid_Set: 727332c9-1a67-11eb-8021-fa163e7d3507:1-841889, 73841e3c-ec47-11ea-9d43-fa163e263d6f:1-150 # 清理binlog PURGE BINARY LOGS TO 'mysql-bin.000001'; # 清理到 PURGE BINARY LOGS BEFORE '2014-04-28 23:59:59'; # 查看binlog事件 show binlog events in 'mysql-bin.000001'; ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:6:1","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"远程查看 mysqlbinlog -R -hhostname -uroot -p123456 mysql-bin.000001 \u003e binlog.sql ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:6:2","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"本地查看 mysqlbinlog --base64-output=DECODE-ROWS --start-position=start_position --end-position=end_position --start-time=start_time --end-time=end_time -v -v mysql-bin.000776 | less Binlog内容 ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:6:3","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"Binlog基本格式 如官方文档所说: binlog文件以一个值为0Xfe62696e的魔数开头，这个魔数对应0xfe ‘b’‘i’’n’。 binlog由一系列的binlog event构成。每个binlog event包含header和data两部分。 ​ header部分提供的是event的公共的类型信息，包括event的创建时间，服务器等 ​ data部分提供的是针对该event的具体信息，如具体数据的修改 最后一个rotate event用于说明下一个binlog文件 binlog索引文件是一个文本文件，其中内容为当前的binlog文件列表。比如下面就是一个mysql-bin.index文件的内容 以执行一个insert语句为例，会产生如下几个binlog event。 ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:7:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"Binlog事件解析 注意 ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:8:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"事务的写入顺序 Reference： 官方Binlog解析 https://www.cnblogs.com/igoodful/p/11920740.html ","date":"2020-11-05","objectID":"/posts/database/mysql-binlog/:9:0","tags":["MySQL"],"title":"【MySQL】Binlog详解","uri":"/posts/database/mysql-binlog/"},{"categories":["MySQL"],"content":"01 | 基础架构：一条 SQL 查询语句是如何执行的？ 配置： wait_timeout：控制 Sleep 连接保持时间。线上未配置，默认 8 小时， SQL 执行步骤 客户端-连接器（管理连接、权限验证）-查询缓存（命中则直接返回，基本没啥用）-分析器（词法分析、语法分析，语法错误在这就能看到了）-优化器（执行计划生成、索引选择）-存储引擎（存储数据、提供读写接口） server 层 连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 存储引擎 负责数据的存储和提取。 ","date":"2020-06-23","objectID":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/:0:0","tags":["MySQL","学习"],"title":"MySQL45讲总结","uri":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/"},{"categories":["MySQL"],"content":"连接器 Sleep：表示是空闲连接。 数据库长连接和短连接： 长连接是连接成功后，如果客户端持续有请求，则一直使用同一个连接。优点：减少建立连接的动作，尽量使用 短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 全部使用长连接问题：可能 MySQL 占用内存会涨的很快，因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的，会在连接断开才释放，如果长连接积累，会导致内存占用较大。 解决办法：定期断开长连接；5.7 版本，执行比较大的操作的后，mysql_reset_connection 来重新初始化连接资源，恢复连接到刚刚创建时的状态。miproxy 连接数太多会自己断开 内存：操作系统 10G，应用 8G， 线程级别的内存占用， 一个连接占多大，tcp 占 1M，文件系统描述符。 为啥会用 swap 内存， 操作系统配置：是否使用 swap cpu 结构有关 对称一致访问：每个核心访问最近的 32G 内存最快，开了的话，cpu0 访问 32G，这个进程用了 32G 就会用 swap 分区。 smp numa ","date":"2020-06-23","objectID":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/:0:1","tags":["MySQL","学习"],"title":"MySQL45讲总结","uri":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/"},{"categories":["MySQL"],"content":"查询缓存 基本没用了 ","date":"2020-06-23","objectID":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/:0:2","tags":["MySQL","学习"],"title":"MySQL45讲总结","uri":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/"},{"categories":["MySQL"],"content":"分析器 词法分析：识别关键字，以及表名之类。 语法分析：根据语法规则判断语法是否错误。 ","date":"2020-06-23","objectID":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/:0:3","tags":["MySQL","学习"],"title":"MySQL45讲总结","uri":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/"},{"categories":["MySQL"],"content":"优化器 索引顺序选择，多表 join 顺序等。 ","date":"2020-06-23","objectID":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/:0:4","tags":["MySQL","学习"],"title":"MySQL45讲总结","uri":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/"},{"categories":["MySQL"],"content":"执行器 执行前判断对表有没有相应权限。（没分析完词法，不知道是哪张表） 问题： 1.Sleep 连接是不是杀了一直没影响 2.miproxy 对连接的管理：长短连接，长连接的维护。功能怎么实现的， 3.MySQL 内存的使用。（innodb_buffer_size_pool 之外的内存）。 4.数据库权限和表权限验证时间不一样 02 | 日志系统：一条 SQL 更新语句是如何执行的？ 线上配置： innodb_flush_log_at_trx_commit：为 1 时保证每次事务的 redo log 都会持久化到磁盘。 sync_binlog：为 1 时保证每次事务的 binlog 都持久化到磁盘。 更新流程：两阶段提交，涉及和 binlog | | | | | | redo log 存储引擎层 物理日志（记录在哪个数据页上做了什么修改） 大小固定，循环写 binlog server 层 逻辑日志（记录原始语句，对某行数据做了什么修改） 追加写 redo log：保证了 MySQL crash-safe 能力。记录更新时，先把记录写到 redo log 并更新内存。 binlog：。。， crash-safe：有了 redo-log，可以保证数据库异常重启时，从 redo log 读取后写入内存再写入磁盘，保证数据部丢失。 两阶段提交： 更新写入到内存后，redolog 处于 prapare 阶段，然后写 binlog，再调用引擎的提交事务接口，将 redolog 改成提交状态。 server 是作为一个协调者。innodb 只知道干啥。发起 commit 时候，innodb redo write innodb 没完成不能马上写磁盘。 MySQL 磁盘满，会休眠，磁盘满。innodb 队列变长了，可能都建立连接不成功：gdbc 建立连接会 show 变量，要不建立连接不成功，要不就连接数暴涨。 原因：如果在写完 binlog 到提交事务之间 MySQL crash 的问题。或者从备份恢复的时候。 问题： 备份恢复 apply log 是在：将 redo log 的数据写入磁盘吗？ 03 | 事务隔离：为什么你改了我还看不见？ 线上配置： 事务 ACID：Atomicity、Consistency、Isolation、Durability（原子性、一致性、隔离性、持久性） 多个事务同时执行会出现的问题：脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read） 隔离级别： 读未提交：可以看到未提交的事务 读提交：只有提交的事务才会被看到 可重复读：一个事务执行过程中看到的数据，总是和启动时看到的一样。不管其他的事务有没有启动。 串行化：顾名思义 | 脏读 不可重复读 幻读 视图开启时间（对于一个查询） 读未提交 0 0 0 直接返回记录最新值 读提交 1 0 0 SQL 执行时创建，此时有别的事务修改记录也可以看到 可重复读 1 1 0 事务启动时创建，事务启动后的改动都看不到 串行化 1 1 1 每次都加锁，避免并行 幻读的原因：update 等操作的当前读，需要读取当前的数据，这个时候就会读到最新的更新数据了。表现为：单独 select 没有值，然后 insert 或者 update，发现值已经有了。 MVCC：undo log 实现 04 | 深入浅出索引（上） innodb 索引类型： 主键索引和：根据叶子节点的内容 主键索引：叶子节点内容是整行数据 非主键索引：叶子节点内容是主键的值。也叫二级索引。使用二级索引，如果想获得整列的值，需要先从索引找到主键值，然后再根据主键查，需要回表。 索引维护： 分裂：某个数据页满了，新插入数据的时候。 合并：相邻两个页删除了数据，利用率很低的时候。 ps：自增主键是不会分裂的，因为一直是增长的。 问题： 1.同时插入较多数据时，索引维护是不是比较占资源。 2.业务字段做主键：只有一个索引；该索引必须是唯一索引？ 05 | 深入浅出索引（下） 避免回表的方式： 覆盖索引（组合索引）： 索引使用注意： 1.最左前缀原则：不管是对于组合索引，还是对于 2.索引下推：MySQL5.6 优化，多个 and 条件的时候，对索引中的字段先过滤，减少回表次数。 2.索引列使用函数会导致索引失效 06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？ 加锁范围分类：全局锁、表级锁和行锁。 全局锁 加全局锁方法：Flush tables with read lock (FTWRL)。使用场景：全库逻辑备份（innodb 已经不需要了，可以使用–single-transaction） 表级锁 分为表锁和元数据锁（MDL） 表锁：lock tables … read/write。 元数据锁：当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。所以给小表加字段，如果读取较多的话，也会阻塞，会阻塞所有的查询和更新，如果客户端有重试机制，会导致该库线程打满。 尽量使用 FTWRL 而不是 set global read_only=1： 1.read_only 可能会用来判断是主库还是备库。 2.FTWRL 命令时，如果客户端异常断开，MySQL 会自动释放，set global read_only 会导致 MySQL 一直只读。 07 | 行锁功过：怎么减少行锁对性能的影响？ 线上配置： innodb_lock_wait_timeout：10 innodb_deadlock_detect：on 两阶段锁协议：行锁在需要的时候才加上，但是在事务结束后才释放。所以要把可能影响并发的锁放在后面。 死锁和死锁检测策略： 一直等待到超时：innodb_lock_wait_timeout：一直等待锁，直到超时。值不能太大，也不能太小。 死锁检测：发现死锁后，主动回滚死锁链条中的某偶一个事务，让其他事务执行。 问题： 死锁检测成本：每个新来的线程，都要要判断会不会由于自己的加入导致死锁，如果同时更新同一行的线程很多的时候。CPU 消耗。 原理怎么做的。 08 | 事务到底是隔离的还是不隔离的？ undolog：实现了 MVCC 数据可见性，锁是实现隔离级别。 查询和更新是当前读还是一致性读。 一致性读：可重复读隔离级别下，读取数据时，会根据 row trx_id 找到是否能读到当前值，不在的话会根据 redo log 往前找。 当前读：操作数据都是要读当前。可重复读隔离级别下，如果需要更新数据，只能拿最新的数据更新，这个时候虽然别的事务还没有提交，但还是能看到的。 undolog 大小。共享表空间 09 | 普通索引和唯一索引，应该怎么选择？ 12 | 为什么我的 MySQL 会“抖”一下？ 线上配置： innodb_flush_neighbors：1 innodb_io_capacity：5000 innodb_max_dirty_pages_pct：75 为什么会抖一下： 1.redo log 满了。redo log 中的 checkpoint 前移动，需要刷脏页。（应该避免，因为此时数据库服务已经阻塞，需要控制刷脏页频率） 一般不会设置，不同百分比的时候不一样。 2.内存不足，需要淘汰脏页。buffer_pool 3.日常刷脏页。对应 MySQL 的配置。 4.MySQL 正常关闭。 正常使用的数据库，buffer 一般未被使用的情况比较少，如果一个查询，需要的内存比较大，查询需要从磁盘读取很多页的时候，也要将脏页刷到磁盘中。 可用的页，刷脏页，写到磁盘，redolog checkpoint 往前走，free list flush list lru list 脏页刷盘参考：一个是脏页比例，一个是 redo log 写盘速度。 如果高配机器 redo log 设置比较小的话：redo log 很容易被写满，就会导致经常要因为 redo log 满了而刷盘。表现为：磁盘压力很小，但是数据库出现间歇性的性能下跌 13 | 为什么表数据删掉一半，表文件大小不变？ ：怎么正确的回收表空间 innodb_file_per_table：1 默认值 删除整个表数据会删除，但是删除表中的部分数据，空间是怎么回收的。 delete 删除一条记录：将记录标记为已删除，之后可以复用。 delete 删除多条记录：如果整个页被删除，则整页都被标记为可复用。相邻的两页使用率低，会合并。但空间均不会被释放。同理：插入数据，如果当前页已满，肯定会开启新页，也会造成数据空洞。 压缩空间：alter table A engine=InnoDB。5.5 之前不要用，会阻塞 DML。5.6 版本之后：Online DDL（先建新表，并将旧表的更新写在一个文件中，新表搞好之后，再读取文件中的更新。会有很短时间的 MDL 写锁） DDL 过程如果是 Online 的，就一定是 inplace 的？ 14 | count(*)这么慢，我该怎么办？ 不加 where 条件： MyISAM 引擎：把一个表的总行数存在了磁盘上，因此执行 count(*)的时候会直接返回这个数，效率很高； InnoDB 引擎：数据一行一行地从引擎里面读出来，然后累积计数。 show table status：不准确。 加 where 条件： InnoDB 引擎：选择从引擎读 效率排序：count(字段)\u003ccount(主键 id)\u003ccount(1)≈count() count()：特殊处理过，因为不会为 nu","date":"2020-06-23","objectID":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/:0:5","tags":["MySQL","学习"],"title":"MySQL45讲总结","uri":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/"},{"categories":["MySQL"],"content":"全字段排序 排序过程对字符串做了“紧凑”处理。即使 name 字段的定义是 varchar(16)，在排序过程中还是要按照实际长度来分配空间的。 max_length_for_sort_data ","date":"2020-06-23","objectID":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/:1:0","tags":["MySQL","学习"],"title":"MySQL45讲总结","uri":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/"},{"categories":["MySQL"],"content":" rowid 排序 ","date":"2020-06-23","objectID":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/:2:0","tags":["MySQL","学习"],"title":"MySQL45讲总结","uri":"/posts/database/mysql45%E8%AE%B2%E6%80%BB%E7%BB%93/"},{"categories":["MySQL"],"content":" MySQL的配置项很多，日常使用中需要调整的并不多，整理几个主要的参数 性能相关 复制相关 ","date":"2020-03-05","objectID":"/draft/mysql_errs/:0:0","tags":["MySQL"],"title":"【MySQL】MySQL常见配置","uri":"/draft/mysql_errs/"},{"categories":["golang"],"content":"配置了 Ubuntu 相关编程环境，学习 Go 语言基础内容，主要是跟着官方教程走一遍，对比 C++的一些不同点学习。 一.Go 语言变量、函数 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:0:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"1.变量的初始化 可以通过 var a int 或者采用 a:=3 省略变量的类型，Go 语言会自动推导变量的类型。 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:1:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"2.Go 语言的基本类型 多了一个 rune 类型，教程里没有仔细介绍，也很少使用，之后再注意。 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:2:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"3.类型转换 Go 语言中不同类型的项之间需要显示转换，没有隐式类型转换。 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:3:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"4.函数有多返回值 二.Go 语言中的流程控制 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:4:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"1.Go 语言中的循环只有 for 所有的循环都采用 for 来实现，for 的使用与 C++类似，但是 for 后面不需要小括号，一定需要大括号。 可以在 for 循环中定义变量，但作用于只在 for 循环中。 需要注意的是，Go 语言只有后置++，没有前置++。 另外，for 语句中可以有空项，但是分号要写上。 当 for 用来写 while 循环时，可以直接采用 for i\u003c100{} ，不需要写上全部分号。 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:5:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"2.if 语句 if 语句表达式外不需要小括号，但是一定需要大括号，这点与 for 语句的使用是类似的。 可以在 if 语句中执行一个简单的语句，分号隔开后再加判断语句。 同样，else 后面也需要大括号 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:6:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"3.switch 语句 Go 语言的 switch 中的 case 可以不是常量，也可以不是整数。 Switch 中的 case 语句，自带 break，不需要再写 break。 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:7:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"4.defer 语句 defer 语句会推迟到外层函数执行结束后执行。 defer 语句会压栈，当有多个 defer 语句时，后面的 defer 语句会先执行。 三.slice 切片就像数组的引用，改变切片会改变底层的值 切片的默认行为，可以不写完整的上下限，切片默认有上下限 只是截取切片是不会改变切片大小的 切片的长度就是它所包含的元素个数，容量是从它的第一个元素开始数，到其底层数组元素末尾的个数 切片的零值是 nil 四.主要问题记录 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:8:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"1. fmt.Println()函数中的执行顺序问题 当 Println()中打印多个函数的执行结果时，Println()会先顺序调用每个函数，将其结果保存，之后再顺序打印。例子如下： package main import \"fmt\" func add(x,y int) int{ sum:=x+y fmt.Println(sum) return sum } func main(){ fmt.Println(add(1,2),add(2,3)) } 执行结果为： 3 5 3 5 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:9:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["golang"],"content":"2.切片的容量扩展问题 类似于 C++中的 vector，切片的容量扩展，大部分时候也是采用 2 倍扩展，但是也有稍许的差别，在学习过程中无意发现，查看源码可以看到 append 的实现。就 int 而言，当元素个数小于 20 时，当 slice 的容量不够时，继续 append 会将 cap+1，超过 20 后才会 cap*2。 ","date":"2019-09-12","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/:10:0","tags":["golang","学习"],"title":"go语言基础学习(3)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/"},{"categories":["工具"],"content":"博客基本架构 如下图所示，博客更新只需要在语雀上发布对应的文章即可，剩下的工作都会自动化进行。 ","date":"2019-08-13","objectID":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/:1:0","tags":["Hexo","博客"],"title":"Hexo折腾笔记","uri":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"categories":["工具"],"content":"对应工具 语雀：编写博客 腾讯云云函数: webhook 解析更新文档推送至 github 私有仓库 travis-ci：当私有仓库有更新时，通过 hexo 生成静态页面，并推送至 mianhk.github.io 仓库 cloud-flare：网页 CDN ","date":"2019-08-13","objectID":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/:2:0","tags":["Hexo","博客"],"title":"Hexo折腾笔记","uri":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"categories":["工具"],"content":"2019-5-12 没错，这几天又开始折腾一下博客了，最近的节奏天天白天待在实验室怼论文，晚上看 C++，时间安排比较紧凑，就觉得更需要阶段性的总结吧，所以又来写博客了，github 始终是一个好的选择，于是入了 Hexo 的坑。。折腾的过程心情总是有些复杂，在激动和 mmp 之间徘徊，虽然很多问题在 wiki 和 issue 里都有，但还是想总结一下自己亲自踩的坑。 修改语雀自动同步，不用再本地编辑和推送了，见： https://www.yuguocong.cn/yuque/mwklk2.html 更换了主题：Aircloud ","date":"2019-08-13","objectID":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/:3:0","tags":["Hexo","博客"],"title":"Hexo折腾笔记","uri":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"categories":["工具"],"content":"2018-12-24 ","date":"2019-08-13","objectID":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/:4:0","tags":["Hexo","博客"],"title":"Hexo折腾笔记","uri":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"categories":["工具"],"content":"Hexo 添加分类 在文件中使用categories，然后配置themes/_config.yml文件： menu: home: / #categories: /categories/ archives: /archives/ tags: /tags/ books: /books movies: /movies friends: /categories/friends about: /categories/about ","date":"2019-08-13","objectID":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/:4:1","tags":["Hexo","博客"],"title":"Hexo折腾笔记","uri":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"categories":["工具"],"content":"添加背景图片 使用插件 jquery-backstretch，编辑文件/themes/next/layout/_layout.swig,将下面的代码添加到最后面 body 的前面: \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js\"\u003e\u003c/script\u003e; \u003cscript\u003e $(\"body\").backstretch(\"http://blog-1252063226.cosbj.myqcloud.com/network/20181224194730.png\"); \u003c/script\u003e \u003c/body\u003e 但是好像没有效果，于是在文件themes\\next\\source\\css_custom\\custom.styl中添加了如下： body { background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; } //修改背景的不透明度 .main-inner { margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.8; min-height: 500px; } ","date":"2019-08-13","objectID":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/:4:2","tags":["Hexo","博客"],"title":"Hexo折腾笔记","uri":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"categories":["工具"],"content":"使用 hexo-neat 进行压缩以增加页面速度 采用hexo-neat进行压缩，插件地址为：https://github.com/rozbo/hexo-neat，使用步骤为： #安装hexo-neat $ npm install hexo-neat --save 添加配置到根目录下的_config.yml，在最后加上(这里跟别人的有一些改动，因为有一些配置出了问题，找了很久，但是还是没有解决，干脆就不折腾了): # hexo-neat # 博文压缩 neat_enable: true # 压缩html neat_html: enable: true exclude: - '**/*.html' # 压缩css neat_css: enable: true exclude: - '**/*.min.css' # 压缩js neat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js' 不用再做其他的改动，压缩前后的对比为： 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 修改``代码块自定义样式 打开\\themes\\next\\source\\css\\_custom\\custom.styl,向里面加入：(颜色可以自己定义): // Custom styles. code { color: #ff7600; background: #fbf7f8; margin: 2px; } // 大代码块的自定义样式 .highlight, pre { margin: 5px 0; padding: 5px; border-radius: 3px; } .highlight, code, pre { border: 1px solid #d6d6d6; } 添加访问量 打开\\themes\\next\\layout\\_partials\\footer.swig文件,搜索\u003cdiv class=\"copyright\"\u003e，在这个div标签前边加上如下代码: \u003cscript async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e\u003c/script\u003e 然后再在合适的位置添加如下代码，放在 footer.swig 文件的末尾: \u003cdiv class=\"powered-by\"\u003e \u003ci class=\"fa fa-user-md\"\u003e\u003c/i\u003e\u003cspan id=\"busuanzi_container_site_uv\"\u003e 本站访客数:\u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e \u003c/span\u003e \u003c/div\u003e 设置博文内链接为蓝色 通过路径：themes\\next\\source\\css\\_common\\components\\post\\,打开post.styl文件，在文件中添加，如下字段： .post-body p a{ color: #0593d3; border-bottom: none; \u0026:hover { color: #0477ab; text-decoration: underline; } } 设置文章末尾”本文结束”标记 显示每篇文章字数 文章末尾添加版权说明 直接修改主题配置文件，定位到post_copyright，将enable由false改为true即可。 # Declare license on posts post_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 实现 fork me on github 在右上角或者左上角实现 fork me on github。 点击这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码： \u003ca href=\"https://github.com/you\"\u003e\u003cimg style=\"position: absolute; top: 0; left: 0; border: 0;\" src=\"https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png\" alt=\"Fork me on GitHub\"\u003e\u003c/a\u003e 粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在\u003cdiv class=\"headband\"\u003e\u003c/div\u003e的下面)，并把href标签改为 github 地址： 修改文章底部的#号标签 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=\"tag\"\u003e#，将其中的 #换成\u003ci class=\"fa fa-tag\"\u003e\u003c/i\u003e 添加搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： npm install hexo-generator-searchdb --save 编辑 站点配置文件 （站点根目录下），新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件 （主题目录下），启用本地搜索功能： # Local search local_search: enable: true 图床修改 由于以前都是直接使用的 github 私人仓库做的图床，但是有时候就是访问不到，因为博客是采用双部署的，可能 coding 上的已经是外链了被屏蔽了，所以还是得想点别的办法了。 看到网上说的各种，其实都还是有点问题，最终发现最近的腾讯对象存储，发现还真的可以。 软件名：picgo 链接：https://sspai.com/post/42310 使用方法：https://github.com/Molunerfinn/PicGo/wiki/详细窗口的使用#v5 版本说明 Next 主题个性化之自动更换背景图片 https://blog.csdn.net/mango_haoming/article/details/78473243 修改主题：yilia（已取消） https://github.com/litten/hexo-theme-yilia 2018-4-22 加入畅言评论（已取消） 详见：https://blog.csdn.net/lcyaiym/article/details/76762074 2018-4-10 加入豆瓣读书和电影 详细见：https://github.com/mythsman/hexo-douban 页面中文无法显示的问题 这种中文问题，基本上都是编码的问题，但是开始各种都没找到原因，改了 language 里面的配置文件，最后发现是文件的编码，需要改成’无 bom 的 utf-8 的编码格式 ' 主界面无法显示 categories 和 tags 的问题 这个问题真的是搞的有点久，因为基本上都被人忽略了，也可能很多人都没遇到而我恰好遇到了吧，不懂前端的我只能对于这种玄学问题强行百度了。 解决办法：将 categories 和 tags 目录下的 index 文件分别改成： categories: type: \"categories\" layout: \"categories\" tags: type: \"tags\" layout: \"tags\" 折腾完又不早了，希望以后好好看书，好好编程吧，最近没有什么特别大的梦想，只想安静的学习。。。 绑定 gitpages 到自己的域名 打开学生包，通过教育邮箱申请之后，可以在 package 中找到那么 namecheap，注册通过 GitHub 进入，可以直接申请域名，会自动绑定到我们的 gitpage，不过还需要一点点修改，就是把 cname 的 www 改成我们的 gitpage 页面，就可以了。。 采用 coding 和 gitpages 双部署 采用双部署的原因是国内访问 github 的速度有时候太感人了，有些人直接打不开，搞得有点尴尬，于是看到了网上所说的双部署，将默认的国内地址解析到 coding 的 pages 服务上，其他的绑定到 gitpage 上，这样国内的访问速度就快了。 具体的 coding pages 的搭建就不写了，在 coding 网站中建好仓库后，在我们本地的 config 文件后面的 push repository 加上 coding page 仓库的地址就可以了。 具体的 cname 记录和 A 记录如下图： ** Reference: ** 域名操作 Hexo 文档 Next 主题文档 绑定到 coding Hexo 搭建的 GitHub 博客之优化大全 解决 Travis CI 总是更新旧博客的问题 修改背景图片 Hexo 添加分类 云端写作，自动部署 静态博客使用语雀编辑器 ","date":"2019-08-13","objectID":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/:4:3","tags":["Hexo","博客"],"title":"Hexo折腾笔记","uri":"/posts/tools/hexo%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":" 类型别名 type S string 与 type S = string 区别？ type S string 是类型声明，S 是一种新的类型，给 S 定义的方法，接口等和 string 没有关系。 而 type S = string 只是一种别名，可以理解为，S 和 String 是完全一样的，只是换了一种叫法而已。类型别名和原类型方法是一样的。也不能在 Switch 中使用两者同时作为分支。 go 语言中没有按地址传递，可以深究一下如何传递 slice，再回复到邮件中 Go 语言中只有按值传递，通过源码可以看到，slice 是一个结构体。结构体中包括真正的数组和长度以及容量。 type slice struct { array unsafe.Pointer len int cap int } 函数传递 slice 时，其实传递的 slice 结构体，其中包括 array 的首地址、len 和 cap。通过下面的代码可以有以下的结果: func add_slice(a []int){ a[0]=2 a[1]=3 return } func append_slice(a []int){ a=append(a,5) } func modify_slice(a *[]int){ *a=append(*a,6) } func main(){ a:=[]int{1,2,3} add_slice(a) fmt.Println(a) //输出[2 3 3] append_slice(a) fmt.Println(a) //输出[2 3 3] modify_slice(\u0026a) fmt.Println(a) //输出[2 3 3 6] } 只是改变 slice 内部的值时，看起来像是按引用传递，因为可以改变 slice 内的值，但是实际上是在参数传递的过程中，传递了 array 的首地址，而 slice 在内存中是一连串的地址，所以知道首地址就可以修改整个数组内部的值。 但是由于是按值传递，所以不能在函数内对 slice 进行 append。如果需要改变 slice 的长度，可以通过传入 slice 的指针。 由于 slice 传递的形式，需要在编程中多多注意，避免进坑。另外看到一个关于传递 slice 的操作，加深了一下对 slice 传参的理解。 func main() { a := []int{7,8,9} b:=[]int{} b=append(b,1,2,3) //a,b初始化的方式不一样，导致两者的cap不一样 fmt.Printf(\"a len: %d cap:%d data:%+v\\n\", len(a), cap(a), a) //a len: 3 cap:3 data:[7 8 9] fmt.Printf(\"b len: %d cap:%d data:%+v\\n\", len(b), cap(b), b) //b len: 3 cap:4 data:[1 2 3] append_slice(a) //显然append是没有效果的 fmt.Printf(\"a len: %d cap:%d data:%+v\\n\", len(a), cap(a), a) p := unsafe.Pointer(\u0026a[2]) //根据slice在内存的连续性，拿到最后一位的指针地址 q := uintptr(p)+8 //将指针往后移一位，因为是int，所以是8 t := (*int)(unsafe.Pointer(q)) fmt.Println(*t) //输出0 append_slice(b) fmt.Printf(\"b len: %d cap:%d data:%+v\\n\", len(b), cap(b), b) p1 := unsafe.Pointer(\u0026b[2]) q1 := uintptr(p1)+8 t1 := (*int)(unsafe.Pointer(q1)) fmt.Println(*t1) //输出10 } func append_slice(a []int) { a = append(a, 10) } 可以看到，直接 append 到 slice 的值，如果 cap 够的话，是会 append 上的，但是由于 len 的值没有改变，所以看不到，可以通过 unsafe 指针观察到结果。但是如果 cap 不够，继续 append，会导致重新分配内存空间，append 在新的位置上，此时通过 unsafe 指针也拿不到 append 的值。 关于函数的执行顺序： func add1(x,y int) int{ fmt.Println(\"in add1. sum1= \",x,y) return x+y } func add(x,y,z,t int) int{ sum:=0 sum=add1(x,y)+add1(z,t) fmt.Println(\"in add. sum=\",sum) return sum } func main(){ fmt.Println(add(1,2,3,4),add(2,3,4,5)) } 结果： in add1. sum1= 1 2 in add1. sum1= 3 4 in add. sum= 10 in add1. sum1= 2 3 in add1. sum1= 4 5 in add. sum= 14 10 14 可以看到，add1 的结果是最先执行的，再执行 add，最后才执行 fmt.Println（）.是按后序遍历的顺序。 go 语言学习 命名返回值:没有参数的 return 语句返回已命名的返回值 println 的执行顺序。会先把函数计算结束之后，再按照顺序输出 没有条件的 switch 同 switch true 一样。 defer 函数调用会被压入一个栈中，所以后 defer 的值会先输出 结构体指针的使用：修改结构体指针的值时，不需要带*号。 数组定义的几种方式 关于切片 切片就像数组的引用，改变切片会改变底层的值 切片的默认行为，可以不写完全部的上下限，因为切片默认有上下限 只是截取切片是不会改变切片大小的 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数 切片的零值是 nil 函数的闭包 接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法，可以定义别名，**type **MyFloat float64 关于方法和接口 指针参数的函数必须接受一个指针,而以指针为接收者的方法被调用时，接收者既能为值又能为指针 跟 C++中一样，使用指针接收者可以修改接收者指向的值；另外，可以避免每次在调用方法时复制该值。 1.函数执行顺序是否是后序遍历的方式，可以再嵌套一层方法试试？ 画个调用树出来看看？ 我在网上没有找到相关的解释，就自己查看了 fmt.Println()函数的源码，会先调用 Fprintln 函数，而 Fprintln 会先执行传入的函数，存在 p 的 buf 中，之后转换成 string 再打印。 func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } func Sprintln(a ...interface{}) string { p := newPrinter() p.doPrintln(a) s := string(p.buf) p.free() return s } 同时也重新把打印语句加复杂了一下，结果与预期相符。 package main import \"fmt\" func add(x,y int) int{ sum:=x+y fmt.Println(sum) return sum } func main(){ fmt.Println(add(1,2),add(add(1,1),add(3,7)),add(4,5)) } 运行结果为： 3 2 10 12 9 3 12 9 切片的增长为什么是 20，是否在大于 1024 或某个值时，有其他的增长方法？ 比如 增加 1.2 倍？ 可以贴源码作为论据 查看了一下 slice 中的 growslice 函数，可以看到当容量小于 1024 时，是按照 2 倍进行增长的，当超过 1024 时，按照 1.25 倍进行增长，应该是从节省空间的角度考虑，毕竟对一个很长的数组，再插入同样长度的数的概率很小。 newcap := old.cap doublecap := newcap + newcap if cap \u003e doublecap { newcap = cap } else { if old.len \u003c 1024 { newcap = doublecap } else { // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. for 0 \u003c newcap \u0026\u0026 newcap \u003c cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u003c= 0 { newcap = cap } } } 通过代码测试上述结果： func main(){ var a []int for i:=0;i\u003c1500;i++{ a=append","date":"2019-07-04","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A04/:0:0","tags":[],"title":"go语言基础学习(4)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A04/"},{"categories":[],"content":"Tips 函数 var rmdirs []func() for _, d := range tempDirs() { dir := d // NOTE: necessary!如果没有这一行会导致传入同样的dir os.MkdirAll(dir, 0755) // creates parent directories too rmdirs = append(rmdirs, func() { os.RemoveAll(dir) }) } // ...do some work… for _, rmdir := range rmdirs { rmdir() // clean up } ","date":"2019-07-04","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A04/:1:0","tags":[],"title":"go语言基础学习(4)","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A04/"},{"categories":[],"content":"基础记录 命名返回值:没有参数的 return 语句返回已命名的返回值 println 的执行顺序。会先把函数计算结束之后，再按照顺序输出 没有条件的 switch 同 switch true 一样。 defer 函数调用会被压入一个栈中，所以后 defer 的值会先输出 结构体指针的使用：修改结构体指针的值时，不需要带*号。 数组定义的几种方式 关于切片 切片就像数组的引用，改变切片会改变底层的值 切片的默认行为，可以不写完全部的上下限，因为切片默认有上下限 只是截取切片是不会改变切片大小的 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数 切片的零值是 nil 函数的闭包 接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法，可以定义别名，**type **MyFloat float64 关于方法和接口 指针参数的函数必须接受一个指针,而以指针为接收者的方法被调用时，接收者既能为值又能为指针 跟 C++中一样，使用指针接收者可以修改接收者指向的值；另外，可以避免每次在调用方法时复制该值。 1.函数执行顺序是否是后序遍历的方式，可以再嵌套一层方法试试？ 画个调用树出来看看？ 我在网上没有找到相关的解释，就自己查看了 fmt.Println()函数的源码，会先调用 Fprintln 函数，而 Fprintln 会先执行传入的函数，存在 p 的 buf 中，之后转换成 string 再打印。 func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } func Sprintln(a ...interface{}) string { p := newPrinter() p.doPrintln(a) s := string(p.buf) p.free() return s } 同时也重新把打印语句加复杂了一下，结果与预期相符。 package main import \"fmt\" func add(x,y int) int{ sum:=x+y fmt.Println(sum) return sum } func main(){ fmt.Println(add(1,2),add(add(1,1),add(3,7)),add(4,5)) } 运行结果为： 3 2 10 12 9 3 12 9 切片的增长为什么是 20，是否在大于 1024 或某个值时，有其他的增长方法？ 比如 增加 1.2 倍？ 可以贴源码作为论据 查看了一下 slice 中的 growslice 函数，可以看到当容量小于 1024 时，是按照 2 倍进行增长的，当超过 1024 时，按照 1.25 倍进行增长，应该是从节省空间的角度考虑，毕竟对一个很长的数组，再插入同样长度的数的概率很小。 newcap := old.cap doublecap := newcap + newcap if cap \u003e doublecap { newcap = cap } else { if old.len \u003c 1024 { newcap = doublecap } else { // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. for 0 \u003c newcap \u0026\u0026 newcap \u003c cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u003c= 0 { newcap = cap } } } 通过代码测试上述结果： func main(){ var a []int for i:=0;i\u003c1500;i++{ a=append(a,i) if i%100==0{ fmt.Printf(\"len: %d , cap; %d\\n\",len(a),cap(a)) } } } 输出结果为： len: 1 , cap; 1 len: 101 , cap; 128 len: 201 , cap; 256 len: 301 , cap; 512 len: 401 , cap; 512 len: 501 , cap; 512 len: 601 , cap; 1024 len: 701 , cap; 1024 len: 801 , cap; 1024 len: 901 , cap; 1024 len: 1001 , cap; 1024 len: 1101 , cap; 1280 len: 1201 , cap; 1280 len: 1301 , cap; 1696 len: 1401 , cap; 1696 如上符合源码结果，所以之前的分析有些问题，但是 append 多个值的时候，与之前的结果相同。再次查看源码，发现实际上还有内存对齐的考虑： capmem = roundupsize(uintptr(newcap) * sys.PtrSize) 其中 capmem 会根据 roundupsize 函数进行内存对齐。其中 uintptr(newcap)表示新容量的大小，sys.PtrSize 表示一个元素的大小，int 时为 8。roundupsize 函数的实现如下 func roundupsize(size uintptr) uintptr { if size \u003c _MaxSmallSize { if size \u003c= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]]) } else { return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]]) } } if size+_PageSize \u003c size { return size } return round(size, _PageSize) } 其中：_MaxSmallSize=32768,2 的 15 次方，是 32K。当需要分配的 size 大于 32K 时，需要 mchche 向 mcentral 申请；当 size 小于 32K 时，计算应该分配的 sizeclass，直接去 mchche 申请。（关于具体的内存申请方面，在后面的开发需要的时候再仔细研究） 当 size 小于 smallSizeMax-8=1024-8=1016 时，采用 size_to_class8 的分配方式，大于 1016 时采用 size_to_class128 的分配方式。 size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31} size_to_class128 = [(_MaxSmallSize-smallSizeMax)/largeSizeDiv + 1]uint8{31, 32, 33, 34, 35, 36, 36, 37, 37, 38, 38, 39, 39, 39, 40, 40, 40, 41, 42, 42, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 47, 47, 47, 48, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58","date":"2019-07-02","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A01/:0:0","tags":["golang"],"title":"【Golang】go语言学习(1)-初识切片","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A01/"},{"categories":[],"content":"配置 user 信息 git config --global user.name 'your_name' git config --global user.email 'your_email' git config --local #local只对某个仓库有效 git config --global #global对当前用户的所有仓库有效 git config --system #对系统所有登录用户有效，一般不用没什么意义 git config --global --list #显示配置项 local 比 global 优先级要高 给文件重命名 #原来的使用： mv readme readme.md git add readme.md git rm readme #直接使用 git mv readme readme.md 查看 gitlog git log #只显示当前分支 git log --all --graph #可以看所有的分支 git log --oneline --all -n4 #一行显示所有分支最近的4个 .git 目录 HEAD：整个仓库正在工作的分支 config：存放仓库本地的配置信息，记录 user 等信息 refs： objects：包括文件夹和 pack commit、tree 和 blob 之间的关系 一个 commit 对应一棵 tree，每个文件夹对应一个 tree 分离头指针 表示某个变更没有基于某个 branch，在切换分支的时候，这些变更很有可能会被 git 当做垃圾清理，所以如果认为这些变更有用的话，一定要与某个 branch 绑定才能得到保留。 HEAD 和 branch 切换分支时，HEAD 指向会发生变化。 git diff HEAD HEAD^ #与上一次HEAD比较 git diff HEAD HEAD^^ #与上上次进行比较 git diff HEAD HEAD^3 #与上上上次进行比较 常用场景 ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"删除分支 git branch -d '分支名' #清除分支的命令 git branch -D '分支名' #确信清除没有影响，采用D清除 ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"修改 commit 的 message 在维护自己的分支的时候，还没有提交的时候 git commit --amend #修改最新的commit的message git rebase -i 'commit id' #修改更久的commit的message 然后按照提示进行修改 ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"整理多个 commit 为 1 个 git rebase -i 'commit-id' # commit-id为最久的想合并的 ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:4:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"比较暂存区和 HEAD 所含文件的差异 git diff --cached #表示暂存区和HEAD的区别 ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:5:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"比较工作区和暂存区的区别 git diff #默认比较的是工作区和暂存区的区别 git diff --文件名 #比较文件 ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:6:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"让暂存区恢复成和 HEAD 一样 git reset HEAD #将暂存区所有的变更恢复成HEAD ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:7:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"工作区的文件恢复成暂存区一样 git checkout -- '文件名' ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:8:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"取消暂存区部分文件的修改 git reset HEAD --'文件名' # 将暂存区某一文件恢复成HEAD ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:9:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"消除最近的几次提交 git reset --hard 'commit-id' #慎用 ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:10:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"看不同提交的指定文件的差异 git diff 'branch1' 'branch2' -- '文件名' git diff 'commit-id1' 'commit-id2' -- '文件名' ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:11:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"正确删除文件的方法 git rm '文件名' ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:12:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"开发临时加塞紧急任务处理方式 git stash git stash apply 或者 git stach pop #两者区别是会丢掉 ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:13:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"Git 的备份 哑协议：不显示进度条 智能协议： Tips ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:14:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":[],"content":"同步含有git的文件夹及问题解决 同步含有 git 的文件夹真的有点烦，由于没有注意同步结果，只是一直在看 travis 构建结果，结果半天没有发现问题，后来发现了也不知道怎么解决，看远程仓库的代码是一个关联的文件夹形式，表示这是一个 git 的文件夹，但是点不开，本地的也没有上传。 ","date":"2019-05-26","objectID":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:15:0","tags":[],"title":"【Git】Git使用总结","uri":"/posts/tools/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"第一个 go 程序 go 语言主函数没有返回值，需要使用 os 包， os.exit() ，也不能直接函数传参。 变量、常量和其他语言的区别 赋值可以自动类型推断： a:=1 ，怎么方便怎么来就行 快速连续赋值 const ( Monday=itoa+1 Tuesday Wednesday ) const( Open=1\u003c\u003citoa Close Pending ) 运算符 算数运算符：没有前置的++、– 比较运算符：用 == 比较时，相同维数的数组可以比较 逻辑运算符 位运算符： \u0026^ ：按位清零 1 \u0026^ 0 --1 1\u0026^ 1 --0 0\u0026^1 --0 0\u0026^0 --0 条件和循环 循环：只支持 for ，并且没有括号，while 条件的写法为 for n\u003c5{ n++ fmt.Println(n) } 条件：条件一定要是个布尔值或表达式。支持在 if 语句中对变量赋值 switch 条件：条件表达式不限制为常量或者整数；单个 case 中，可以出现多个结果选项，使用逗号分隔；不需要 break；可以不设定 switch 之后的条件表达式 数组和切片 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:0:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"数组 数组的声明：声明同时初始化：arr3:=[...]int{1,3,4,5} 数组的遍历 数组截取：a[index_begin(包含),index_end(不包含)] ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:1:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"切片 切片的声明方式：与数组的声明有点相似 var s0 []int s1:=[]int{} s2:=[]int{1,2,3} s2:=make([]int,2,4) //([]type,len,cap) len个元素会被初始化为零值， cap中其它未初始化的元素不能访问 切片的增长方式：类似于 c++的 vector。 切片共享存储结构：切片截取后，计算 cap 得到的结果。其实切片截取，指向的是内部共享的切片存储空间。所以修改截取的切片的数据，其他截取的相同区域也会发生改变。这是一个容易出错的问题。 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:2:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"切片和数组的区别 容量是否可伸缩 是否可以进行比较 Map 基础 Map 声明方式 m:=map[string]int{\"one\":1,\"two\":2,\"three\":3} m1:=map[string]int{} m1[\"one\"]=1 m2:=make(map[string]int,10) //10表示初始化的cap,不需要初始化len 元素访问：当访问的 key 不存在时，仍然会返回零值，编程时需要根据 nil 来判断元素是否存在 Map 与工厂模式 Map 的 value 可以是一个方法 与 Go 的 Dock type 接口方式一起，可以方便的实现单一方法对象的工厂模式 Go 内置集合中没有 Set，可以通过 map 实现mySet:=**map**[int]bool{} 字符串 string 是数据类型，不是引用或指针类型。零值不是空，而是空字符串。 string 是只读的 byte slice，不能重复赋值。len 函数可以表示它所包含的 byte 数 string 的 byte 数组可以存放任何数据 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:3:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"Unicode 和 UTF-8 Unicode 是一种字符集（code point） UTF-8 是 Unicode 的存储实现（转换为） Go 语言的函数 函数可以返回多个值 所有参数都是值传递：slice，map，channel 会有传引用的错觉 函数可以作为变量的值 函数可以作为参数和返回值 可变参数及 defer 延迟执行函数：defer。类似于其他语言中的 finally，主要作用是最后关闭一些资源或者关闭一些锁 行为的定义和实现 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:4:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"封装数据和行为 type Employee struct{ Id string Name string Age int } 实例的创建和初始化 e:=Employee{\"0\",\"Bob\",20} e1:=Employee{Name:\"Mike\",Age:30} e2:=new(Employee) //这里返回的是实例的指针 e2.Id=\"2\" //通过实例的指针访问指针不需要“-\u003e” ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:5:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"行为（方法）定义 func (e Employee)String1() string{ return fmt.Sprintf(\"ID:%s-Name:%s-Age:%d\",e.Id,e.Name,e.Age) } //推荐使用的方式，类似于c++的引用 func (e *Employee)String() string{ return fmt.Sprintf(\"ID:%s-Name:%s-Age:%d\",e.Id,e.Name,e.Age) } Go 语言的相关接口 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:6:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"Duck Type 方法签名是一样的，就认为是这样的 接口是非入侵性的，实现不依赖于接口定义 接口的定义可以包含在接口使用者包内 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:7:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"接口变量 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:8:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"自定义类型 type IntConv func (op int) int 扩展与复用 不一样的接口类型，一样的多态 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:9:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"空接口与断言 空接口可以表示任何类型 通过断言来将空接口转换为制定类型 v,ok:=p.(int) //ok=true时为转换成功 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:10:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"Go 接口最佳实践 倾向于使用小的接口定义，很多接口只包含一个方法。实现的负担较小。 Type Reader interface{ Read(p []byte)(n int,err error) } Type Writer interface{ Write(p []byte)(n int,err error) } 较大的接口定义，可以由多个小接口定义组合而成。 Type ReadWrite interface{ Reader Writer } 只依赖于必要功能的最小接口，方法才能更多的被复用 func StoreData(reader Reader) error{} 编写好的错误处理 没有异常机制 error 类型实现了 error 接口 可以通过 errors.New 来快速创建错误实例 panic 和 recover ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:11:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"panic panic 用于不可恢复的错误 panic 退出前会执行 defer 指定的内容 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:12:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"panic vs os.Exit os.Exit 退出时不会调用 defer 指定的函数 os.Exit 退出时不会输出当前调用栈信息 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:13:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"recover defer func(){ if err:=recover();err!=nil{ //恢复错误 } }() 不要强制恢复错误，有的时候“Let it crash”可能更好，让程序重启来恢复。 构建可复用的模块（包） ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:14:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"package 基本复用模块单元：以首字母大写来表名可被包外代码访问 代码在 package 可以和所在的目录了不一致（相对于 Java 而言） 同一目录里的 Go 代码的 package 要保持一致 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:15:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"init 方法 在 main 被执行前，所有依赖的 package 的 init 方法都会被执行 不同包的 init 函数按照包导入的依赖关系决定执行顺序 每个包可以有多个 init 函数 包的每个源文件也可以有多个 init 函数，比较特殊 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:16:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"go get 通过 go get 来获取远程依赖 go get -u 强制从网络更新远程依赖 注意代码在 Github 上的组织形式，以适应 go get：直接以代码路径开始，不要有 src 依赖管理 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:17:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"Go 未解决的依赖问题 同一环境下，不同项目使用同一包的不同版本 无法管理对包的特定版本的依赖 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:18:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"vendor 路径 Go1.5 release 版本，vendor 目录被添加到除了 GOPATH 和 GOROOT 以外的依赖目录查找方案。查找依赖包路径的解决方案： 当前包下的 vendor 目录 向上级目录查找，直到找到 src 下的 vendor 目录 在 GOPATH 下面查找依赖包 在 GOROOT 目录下查找 其他第三方依赖管理工具：godep，glide，dep ** 协程机制 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:19:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"线程 vs 协程 创建时默认的 stack 大小：JAVA 1M vs Goroutine 2K 和 KSE（Kernel Space Entity）：java Thread 是 1:1；GO M:N 共享内存并发机制 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:20:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"Lock ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:21:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"WaitGroup 相当于 Java 的 join CSP 并发机制 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:22:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"CSP vs Actor 和 Actor 的直接通讯不同，CSP 模式是通过 Channel 进行通讯的，更松耦合一些 Go 中 Channel 是有容量限制并且独立于处理 Goroutine，而如 Erlang，Actor 模式中的 mailbox 容量是无限的，接收进程也总是被动地处理消息。 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:23:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"Channel 两种情况：一种是一直等待，一种 Buffered Channel ，更松耦合的 Channel，消息发送方可以在容量没满的时候一直放，满了之后需要等待。对于接收方来说，只要 Channel 内有消息就可以一直接收。 多路选择和超时 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:24:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"select 运行到 select 时，当任一个事件准备好了，就可以对应响应。当不想一直等待某事件时，可以进行超时控制。 channel 的关闭和广播 解决怎么知道 channel 数据完了的问题 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:25:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"channel 的关闭 向关闭的 channel 发送数据，会导致 panic v,ok\u003c-ch；ok 为 bool 值，true 表示正常接收，false 表示通道关闭 所有的 channel 接收者都会在 channel 关闭时，立即从阻塞等待中返回且上述 ok 值为 false。这个广播机制常被利用，进行向多个订阅者发送信号，如：退出信号。 任务的取消 Context 与任务取消 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:26:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"Context 根 Context：通过 context.Background()创建 子 Context：context.WithCancel(parentContext)创建 ctx,cancel：context.WithCancel(context.Background()) 当前 Context 被取消时，基于他的子 context 也会被取消 接收取消通知\u003c-ctx.Done() 还有一些其他的方法 典型并发任务 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:27:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"只运行一次（常见的并发任务） 在常见的多任务环境下，只执行一次。单例模式（懒汉式，线程安全） type Singleton struct { } var singleInstance *Singleton var once sync.Once func GetSingletonObj() *Singleton{ once.Do(func() { //传入创建方法 fmt.Println(\"Create Obj\") singleInstance=new(Singleton) }) return singleInstance } ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:28:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"所需任意任务完成 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:29:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"所有任务完成 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:30:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"对象池 数据库连接，网络连接，经常将这些对象池化，避免重复创建。 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:31:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"sync.pool 对象缓存 从名字来看，像是 go 语言提供的池。其实是对象的缓存 如果私有对象不存在则保存为私有对象 如果私有对象存在，就放入当前 Processor 子池的共享池中 使用： **sync.pool 对象的生命周期—**sync.pool 不能作为对象池的原因 GC 会清除 sync.pool 缓存的对象 sync.pool 对象的缓存有效期为下一次 GC 之前 总结： 适合于通过复用，降低复杂对象的创建和 GC 代价 协程安全，会有锁的开销 声明周期受 GC 影响，不适合于做连接池等，需自己管理生命周期资源的池化 所以具体要看锁的开销大，还是初始化的开销大 测试 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:32:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"单元测试 表格测试 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:33:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"内置单元测试框架 Fail，Error：该测试失败，该测试继续，其他测试继续执行 FailNow，Fatal：该测试失败，该测试中止，其他测试继续执行 代码覆盖率 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:33:1","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"Benchmark 以 Benchmark 开头，参数类型稍有不同。 通过 ResetTimer 和 StopTimer 将测试代码隔开 命令行下运行： ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:34:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"BBD Behavior Driven Development 常用框架：goconvey ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:35:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"反射编程 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:36:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"万能程序 DeepEqual 比较切片和 map 与配置相关的，要求灵活性和复用性时，可以 反射的 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:37:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"不安全编程 unsafe，一般涉及到库的交互，与 c 语言交互。 “不安全”行为危险性：Go 语言中不支持强制类型转换。下列操作看似可以，实际不能转换，而且实际使用起来很危险。 i:=10 f:=*(*floa64)(unsafe.Pointer(\u0026i)) 场景 2：用到内置的 Atomic 操作，指针原子操作，并发读写 架构模式 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:38:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"Pipe-Filter 架构 非常适合与数据处理及数据分析系统 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:39:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"micro kernel 特点：易于拓展，错误隔离，保持架构一致性 要点： 内核包含公共流程或通用逻辑 将可变成或可扩展部分规划为扩展点 抽象扩展点行为，定义接口 利用插件进行扩展 生产过程任务的开发 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:40:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"内置 json 解析 远程过程调用等过程中，会用 json，以及在配置文件中，很多使用 json ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:41:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"easyjson go 内置的，一般适用于配置文件解析，对于 qps 较高，运用了反射，效率较低。尽量使用高性能的 json 解析 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:42:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"HTTP 服务 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:43:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"构建 Restful 服务 更好的 router，httprouter 面向资源的架构（Resource Oriented Architecture） ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:44:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["Golang"],"content":"性能分析工具 学习函数式编程：《计算机程序的构造和解释》functional programming 《Restful Web Service》 《Go 程序设计语言》 《面向模式的软件架构》1,2,3 本 ","date":"2019-04-28","objectID":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/:45:0","tags":["Golang"],"title":"go语言学习(2)-极客时间","uri":"/posts/language/golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"categories":["MySQL"],"content":"三大范式 **第一范式（1NF）：**无重复的列。 要求：表所有的属性不可再分。 如果不符合第一范式，则不符合关系模型的定义。 **第二范式（2NF）：**属性完全依赖于主键 [ 消除部分子函数依赖 ]。 要求：在满足 1NF 前提，每一行能够唯一标识，不存在非主键字段。 常用方法可以增加一个单字段的主键。 第三范式（3NF）：属性不依赖于其它非主属性 [ 消除传递依赖 ]。 要求：在满足 2NF 前提，不出现类似于 A-\u003eB-\u003eC 的情况，这样的传递依赖可以分为两个表，分别保存。 通用的原则： 每个实体都有一个表。 为每一个关系（二维表）增加一个逻辑主键作为标识。 出现二维表对应的关系，采用 1:1, 1:N, M:n 的形式将关联关系设计。 MySQL 日志类型 错误日志：记录启动、运行或停止 mysqld 时出现的问题 查询日志：记录建立的客户端连接和执行的所有语句（包括错误的） 二进制日志：记录所有更改数据的语句、还用于主从复制 慢日志：记录所有执行时间超过 long_query_time 秒的所有查询 索引 索引：对数据库表中一或多个列的值进行排序的结构，是帮助 MySQL 高效获取数据的数据结构，可以 加快检索表中的数据，而不必扫描整个数据库。 缺点是：需要占用额外的空间，并且需要定期维护，每条记录的 INSERT,DELETE,UPDATE 操作可能付出更多的磁盘 IO。同时不必要的索引反而会使查询速度变慢。 索引查询的适用的情况：基于一个范围的检索，一般查询返回结果集小于表中记录数的 30%。基于非唯一性索引的检索。 数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引 事务 事务：并发控制的基本单位，是一个操作序列，这些操作要么都执行，要么都不执行，是一个不可分割的工作单位。 ","date":"2019-01-25","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%803/:0:0","tags":["MySQL"],"title":"MySQL学习基础(3)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%803/"},{"categories":["MySQL"],"content":"事务的隔离级别 分为四个级别： 未提交读:允许脏读，可能读到其他会话没有提交的数据。 已提交读:只能读到已经提交的数据。ORACAL 等多数数据库的默认隔离级别。 可重复读:可重复读，同一事务内的查询都是和事务开始时一致的，Innodb 的默认隔离级别。 串行读：完全串行化的读，每次读都需要获得表级共享锁，读写相互会阻塞。 对应：脏读、不可重复读、幻读情况为： 脏读：当一个事务正在访问数据，并且对数据进行了修改，这个修改还没提交到数据库。另一个事务也访问这个数据，使用了这个数据。 不可重复读：一个事务内，多次读同一数据。这个事务还没结束时，另一个事务也访问这个数据，导致第一个事务两次访问的数据不一样。 幻读：第一个事务对表中的每一行数据进行了修改，同时第二个事务也访问这个表中的数据，这种修改是向表中插入而来一行数据，那么以后就会发生操作第一个事物的用户表中发现表中还有没修改的数据行，像是产生了幻觉。 MySQL 四种事务隔离级的说明 DROP、DELETE 与 TRUNCATE DROP：不仅删除表的数据，还删除表的结构。 DELETE 和 TRUNCATE 只删除表的数据不删除表的结构。 删除速度：DROP\u003e DELETE\u003eTRUNCATE 适用场景：当不需要一张表的时候，适用 DROP；删除部分数据行的时候，用 DELETE，并且使用 where 子句；保留表而删除所有数据的时候用 TRUNCATE。 存储引擎 MySQL 目前用的比较多的两种，是 Innodb 和 Myisam ","date":"2019-01-25","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%803/:1:0","tags":["MySQL"],"title":"MySQL学习基础(3)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%803/"},{"categories":["MySQL"],"content":" 在关系型数据库里面，每个实体有自己的一张表，所有属性都是这张表的字段，表与表之间根据关联字段\"连接\"在一起。 什么是连接 两张表根据关联字段，组合成一个数据集。当两张表的关联字段不匹配时，例如表 A 和表 B，处理方式为： 只返回两张表匹配的记录，内连接（inner join）。 返回匹配的记录，以及表 A 多余的记录，左连接（left join）。 返回匹配的记录，以及表 B 多余的记录，右连接（right join）。 返回匹配的记录，以及表 A 和表 B 各自的多余记录，全连接（full join）。 这里看到了阮一峰老师的一个总结，引用了图片： 内连接（inner join） MySQL 默认的连接就是内连接，可以省略 inner。 有条件的内连接： where：数据过滤，理解上，数据交叉连接完成后再进行过滤。 on：在连接时，就对数据进行判断。 using：要求负责连接的两个实体之间的字段名称一致。 在有同名字段时，使用 using，通用条件时，使用 on，在数据过滤时（不是连接的过滤）时，使用 where。 外连接（outer join） 连接的数据不真实存在。意思是外连接的两个表，存在单个表中没有的数据。 ","date":"2019-01-23","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/:0:0","tags":["MySQL"],"title":"MySQL学习总结(2)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/"},{"categories":["MySQL"],"content":"左连接（left join） 在连接时，出现了左边表连接不到右边表的情况，则左边表的数据会被保留，而右边表的数据连接不到左表的情况，会被抛弃。 ","date":"2019-01-23","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/:1:0","tags":["MySQL"],"title":"MySQL学习总结(2)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/"},{"categories":["MySQL"],"content":"右连接（right join） 在连接时，出现了左边表连接不到右边表的情况，则数据会被抛弃，而右边表的数据连接不到左表的情况，会被保留。 ","date":"2019-01-23","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/:2:0","tags":["MySQL"],"title":"MySQL学习总结(2)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/"},{"categories":["MySQL"],"content":"全连接（full join） ","date":"2019-01-23","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/:3:0","tags":["MySQL"],"title":"MySQL学习总结(2)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932/"},{"categories":[],"content":"数据库和 SQL SQL(Structured Query Language)：结构化查询语言。包括 DDL（Data Definition Language 数据定义语言）、DML（Data Management Language 数据管理语言）、DCL（Data Control Language 数据库控制语言）。其中 DML 包括：DQL（Data Query Language 数据查询语言）和 DML（Data Management Language 数据管理语言），一般来说，数据查询和管理都称为数据管理语言。 安装 基础 ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:0:0","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"DML ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:1:0","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"数据库操作 # 数据库创建 CREATE database db_name; # 创建数据库 CREATE database db_name if not exits; # 数据库查询 SHOW databases; # 查看当前存在的数据库 SHOW CREATE DATABASE db_name; # 查看数据库创建的语言，显示结果为 # 选择数据库 USE database; # 操作表时会使用默认的数据库，所以需要先使用USE表示使用的是哪一个数据库 # 查看数据库中表 SHOW TABLES [like 'pattern_%']; # 可以使用通配符匹配 # 数据库删除 DROP database db_name; #还有其他的两种，记得区分结果 # 数据库修改 ALTER database db_name; # 数据库权限修改 GRANT ALL ON db_name.* TO 'your_mysql_name'@'your_client_host'; # ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:1:1","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"表操作 # 表创建 CREATE TABLE tbl_name (列结构)[表选项] CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE); # 从外部导入数据到表 LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet LINES TERMINATED BY '\\r\\n'; # 从本地导入，分隔符为\"\\r\\n\" # 插入数据到表 INSERT INTO pet VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL); # 如果设置了NOT NULL，则需要 在插入数据的时候该项有值 # 修改列定义 ALTER TABLE tbl_name[ADD|DROP|CHANGE|MODIFY] #添加|删除|重命名|修改 # 修改表选项 ALTER TABLE tbl_name 新的表选型 ALTER TABLE pet CHARACTER SET UTF8; ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:1:2","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"数据操作 # 创建数据 INSERT INTO tbl_name (field_list) VALUES (values); # # 获取数据 SELECT field_list FROM tbl_name conditions; SELECT field_list FROM tbl_name WHERE conditions LIKE 'a%'; # %为通配符 SELECT field_list FROM tbl_name WHERE REGEXP_LIKE(field_name,regex); # 使用正则表达式匹配 # 删除数据 DELETE FROM tbl_name conditions; # 修改数据 UPDATE tbl_name SET field=new_value, conditions; ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:1:3","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"Mysql 数据类型 ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:2:0","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"整型:默认有符号，无符号要指定 unsigned TINYINT:1 字节 无符号：-128—127 有符号： 0—255 SMALLINT:2 字节 无符号：-32768—32767 有符号：0-65536 MEDIUMINT：3 字节 INT：4 字节 BIGINT:8 字节 可以听过类似 INT(2)表示显示的宽度，显示宽度不影响数值的范围，只是为了表示 ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:2:1","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"小数 浮点数： ** 可以通过TYPE(M,D)**控制数值位数，M 为所有的数值位数，D 为小数位数 float：单精度浮点数，默认精度位数为 6 左右 double：双精度浮点数，默认精度 16 左右 ** 定点数： DECIMAL(M,D) **同样的 M 为所有的数值位数，D 为小数位数，M 默认为 10，D 默认为 0 ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:2:2","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"日期和时间 DATATIME 8 YYYY-MM-DD HH:MM:SS TIMESTAMP 4 YYYY-MM-DD HH:MM:SS 从 1970 年开始 DATE 3 YYYY-MM-DD TIME 3 HH:MM:SS YEAR 1 YYYY 范围为 1901-2155 ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:2:3","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"字符串 **CHAR(M) :**表示固定长度。M 表示允许的字符串长度,限制了字符串的长度 **VARCHAR(M): **可变长度 。M 表示允许的最大长度，在内存中表示，需要多一个字节保存字符串的总长度，因此如果有时候不是很需要改变长度的话，尽量用固定长度的 CHAR ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:2:4","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"列属性 ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:3:0","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"主键 可以唯一标识某条记录的字段或字段的集合。通常的做法是，设计每个表存在一个可以唯一标识的主键字段，最好利用与实体信息不相关的属性，作为唯一标识，与业务逻辑不发生关系，只用来记录标识，例如 ID。 设置方式：在字段上设置或者定义完字段后再定义 # 在字段上设置 CREATE TABLE pet ( id INT PRIMARY KEY,NAME VARCHAR (5)); # 定义完字段后再设置 CREATE TABLE pet1 ( id INT,NAME VARCHAR (5),PRIMARY KEY (id)); ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:3:1","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":[],"content":"自动增长 为每条记录提供唯一的标识，每次插入记录时，某个字段的值都自动加 1，使用 auto_increment 标识。要求需要整型和索引。在插入数据的时候，可以选择插入 null 也可以不插入。 自动增长的初始值默认是 1，也可以通过 auto_increment n 重新设置从 n 开始增长。 也可以手动插入自动增长的值，但是如果是主键的话，不能重复。 注意事项 数据库语言关键字一般用大写，虽然大小写都可以，但是为了区分。 数据库名的大小写取决于系统，所以操作的时候尽量有自己的规范，进行大小写区分。 NULL 是区别于 0 或者’ ‘的 ","date":"2019-01-14","objectID":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/:3:2","tags":[],"title":"【MySQL】MySQL学习基础(1)","uri":"/posts/database/mysql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801/"},{"categories":["life"],"content":" 2018 年总结。 2018 已经到了尾声了，还从来没好好总结一年，该养成及时总结反思的习惯。 学习 找工作相关的内容：编程语言 C++/Python/Shell 脚本等，计算机网络、数据库、操作系统、服务器 Nginx 都有了一定的学习和总结，但是还是理论的较多一些，实践倒是有，但是还远远不够。 跟着 github 上写了个 C++的 web 服务器，不过还是有很多不明白，只是面试的时候能讲一讲。 另外找完工作后，开始要学习 Go 语言，还有数据库的基础，其实总觉得数据库自己掌握的还是很少，而且以后就是 DBA 了，更要把基础打劳一点。 工作 首先今年最重要的就是找工作了，说实话，找工作的策略并不是很好，但是也是跟自己的复习有关系吧，对于数据结构和算法，看了很多，自己也刷了很多题，但是一些复杂的算法，以及广度还是不够，所以在面试的时候遇到难点的算法题就很虚。另外就是找工作的策略上，海投的时候投了很多，以至于找工作的很多的精力都花在了不想去的公司上，而好几个大公司都没有准备好。 拿到的 Offer 还是很乱的，国企、研究所、互联网基本上都有。总结下 Offer 有： 国企银行：银联、招银网络 研究所：航天 804、中电 20 所、中电 54 所、中船重工 701 互联网：老虎证券、竞技世界、vipkid、好未来、新思科技、oppo、海康威视、大华、小米等 最后看其实找到的工作也不是很好，其实也有个原因是小米很早给了意向就不是很想找了，很多面试都没去。策略有些问题，不过最后的结果也还不错，能回武汉工作。当然找工作的过程其实也有很大的收获，不只是技术上的，还有心理上的。 关于实验室的工作，就还是那样，感觉自己的态度有一些问题，就是太不重视了，总是以老板为驱动，总想着自己以后也不从事这方面，就比较不在意，这样就有些问题。 生活 关于身体健康。减肥这个事情，说了很多遍，也有的时候能坚持，但是还是一直保重的状态。而且年底马上就要去当伴郎了，作为伴郎里最胖的一个，压力很大呀。今年看来希望渺茫了，把 flag 留给明年吧。 关于读书。最近也都很久没看了。今年除了找工作看的一些专业书外，别的都看的很少了，需要加强呀。 关于感情。跟亲爱的在一起了，到今天也已经 300 天了，时间过得很快，异地恋其实在一起的时间也不是很多，刚刚到一个月，但是互相很能为对方着想，有问题积极解决，保持几乎每天都开视频。不过关于两人的相处，还有很多需要慢慢改进。也剩明年半年的异地了，期待明年。 关于家人朋友。爷爷今年去世了，享年 85 岁。小时候爸妈不在家，基本上爷爷奶奶从小把我带大，远在西安的我没能看到最后一面，虽然知道这一天总是会来，但是觉得太快了，以后再也没有过年在家吃饭的时候还叫上我一起陪着喝个白酒的了，喝了酒又开始讲自己小时候躲日本鬼子，年轻的时候修长江大桥了，讲以前穷日子的时候了。。你总是在长大，只是时间让你感觉长大的方式不再那么温柔了。 流水 2.24 开始跟亲爱的在一起 3 月，开始准备 miniweb 4 月，参加华为的比赛，但是没有进 64 7 月，爷爷 8-9 月，找工作 总结 总之，关于 2018 年，是失去也是收获的一年，但是不管怎么样，那都是这一年的自己，也需要更好的总结来让新的一年变得更好。 保持专注和思考。一直觉得认真是自己的优势之一，但是今年却感觉做很多事情的时候，不是很能专注，做事的效率不是很高了。另一个是抓住重点，时间有限，尽量做更有价值的事情，把时间看做重要的成本。这永远是核心竞争力的保证。 学会沟通。通过谈恋爱，以前觉得自己是一个很爱说话的人，很喜欢开玩笑的人，但现在发现自己不是一个很会沟通的人。现在发现这两个还是有区别的，笑的再好，不会沟通，问题还在那，只不过暂时忘了而已。 学会自律。自律才能自由，用自己的想法约束自己的行为，这才是更高程度的自由，而不是想吃就吃，想玩就玩。 提高自己。身体上，精神上。看书和锻炼， 2019 计划 一年之计在于春，先提前订点小目标吧。等年底了再来看。 看 50 本书，包括专业书和业余书。专业书主要是接下来工作需要的，数据库和 Go 语言方面。业余书主要关注历史和经济。 锻炼身体。把肚子减下去，要在 130 一下了吧，咳咳。 ","date":"2018-12-16","objectID":"/posts/daily/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:0:0","tags":["生活","总结"],"title":"2018年终总结","uri":"/posts/daily/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["MySQL"],"content":" MySQL 在 CentOS 上的安装和使用 yum 安装 date: 2018-12-9 21:57:59 update: 2018-12-9 21:57:59 1.首先找到官网 yum 的地址：https://dev.mysql.com/downloads/repo/yum/，找到 redhat 的版本Red Hat Enterprise Linux 7 / Oracle Linux 7 (Architecture Independent), RPM Package,并复制 download 的地址，然后下载下来： wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 2.进行 rpm 解包并安装 mysql-server rpm -ivh mysql-community-release-el7-5.noarch.rpm yum update yum install mysql-server 3.修改权限 chown mysql:mysql -R /var/lib/mysql 4.然后就可以启动 mysql 了。。 systemctl start mysqld 问题记录 当然，看着上面好像很爽，很快的样子，但是没想到接下来坑还是很多的。都有点怀疑自己了，到现在装个 mysql 还这么多问题。关键是，网上的解决办法，都是什么乱七八糟的。 ","date":"2018-12-07","objectID":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/:0:0","tags":["MySQL","学习"],"title":" CentOS7安装并使用MySQL","uri":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/"},{"categories":["MySQL"],"content":"1.状态查看-灰色 ➜ ~ systemctl status mysqld ● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: inactive (dead) Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html ➜ ~ ps ajx | grep mysql 1768 1784 1784 1784 ? -1 Ssl 999 0:19 mysqld 1.看了一下版本号，没错是 8.0： ➜ ~ mysqladmin --version mysqladmin Ver 8.0.13 for Linux on x86_64 (MySQL Community Server - GPL) 2.然后 mysql 连一波，出问题，连不上： ➜ ~ mysql ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2) 看样子是没有这个 socket，应该是位置不对，于是sudo find / -name mysql.sock 赶紧搜一下，什么都没有，没有办法，重启一下试试吧。 3.重启 ➜ ~ sudo systemctl restart mysqld Job for mysqld.service failed because the control process exited with error code. See \"systemctl status mysqld.service\" and \"journalctl -xe\" for details. 不行，换种方式重启看看： ➜ ~ service mysqld start Redirecting to /bin/systemctl start mysqld.service ==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units === Authentication is required to manage system services or units. Authenticating as: root Password: polkit-agent-helper-1: pam_authenticate failed: Authentication failure ==== AUTHENTICATION FAILED === Failed to start mysqld.service: Access denied See system logs and 'systemctl status mysqld.service' for details. ","date":"2018-12-07","objectID":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/:1:0","tags":["MySQL","学习"],"title":" CentOS7安装并使用MySQL","uri":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/"},{"categories":["MySQL"],"content":"2.错误：2002 错误详情： ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2) 这个错误网上找了一下，有看起来还可以的处理:http://blog.51cto.com/pengjc/1861088 。但是实际上我打开都没有这个文件，搜也没有搜到，于是放弃，这个问题应该不算个问题，先放着解决别的。 ","date":"2018-12-07","objectID":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/:2:0","tags":["MySQL","学习"],"title":" CentOS7安装并使用MySQL","uri":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/"},{"categories":["MySQL"],"content":"3.错误：service failed 错误详情： Job for mysqld.service failed because the control process exited with error code. See “systemctl status mysqld.service” and “journalctl -xe” for details. 看了一下网上的解决办法，说是由于权限的问题：https://www.cnblogs.com/ivictor/p/5146247.html ，通过命令chown mysql.mysql /var/run/mysqld/，但是问题还是没有解决。 看了一下stackoverflow上面的说法，先通过tail -f /var/log/mysqld.log查看一下,，但是我的这个问题不是因为没有权限， ➜ ~ tail /var/log/mysqld.log 2018-12-07T09:13:21.651467Z 0 [ERROR] [MY-010119] [Server] Aborting 2018-12-07T09:13:21.655750Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.13) MySQL Community Server - GPL. 2018-12-07T09:15:40.466437Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.13) starting as process 12759 2018-12-07T09:15:40.965670Z 0 [ERROR] [MY-012681] [InnoDB] mmap(137428992 bytes) failed; errno 12 2018-12-07T09:15:40.965740Z 1 [ERROR] [MY-012956] [InnoDB] Cannot allocate memory for the buffer pool 2018-12-07T09:15:40.965766Z 1 [ERROR] [MY-012930] [InnoDB] Plugin initialization aborted with error Generic error. 2018-12-07T09:15:40.965794Z 1 [ERROR] [MY-010334] [Server] Failed to initialize DD Storage Engine 2018-12-07T09:15:40.965949Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed. 2018-12-07T09:15:40.965977Z 0 [ERROR] [MY-010119] [Server] Aborting 2018-12-07T09:15:40.966835Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.13) MySQL Community Server - GPL. 搜了一下这个问题： [ERROR] [MY-012681] [InnoDB] mmap(137428992 bytes) failed; errno 12 看样子是内存映射出错，再通过命令journalctl -xe看一下,同时也找到了原因：原来是swap 分区是 0(https://blog.csdn.net/sxyandapp/article/details/77091007),于是一阵操作： ➜ ~ free -m /dev/vda1 / ext4 noatime,acl,user_xattr 1 1 total used free shared buff/cache available Mem: 992 516 304 0 171 321 Swap: 0 0 0 ➜ ~ dd if=/dev/zero of=/swap bs=1M count=512 dd: failed to open ‘/swap’: Permission denied ➜ ~ sudo dd if=/dev/zero of=/swap bs=1M count=512 512+0 records in 512+0 records out 536870912 bytes (537 MB) copied, 4.01658 s, 134 MB/s ➜ ~ sudo mkswap /swap Setting up swapspace version 1, size = 524284 KiB no label, UUID=9bbac588-e6ee-4b1c-a398-4ac460ad476a ➜ ~ sudo swapon /swap swapon: /swap: insecure permissions 0644, 0600 suggested. ➜ ~ free -m total used free shared buff/cache available Mem: 992 516 64 0 410 317 Swap: 511 0 511 vi /etc/fstab #在其中添加如下一行,保证下次系统启动后，此swap分区被自动加载，需要修改系统的fstab文件 /swap swap swap defaults 0 0 之后再重启就好了。 ","date":"2018-12-07","objectID":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/:3:0","tags":["MySQL","学习"],"title":" CentOS7安装并使用MySQL","uri":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/"},{"categories":["MySQL"],"content":"4.错误：登录问题 错误详情： error: ‘Access denied for user ‘root’@’localhost’ (using password: NO)’ 这个其实是密码的问题，没有设置密码的时候，mysql 会生成一个临时的密码，通过命令： ➜ ~ sudo grep 'temporary password' /var/log/mysqld.log 2018-12-07T09:08:22.908621Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: TdqPeZ-n;4Ah 可以看到生成的临时密码，然后用临时密码登录即可。 ","date":"2018-12-07","objectID":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/:4:0","tags":["MySQL","学习"],"title":" CentOS7安装并使用MySQL","uri":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/"},{"categories":["MySQL"],"content":"5.修改密码 可能因为 8.0 的版本，修改的密码不能过于简单，并且命令好像也有些不一样了，用的是`` ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass'; 看到一个别人的回答： 应该是后面才改的？ 6.外网连接 mysql 由于两台服务器的版本有点不一样，修改外网连接也有点不一样。 ","date":"2018-12-07","objectID":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/:5:0","tags":["MySQL","学习"],"title":" CentOS7安装并使用MySQL","uri":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/"},{"categories":["MySQL"],"content":"MySQL5.7 1.修改配置文件 #修改配置文件 sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf # bind-address=127.0.0.1 修改成 bind-address=0.0.0.0 # 重启服务 service mysql restart # 添加远程连接mysql的账号 \u003e grant all on *.* to root@'%' identified by '123456'; \u003e flush privileges; # *.* 第一个*表示库，第二个*表示表; *.*对全部数据库的全部表授权，so.ok 表示只对so这个库中的ok表授权 root 表示要给哪个用户授权，这个用户可以是存在的用户，也可以是不存在的 '%' 表示允许远程连接的IP地址，%代表允许所有IP连接 ","date":"2018-12-07","objectID":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/:6:0","tags":["MySQL","学习"],"title":" CentOS7安装并使用MySQL","uri":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/"},{"categories":["MySQL"],"content":"MySQL8.0 8.0 的版本总结的对权限的管理严格很多，毕竟数据很重要，只有安全才能放心。尝试过上述方式，但是连接不上。最终在 Stack Overflow 上找到了办法。 CREATE USER 'root'@'%' IDENTIFIED BY 'root'; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION; 但是修改之后还是会有问题，出现了 2059 错误： 解决方式可以采用修改密码为简单密码： SET GLOBAL validate_password.policy=0; ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '12345678'; 使用过程问题 ","date":"2018-12-07","objectID":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/:7:0","tags":["MySQL","学习"],"title":" CentOS7安装并使用MySQL","uri":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/"},{"categories":["MySQL"],"content":"1.导入数据出错 错误代码： mysql\u003e LOAD DATA LOCAL INFILE '/home/mianhk/pet.txt' INTO TABLE pet; ERROR 1148 (42000): The used command is not allowed with this MySQL version mysql\u003e LOAD DATA INFILE '/home/mianhk/pet.txt' INTO TABLE pet; ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it ca nnot execute this statement mysql\u003e LOAD DATA INFILE '/home/mianhk/pet.txt' INTO TABLE pet LINES TERMINATED BY '\\r\\n'; ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it ca nnot execute this statement 原因： secure_file_priv 设置了指定目录，需要在指定的目录下进行数据导出。 mysql\u003e show variables like '%secure%'; +--------------------------+-----------------------+ | Variable_name | Value | +--------------------------+-----------------------+ | require_secure_transport | OFF | | secure_file_priv | /var/lib/mysql-files/ |+--------------------------+-----------------------+ 2 rows in set (0.01 sec) 数据导入需要注意的: 空值要用 \\N 代替，而不能直接使用空 分隔符一般用 tab 注意换行符 总结 总之，感觉之前 windows 和 ubuntu 下都没有这么麻烦，这里总结一下吧，感觉以后会用的很多，不想踩坑了。 参考： MySQL8.0.11 连接错误 2059 解决方法 How to grant all privileges to root user in MySQL 8.0 centos mysql 初探 – 配置、基本操作及问题 ","date":"2018-12-07","objectID":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/:8:0","tags":["MySQL","学习"],"title":" CentOS7安装并使用MySQL","uri":"/posts/linux/centos7%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8mysql/"},{"categories":["工具"],"content":" 本来以为已经是最后一次折腾了，但是总是生活不停，折腾不止，觉得本地文件管起来还是有点麻烦，看到语雀 markdown 又做的这么好，前几天还准备拿它当云笔记用，但是据说底层存的都是 md 格式，有的时候又还是不太方便，不过做编辑器来说确实很爽了，自带图床，还有 github 上开源的一个接口。 准备工作 ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:0:0","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"更新 node.js 和 npm 刚刚来就是坑，不过还是准备从正常的步骤开始说吧，就是博客基于的是 nodejs，很多包的安装都是采用 npm 统一管理的，因为有些插件需要使用新的版本，所以需要先更新一下，这里只说一下 windows 下面的操作。 ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:1:0","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"更新 node.js window 下并没有网上说的乱七八糟的命令行更新方式，直接在官网下载最新的安装包就可以。然后安装在之前的位置进行覆盖就可以更新了。更新之后通过命令: $node -v v10.13.0 ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:1:1","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"更新 npm 通过命令： $npm install -g npm #更新后的版本可以看到 $npm -v 6.4.1 ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:1:2","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"更新包 可以使用命令查看可以更新的包: $npm outdated #查看需要更新的包： Package Current Wanted Latest Location hexo-helper-live2d MISSING 3.1.0 3.1.0 hexo-site hexo 3.3.9 3.8.0 3.8.0 hexo-site hexo-douban 0.2.14 0.2.16 1.0.6 hexo-site hexo-generator-archive 0.1.4 0.1.5 0.1.5 hexo-site hexo-generator-search 2.2.5 2.3.0 2.3.0 hexo-site hexo-renderer-ejs 0.2.0 0.2.0 0.3.1 hexo-site hexo-renderer-marked 0.2.11 0.2.11 0.3.2 hexo-site hexo-server 0.2.2 0.2.2 0.3.3 hexo-site $npm install --save # 之后修改package.json文件，修改到对应的版本。然后执行命令，进行更新： $npm install --save ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:1:3","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"安装语雀文章下载插件 首先这里鸣谢开源的插件：[yuque-hexo](https://github.com/x-cold/yuque-hexo)，通过工具可以将语雀知识库中的文件同步到本地，大部分功能和步骤在仓库中都有些，但是自己做的时候还是踩了坑，这里就还是写一下吧。 ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:2:0","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"1.创建语雀知识库 打开语雀 创建自己的博客知识库，并且要设置成公开的。可以在设置中看到链接如下： 同时打开blog 知识库:https://www.yuque.com/mianhk/gaqqwc可以打开知识库。 ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:2:1","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"2.在本地安装 yuque-hexo npm i -g yuque-hexo ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:2:2","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"3.配置 package.json \"scripts\": { \"clean\": \"npm run clean:yuque \u0026\u0026 hexo clean\", \"clean:yuque\": \"DEBUG=yuque-hexo.* yuque-hexo clean\", \"deploy\": \"hexo deploy\", \"publish\": \"npm run clean \u0026\u0026 npm run deploy\", \"dev\": \"hexo s\", \"sync\": \"DEBUG=yuque-hexo.* yuque-hexo sync\", \"reset\": \"npm run clean:yuque \u0026\u0026 npm run sync\" }, \"yuqueConfig\": { \"baseUrl\": \"https://www.yuque.com/api/v2\", #这是语雀的永久链接，直接复制就可以 \"login\": \"mianhk\", #用户名，上个链接的第一个下划线 \"repo\": \"gaqqwc\", #知识库链接，第二个下划线 \"mdNameFormat\": \"slug\", #导出本地的文件名为随机的数字，比直接的中文title要好看， 可以直接用了 \"postPath\": \"source/_posts/yuque\" #存在本地文件夹的位置 } ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:2:3","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"4.删除和同步文章 #删除文章 $yuque-clean [INFO] yuque-hexo clean start. [INFO] remove yuque posts: F:\\blog\\mianhk.github.io\\source\\_posts\\yuque\\ [INFO] remove yuque local file: F:\\blog\\mianhk.github.io\\yuque.json [INFO] yuque-hexo clean finished. #同步文章 $yuque-hexo sync [INFO] yuque-hexo sync start. [INFO] remove yuque posts: F:\\blog\\mianhk.github.io\\source\\_posts\\yuque\\ [INFO] loading config: F:\\blog\\mianhk.github.io\\package.json [INFO] downloading articles: {\"baseUrl\":\"https://www.yuque.com/api/v2\",\"login\":\"mianhk\",\"repo\":\"gaqqwc\",\"mdNameFormat\":\"slug\",\"postPath\":\"source/_posts/yuque\"} [INFO] reading from local file: F:\\blog\\mianhk.github.io\\yuque.json [INFO] download article body: 11月生活小结 [INFO] download articls done! [INFO] writing to local file: F:\\blog\\mianhk.github.io\\yuque.json [INFO] create posts director (if it not exists): F:\\blog\\mianhk.github.io\\source\\_posts\\yuque [INFO] generate post file: F:\\blog\\mianhk.github.io\\source\\_posts\\yuque\\xzxhcv.md [INFO] yuque-hexo sync finished. ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:2:4","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"5.修改文章的 title 和 tag 等 还是跟之前的格式直接写即可。 title: date: update: categories: tags: [] ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:2:5","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"6.部署博客 记录一些坑 知识库一定要是公开的 windows 下更新 nodejs 不能用 n，即使强制使用了也还是无法更新 新版本的 npm。如果改了 package.json，且 package.json 和 lock 文件不同，那么执行npm i时 npm 会根据 package 中的版本号以及语义含义去下载最新的包，并更新至 lock。 ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:2:6","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"Reference: https://github.com/x-cold/yuque-hexo https://luan.ma/post/yuque2blog/ https://www.zhihu.com/question/62331583 将 Hexo 升级到 v3.5.0 Demo Json https://segmentfault.com/a/1190000017797561 https://lkc.im/archives/1d99.html https://x-d.xyz/2019/04/02/yuque/Hexo%E5%8D%9A%E5%AE%A2%E4%BA%91%E7%AB%AF%E5%86%99%E4%BD%9C%EF%BC%8C%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/ ","date":"2018-11-14","objectID":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:3:0","tags":["Hexo","折腾","语雀"],"title":" 使用语雀编辑器写静态博客","uri":"/draft/deprecated/yuque/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%99%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":" 最近又到了生活有点不知道干什么的时候，有的时候觉得自己对什么都很有信心，有的时候又觉得什么都做不好。想起来以前总是站在自己的角度看一些事情，看自己。直到现在有时候看看，自己的问题，一直放在那，并没有好多少，只不过我像对待其他人一样宽容的对待了自己。 ","date":"2018-11-05","objectID":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/:0:0","tags":["随笔","生活","日常总结"],"title":" 11月生活小结(2018)","uri":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/"},{"categories":["随笔"],"content":"专注的做自己该做的事情 发现自己原来一直是个喜欢折腾的人，平时折腾 Linux，折腾 chrome 的插件，学一些东西的时候，好像总是把关注点搞错了。先以几件事举个例子吧。 ","date":"2018-11-05","objectID":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/:1:0","tags":["随笔","生活","日常总结"],"title":" 11月生活小结(2018)","uri":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/"},{"categories":["随笔"],"content":"学习 C++ 比如学个语言，C++，先在网上搜 Windows 下 C 好用的编辑器，嗯，找到了 Dev C，觉得还挺好的，确实，直接编译就能运行，而且还是 gcc 的编译，也比较符合现在吧，总比那些 VC6.0 要好。然后写了一段，刷题的时候发现怎么有的时候中文粘贴会有问题，垃圾，赶紧换一个。 于是就看到了网上的很多说 vim 搭建 IDE 很酷，而且 vim 自己也用过，自己也恰好有台云服务器，自己要做的也是 Linux 下的 C++开发，也恰好可以练习一些比如 gcc 工具链呀，写写 Makefile 呀，嗯，于是网上找了一堆 vim 的配置，配置的很酷，找了很多，各种修改，甚至白天都没心思干活了也要搞好，中午回宿舍开着电脑马上开始弄，到了后面折腾的都累了，在 github 上找到了一个别人配好的，看了一下界面，唉，算了就这个吧。于是 vim 下一阵操作，还学了配置的一些快捷键：诸如切换窗口，切换文件，语法错误之类的，还有即时运行之类的操作。就像下面这样。。 过段时间发现，这个云服务器下面写代码还是不太好，1M 的小水管，有的时候会卡，这就很难受了，而且说得联系 Makefile 那些，其实能练的也比较少，一般都是直接 make 一下文件就好了，或者是一个写好的 Makefile 直接全编译了。于是又转回了 Windows，试了一下宇宙 IDE–VS，果然不一样，先下个最新版吧，2017 怎么这么大呀，算了，换 2015 吧，额，2015 好像也有点大，要不就试试 2013 吧，这个大小好像还凑和，于是下载下来，一顿折腾，终于可以写了，唉，这个怎么每次还要加 pause 才行呀，而且这个小黑框输入也太难受了，而且打开一下这么大，算了，溜了溜了。 又看到 Idea 家的跨平台的 Clion，因为之前用过 idea，所以觉得还不错，现代的 IDE，那就用用看吧，但是这个环境，还要配置 MINGW64 呀，算了，配置吧，网上一大堆了，虽然有些有坑，虽然有的时候网速很慢，但是没事，我能克服困难。。于是就用了这个，确实还挺好看的，用着也还算顺手吧，赶紧把主题呀，各种呀配置一下呀，哦，还有 vim，这么好用的工具。试了一段时间写项目确实不错，做个小项目，写起来还可以的。但是是要在 Linux 下编译的呀，于是又找到了 ftp 工具。。。 讲道理到这应该也差不多了，但是，Clion 每次打开也是很大了，总感觉不是很方便，要不还是？ 哦，最近正好出了一个编辑器还挺好用的，网上看着各种推荐，vscode，网上都说还可以，微软做的，我试试吧。哎，做编辑器确实可以，平时写个算法之类的呀。于是又是各种插件折腾，对了，再弄个 c++的编译环境吧，但是这个编译也有点慢呀，算了，忍忍吧。 上面大概是这一年多以来学习 C++过程的坑了，不知道很多 Programmer 是不是也跟我一样，但是回头想想真的花了很多乱七八糟的时间来做一些无关紧要的事情，其实就是没有抓住重点吧。 ","date":"2018-11-05","objectID":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/:1:1","tags":["随笔","生活","日常总结"],"title":" 11月生活小结(2018)","uri":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/"},{"categories":["随笔"],"content":"服务器和博客的折腾 因为一直有台服务器，为了不用开虚拟机就做 Linux 操作，自己在上面的折腾也算是蛮多吧，从最开始想跑个微信（一个 github 上的项目），然后折腾 vim，折腾挖矿（收益当然是不用说，但是当时感觉还不错），后面又折腾 Jupyter notebook，tmux，zsh，也是花费了不少的时间，但是结果是，关于真正技术方面的，反而学到的比较少。 ","date":"2018-11-05","objectID":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/:1:2","tags":["随笔","生活","日常总结"],"title":" 11月生活小结(2018)","uri":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/"},{"categories":["随笔"],"content":"What’s Next 有的时候自己也在想这些原因，以前可能也会有些这样，但是至少能在一方面能够保持很好的一个学习状态，但是直到最近，可能也是找完了工作吧，心态也有些放松了，所以就更。但是，真正的自由，是在自律的条件下的。 所以计划和要求也还是要有的： 学习 MySQL 和 Go 语言 每周至少一篇技术博客 上班时间，就干该干的事情 玩的时候，一定不要想着学习 不吃夜宵 ","date":"2018-11-05","objectID":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/:2:0","tags":["随笔","生活","日常总结"],"title":" 11月生活小结(2018)","uri":"/posts/daily/11%E6%9C%88%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%932018/"},{"categories":["Golang"],"content":" 并发是Go语言一直宣扬的优势之一，写起来很方便，但在实际的并发编程中，还是有很多需要注意的，学习了极客时间的《Go 并发编程实战课》，这里重新梳理总结一下 基本并发原语 ","date":"2018-11-05","objectID":"/draft/go-concurrent/:0:0","tags":["Golang","并发"],"title":"【Golang】go并发编程","uri":"/draft/go-concurrent/"},{"categories":["Golang"],"content":"mutex 互斥锁提供两种方法Lock和Unlock，进入临界区前调用Lock，离开临界区是调用Unlock。 当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine 就会阻塞在 Lock 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权。 ","date":"2018-11-05","objectID":"/draft/go-concurrent/:1:0","tags":["Golang","并发"],"title":"【Golang】go并发编程","uri":"/draft/go-concurrent/"},{"categories":["Golang"],"content":"(1)嵌入在struct中使用 type Counter struct{ mu sync.Mutex Count int } # 或采用直接嵌入字段 type Counter struct{ sync.Mutex Count int } 当初始化Counter时，可以不用初始化Mutex字段，而不会因为没有初始化出现空指针或者是无法获取到锁的情况。 ","date":"2018-11-05","objectID":"/draft/go-concurrent/:1:1","tags":["Golang","并发"],"title":"【Golang】go并发编程","uri":"/draft/go-concurrent/"},{"categories":["Golang"],"content":"(2) 方法封装 type Counter struct{ name string mu sync.Mutex //一般将Mutex放在要控制的字段上面，然后加空格（便于识别） count int } func (c *Counter) Incr(){ c.mu.Lock() c.count++ c.mu.Unlock() } 这样可以对外不暴露加锁的逻辑（当然还需要写获取值等方法配合使用） ","date":"2018-11-05","objectID":"/draft/go-concurrent/:1:2","tags":["Golang","并发"],"title":"【Golang】go并发编程","uri":"/draft/go-concurrent/"},{"categories":["Golang"],"content":"实现原理 channel 其他并发原语 当然最近很不喜欢用其他这个词，因为其他意味 ","date":"2018-11-05","objectID":"/draft/go-concurrent/:1:3","tags":["Golang","并发"],"title":"【Golang】go并发编程","uri":"/draft/go-concurrent/"},{"categories":["工具"],"content":" Hexo的又双叒一次折腾，以前觉得hexo部署博客还是很麻烦，除了每次操作完都得等待生成一下，还有的就是有时候很久一生成，都是看人品出错，以前也弄过那种自动的脚本，每天自己生成然后push，但是出错的时候就又是很麻烦。直到这次看到了Travis CI… 听到持续集成这个词还是最近逛github的时候，看到一些讨论才搜了一下这个，不过之前也是想过这个问题，毕竟有痛点就会想。之前折腾hexo博客的时候，试过在windows下面写个bat脚本，定时hexo clean hexo g -d一下，但是有时候文件太多搞乱了，就出问题了，一段时间没弄，就又得回来折腾。后面也试过就不在windows下面操作了，干脆只在博客文件夹弄，然后编辑器自动ftp到服务器上，再在服务器上自动生成，好像也没啥区别。直到看到Travis CI，才知道大佬们为啥都这么青睐hexo了。那就开整吧。 Travis思想 简单点就是，当我们的github公开仓库与Travis CI绑定后，在仓库中建立一个Travis CI.travis.yml文件，每当.travis.yml文件中监听的分支发现有变动时，会根据.travis.yml中的配置进行操作。 Github准备 首先是准备gitpages，仓库之前已经有了，这个是放生成的静态页面的，还有一个仓库，放的是博客的源码。之前的一般操作都是在源码博客中通过hexo g -d后push到gitpages目录中，所以大部分操作一般都是在这个源码中进行的，gitpages仓库是用来展示的，准确来说是gitpages仓库的master分支。 由于Travis CI可以监听某个分支，所以这样一想，就不用弄两个仓库了，只需要弄两个分支即可：源码放在source分支，并又Travis CI监听，每次push后会自动push到master分支，完成博客的自动部署。 Travis CI连接到仓库需要token才能操作，就相当于一把钥匙，可以在Settings-\u003e Developer settings-\u003ePersonal access tokens-\u003eGenerate new token,填写Token description，之后勾选repo，选择generate token。如图： 点击复制按钮复制token： Travis CI设置 ","date":"2018-10-26","objectID":"/posts/tools/hexo_travis-ci/:0:0","tags":["博客","折腾"],"title":"Travis CI 自动部署博客","uri":"/posts/tools/hexo_travis-ci/"},{"categories":["工具"],"content":"github账号登录 在Travis CI网站通过github账号登录后，开启gitpages仓库的同步，然后点击settings进行设置。 ","date":"2018-10-26","objectID":"/posts/tools/hexo_travis-ci/:1:0","tags":["博客","折腾"],"title":"Travis CI 自动部署博客","uri":"/posts/tools/hexo_travis-ci/"},{"categories":["工具"],"content":"通用设置和配置环境变量 之后开启设置，并设置环境变量(主要是为了travis的自动部署，但是token直接公开有风险，因此需要在这里设置): 在source分支创建.travis.yml 文件 在gitpages仓库的source分支创建。这里涉及几个git的操作，真是坑踩多了，自然就会多用几个命令了。。 ","date":"2018-10-26","objectID":"/posts/tools/hexo_travis-ci/:2:0","tags":["博客","折腾"],"title":"Travis CI 自动部署博客","uri":"/posts/tools/hexo_travis-ci/"},{"categories":["工具"],"content":"拉取远程仓库并创建新分支 操作步骤为： # 克隆项目到本地 \u003e git clone git@github.com:mianhk/mianhk.github.io.git # 创建并切换到source分支 \u003e git checkout -b source 切换到source分支后，将本地除.git文件夹的其他文件删除，并将之前的源码文件拷贝到当前文件夹，然后提交到远程的source分支。 # 提交本地hexo分支到远程仓库的hexo分支 git push origin hexo:hexo ","date":"2018-10-26","objectID":"/posts/tools/hexo_travis-ci/:3:0","tags":["博客","折腾"],"title":"Travis CI 自动部署博客","uri":"/posts/tools/hexo_travis-ci/"},{"categories":["工具"],"content":"创建.travis.yml文件 当然这个文件网上一找一大堆，也不是我自己写的，参考：https://juejin.im/post/5a1fa30c6fb9a045263b5d2a 自己进行了一点修改：具体如下： # 使用语言 language: node_js # node版本 node_js: stable # 设置只监听哪个分支 branches: only: - source # 缓存，可以节省集成的时间，这里我用了yarn，如果不用可以删除 cache: apt: true directories: - node_modules # tarvis生命周期执行顺序详见官网文档 before_install: - export TZ='Asia/Shanghai' # 更改时区 - git config --global user.name \"mianhk\" - git config --global user.email \"gcyu@gmail.com\" # 由于使用了yarn，所以需要下载，如不用yarn这两行可以删除 #- curl -o- -L https://yarnpkg.com/install.sh | bash #- export PATH=$HOME/.yarn/bin:$PATH - npm install -g hexo-cli install: # 不用yarn的话这里改成 npm i 即可 #- yarn - npm i script: - hexo clean - hexo generate after_success: - cd ./public - git init - git add --all . # commit 中间添加时间信息 - git commit -m \"Travis CI Auto Builder at `date +\"%Y-%m-%d %H:%M\"`\" # 这里的 REPO_TOKEN 即之前在 travis 项目的环境变量里添加的 - git push --quiet --force https://$REPO_TOKEN@github.com/mianhk/mianhk.github.io.git master 之后便可以通过在本地或者其他电脑上通过git在source分支上的操作实现自动部署了。 一些坑 一些拷贝文件产生的错误，导致中间出错了好几次，通过调整文件进行本地测试的时候，没有问题，但是自动构建就还是出问题。需要将原来的源码中的config.yml的push选项进行一下修改。 Reference 使用Travis CI自动部署Hexo博客 Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程 ","date":"2018-10-26","objectID":"/posts/tools/hexo_travis-ci/:4:0","tags":["博客","折腾"],"title":"Travis CI 自动部署博客","uri":"/posts/tools/hexo_travis-ci/"},{"categories":["面试经验"],"content":"操作系统的分页分段 操作系统之分页分段介绍 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:0:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"分页存储 思想：将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)或物理块，每个物理块的大小一般取2的整数幂。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）。 逻辑地址道物理地址变化原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。 优点：没有外碎片，提高内存的利用率。一个程序不必连续存放。便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。 缺点：无论数据有多少，都只能按照页面大小分配，容易产生内部碎片。无法体现程序逻辑。页长与程序的逻辑大小不相关。不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:1:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"分段存储 思想：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中（写c程序时会用到），并且每个程序可以有多个相同类型的段。段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。 在为某个段分配物理内存时，可以采用首先适配法、下次适配法、最佳适配法等方法。在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。 地址映射: 在分段存储中，整个进程的地址空间是二维的，即其逻辑地址由段号和段内地址两部分组成。 优点：分段对程序员可见。段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。方便编程，分段共享，分段保护，动态链接，动态增长。 缺点：主存空间分配比较麻烦。外部碎片。由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚拟地址和实存地址的最低若干二进制位作为段内地址，并与段号进行直接拼接，必须用加法操作通过段起址与段内地址的求和运算得到物理地址。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:2:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"分页存储和分段存储的区别 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；段则是信息的逻辑单位，它含有一组其意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址是，即需给出段名，又需给出段内地址。 分页信息很难保护和共享、分段存储按逻辑存储所以容易实现对段的保存和共享。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:3:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"段页存储 程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。 它首先将程序按其逻辑结构划分为若干个大小不等的逻辑段，然后再将每个逻辑段划分为若干个大小相等的逻辑页。主存空间也划分为若干个同样大小的物理页。辅存和主存之间的信息调度以页为基本传送单位，每个程序段对应一个段表，每页对应一个页表。 段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量 CPU访问时，段表指示每段对应的页表地址，每一段的页表确定页所在的主存空间的位置，最后与页表内地址拼接，确定CPU要访问单元的物理地址。 段页存储管理方式综合了段式管理和页式管理的优点，但需要经过两级查表才能完成地址转换，消耗时间多。 过程：检查是否越界。利用段表始址和段号来求出该段所对应的段表项在段表中的位置，得到该段的页表始址。读出该页所在的物理块号b。构建物理地址。 优点：提供了大量的虚拟存储空间。有效地利用主存，为组织多道程序运行提供了方便。 缺点：增加了硬件成本、系统的复杂性和管理上的开销。存在系统抖动的风险。存在内碎片。各种表占用更多的空间。 Linux自旋锁 线程同步 http://bestmind.space/posts/%E5%B8%B8%E8%A7%81C-%E9%9D%A2%E8%AF%95%E9%A2%98/ 线程同步和线程互斥的区别 线程同步的方式:互斥锁、读写锁(共享-独占锁)、条件变量和信号量 进程间通信 进程间的通信方式 管道、有名管道、信号、共享内存、消息队列、信号量、套接字、文件. (1)管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。 管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的首端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。分为普通管道、流管道、命名管道。 (2)命名管道(named pipe):命名管道也是半双工的通信方式，它克服了管道没有名字的限制，并且它允许无亲缘关系进程间的通信。命令管道在文件系统中有对应的文件名，命名管道通过命令mkfifo或系统调用mkfifo来创建。 (3)信号:信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。除了用于进程通信外，进程还可以发送信号给进程本身。 (4)消息队列：克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小的限制。由消息链表的结构实现。 (5)信号量(semophore):信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 (6)共享内存：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。 (7)套接字: 与其他通信机制不同的是，它可用于不同机器间的进程通信。但是将通信转移到了应用层。 select、poll、epoll的区别 死锁 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 死锁产生的四个必要条件: 互斥条件:一个资源每次只能被一个进程使用 不可剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺 请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系. ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:4:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"死锁避免 银行家算法：检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:5:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"死锁解除 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。 进程有哪几种状态？ 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源； 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数； 阻塞状态： 进程等待某种条件，在条件满足之前无法执行； 操作系统中进程调度策略有哪几种？ FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化 时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。 虚拟内存 为什么有虚拟内存：对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上 缺页：如果虚拟内存的页并不存在于物理内存中，会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。 页面置换算法： FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）； LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断； LFU（Least frequently use）最少使用次数算法：根据使用次数来判断； OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:6:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"多线程中栈与堆是公有的还是私有的 一般来说栈是私有的，堆是公有的。 但是在多线程中，可以为特定的线程创建私有的堆。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:7:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"进程是资源分配的最小单位，线程是CPU调度的最小单位 进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。 与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。 线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。 因此一个简单的解释就是：进程拥有PCB，而多个线程共享一个进程的PCB。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:8:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"进程和线程的区别 进程与线程的一个简单解释 地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 调度和切换：线程上下文切换比进程上下文切换要快得多。 在多线程OS中，进程不是一个可执行的实体。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:8:1","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"进程的基本状态 状态：运行、阻塞、挂起阻塞、就绪、挂起就绪 状态之间的转换： 准备就绪的进程，被CPU调度执行，变成运行态； 运行中的进程，进行I/O请求或者不能得到所请求的资源，变成阻塞态； 运行中的进程，进程执行完毕（或时间片已到），变成就绪态； 将阻塞态的进程挂起，变成挂起阻塞态，当导致进程阻塞的I/O操作在用户重启进程前完成（称之为唤醒），挂起阻塞态变成挂起就绪态，当用户在I/O操作结束之前重启进程，挂起阻塞态变成阻塞态； 将就绪（或运行）中的进程挂起，变成挂起就绪态，当该进程恢复之后，挂起就绪态变成就绪态； \"R (running)\", /* 0 */ \"S (sleeping)\", /* 1 */ \"D (disk sleep)\", /* 2 */ \"T (stopped)\", /* 4 */ \"t (tracing stop)\", /* 8 */ \"X (dead)\", /* 16 */ \"Z (zombie)\", /* 32 */ }; ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:9:0","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"1.进程管理-\u003eCPU 任务调度算法 1.先来先服务算法 优点：简单，易于理解和实现。 缺点：一批任务的平均周转时间取决于各个任务到达的顺序，如果短任务位于长任务之后，那么将增大平均周转时间。 2.短作业优先算法 SJF算法的基本思路是：各个任务在开始执行之前，必须事先预计好它的执行时间，然后调度器将根据这些时间，从中选择用时较短的任务优先执行。 SJF算法有两种：不可抢占方式和可抢占方式。其中可抢占方式又叫最短剩余时间优先算法（Shortest Remaining Time First，SRTF）。 3.时间片轮转算法 时间片轮转算法（Round Robin，RR）的基本思路是：把系统当中的所有就绪任务按照先来先服务的原则，排成一个队列，然后再每次调度的时候，把处理器分派给队列当中的第一个任务，让它去执行一小段CPU时间（即时间片，time slice）。当这个时间片结束时，如果任务还没有执行完成的话，将会发生时钟中断，在时钟中断里面，调度器将会暂停当前任务的执行，并把它送到就绪队列的末尾，然后执行当前的队首任务。反之，如果一个任务在它的时间片用完之前就已经结束了或者阻塞了，那么它就会立即让出CPU给其他任务。 优点：公平性，各个就绪任务能得到相同的时间片；活动性，每个就绪任务能一直保持活动。 缺点：时间片的大小q要适当选取，如果选择不当，将会影响到系统的性能和效率。如果q太大，每个任务都在一个时间片内完成，这就退化为先来先服务算法了。如果q太小，每个任务需要更多的时间片才能运行结束，这就使任务之间的切换次数增加，从而增大了系统的管理开销，降低了CPU的使用效率。一般来说，q值选取在20ms~50ms比较合适。 4.优先级算法 优先级调度算法（priority）的基本思路是：给每个任务都设置一个优先级，然后在任务调度的时候，在所有处于就绪状态的任务中选择优先级最高的任务去运行。上文提到的短作业优先算法其实也是一种优先级算法，每个任务的优先级就是它的运行时间，运行时间越短，优先级越高。 进程与线程 简单的一句话：进程是资源分配的基本单位、线程是资源调度的基本单位。这句话看起来很简单，但是核心却不仅仅如此。 进程 进程间通信方式 管道（pipe）,流管道(s_pipe)和有名管道（FIFO） 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。 信号（signal） 信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。 消息队列 消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。 信号量 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:9:1","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"Linux 的启动流程 BIOS-\u003e主引导记录-\u003e操作系统-\u003e加载内核(/boot):载入内核文件-\u003e启动初始化进程：运行第一个程序 /sbin/init，初始化系统环境。-\u003e确定运行级别:运行这些开机启动的程序。-\u003e加载开机启动程序-\u003e用户登录-\u003e进入 login shell-\u003e打开 non-login shell ","date":"2018-06-24","objectID":"/posts/sumary/interview_operation/:9:2","tags":["面试","操作系统","工作","Linux"],"title":"面试总结-操作系统","uri":"/posts/sumary/interview_operation/"},{"categories":["面试经验"],"content":"编程基础 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:0","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"C++ 内存管理方式 堆、栈、自由存储区、全局/静态存储区、常量存储区 自由存储区存储malloc申请的内存 (1)从静态存储区域分配 。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如 全局变量， static 变量 。 (2)在栈上创建 。在执行函数时， 函数内局部变量的存储单元都可以在栈上创建 ，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 (3)从堆上分配 ， 亦称动态内存分配 。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:1","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"extern “C\"和extern的作用 extern “C\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。 (http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html) ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:2","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"为什么需要内存对齐 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:3","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"c++内存问题 缓冲区溢出（buffer overrun）。 用 std::vector/std::string 或自己编写 Buffer class 来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。 空悬指针/野指针。 用 shared_ptr/weak_ptr 重复释放（double delete）。 内存泄漏（memory leak）。 不配对的 new[]/delete。 把 new[] 统统替换为 std::vector/scoped_array。 内存碎片（memory fragmentation）。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:4","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"static关键字 作用： 函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值 在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问 在模块内的 static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内。起到了隐藏的作用 在类的 static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量 静态全局变量不要放在头文件里 (https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html) 第6条 C++中的static关键字的总结 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:5","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"几个复制的声明 void * ( * (*fp1)(int))[10]; //fp1是一个指针，指向一个函数，函数参数为int，函数返回参数是一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个void* 指针。 float (*(* fp2)(int,int,int))(int); //fp2是一个指针，指向一个函数，函数参数为3个int，函数的返回值是一个指针，指针指向一个函数，函数的参数是1个int，返回float。 int (* ( * fp3)())[10](); //fp3是一个指针，指向一个函数，函数没有参数，函数返回值为一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个函数指针，函数没有参数，返回int。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:6","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"strlen()和sizeof() 区别与联系： 种类： sizeof是运算符，并不是函数，结果在编译时得到,因此sizeof不能用来返回动态分配的内存空间的大小。用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系；strlen是字符处理的库函数,当数组名作为参数传入时，实际上数组就退化成指针了。。 输入参数： sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化），还可以用函数做参数；strlen的参数只能是字符指针且结尾是’\\0’的字符串。 功能： sizeof():获得保证能容纳实现所建立的最大对象的字节大小 strlen():返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。 返回： 当适用于一个结构类型时或变量， sizeof 返回实际的大小， 当适用于一静态地空间数组， sizeof 归还全部数组的尺寸。 sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸 https://blog.csdn.net/21aspnet/article/details/1539951 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:7","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"变量声明和定义 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。 相同变量可以再多处声明（外部变量extern），但只能在一处定义。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:8","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"结构体和union 1.在存储多个成员信息时，编译器会自动给struct第个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。 2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。 3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。 未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。 eg: struct sTest { int a; //sizeof(int) = 4 char b; //sizeof(char) = 1 short c； //sizeof(short) = 2 }x; #最终实际占用不止4+1+2，因为要考虑内存对齐的问题 union uTest { int a; //sizeof(int) = 4 double b; //sizeof(double) = 8 char c; //sizeof(char) = 1 }x; #分配的内存 size 就是8 byte pragma pack () 取消指定对齐，恢复缺省对齐 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:9","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"static ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:10","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"malloc/new和free/delete malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。 malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。 malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。 free和delete对应。当delete一个对象数组时，delete只删除了一个，需要使用delete[] ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:11","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"const 宏定义和const函数的区别 宏在编译时完成替换，直接进行替换，执行起来更快，但是可能会存在一些风险；函数调用在运行时需要跳转到具体调用函数。如： #define area(x) x*x int main(){ int y=area(2+2); std::cout\u003c\u003cy\u003c\u003cstd::endl; # 输出为8=2+2*2+2，而不是以为的16 } 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。 一般可以对const常量进行调试，但不能对宏常量进行调试。 宏函数不要在最后加分号。 总之，一般尽量用const比较好。 const的分辨(顶层const和底层const) 一般来说，const的分辨可以直接通过看const的最左侧，如果是指针，则指针是const，若为类型，则变量为const。当const在最左侧时，看const右侧。 常量指针和指针常量： 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。 指针常量是一个常量，指针的值可以改变。如int *const p。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:12","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"指针和引用 区别 指针是具体的变量，需要占存储空间。引用只是别名，不占用具体存储空间。这是最基本的一点，其他的特点也就可想而知了。 指针可以先声明，但是引用声明的时候就必须初始化，不存在空的引用很容易理解。 指针变量可以改变所指的对象。但是引用一旦声明了就不能再改变引用的对象了。 引用相关问题 引用是某个变量的别名，因此定义的时候必须初始化，也不能把该引用再改成其他变量的别名。 声明一个引用并没有定义新变量，引用本身不是一种数据类型。也不占用存储空间。 不能建立数组的引用。其实这句话的意思是：不能建立引用的数组，例如：int \u0026 ref[3] = { 2, 3, 5}; 但是可以建立数组的引用:例如：int arr[3]; int (\u0026tef)[3] = arr; 原因是：引用时不占空间的，声明引用数组没法分配空间。见为什么不能建立引用数组 将引用作为函数的参数时，可以避免对变量或者对象的复制，因此不会调用对象的拷贝构造函数。当不希望传入的引用参数不被改变时，使用const引用。 函数中不能返回局部变量的引用，不能返回函数内部ne分配的内存的引用。（虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄露。）。 可以返回类成员的引用，但最好是const。 当类中存在const或者引用时成员变量时，必须使用初始化表。 指针相关问题 指针的相关判断 int *p[10] int (*p)[10] int *p(int) int (*p)(int) int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。 int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。 int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。 int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。 指针与数组名 二者均可通过增减偏移量来访问数组中的元素。 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。 野指针 空悬指针，不是指向null的指针，是指向垃圾内存的指针。 产生原因及解决办法： 指针变量未及时初始化 =\u003e 定义指针变量及时初始化，要么置空。 指针free或delete之后没有及时置空 =\u003e 释放操作后立即置空。 指针和数组的区别 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。 修改内容上的差别:指针可能指向一块内存，但是指向的常量却无法通过下标计算。 char a[] = “hello”; a[0] = ‘X’; char *p = “world”; // 注意p 指向常量字符串，指向的是常量区 p[0] = ‘X’; // 编译器不能发现该错误，运行时错误 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。 char a[] = \"hello world\"; char *p = a; cout\u003c\u003c sizeof(a) \u003c\u003c endl; // 12 字节 cout\u003c\u003c sizeof(p) \u003c\u003c endl; // 4 字节 //计算数组和指针的内存容量 void Func(char a[100]) { cout\u003c\u003c sizeof(a) \u003c\u003c endl; // 4 字节而不是100 字节 } ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:13","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"volatile volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。 多线程中被几个任务共享的变量需要定义为volatile类型。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:14","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"堆栈 区别 申请方式不同：栈由系统自动分配，堆由程序员手动分配 申请大小不同：栈顶和栈底都是设定好的，大小固定，可以通过ulimit -a查看，通过ulimit -s修改。堆向高地址扩展，是不连续的内存区域，大小可以调整。 申请效率不同：栈由系统分配，速度快，没有碎片。堆速度慢，且有碎片。 内存分配 https://blog.csdn.net/nkguohao/article/details/8771867 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:1:15","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"面向对象 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:2:0","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"面向对象三大特性 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。 继承性：让某种类型对象获得另一个类型对象的属性和方法。 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:2:1","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"构造函数和析构函数 1.构造函数、析构函数中都不要调用虚函数 我们知道，构造函数一般不能是虚函数，而析构函数一般必须是虚函数。原理也很清晰，构造函数，由于构造顺序是从基类到派生类，所以调用虚函数，可能派生类还没有构造出来，没有意义。而对于析构函数来说，又必须是虚函数，因为只有先从子类对象进行销毁，才能保证资源不泄露。 在构造函数和析构函数中都不要调用虚函数也是这个道理。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:2:2","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"成员变量和成员函数 1.静态成员变量是需要初始化 其实这样说的是有点问题的，应该是静态成员是需要定义的。 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。 《c++primer》里面说在类外定义和初始化是保证static成员变量只被定义一次的好方法。 但static const int就可以在类里面初始化 class Base{ public: static int class_p; //只有声明，而没有定义，不能直接调用 }; int Base::class_p=3; //进行定义 https://blog.csdn.net/qq_16209077/article/details/52602601 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:2:3","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"拷贝构造函数 调用情况： 用一个类的对象去初始化该类的另一个对象时。 函数形参是类的对象时，调用函数将函数的形参和实参结合的时候。 函数返回值是类的对象，函数调用完成返回时。 重写拷贝构造函数 一般会默认生成类的拷贝构造函数，但是当涉及动态分配存储空间时，默认的拷贝构造函数就会有问题，因此需要重写拷贝构造函数，并且采用深拷贝。 浅拷贝和深拷贝： ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:2:4","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"多态 多态：对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面： 编译时多态：函数和运算符的重载。 运行时多态：继承和虚函数。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:2:5","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"友元 特性：单向的，传递性，不能继承 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:2:6","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"标准模板库 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:3:0","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"编译和调试 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:4:0","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"编译过程 预处理-\u003e编译-\u003e汇编-\u003e链接 预处理：展开宏定义；处理条件编译；处理#include指令；去掉注释；添加行号和文件名标识；保留所有#pragma编译器指令。 编译：词法分析；语法分析；语义分析；中间语言生成；目标代码生成与优化。 链接：各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:4:1","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"静态库和动态库 二者的不同点在于代码被载入的时刻不同。静态库和动态库的最大区别,静态情况下,把库直接加载到程序中,而动态库链接的时候,它只是保留接口,将动态库与程序代码独立,这样就可以提高代码的可复用度，和降低程序的耦合度。 静态库的代码在编译过程中已经被载入可执行程序,程序运行时将不再需要该静态库，因此可执行程序体积比较大。在Linux中以.a结尾 动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小,在程序运行时还需要动态库存在。不同的应用程序如果调用相同的库,那么在内存中只需要有一份该动态库(共享库)的实例。在Linux中以.so结尾 当静态库和动态库同名时， gcc命令将优先使用动态库.为了确保使用的是静态库, 编译时可以加上 -static 选项，因此多第三方程序为了确保在没有相应动态库时运行正常，喜欢在编译最后应用程序时加入-static 优缺点： 1.动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。 2.动态库更新很容易，当库发生变化时，接口没变只需要用新的动态库替换掉就可以。静态库需要重新编译。 3.静态库静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会高一些。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:4:2","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"安全相关 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:5:0","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"类型安全 类型安全很大程度上可以理解为内存安全。类型安全的代码不会试图去访问自己没有被授权的内存区域。 对于C语言来说，很多操作都不是类型安全的。例如打印的时候:printf(\"%f\\n\",10) //编译通过，没有报错，结果为0.000000. 对于C++来说，有些操作也不是类型安全的，比如不同类型指针之间可以强制转换(reinterpret cast) 注：C#、Java是类型安全的 C++使用得当，可以远比C更有类型安全性。 （1）操作符new返回的指针类型严格与对象匹配，而不是void*； （2）C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的； （3）引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换； （4）一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全； （5）C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:5:1","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"线程安全 如果代码在多线程运行和单线程运行具有相同的结果，那就是线程安全的。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:5:2","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"异常安全 当异常抛出时，带有异常安全的函数会： （1）不泄露任何资源 一般采用RAII技术，即以对象管(智能指针)理资源来防止资源泄漏。 (2)不允许数据被破坏（例如正常指针变野指针） (3)少些try catch，因为大量的try catch会影响代码逻辑。导致代码丑陋混乱不优雅 解决异常安全的问题： 1.多使用RAII，使用智能指针来管理内存。由于unwind机制的保证，当异常发生时，函数栈内已构造的局部对象的析构函数会被一一调用，在析构函数内释放资源，也就杜绝了内存泄漏的问题。 2.做好程序设计。特别是异常发生时的回滚机制的正确使用，copy-and-swap是有效的方法。 3.注意需要异常保证的函数内部的调用函数，异常安全等级是以有最低等级异常保证的函数确定的。一个系统即使只有一个函数不是异常安全的，那么系统作为一个整体就不是异常安全的。 4.流对象，资源对象，new对象，不应该直接作为参数，一旦抛出异常，就可能会导致严重的问题，函数也许会被错误的执行，资源也许会泄漏。 5.减少全局变量的使用。 6.如果不知道如何处理异常，就不要捕获异常，直接终止比吞掉异常不处理要好。 7.保证构造、析构、swap不会失败 类型安全 与 线程安全 、异常安全、事务安全 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:5:3","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"其他 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:6:0","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"为什么说栈比堆要快 分配和释放：堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，具体可以看看MALLOC和FREE的源代码，他们做了很多额外的工作，而栈却不需要这些。 访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。 堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:6:1","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"c++协程的实现 ucontext-人人都可以实现的简单协程库 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:6:2","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"设计模式 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:7:0","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"单例模式 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:7:1","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"工厂方法 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:7:2","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"观察者模式 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:7:3","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"怎么判断两个结构体变量是否相等？ 1，元素的话，一个个比咯：if(p1-\u003eage==p2-\u003eage)…有一个元素不等，即是两个实例不相等！没什么效率高的方法吧！ 2，指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真！ 3，重载==运算符； ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:7:4","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["面试经验"],"content":"Refeence: 常见C++面试题 ","date":"2018-06-24","objectID":"/posts/sumary/interview_cpp/:7:6","tags":["面试","C++","工作"],"title":"面试总结-C++","uri":"/posts/sumary/interview_cpp/"},{"categories":["刷题"],"content":" 重刷剑指offer总结 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:0:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"01.二维数组中的查找 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 分析：由于每一行都有递增的特性，我们可以采用类似二分搜索的方法。将数组分成行列来进行搜索。 class Solution { public: bool Find(int target, vector\u003cvector\u003cint\u003e \u003e array) { if(0==array.size()) return false; int raw=array.size(); int col=array[0].size(); for(int i=0;i\u003craw;++i){ if(array[i][col-1]\u003e=target){ for(int j=0;j\u003ccol;++j){ if(array[i][j]==target) return true; } } } return false; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:1:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"02.替换空格 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 考虑到是在原字符串上操作，如果遇到一个空格就替换的话，需要把后面的都要后移两位，这个复杂度就大了，所以可以先遍历第一遍，找到空格的总数，之后就可以计算替换后的字符串长度。再经过第二遍遍历，从后往前开始替换，这样就不用移动了。 class Solution { public: void replaceSpace(char *str,int length) { if(length\u003c=0) return; int origin_length=0,new_length=0,space_num=0; for(int i=0;str[i]!='\\0';++i){ origin_length++; if(str[i]==' ') space_num++; } new_length=origin_length+2*space_num; if(new_length\u003elength) return; str[new_length]='\\0'; while(origin_length\u003e0){ --origin_length; if(str[origin_length]==' '){ str[--new_length]='0'; str[--new_length]='2'; str[--new_length]='%'; } else{ str[--new_length]=str[origin_length]; } } } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:2:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"03.从尾到头打印链表 输入一个链表，从尾到头打印链表每个节点的值。 分析：由于链表我们必须从头到尾遍历才能从链表尾开始，所以直接打印的话，需要先从前往后遍历一遍找到链表尾节点，再从后往前遍历打印。能够进行的改善是，通过增加O(N)的空间复杂度，第一次遍历的时候，将数据放在一个栈中，之后再从栈中把所有的数都弹出来就好。 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector\u003cint\u003e printListFromTailToHead(ListNode* head) { vector\u003cint\u003e res; if(!head) return res; stack\u003cint\u003e istack; while(head){ istack.push(head-\u003eval); head=head-\u003enext; } while(!istack.empty()){ res.push_back(istack.top()); istack.pop(); } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:3:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"04.重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 分析：首先需要知道的是前序遍历和后续遍历的特点，程序中可以维护4个子数组，当进行递归调用。 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reConstructBinaryTree(vector\u003cint\u003e pre,vector\u003cint\u003e vin) { if(pre.empty() || pre.size()!=vin.size()) return nullptr; vector\u003cint\u003e pre1,pre2,vin1,vin2; TreeNode* root=new TreeNode(pre[0]); int i=0; for(;i\u003cvin.size();++i){ if(pre[0]==vin[i]) break; } //不需要判断i ==0 或者i==vin.size()-1的情况 for(int j=0;j\u003ci;++j){ pre1.push_back(pre[1+j]); vin1.push_back(vin[j]); } for(int j=i+1;j\u003cpre.size();++j){ pre2.push_back(pre[j]); vin2.push_back(vin[j]); } root-\u003eleft=reConstructBinaryTree(pre1,vin1); root-\u003eright=reConstructBinaryTree(pre2,vin2); return root; } }; 不过上述的方法有个问题，虽然看起来比较好理解，但是增加了空间复杂度，其实这里可以多加一个递归函数就好了，所以觉得还是需要重新写一下。 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* recurse(vector\u003cint\u003e\u0026 pre,int begin1,int end1,vector\u003cint \u003e\u0026 vin,int begin2,int end2){ if(begin1\u003eend1 || begin2\u003eend2) //退出条件 return nullptr; TreeNode* root=new TreeNode(pre[begin1]); for(int i=begin2;i\u003c=end2;++i){ if(pre[begin1]==vin[i]){ root-\u003eleft=recurse(pre,begin1+1,begin1+i-begin2,vin,begin2,i-1); //递归的重点，这个要考虑清楚 root-\u003eright=recurse(pre,begin1+1+i-begin2,end1,vin,1+i,end2); break; } } return root; } TreeNode* reConstructBinaryTree(vector\u003cint\u003e pre,vector\u003cint\u003e vin) { if(pre.empty() || pre.size()!=vin.size()) return nullptr; return recurse(pre,0,pre.size()-1,vin,0,vin.size()-1); } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:4:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"05.用两个栈实现队列 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 分析：由于栈是先进后出，队列是先进先出，于是可以想到，两个栈，必然能够实现一个队列。原理就是，当push的时候就往第一个栈push，pop的时候就从第二个栈pop，当第二个栈的数为空时，从第一个栈pop再push到第二个栈。 class Solution { public: void push(int node) { stack1.push(node); } int pop() { if(stack2.empty()){ while(!stack1.empty()){ stack2.push(stack1.top()); stack1.pop(); } } int top=stack2.top(); stack2.pop(); return top; } private: stack\u003cint\u003e stack1; stack\u003cint\u003e stack2; }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:5:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"06.旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 分析：对于排序的数组，即使被旋转过，也能想到的是，采用二分查找。不过可能会存在的问题的是：当整个数组的值都是1 0 0 1 1之类的时候，就会失效了，只是非递减，但是不一定递增。 class Solution { public: int minNumberInRotateArray(vector\u003cint\u003e rotateArray) { if(0==rotateArray.size()){ return 0; } int begin=0,end=rotateArray.size()-1; while(begin\u003cend-1){ int mid=begin+(end-begin)/2; if(rotateArray[begin]\u003crotateArray[mid]) begin=mid; else if(rotateArray[begin]\u003erotateArray[mid]) end=mid; else{ int res=begin; for(size_t i=1;i\u003crotateArray.size();++i){ res=(res\u003crotateArray[i]?res:rotateArray[i]); } return res; } } return rotateArray[end]; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:6:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"07.斐波那契数列 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n\u003c=39 分析：斐波拉契数列原理很简单，不过按照原理写的显然复杂度过高了，这里我们可以采用变量存下之前计算过的数。 class Solution { public: int Fibonacci(int n) { if(n==0) return 0; if(n==1||n==2) return 1; int first=1,second=1,res=0; while(--n\u003e1){ res=first+second; first=second; second=res; } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:7:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"08.跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 分析：原理同斐波拉契数列。 class Solution { public: int jumpFloor(int number) { if(number\u003c=2) return number; int first=1,second=2,res=0; while(--number\u003e1){ res=first+second; first=second; second=res; } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:8:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"09.变态跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 分析： f(n)=f(1)+f(2)+...+f(n-1) f(n+1)=f(1)+f(2)+...+f(n-1)+f(n)=2f(n) //代码如下： class Solution { public: int jumpFloorII(int number) { if(number\u003c=2) return number; int res=2; while(--number\u003e=2){ res*=2; } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:9:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"10.矩形覆盖 /TODO: ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:10:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"11.二进制中1的个数 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 分析：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 class Solution { public: int NumberOf1(int n) { int count=0; while(n){ count++; n=n\u0026(n-1); } return count; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:11:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"12.数值的整数次方 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 分析：求一个数的次方，一个就是幂数是负数的处理，另一个就是，对幂的处理，连乘必然带来复杂度，可以想到的是2^4可以表示为(2^2)^2，想到这里，考虑的开水奇偶exponent的奇偶性了，奇数的时候直接乘以base，偶数的时候自乘。 class Solution { public: double Power(double base, int exponent) { bool flag=true; if(exponent\u003c0){ flag=false; exponent*=-1; } double res=1; while(exponent){ if(exponent\u00261){ res*=base; exponent--; } else{ exponent=exponent/2; res*=res; } } return flag?res:(1/res); } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:12:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"13.调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 class Solution { public: void reOrderArray(vector\u003cint\u003e \u0026array) { if(array.empty()) return; int begin=0,end=array.size(); int even=-1; while(begin\u003cend){ while((array[begin]\u00261) \u0026\u0026 (begin\u003cend)){ begin++; } even=begin; while((!(array[begin]\u00261))){ begin++; } if(begin\u003e=end) return; int temp=array[begin]; while(even\u003cbegin){ array[begin]=array[begin-1]; begin--; } array[even]=temp; } } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:13:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"14.链表中倒数第k个结点 输入一个链表，输出该链表中倒数第k个结点。 分析：采用两个指针一起移动是一个很好的办法，不过需要考虑是否越界。 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { ListNode* p1=pListHead; for(int i=0;i\u003ck;++i){ if(!p1) return nullptr; p1=p1-\u003enext; } while(p1){ p1=p1-\u003enext; pListHead=pListHead-\u003enext; } return pListHead; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:14:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"15.反转链表 输入一个链表，反转链表后，输出新链表的表头。 分析：注意断开链表重连的过程。 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ //最开始的一版代码，采用的是栈，看起来比较复杂。 class Solution { public: ListNode* ReverseList(ListNode* pHead) { if((!pHead)||(!pHead-\u003enext)) return pHead; stack\u003cListNode*\u003e list_stack; while(pHead-\u003enext){ list_stack.push(pHead); pHead=pHead-\u003enext; } ListNode *newHead=pHead; while(!list_stack.empty()){ pHead-\u003enext=list_stack.top(); pHead=pHead-\u003enext; list_stack.pop(); } pHead-\u003enext=nullptr; return newHead; } }; //采用在链表中的穿针引线。涉及到链表的断开与重连，维护三个指针，分别为：pre,cur,next class Solution { public: ListNode* ReverseList(ListNode* pHead) { ListNode* pre=nullptr; ListNode* cur=pHead; while(cur){ ListNode* next=cur-\u003enext; cur-\u003enext=pre; pre=cur; cur=next; } return pre; } }; //采用递归实现 class Solution { public: ListNode* ReverseList(ListNode* pHead) { if(!pHead||!pHead-\u003enext) return pHead; ListNode* rHead=ReverseList(pHead-\u003enext); // head-\u003enext此刻指向head后面的链表的尾节点 // head-\u003enext-\u003enext = head把head节点放在了尾部 pHead-\u003enext-\u003enext=pHead; pHead-\u003enext=nullptr; return rHead; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:15:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"16.合并两个排序的链表 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { //当一个链表为空时，直接返回另一个链表 if(!pHead1) return pHead2; if(!pHead2) return pHead1; ListNode* vHead=new ListNode(0); //设立虚拟的头节点 ListNode* vHeadHead=vHead; while(pHead1 \u0026\u0026 pHead2){ //一旦有一个链表为空，就退出循环 if(pHead1-\u003eval\u003c=pHead2-\u003eval){ vHead-\u003enext=pHead1; pHead1=pHead1-\u003enext; } else{ vHead-\u003enext=pHead2; pHead2=pHead2-\u003enext; } vHead=vHead-\u003enext; } //另一个链表不为空时，加在后面 if(!pHead1) vHead-\u003enext=pHead2; else vHead-\u003enext=pHead1; return vHeadHead-\u003enext; //返回虚拟头节点的下一个节点 } }; //采用递归实现 class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { if(!pHead1) return pHead2; if(!pHead2) return pHead1; ListNode* vHead=nullptr; if(pHead1-\u003eval\u003c=pHead2-\u003eval){ vHead=pHead1; vHead-\u003enext=Merge(pHead1-\u003enext,pHead2); } else{ vHead=pHead2; vHead-\u003enext=Merge(pHead1,pHead2-\u003enext); } return vHead; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:16:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"17.树的子结构 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） class Solution { public: bool dfs(TreeNode* pRoot1,TreeNode* pRoot2){ if(!pRoot2) //注意不能先判断pRoot1再判断pRoot2，因为，只要pRoot2为空的时候，都是true了，而不管这时候pRoot1是不是为空。 return true; if(!pRoot1) return false; if(pRoot1-\u003eval!=pRoot2-\u003eval) return false; return dfs(pRoot1-\u003eleft,pRoot2-\u003eleft)\u0026\u0026dfs(pRoot1-\u003eright,pRoot2-\u003eright); } bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { if((!pRoot2)||(!pRoot1)) return false; return (dfs(pRoot1,pRoot2)||HasSubtree(pRoot1-\u003eleft,pRoot2)||HasSubtree(pRoot1-\u003eright,pRoot2)); } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:17:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"18.二叉树的镜像 操作给定的二叉树，将其变换为源二叉树的镜像。 分析：简单的递归解决。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void Mirror(TreeNode *pRoot) { if(pRoot==nullptr) return; Mirror(pRoot-\u003eleft); Mirror(pRoot-\u003eright); swap(pRoot-\u003eleft,pRoot-\u003eright); } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:18:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"19.顺时针打印矩阵 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:19:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"20.包含min函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 分析：维护两个栈，其中一个是压入数据的栈，另一个是min栈，存储当前数据的最小的值。只有压入的数小于min栈的时候，才压入新值，否则继续压入最小值。 class Solution { public: void push(int value) { stk.push(value); if(!stk_min.empty()){ if(value\u003cstk_min.top()) stk_min.push(value); else{ int temp=stk_min.top(); stk_min.push(temp); } } else stk_min.push(value); } void pop() { stk_min.pop(); stk.pop(); } int top() { return stk.top(); } int min() { return stk_min.top(); } private: stack\u003cint\u003e stk; stack\u003cint\u003e stk_min; }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:20:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"21.栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路：判断是否是压入弹出序列，可以直接使用一个栈进行压入，然后在压入的过程中判断是否跟弹出序列的值相同，是的话则先弹出，最后判断栈是否为空即可。 class Solution { public: bool IsPopOrder(vector\u003cint\u003e pushV,vector\u003cint\u003e popV) { stack\u003cint\u003e istack; int i=0,j=0; while(i\u003cpushV.size()){ istack.push(pushV[i++]); while(j\u003cpopV.size() \u0026\u0026 istack.top()==popV[j]){ istack.pop(); ++j; } } return istack.empty(); } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:21:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"22.从上往下打印二叉树 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 分析：层序遍历，需要每遍历一个节点，就将他们的左右节点保存起来，当前层遍历完后，再顺序遍历他们的孩子节点。于是很容易想到先入先出的结构，队列。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector\u003cint\u003e PrintFromTopToBottom(TreeNode* root) { vector\u003cint\u003e res; if(root==nullptr) return res; queue\u003cTreeNode*\u003e ique; ique.push(root); while(!ique.empty()){ TreeNode* temp=ique.front(); res.push_back(temp-\u003eval); ique.pop(); if(temp-\u003eleft) ique.push(temp-\u003eleft); if(temp-\u003eright) ique.push(temp-\u003eright); } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:22:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"23.二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 class Solution { public: bool VerifySquenceOfBST(vector\u003cint\u003e sequence) { return Verify(sequence,0,sequence.size()); } bool Verify(vector\u003cint\u003e sequence,int start,int end){ int i=start; if(start==end) return false; for(;i\u003cend-1;++i){ if(sequence[i]\u003esequence[end-1]){ break; } } for(int j=i;j!=end;++j){ if(sequence[j]\u003csequence[end-1]){ return false; } } bool left=true; if(i\u003estart) left=Verify(sequence,start,i); bool right=true; if(i\u003cend-1) right=Verify(sequence,i,end-1); return left\u0026\u0026right; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:23:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"24.二叉树中和为某一值的路径 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 class Solution { public: vector\u003cvector\u003cint\u003e\u003e res; vector\u003cint\u003e temp; vector\u003cvector\u003cint\u003e \u003e FindPath(TreeNode* root,int expectNumber) { if(!root) return res; temp.push_back(root-\u003eval); if(expectNumber-root-\u003eval==0 \u0026\u0026 root-\u003eleft==nullptr \u0026\u0026 root-\u003eright==nullptr) res.push_back(temp); FindPath(root-\u003eleft,expectNumber-root-\u003eval); FindPath(root-\u003eright,expectNumber-root-\u003eval); if(!temp.empty()) temp.pop_back(); return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:24:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"25.复杂链表的复制 代码问题： while(pHead-\u003enext){ // cout\u003c\u003cpHead-\u003elabel\u003c\u003cendl; // RandomListNode* pTemp=pHead; //傻了吧 RandomListNode* pTemp=new RandomListNode(pHead-\u003elabel); pTemp-\u003enext=pHead-\u003enext; cout\u003c\u003cpTemp-\u003enext-\u003elabel\u003c\u003cendl; pHead-\u003enext=pTemp; pHead=pTemp-\u003enext; } //拆分 pNode=pHead; RandomListNode* newHead=pHead-\u003enext; RandomListNode* pTemp=pNode-\u003enext; while(pNode){ pNode-\u003enext=pTemp-\u003enext; pNode=pNode-\u003enext; pTemp-\u003enext=pNode?pNode-\u003enext:NULL; //pTemp-\u003enext=pNode-\u003enext; //cout\u003c\u003c\"pTemp: \"\u003c\u003cpTemp-\u003elabel\u003c\u003cendl; pTemp=pTemp-\u003enext; //cout\u003c\u003c\"text\"\u003c\u003cendl; } class Solution { public: RandomListNode* Clone(RandomListNode* pHead) { if(!pHead) return pHead; RandomListNode* pNode=pHead; while(pNode){ RandomListNode* pClone=new RandomListNode(pNode-\u003elabel); pClone-\u003enext=pNode-\u003enext; pNode-\u003enext=pClone; pNode=pClone-\u003enext; } pNode=pHead; while(pNode){ RandomListNode* pClone=pNode-\u003enext; if(pNode-\u003erandom) pClone-\u003erandom=pNode-\u003erandom-\u003enext; pNode=pClone-\u003enext; } pNode=pHead; RandomListNode* newHead=pNode-\u003enext; while(pNode-\u003enext){ RandomListNode* pTemp=pNode-\u003enext; pNode-\u003enext=pTemp-\u003enext; pNode=pTemp; // pNode=pNode-\u003enext; //这种不行，搞得我折腾了很久 // pTemp-\u003enext=pNode-\u003enext; } return newHead; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:25:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"26.二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 TODO: ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:26:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"27.字符串的排列 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:27:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"28.数组中出现次数超过一半的数字 解决一个问题，最终输出的判断，是1，还是0。如果大于1的话，万一最后只剩下了一个呢。所以还需要再判断最后剩下的结果是不是符合条件的，即是大于一般数目的。 class Solution { public: int MoreThanHalfNum_Solution(vector\u003cint\u003e numbers) { if(numbers.empty()) return 0; int count=1; int num=numbers[0]; for(int i=1;i\u003cnumbers.size();++i){ if(numbers[i]==num) count++; else{ if((--count)\u003c=0){ num=numbers[i]; count=1; } } } //判断结果是否符合条件 count=0; for(int i=0;i\u003cnumbers.size();++i){ if(num==numbers[i]){ count++; } } return count*2\u003enumbers.size()?num:0; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:28:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"29.最小的K个数 存在的问题，写程序的时候越界，没有判断好边界条件。 class Solution { public: vector\u003cint\u003e GetLeastNumbers_Solution(vector\u003cint\u003e input, int k) { vector\u003cint\u003e min_stack; if(input.empty()||(k\u003c=0)||(k\u003einput.size())) //边界条件的判断 return min_stack; for(int i=0;i\u003cinput.size();++i){ sort(min_stack.begin(),min_stack.end()); if(min_stack.size()\u003ck){ min_stack.push_back(input[i]); } else{ //cout\u003c\u003c\"min_stack[min_stack.size()-1]: \"\u003c\u003cmin_stack[min_stack.size()-1]\u003c\u003cendl; if(input[i]\u003cmin_stack[min_stack.size()-1]){ min_stack.pop_back(); min_stack.push_back(input[i]); } } } return min_stack; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:29:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"30.连续子数组的最大和 class Solution { public: int FindGreatestSumOfSubArray(vector\u003cint\u003e array) { int res=array[0]; int cur=array[0]; for(int i=1;i\u003carray.size();++i){ cur+=array[i]; if(cur\u003carray[i]) cur=array[i]; res=(res\u003ecur?res:cur); } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:30:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"31.整数中1出现的次数（从1到n整数中1出现的次数） 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 分析：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析。 当i表示百位，且百位对应的数\u003e=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)100个点的百位为1 当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10100）+(b+1)，这些点百位对应为1 当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30） 综合以上三种情况，当百位对应0或\u003e=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1 之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位\u003e=2，补8会产生进位位，效果等同于(a/10+1) class Solution { public: int NumberOf1Between1AndN_Solution(int n) { int count=0; //n=1的情况 if(n==1) return 1; //考虑的边界情况，n=10,100,1000之类的，同时循环中没有考虑n=0的情况 if(n\u003e1\u0026\u0026n%10==0) count++; //没有考虑n=1的情况 for(int i=1;i\u003cn;i*=10){ int a=n/i,b=n%i; count+=(a+8)/10*i+(a%10==1)*(b+1); } return count; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:31:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"32.把数组排成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 class Solution { public: static bool equal(int a,int b){ string str1=to_string(a)+to_string(b); string str2=to_string(b)+to_string(a); return str1\u003cstr2; } string PrintMinNumber(vector\u003cint\u003e numbers) { string result; sort(numbers.begin(),numbers.end(),equal); for(int i=0;i\u003cnumbers.size();++i){ result+=to_string(numbers[i]); } return result; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:32:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"33.丑数 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 class Solution { public: int GetUglyNumber_Solution(int index) { if(index\u003c=0) return 0; vector\u003cint \u003e res(index); res[0]=1; int x=0,y=0,z=0; for(int i=1;i\u003cindex;++i){ res[i]=min(2*res[x],min(3*res[y],5*res[z])); if(res[i]==2*res[x]) x++; if(res[i]==3*res[y]) y++; if(res[i]==5*res[z]) z++; } return res[index-1]; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:33:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"34.第一个只出现一次的字符位置 在一个字符串(1\u003c=字符串长度\u003c=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置 一般对于这种字符的处理，因为字符一般都是不超过256的，所以尤其是计数之类的，我们可以首先考虑数组。 class Solution { public: int FirstNotRepeatingChar(string str) { if(str.size()\u003c=0) return -1; int array[256]={0}; for(int i=0;i\u003cstr.size();++i){ array[int(str[i])]++; } for(int i=0;i\u003cstr.size();++i){ if(array[int(str[i])]==1) return i; } return str.size(); } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:34:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"35.数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:35:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"36.两个链表的第一个公共结点 输入两个链表，找出它们的第一个公共结点。 需要知道的一个常识是，对于只有一个单链表，两个链表有公共节点，意味着从公共节点开始，之后两个链表都是公共的，因此他们有共同的终点。有了这个就好办了。可以将两个链表一直遍历，当遍历到链表尾的时候，就换另一个链表，当他们有公共节点时，在他们遍历到同一个节点时停止遍历，此节点即为第一个公共节点。 对于这种将两个不同的长度，通过两个结合在一起，使两个长度相等的方法，其实我们用到过很多次。例如本题中的找公共节点，原因是两个链表长度不同。还有之前的一个判断两个string的大小，可以把他们放在一起，这样他们的长度就相同了，可以直接用string的方法进行比较。 class Solution { public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) { ListNode* p1=pHead1; ListNode* p2=pHead2; while(p1!=p2){ p1=(p1==nullptr?pHead2:p1-\u003enext); p2=(p2==nullptr?pHead1:p2-\u003enext); } return p1; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:36:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"37.数字在排序数组中出现的次数 统计一个数字在排序数组中出现的次数。 显然很容易想到的是二分法,没有用函数的话，就存在一个找到没找到的问题，在这采用了一个返回值的处理。如果没找到，(end-begin-1)\u003c0，则可以判断是没有找到。 class Solution { public: int GetNumberOfK(vector\u003cint\u003e data ,int k) { if(data.empty()) return 0; int begin=0,end=data.size()-1; int count=0; int mid; while(begin\u003c=end){ mid=(begin+end)/2; // cout\u003c\u003c\"dsdasads\"\u003c\u003cendl; if(data[mid]==k) break; else if(data[mid]\u003ck){ begin=mid+1; continue; } else if(data[mid]\u003ek){ end=mid-1; continue; } } begin=end=mid; while(data[begin]==k) --begin; while(data[end]==k) ++end; count=(end-begin-1)\u003e0?(end-begin-1):0; return count; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:37:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"38.二叉树的深度 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 class Solution { public: int TreeDepth(TreeNode* pRoot) { if(!pRoot) return 0; return max(1+TreeDepth(pRoot-\u003eleft),1+TreeDepth(pRoot-\u003eright)); } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:38:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"39.平衡二叉树 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:39:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"40.数组中只出现一次的数字 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 数组中只出现一次的数字，当有一个的时候，很容易利用的特性是：全部异或，最后剩下的那个就是。原因是一个数跟自身异或，结果为0.那么出现有两个的时候呢。很容易想到的还是异或，最后的结果是两个只出现一次数字异或的结果，再进行分组解决。分组的依据是：因为有两个不同的数字只出现一次，所以整个数组异或的结果必然不为0，不为0就肯定有一位为1.按该位是否为1来进行划分即可。代码如下： class Solution { public: void FindNumsAppearOnce(vector\u003cint\u003e data,int* num1,int *num2) { if(data.empty()) return; //第一次遍历一遍，求两个数字最后的异或 int res=data[0]; for(int i=1;i\u003cdata.size();++i){ res=res^data[i]; } if(res==0) return; //由于存在两个只出现一次的数字，所以res的值为这两个数字的异或，因此肯定不为0，肯定不为0意味着肯定有一位是1.找出这一位是1的 int index=0; while((res\u00261)==0){ res=res\u003e\u003e1; index++; } *num1=*num2=0; //根据index位为不为1，将数组分为两部分。 int x; for(int i=0;i\u003cdata.size();++i){ if((x=data[i]\u003e\u003eindex)\u00261) *num1^=data[i]; else { *num2^=data[i]; } } } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:40:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"41.和为S的连续正数序列 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 class Solution { public: vector\u003cvector\u003cint\u003e \u003e FindContinuousSequence(int sum) { vector\u003cvector\u003cint\u003e\u003e res; vector\u003cint\u003e temp; //边界条件的判断 if(sum\u003c0) return res; int end=0; int tempSum=0; //遍历数组 while(end\u003csum){ if(tempSum==sum){ res.push_back(temp); end=temp[0]; //这一句其实很重要,因为要考虑将end从最开始重新开始计算，不然可能会有所遗漏,eg:9=2+3+4=4+5，其中4会重复 temp.erase(temp.begin(),temp.end()); tempSum=0; continue; } if(tempSum\u003esum){ tempSum-=temp[0]; temp.erase(temp.begin()); continue; } temp.push_back(++end); tempSum+=end; } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:41:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"42.和为S的两个数字 输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出乘积最小的，显然距离最大的乘积就越小，所以，可以直接前后两个指针搜索，搜到的第一个就是。 class Solution { public: vector\u003cint\u003e FindNumbersWithSum(vector\u003cint\u003e array, int sum) { vector\u003cint \u003e res; if(array.empty()) return res; int i=0,j=array.size()-1; while(i\u003cj){ int temp=array[i]+array[j]; if(temp\u003esum) --j; if(temp\u003csum) ++i; if(temp==sum) { res.push_back(array[i]); res.push_back(array[j]); return res; } } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:42:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"43.左旋转字符串 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 由BA=(ATBT)T计算可得 //第一次通过代码 class Solution { public: string LeftRotateString(string str, int n) { int len=str.size(); if(n\u003e=len) return str; int i=0,j=0; for(i=0,j=n-1;i\u003cj;++i,--j){swap(str[i],str[j]);} for(i=n,j=len-1;i\u003cj;++i,--j){swap(str[i],str[j]);} for(i=0,j=len-1;i\u003cj;++i,--j){swap(str[i],str[j]);} return str; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:43:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"44.翻转单词顺序列 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ //以前买的 class Solution { public: void ReverseSentence(string \u0026str,int begin,int end){ while(begin\u003cend){ char tmp=str[begin]; str[begin]=str[end]; str[end]=tmp; begin++; end--; } } string ReverseSentence(string str) { if(str.size()\u003c=1) return str; int begin=0; int end=0; //这里需要注意，考虑只有一个单词的情况 while(end!=str.size()){ if(str[end]==' '){ ReverseSentence(str,0,str.size()-1); break; } else if(end==str.size()-1) return str; else ++end; } end=0; //开始遍历，旋转每个单词 while(begin!=str.size()){ if(str[begin]==' '){ ++end; ++begin; } else if(str[end]==' '||end==str.size()){ ReverseSentence(str,begin,--end); begin=++end; } else ++end; } return str; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:44:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"45.扑克牌顺子 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。 class Solution { public: bool IsContinuous(vector\u003cint\u003e numbers) { if (numbers.empty()) return false; sort(numbers.begin(), numbers.end()); int sum = 0, zero_num = 0; for (int i = 0; i \u003c numbers.size() - 1; ++i) { if (numbers[i] == 0) { zero_num++; continue; } //考虑数字重复的情况 if (numbers[i + 1] == numbers[i]) return false; sum += numbers[i + 1] - numbers[i] - 1; } return sum \u003c= zero_num; //注意这里要大于等于就可以，不一定等于 } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:45:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"46.孩子们的游戏(圆圈中最后剩下的数) 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 此约瑟夫环的问题。https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365 class Solution { public: int LastRemaining_Solution(int n, int m) { if(n\u003c=0) return -1; int last=0; for(int i=2;i\u003c=n;++i){ last=(last+m)%i; } return last; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:46:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"47.求1+2+3+…+n 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 这个题，可以有好几种解决办法，一个容易想到的就是递归，每次都跟自己相加，直到加到0为止，判断的条件可以采用\u0026\u0026的短路特性：通过\u0026\u0026判断值是否为0已经到达结尾了。 另一种办法，可以利用类的构造函数。 class Solution { public: int Sum_Solution(int n) { int sum=n; sum\u0026\u0026(sum+=Sum_Solution(n-1)); return sum; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:47:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"48.不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 不能用加法做加法运算，可以想到的计算机中利用的二进制的加法。通过异或两个数，也就是模2加，得到的是不考虑进位的加法的结果。通过两个数异或，左移一位得到的是进位。无进位结果加上进位，一直循环知道进位为0的时候，结果即为加法的结果。 计算的过程中，一定要细心。方法虽然简单，但是要写对。 class Solution { public: int Add(int num1, int num2) { int res = num1 ^ num2, temp = num1 \u0026 num2; while (temp != 0) { temp = temp \u003c\u003c 1; int t = res; //暂存res,以避免res的值被改变 res ^= temp; temp = temp \u0026 t; } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:48:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"49.把字符串转换成整数 输入一个字符串,包括数字字母符号,可以为空.如果是合法的数值表达则返回该数字，否则返回0 分析：主要首先要考虑正负号，这里有一个小细节，我们把flag直接置1的话，可以直接输出flag*res得到结果，而不需要进行判断，是一种省略。另外的判断就比较简单了，按照正常的思路去判断就行。 class Solution { public: int StrToInt(string str) { if (str.size() == 0) return 0; int flag = 1; int size = str.size(), res = 0; int i = 0; if (str[0] == '-') { flag = -1; i++; } else if (str[0] == '+') { i++; } for (; i \u003c size; ++i) { if (str[i] \u003c= '0' || str[i] \u003e= '9') { return 0; } else res = res * 10 + (str[i] - '0'); } return flag * res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:49:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"50.数组中重复的数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 分析：由于规定了数组中的数字在范围为0–n内，所以可以利用当前数组的位置进行遍历，比如每次遍历到一个位置，就将该数字对应位置的值加n，这样，当再次遍历到该值时，发现如果该值已经大于n，说明已经重复了，返回即可。不过在遍历的时候，如果发现某一位置的值大于n，应该先减去n，得到该位置上原来的值，这里应该捋清楚。 class Solution { public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int *duplication) { for(int i=0;i\u003clength;++i){ int index=numbers[i]; if(index\u003e=length) index=index-length; if(numbers[index]\u003e=length){ *duplication=index; return true; } numbers[index]+=length; } return false; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:50:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"51.构建乘积数组 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…*A[i-1]A[i+1]…*A[n-1]。不能使用除法。 class Solution { public: vector\u003cint\u003e multiply(const vector\u003cint\u003e\u0026 A) { vector\u003cint\u003e res(A.size()); if(A.empty()) return res; res[0]=1; //计算下三角 for(int i=1;i\u003cA.size();++i){ res[i]=res[i-1]*A[i-1]; } int temp=1; for(int i=A.size()-2;i\u003e=0;--i){ temp*=A[i+1]; res[i]*=temp; } return res; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:51:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"52.正则表达式匹配 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:52:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"53.表示数值的字符串 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(pHead==nullptr) return pHead; ListNode* virtualHead=new ListNode(0); virtualHead-\u003enext=pHead; ListNode* prev=virtualHead; while(pHead-\u003enext){ if(pHead-\u003eval==pHead-\u003enext-\u003eval){ if(pHead-\u003enext-\u003enext){ pHead=pHead-\u003enext-\u003enext; prev-\u003enext=pHead; } else return virtualHead-\u003enext; } else{ pHead=pHead-\u003enext; prev=prev-\u003enext; } } return virtualHead-\u003enext; } }; 测试用例: {1,1,1,1,1,1,1} 对应输出应该为: ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:53:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"54.字符流中第一个不重复的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符\"go\"时，第一个只出现一次的字符是\"g\"。当从该字符流中读出前六个字符“google\"时，第一个只出现一次的字符是\"l\"。 如果当前字符流没有存在出现一次的字符，返回#字符。 class Solution { public: //Insert one char from stringstream void Insert(char ch) { if(!array[ch]) ique.push(ch); array[ch]++; } //return the first appearence once char in current stringstream char FirstAppearingOnce() { while(!ique.empty() \u0026\u0026 array[ique.front()]\u003e1){ ique.pop(); } if(!ique.empty()) return ique.front(); return '#'; } private: int array[256]={0}; queue\u003cchar\u003e ique; }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:54:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"55.链表中环的入口结点 一个链表中包含环，请找出该链表的环的入口结点。 分析：http://wuchong.me/blog/2014/03/25/interview-link-questions/ class Solution { public: ListNode* EntryNodeOfLoop(ListNode* pHead) { if(!pHead || !pHead-\u003enext) return nullptr; ListNode* fast=pHead,*slow=pHead; while(fast-\u003enext \u0026\u0026 slow){ fast=fast-\u003enext-\u003enext; slow=slow-\u003enext; if(fast==slow) break; } if(fast!=slow) return nullptr; fast=pHead; while(fast!=slow){ fast=fast-\u003enext; slow=slow-\u003enext; } return fast; } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:55:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"56.删除链表中重复的结点 //一个不通过的代码 class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(!pHead || !pHead-\u003enext) return pHead; ListNode* vHead=new ListNode(0); vHead-\u003enext=pHead; ListNode* pre=vHead; ListNode* cur=pHead; int temp; while(cur \u0026\u0026 cur-\u003enext){ ListNode* next=cur-\u003enext; if(cur-\u003eval==next-\u003eval){ //原因是这个相等的处理有问题，没有考虑一直是同一个值的处理 temp=cur-\u003eval; cur=next-\u003enext; pre-\u003enext=cur; } else if(next-\u003eval==temp){ cur-\u003enext=next-\u003enext; pre-\u003enext=cur; } else{ if(next-\u003enext){ pre=cur; cur=next; // next=next-\u003enext; } else return vHead-\u003enext; } } return vHead-\u003enext; } }; //一个通过了的代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(!pHead || !pHead-\u003enext) return pHead; ListNode* vHead=new ListNode(-1); vHead-\u003enext=pHead; ListNode* pre=vHead; ListNode* cur=pHead; while(cur \u0026\u0026 cur-\u003enext){ ListNode* next=cur-\u003enext; if(cur-\u003eval==next-\u003eval){ int val=cur-\u003eval; while(cur \u0026\u0026 cur-\u003eval==val) //一直遍历到不为当前值为止 cur=cur-\u003enext; pre-\u003enext=cur; cur=pre-\u003enext; } else{ pre=pre-\u003enext; cur=cur-\u003enext; } } return vHead-\u003enext; } }; //递归解决 class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(pHead==nullptr || pHead-\u003enext==nullptr) return pHead; ListNode* current=pHead; if(pHead-\u003eval==pHead-\u003enext-\u003eval){ current=pHead-\u003enext-\u003enext; while(current!=nullptr \u0026\u0026 current-\u003eval==pHead-\u003eval) current=current-\u003enext; return deleteDuplication(current); } else{ current=pHead-\u003enext; pHead-\u003enext=deleteDuplication(current); return pHead; } } }; ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:56:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"57.二叉树的下一个结点 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 分析二叉树的下一个节点，一共有以下情况： 1.二叉树为空，则返回空； 2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点； 3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:57:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"58.对称的二叉树 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:58:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"59.按之字形顺序打印二叉树 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:59:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"60.把二叉树打印成多行 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:60:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"61.序列化二叉树 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:61:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"62.二叉搜索树的第k个结点 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:62:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"63.数据流中的中位数 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:63:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"64.滑动窗口的最大值 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:64:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"65.矩阵中的路径 ","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:65:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["刷题"],"content":"66.机器人的运动范围","date":"2018-06-20","objectID":"/posts/algorithm/re_sword_to_offer/:66:0","tags":["C++","LeetCode","剑指offer"],"title":"剑指offer-刷题总结","uri":"/posts/algorithm/re_sword_to_offer/"},{"categories":["other"],"content":" Redis设计与实现，以及关于Redis使用的总结 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:0:0","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"1.数据结构与对象 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:1:0","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"1.简单动态字符串 Redis自己构建了简单动态字符串(Simple Dynamic String,SDS)来作为默认的字符串表示。 SDS的构造如下： 优势是： 能够在常数时间内获取字符串的长度-通过len属性 能够杜绝缓冲区溢出：记录了缓冲区的大小，在长度不够时，能够自动扩展空间 减少修改字符串时带来的内存重新分配次数：采用空间预分配和惰性空间释放 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:1:1","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"2.链表 Redis自己实现了链表。拥有以下特性：双端无环、带表头指针和表尾指针、带链表长度计数器、多态(使用void* 保存节点值) ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:1:2","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"3.字典 Redis字典底层采用哈希表实现。采用MurmurHash2算法，解决键冲突的方式是：链地址法。 哈希表的扩展与收缩：以下条件满足时： 服务器没有执行BGSAVE或BGREWRITEAOF命令，哈希表负载因子\u003e1 服务器在执行BGSAVE或BGREWRITEAOF命令，哈希表负载因子\u003e5 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:1:3","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"4.跳跃表 Redis采用跳跃表作为有序集合键的底层数据结构，另：在集群节点中用作内部数据结构 跳跃表：一种有序数据结构，通过在一个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。支持平均O(logN),最差O(N)复杂度的查找。 Redis中跳跃表的实现： ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:1:4","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"5.整数集合 Redis中集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合中元素的数量不多时，就会使用整数集合作为集合键的底层实现。 整数集合的升级策略：能够提高整数集合的灵活性，并且能够尽可能的节约内存。升级后不支持降级 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:1:5","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"6.压缩列表 Redis中列表键和哈希键的底层实现之一。 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:1:6","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"7.对象 Redis使用上述的数据结构创建了一个对象系统。包括：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。其实这就是一直说的Redis五种数据结构：字符串、列表、字典、集合、有序集合。 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:1:7","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"2.单机数据库的实现 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:2:0","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"数据库 Redis服务器讲所有数据库保存在一个db数组中，默认创建16个数据库。 切换数据库:select 0 #选择0号数据库 数据库键空间 键空间的键也是数据库的键。每个键都是一个字符串对象。 键空间的值也是数据库的值，每个值可以是字符串对象、列表对象、哈希对象、集合对象，有序集合对象中的任意一个Redis对象。 一个键空间的例子： 设置键的生存时间或过期时间 原理是：过期时间是一个UNIX时间戳，当键的过期时间来临是，服务器就会自动从数据库中删除一个键。 命令: expire \u003ckey\u003e \u003cttl\u003e #key的生存时间为ttl秒 pexpire \u003ckey\u003e \u003cttl\u003e #key的生存时间为ttl毫秒 expireat \u003ckey\u003e \u003ctimestamp\u003e #key的生存时间直到timestamp指定的时间戳s pexpireat \u003ckey\u003e \u003ctimestamp\u003e #key的生存时间直到timestamp指定的时间戳ms persist \u003ckey\u003e #移除key的过期时间 ttl \u003ckey\u003e #计算key的剩余生存时间 setex命令可以设置一个字符串键的同时为键设置过期时间。 一个带有过期字典的数据库例子：（实际中，键空间的键和过期字典中的键都指向同一个键对象） 过期键删除策略 定时删除： 内存最友好，CPU时间最不友好 惰性删除：CPU时间友好，内存不友好 定期删除：折中 Redis实际使用：惰性删除和定期删除配合使用。 过期键的处理 RDB文件： 生成RDB文件：已过期的键不会保存到新创建的RDB文件中，因此对生成新的RDB文件没有影响。 载入RDB文件：主服务器模式时，过期键不会被载入。从服务器模式时，都会被载入，但同步后，从服务器数据会被清空，所以也没有影响。 AOF文件： AOF写入：如果某个键已经过期，但没有被删除，AOF文件不会因为这个过期键产生任何影响。如果已经删除，AOF文件会追加一条DEL命令显式记录该键已被删除。 AOF重写：已过期的键不会被保存到重写的AOF文件。 复制： 主服务器删除一个过期键，会显示向所有的从服务器发送DEL命令，告知删除。 从服务器遇到过期的键也不会删除。只有接收到DEL命令后才会删除过期键。 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:2:1","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"RDB持久化 通过保存数据库中的键值对来记录数据库状态不同。 功能：将Redis在内存中的数据库状态保存到磁盘中，避免数据意外丢失。RDB文件是一个经过压缩的二进制文件，保存在硬盘中，因此Redis进程退出，只要RDB文件仍在，就可以用来还原数据库的状态。 RDB文件的创建和载入 服务器在载入RDB文件期间，会一直阻塞。 SAVE命令由服务器进程执行保存工作，因此会阻塞服务器。BGSAVE命令由子进程执行保存工作。 自动间隔性保存 设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。 save 900 1 # 900s内发生了至少一次修改 save 300 10 save 60 10000 满足上述一个条件，BASAVE就会执行。 RDB文件结构 头部 数据库版本 数据 正文结束符 校验和 REDIS db_version databases EOF check_sum ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:2:2","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"AOF持久化(Append Only File) 通过保存Redis服务器所执行的写命令来记录数据库状态。 AOF持久化的实现过程 命令追加:将内容追加到aof_buf缓冲区的末尾。 写入与同步：服务器每次结束一个时间循环之前，都会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区中的内容写入和保存到AOF文件中。选项值为：alwals,everysec,no 载入与数据还原：还原过程：创建一个不带网络连接的伪客户端；从AOF文件中分析并读取一条写命令；使用伪客户端执行被读出的写命令；循环处理。 AOF重写 目的：解决AOF文件体积膨胀。 实现原理：从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。 后台重写：子进程AOF重写期间，服务器进程可以继续处理命令请求。 后台重写问题：子进程重写期间，服务器还需要处理命令请求，可能导致服务器当前数据库状态和重写后的AOF文件所保存的数据库状态不一致。解决办法：AOF重写缓冲区。 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:2:3","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"事件 文件事件 文件事件处理器。基于Reactor模式，使用IO多路复用程序同时监听多个套接字。 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:2:4","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"3.多机数据库的实现 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:3:0","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"4.独立功能的实现 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:4:0","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"常见问题 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:0","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"AOF和RDB比较 两者区别：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。 优缺点：RDB：灵活设置备份频率和周期。方便灾难恢复，可以轻松的将一个单独的文件压缩再转移到其他存储介质上。性能最大化。数据集很大时，启动效率相对AOF较高。缺点：很难保证高可用，可能数据在写入磁盘之前会丢失。数据集较大时，可能导致服务器停止服务。 AOF：数据持久性。对日志的写入操作采用的是append模式，写入过程即使出现宕机，也不会破坏日志文件中已经存在的内容。如果日志过大，Redis可以自动启用rewrite机制。包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。缺点：RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。根据同步策略的不同，AOF在运行效率上往往会慢于RDB。 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:1","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis分布式锁 使用setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？ 同时把setnx和expire合成一条指令来用 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:2","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"寻找key 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 用keys指令可以扫出指定模式的key列表。 redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:3","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis同步机制 Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:4","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"redis相比memcached有哪些优势 丰富的数据类型 速度快 可以持久化 区别： 存储方式：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。 数据类型：Memcache对数据类型支持相对简单。Redis有复杂的数据类型,Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 底层模型：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 value大小：redis最大可以达到1GB，而memcache只有1MB。 Redis支持数据的备份，即master-slave模式的数据备份。 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:5","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis的LRU算法 最近最久未用算法。当内存达到限制时，Redis 具体的回收策略是通过 maxmemory-policy 配置项配置的。 no-eviction：不清除数据，只是返回错误，这样会导致浪费掉更多的内存，对大多数写命令（DEL 命令和其他的少数命令例外） allkeys-lru：从所有的数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，以供新数据使用 volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰，以供新数据使用 allkeys-random：从所有数据集（server.db[i].dict）中任意选择数据淘汰，以供新数据使用 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰，以供新数据使用 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，以供新数据使用 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:6","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis常见的性能问题及解决 Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件. 特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。 尽量避免在压力很大的主库上增加从库。 Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。 Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:7","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"适合Redis的场景 会话缓存 全页缓存 队列 排行榜/计数器 发布/订阅 会话 购物车 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:8","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Nosql和Key-Value数据库 NoSQL，泛指非关系型的数据库，全称Not Only SQL，意即“不仅仅是SQL”。 NoSQL数据库的四大家族： 键值（Key-Value）数据库:Redis、Memcached 面向文档（Document-Oriented）数据库:MongoDB 适用：日志、分析 列存储（Wide Column Store/Column-Family）数据库 HBase 适用:日志、博客平台 图（Graph-Oriented）数据库 适用：关系性强，推荐引擎 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:9","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis最大连接数 默认10000 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:10","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"redis的瓶颈 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:11","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis 主从复制 Redis 复制功能 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:12","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:13","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis是单线程的，为什么这么高效。我用了对比的方式说，举例Apache和Nginx，一个多线程，一个IO多路复用 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:14","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis的数据类型有哪些，底层怎么实现，跳跃表，哈希表，整数集合等等 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:15","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:16","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Redis和memcached的区别，Redis为什么可以组集群 ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:5:17","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["other"],"content":"Reference： https://www.bookstack.cn/read/note-of-interview/framework-redis.md http://www.techug.com/post/nosql.html ","date":"2018-06-19","objectID":"/posts/database/redis_sum/:6:0","tags":["Linux","后台开发","Redis","Nosql"],"title":"《redis 设计与实现》--总结","uri":"/posts/database/redis_sum/"},{"categories":["工具"],"content":" 由于人比较懒，总是忘了自己提交到github上，也觉得博客好不容易写了还要打开文件夹，点一下交，这个体验有点差呀。于是就写了个Linux自动提交代码的和windows自动更新博客的。 ","date":"2018-05-24","objectID":"/draft/deprecated/shell_autopush/:0:0","tags":["工具"],"title":"ubuntu自动push到github脚本","uri":"/draft/deprecated/shell_autopush/"},{"categories":["工具"],"content":"Linux编写shell脚本 ","date":"2018-05-24","objectID":"/draft/deprecated/shell_autopush/:1:0","tags":["工具"],"title":"ubuntu自动push到github脚本","uri":"/draft/deprecated/shell_autopush/"},{"categories":["工具"],"content":"脚本代码 #!/bin/bash path=~/github/ git_push(){ echo \"开始push\" modify_time=`stat -c %Y ${1}` this_time=`date +%s` cd ${1} echo \"-------切换目录------\" echo `pwd` echo \"---------------------\" if [ $[ ${modify_time}-${this_time} ] -gt 86400 ]; then echo \"${1} 文件夹 有变化，正在准备push...\" date=`date \"+%Y-%m-%d %H:%M:%S\"` git add . git commit -m \"automatic push @$(date)\" echo \"git fetch origin master\" git fetch origin master echo \"git merge origin/master\" git merge origin/master echo \"git push origin master:master\" git push origin master:master fi } git_push ~/github/Linux_pro git_push ~/github/miniweb ","date":"2018-05-24","objectID":"/draft/deprecated/shell_autopush/:1:1","tags":["工具"],"title":"ubuntu自动push到github脚本","uri":"/draft/deprecated/shell_autopush/"},{"categories":["工具"],"content":"加入定时任务 ","date":"2018-05-24","objectID":"/draft/deprecated/shell_autopush/:1:2","tags":["工具"],"title":"ubuntu自动push到github脚本","uri":"/draft/deprecated/shell_autopush/"},{"categories":["工具"],"content":"编辑定时任务文件 (https://blog.csdn.net/xiyuan1999/article/details/8160998) crontab -e 在文件的末尾添加： 30 5 * * * /home/mianhk/shell/auto_push.sh 表示在每天的 5.30执行 ","date":"2018-05-24","objectID":"/draft/deprecated/shell_autopush/:1:3","tags":["工具"],"title":"ubuntu自动push到github脚本","uri":"/draft/deprecated/shell_autopush/"},{"categories":["工具"],"content":"启动服务 /etc/init.d/cron start ","date":"2018-05-24","objectID":"/draft/deprecated/shell_autopush/:1:4","tags":["工具"],"title":"ubuntu自动push到github脚本","uri":"/draft/deprecated/shell_autopush/"},{"categories":["工具"],"content":"Windows自动提交博客 其实windows的也差不多，写一个bat的脚本，然后加到系统的定时任务里面 ","date":"2018-05-24","objectID":"/draft/deprecated/shell_autopush/:2:0","tags":["工具"],"title":"ubuntu自动push到github脚本","uri":"/draft/deprecated/shell_autopush/"},{"categories":["工具"],"content":"代码如下 title 同步博客到远端——余国聪 color 16 echo; echo; echo 切换目录到blog f: cd \\github\\mianhk cd .\\blog echo clean hexo g -d echo 切换到GitHub备份目录 cd .. echo 开始提交代码到本地仓库 echo 当前目录是：%cd% echo 开始添加变更 echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ git add -A . echo 执行结束！ echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ echo; echo 提交变更到本地仓库 echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ set declation=%date:~0,4%%date:~5,2%%date:~8,2% git commit -m \"%declation%同步博客\" echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ echo; echo 将变更情况提交到远程git服务器 echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ git push origin master echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ echo; echo 批处理执行完毕！ echo; pause ","date":"2018-05-24","objectID":"/draft/deprecated/shell_autopush/:2:1","tags":["工具"],"title":"ubuntu自动push到github脚本","uri":"/draft/deprecated/shell_autopush/"},{"categories":["工具"],"content":"添加到自动任务 计算机-\u003e管理-\u003e任务计划程序-\u003e添加任务即可 我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=174pin6hqb074 ","date":"2018-05-24","objectID":"/draft/deprecated/shell_autopush/:2:2","tags":["工具"],"title":"ubuntu自动push到github脚本","uri":"/draft/deprecated/shell_autopush/"},{"categories":["other"],"content":" jupyter notebook折腾日记 安装 ","date":"2018-04-26","objectID":"/posts/tools/use_of_jupyter/:0:0","tags":["Linux","工具","jupyter","笔记"],"title":"jupyter-notebook安装和问题解决","uri":"/posts/tools/use_of_jupyter/"},{"categories":["other"],"content":"1.采用直接pip安装 pip install jupyter 不过可能由于是版本自带的pip有问题，而且用的Python版本也还是2.7的，反正就出现了各种问题。中间解决的有： 重新升级pip，但是发现直接pip还是有问题，于是找到问题原因，可能名字有点对不上，找到bin目录下还有一个pip2，在Python里面运行，发现果然是这个，有点心酸，还是换了这个。 升级之后，会出现各种的权限问题，没事，给！ 之后运行，发现没有浏览器，于是又想起服务器上没有，又加上命令试了一下，而且每次都要复制一个长长的token吗？。。 ","date":"2018-04-26","objectID":"/posts/tools/use_of_jupyter/:1:0","tags":["Linux","工具","jupyter","笔记"],"title":"jupyter-notebook安装和问题解决","uri":"/posts/tools/use_of_jupyter/"},{"categories":["other"],"content":"2.采用Anaconda安装 正好晚上在床上看到一个链接，说这个更方便，反正也是折腾嘛，就试试了。过程稍微写一写哈 在清华镜像站找到采用Anaconda相应版本下载：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 找到后复制链接：wget 链接 安装Anaconda: sh Anaconda3-5.1.0-Linux-x86_64.sh # 一路yes就装了 服务器管理控制台开放8888端口（当然端口可以配置，也随便换了） 运行jupyter notebook --generate-config 生成默认的jupyter配置文件 编辑config文件： cd .jupyter vim jupyter_notebook_config.py #编辑config文件 c.NotebookApp.ip = '*' #允许所有的ip登录 c.NotebookApp.open_browser = False #打开浏览器：关闭，因为服务器没有浏览器 c.NotebookApp.port = 8888 #开放使用的端口 保存退出。运行jupyter notebook，会得到一个带token的访问地址。复制地址，将其中的localhost替换成服务器的公网IP，访问，应该可以正常进入jupyter。 每次都tocken当然有点麻烦了。设置一个密码吧： jupyter-notebook password 之后就可以公网输入登录了。 ","date":"2018-04-26","objectID":"/posts/tools/use_of_jupyter/:2:0","tags":["Linux","工具","jupyter","笔记"],"title":"jupyter-notebook安装和问题解决","uri":"/posts/tools/use_of_jupyter/"},{"categories":["other"],"content":"3.安装主题和相关插件 jupyter_contrib_nbextensions 直接使用conda install -c conda-forge jupyter_contrib_nbextensions 使用注意： 1.关于ubuntu的环境变量设置没有对，导致conda命令不能用的问题。当然知道应该是环境变量的问题，不过还是搞了很久。才发现是加在ubuntu的home目录下的.bashrc后面export PATH=~/anaconda3/bin:$PATH 2.由于我的conda版本没有更新，所以出现了插件也只有几个的情况，所以需要先更新。之后再重启jupyter notebook。 参考 http://www.yaozihao.cn/2017/04/25/jupyter-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/ https://zhuanlan.zhihu.com/p/34289322 https://zhuanlan.zhihu.com/p/20226040?utm_source=qq\u0026utm_medium=social\u0026utm_member=Y2E2MjI0YTdlMTI5YTMzOTA2NTlhZDRiMzY2MjFiNmQ%3D%0A ","date":"2018-04-26","objectID":"/posts/tools/use_of_jupyter/:3:0","tags":["Linux","工具","jupyter","笔记"],"title":"jupyter-notebook安装和问题解决","uri":"/posts/tools/use_of_jupyter/"},{"categories":["工具"],"content":" 俗话说，生活就是不断的折腾，恰好自己是个这样的人。可能就是这样一个虽然不是很年轻了，但是心态总是年轻的，看到一些有趣的或者有意思的，总是忍不住想看看，或者试试。但是有时候又觉得自己不再年轻了，有些东西虽然当时记着了，但是后来又忘了，或者有时候记着又找起来很耽误时间。所以就在这记录一下吧。 ","date":"2018-04-25","objectID":"/posts/tools/daily_zheteng/:0:0","tags":["博客","资源","收集"],"title":"日常折腾日记","uri":"/posts/tools/daily_zheteng/"},{"categories":["工具"],"content":"博客相关 hexo博客插件 我的博客折腾 自动构建博客 hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌） ","date":"2018-04-25","objectID":"/posts/tools/daily_zheteng/:1:0","tags":["博客","资源","收集"],"title":"日常折腾日记","uri":"/posts/tools/daily_zheteng/"},{"categories":["工具"],"content":"Linux jupyter tmux的使用 tmux的使用2 ","date":"2018-04-25","objectID":"/posts/tools/daily_zheteng/:2:0","tags":["博客","资源","收集"],"title":"日常折腾日记","uri":"/posts/tools/daily_zheteng/"},{"categories":["工具"],"content":"Sublime Text ","date":"2018-04-25","objectID":"/posts/tools/daily_zheteng/:3:0","tags":["博客","资源","收集"],"title":"日常折腾日记","uri":"/posts/tools/daily_zheteng/"},{"categories":["工具"],"content":"娱乐 vip视频： https://github.com/laidefa/Flask_Web_Vip： http://101.37.147.236:1518/ ","date":"2018-04-25","objectID":"/posts/tools/daily_zheteng/:4:0","tags":["博客","资源","收集"],"title":"日常折腾日记","uri":"/posts/tools/daily_zheteng/"},{"categories":["工具"],"content":"update: 2018-04-24 首次更新:突然发现Sublime Text3也还是挺好用的，之前切出去光标总是乱跳，就有点烦，以为是这样的就没管，用了网易云，没想到发现只有我的是这样，赶紧找找问题，解决一下。顺便把很多重新折腾一下。 #用好sublime ","date":"2018-04-24","objectID":"/posts/tools/use-of-sublime/:0:0","tags":["工具","折腾"],"title":"Sublime Text3使用总结","uri":"/posts/tools/use-of-sublime/"},{"categories":["工具"],"content":"为Sublime Text3添加插入当前时间的命令 创建插件： Tools → New Plugin: import datetime import sublime_plugin class AddCurrentTimeCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.run_command(\"insert_snippet\", { \"contents\": \"%s\" % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") } ) 保存为Sublime Text3\\Packages\\User\\addCurrentTime.py 创建快捷键： Preference → Key Bindings - User: [ { \"command\": \"add_current_time\", \"keys\": [ \"ctrl+shift+.\" ] } ] ","date":"2018-04-24","objectID":"/posts/tools/use-of-sublime/:0:1","tags":["工具","折腾"],"title":"Sublime Text3使用总结","uri":"/posts/tools/use-of-sublime/"},{"categories":["工具"],"content":"添加了一个主题https://packagecontrol.io/packages/Predawn：Predawn ","date":"2018-04-24","objectID":"/posts/tools/use-of-sublime/:0:2","tags":["工具","折腾"],"title":"Sublime Text3使用总结","uri":"/posts/tools/use-of-sublime/"},{"categories":["工具"],"content":"其他链接 小土刀博客：http://wdxtub.com/2016/03/24/sublime-guide/ ","date":"2018-04-24","objectID":"/posts/tools/use-of-sublime/:0:3","tags":["工具","折腾"],"title":"Sublime Text3使用总结","uri":"/posts/tools/use-of-sublime/"},{"categories":["other"],"content":"why title 生活就是要不断的思考,不是吗? ","date":"2018-04-24","objectID":"/posts/redo-mylife/:1:0","tags":["随笔","生活"],"title":"阶段性生活思考","uri":"/posts/redo-mylife/"},{"categories":["other"],"content":"update:2018-05-13 21:15:04 周日 突然觉得很久没思考自己的生活了。 1.做事情注意力不集中。最近虽然看起来学习态度要好一些，每天都是待在实验室，但是学习的效率却感觉没有以前高了。而且总是注意力不够集中，明明在该学习的时候，却看看这个看看那个。做这个的时候看看想起另外一件事，就去看看，结果就该做的事情没做好。看看论文就想玩玩手机，玩着又有点愧疚就去看看c++，总是三心二意的。 2.不太爱思考。另一个问题就是，遇到问题不求甚解。这还是以前的老问题吧，对于以前的应试教育来说，可能里面的道理也不用太深究，毕竟能最后写在试卷上就行了，看起来还能有个差不多好看的分数。但是现在处于的阶段不一样了，不管是日常的工作学习，还是平时看到一些新闻的想法，这都会有一些问题。当然，这方面可能手机因素也比较大一点，有很多的观点唾手可得，找找资料就能看到很多东西，恰好这方面自己又比较擅长，于是就又陷入了找资料不思考的陷阱。这样虽然有时候找到了很多有价值的东西，平时看到了很多，说吧，都知道，但是具体的就是不清楚，更别谈再有所新的想法了。所以这是个重要的问题。 3.做事情应该更有目的。就是可能现在感觉很忙，但是却没有个统一的目的，有时候花的时间是多了，但是却没有很好的效果。 ","date":"2018-04-24","objectID":"/posts/redo-mylife/:1:1","tags":["随笔","生活"],"title":"阶段性生活思考","uri":"/posts/redo-mylife/"},{"categories":["other"],"content":"update:2018-05-30 20:21:01 周三 学习方面稍微集中了一点，但是还是没有太专注。 做事情还是要抓住重点，仍然需要注意。 多多总结。 ","date":"2018-04-24","objectID":"/posts/redo-mylife/:1:2","tags":["随笔","生活"],"title":"阶段性生活思考","uri":"/posts/redo-mylife/"},{"categories":["other"],"content":" 生活有时候看的一些书，一些视频，有些想法，专门找个文件记录一下吧。 ","date":"2018-04-24","objectID":"/posts/daily/life_random/:0:0","tags":["随笔","生活"],"title":"生活随笔","uri":"/posts/daily/life_random/"},{"categories":["other"],"content":"update:2018-07-17 19:22:01 周二 看了个视频：https://www.youtube.com/watch?v=jbUJGkM4Ksk 成长型思维和固定型思维。虽然看名字有点鸡汤了，但是确实很久都忘了这些了。 可能已经不像很久以前那样了，什么都不怕，能够不问结果的去做很多事情，现在考虑的很多，也更想着用一些以前的思路去考虑问题，却忘了自己本来的优势了。 1.了解大脑可塑性 2.以过程为焦点 3.尝试做有挑战性的事情 ","date":"2018-04-24","objectID":"/posts/daily/life_random/:0:1","tags":["随笔","生活"],"title":"生活随笔","uri":"/posts/daily/life_random/"},{"categories":["面试经验"],"content":" 最近一直在看网络编程的东西，不管是看书、还是一些博客，或者是自己的一些编程，都觉得写的有点乱，有点杂。虽然这也比较符合网络方面的特点，零碎的知识点，有些人觉得重要就写上了，另一些就没有写。想到将来可能跟网络编程接触很多，也觉得最近的学习就是缺少一些总结。就在这里站在大佬的肩膀上整理一下吧。 计算机网络体系结构（TCP/IP四层模型） 一般所说的计算机体系结构分为三种，其中TCP/IP体系结构是实际应用较多的。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:0:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"五层模型 应用层：为特定应用程序提供数据传输服务，例如 http、DNS 等。数据单位为报文。 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:0:1","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"TCP/IP四层模型 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 通道： 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播 双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息 通道复用技术： 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:0:2","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"数据链路层 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:1:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"主要信道： 点对点信道 广播信道 点对点信道 数据单元–帧 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议 广播信道 广播通信： 硬件地址（物理地址、MAC 地址） 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:1:1","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"三个基本问题 封装成帧 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:1:2","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"IP 网际协议 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:2:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"IP 地址分类： IP 地址 ::= {\u003c网络号\u003e,\u003c主机号\u003e} IP 地址类别 网络号 网络范围 主机号 IP 地址范围 A 类 8bit，第一位固定为 0 0 —— 127 24bit 1.0.0.0 —— 127.255.255.255 B 类 16bit，前两位固定为 10 128.0 —— 191.255 16bit 128.0.0.0 —— 191.255.255.255 C 类 24bit，前三位固定为 110 192.0.0 —— 223.255.255 8bit 192.0.0.0 —— 223.255.255.255 D 类 前四位固定为 1110，后面为多播地址 E 类 前五位固定为 11110，后面保留为今后所用 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:2:1","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"IP 数据报格式： ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:2:2","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"ARP/RARP 地址解析协议/反向地址转化协议 地址解析协议: 在数据报向下一个站点传递时，负责将IP地址转换为物理地址。 主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接受返回消息，以此确定目标的物理地址； 接收的返回消息后将该IP地址和物理地址存入本机并保留一段时间，下次请求时直接查询ARP缓存以节约时间。 （地址解析协议是IPV4中广泛使用的协议；但在IPV6中不存在该协议，使用NDP（邻居发现协议）） 工作流程： 当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址解析为主机B的MAC（物理）地址。 ARP缓存是一个用来存储IP地址和MAC地址的一个缓冲区，其本质是一个IP地址对应一个MAC地址。当地址解析协议在查询IP时，首先在ARP缓存中查看，若存在则返回，否则发送ARP请求； 地址解析协议是通过报文工作的。报文包括如下字段：硬件类型，协议类型，硬件地址长度，协议长度，操作类型。 APR缓存包含一个或多个表，他们用于存储IP地址及经过地址解析的MAC地址。ARP命令用于查询本机的ARP缓存中的IP到MAC地址的对应关系、添加或删除静态对应关系等。如果再没有参数的情况下ARP命令将显示帮助信息。 ARP-a 查看缓存中的所有项目，在Linux中命令式ARP-g; 反向地址转化协议: 作用于ARP相反，负责将物理层地址转换为IP地址 反向地址转化协议，作用于ARP相反，负责将物理层地址转换为IP地址； 允许局域网物理机器从网关服务器的ARP表或缓存上请求主机的IP地址；当设置一台新机器时，其RARP客户机程序需要向路由器上的RARP服务器请求相应的IP地址。 ARP是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议，假设知道自己的物理地址但不知道自己的IP地址，这种情况就该使用RARP协议。 RARP工作方式与ARP相反，RARP发出需要反向解析的MAC地址，并且希望返回其对应的IP地址，应答包括由能提供信息的RARP服务器发出的IP地址。 工作流程： 从网卡读取自己的MAC地址—\u003e发送RARP请求的广播数据包—\u003eRARP服务器收到请求，为其分配IP地址，并将RARP回应发送给该机器—\u003e该机器收到IP地址后，使用IP地址进行通信 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:2:3","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"ICMP 网际控制报文协议 由于IP协议提供的是一种不可靠的和无连接的数据报服务，为了对IP数据报的传送进行差错控制，对未能完成传送的数据报给出出错的原因，TCP/IP协议簇在网络连层提供了一个用于传递控制报文的ICMP协议，即网际控制报文协议。 ICMP 报文格式： ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:2:4","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"IGMP 网际组管理协议 运输层 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:2:5","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"TCP协议 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:3:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"概念： 面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:3:1","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"TCP首部格式 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:3:2","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"TCP三次握手和四次挥手 TCP四次挥手 当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的。那对于TCP的断开连接，就是通常说的“四次挥手”。 第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，主机1也关闭连接。 为什么需要三次握手 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接，解决网络中存在延迟的分组，防止了服务器端的一直等待而浪费资源。 “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。 为什么要四次挥手 TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。 TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 TCP的十一种状态 TCP长连接和短连接 概念 长连接，也叫持久连接，在TCP层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息（包括心跳）交互，直至连接的任意一方（客户端OR服务端）主动断开连接，此过程称为一次完整的长连接。HTTP 1.1相对于1.0最重要的新特性就是引入了长连接。 短连接，与长连接的区别就是，客户端收到服务端的响应后，立刻发送FIN消息，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互（发请求-收响应）之后立刻断开连接的情况都称为短连接。 使用场景 1、需要频繁交互的场景使用长连接，如即时通信工具（微信/QQ，QQ也有UDP），相反则使用短连接，比如普通的web网站，只有当浏览器发起请求时才会建立连接，服务器返回响应后，连接立即断开。 2、维持长连接会有一定的系统开销，用户量少不容易看出系统瓶颈，一旦用户量上去了，就很有可能把服务器资源（内存/CPU/网卡）耗尽，所以使用需谨慎。 快速区分使用的是长连接还是短连接 1、凡是在一次完整的消息交互（发请求-收响应）之后，立刻断开连接（有一方发送FIN消息）的情况都称为短连接； 2、长连接的一个明显特征是会有心跳消息（也有没有心跳的情况），且一般心跳间隔都在30S或者1MIN左右，用wireshark抓包可以看到有规律的心跳消息交互（可能会存在毫秒级别的误差）。 TCP实现可靠传输 建立连接（标志位）：通信前确认通信实体存在。 序号机制（序号、确认号）：确保了数据是按序、完整到达。 数据校验（校验和）：CRC校验全部数据。 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。 窗口机制（窗口）：提供流量控制，避免过量发送。 拥塞控制：同上。 超时重传 超时重传机制：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况： 发送的数据没能到达接收端，所以对方没有响应。 接收端接收到数据，但是ACK报文在返回过程中丢失。 接收端拒绝或丢弃数据。 重传间隔(RTO)：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。 通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT…… 重传次数到达上限之后停止重传。 RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。 TCP流量控制 利用滑动窗口实现流量控制 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。 设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。 TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。 考虑传输速率 可以用不同的机制来控制TCP报文段的发送时机。如： TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。 由发送方的应用进程指明要求发送报文段，即TCP支持的推送( push )操作。 发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。 Nagle算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定：当到达的数据已达到 发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。 糊涂窗口综合证：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。 TCP拥塞控制 拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。 拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。 流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:3:3","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"UDP协议 面向无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），对于一些控制需要在应用层解决。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:4:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"UDP头部 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:4:1","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"socket编程 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:5:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"socket原理 套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:5:1","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"建立socket连接 建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 *连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:5:2","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"创建TCP的socket流程 服务端 创建socket： int socket(int domain, int type, int protocol); 将socket绑定地址和端口号：int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 监听：int listen(int sockfd, int backlog); 接受连接：int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 读取数据：ssize_t read(int fd, void *buf, size_t count); 关闭socket:int close(int fd); 客户端 创建socket： int socket(int domain, int type, int protocol); 连接：int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen); 输入数据: ssize_t write(int fd, const void *buf, size_t count); 关闭socket:int close(int fd); 应用层 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:5:3","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"域名系统 DNS DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:6:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"文件传输协议 FTP FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。 TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:7:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"远程终端协议 TELNET TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:8:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"电子邮件协议 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:9:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"动态主机配置协议 DHCP DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途： 用于内部网络或网络服务供应商自动分配 IP 地址给用户 用于内部网络管理员作为对所有电脑作中央管理的手段 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:10:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"超文本传送协议 HTTP 其他问题 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:11:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"从输入URL到页面加载发生了什么 https://segmentfault.com/a/1190000006879700 DNS解析-\u003eTCP连接-\u003e发送HTTP请求-\u003e服务器处理请求并返回HTTP报文-\u003e浏览器解析并渲染界面-\u003e连接结束 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:12:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["面试经验"],"content":"为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ TIME_WAIT状态由两个存在的理由。 （1）可靠的实现TCP全双工链接的终止。 这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。 （2）允许老的重复的分节在网络中消逝。 假 设在12.106.32.254的1500端口和206.168.1.112.219的21端口之间有一个TCP连接。我们关闭这个链接，过一段时间后在 相同的IP地址和端口建立另一个连接。后一个链接成为前一个的化身。因为它们的IP地址和端口号都相同。TCP必须防止来自某一个连接的老的重复分组在连 接已经终止后再现，从而被误解成属于同一链接的某一个某一个新的化身。为做到这一点，TCP将不给处于TIME_WAIT状态的链接发起新的化身。既然 TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活msl秒即被丢弃，另一个方向上的应答最多存活msl秒也被丢弃。 通过实施这个规则，我们就能保证每成功建立一个TCP连接时。来自该链接先前化身的重复分组都已经在网络中消逝了。 参考链接： https://github.com/huihut/interview#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82 https://blog.csdn.net/yechaodechuntian/article/details/25429143 http://www.cnblogs.com/maybe2030/p/4781555.html#_label3 ","date":"2018-04-10","objectID":"/posts/sumary/interview_network/:13:0","tags":["网络"],"title":"一文总结计算机网络","uri":"/posts/sumary/interview_network/"},{"categories":["other"],"content":"Linux的fork使用 fork函数可以算是Linux里有点不好明白的函数了，调用一次，返回两次，虽然在平时的写法中，有基本固定的写法，但是有时候看起来还是有些让人头疼的。这里就把关于fork函数好好整理一下 ","date":"2018-03-15","objectID":"/posts/linux/use_of_fork/:1:0","tags":["Linux","后台开发"],"title":"Linux的fork使用","uri":"/posts/linux/use_of_fork/"},{"categories":["other"],"content":"函数介绍 功能：fork函数是从一个已经存在的进程中创建一个新的进程，新的进程称为子进程，原来的进程称为父进程。 参数：无 返回值： 成功：子进程中返回 0，父进程中返回子进程 ID。pid_t，为无符号整型。 失败：返回 -1。 失败的两个主要原因是： 1）当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN。 2）系统内存不足，这时 errno 的值被设置为 ENOMEM。 ","date":"2018-03-15","objectID":"/posts/linux/use_of_fork/:1:1","tags":["Linux","后台开发"],"title":"Linux的fork使用","uri":"/posts/linux/use_of_fork/"},{"categories":["other"],"content":"测试的例子 下面是一个简单的创建子进程的例子。 #include \u003ciostream\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e int main(){ int pid=1; pid=fork(); if(0==pid){ //pid为0，表示为子进程 cout\u003c\u003c\"我是子进程，我的pid是：\"\u003c\u003cgetpid()\u003c\u003cendl; } else if(pid\u003e0){ //pid\u003e0表示父进程，此时返回值为子进程的pid cout\u003c\u003c\"我是父进程，我的pid是\"\u003c\u003cgetpid()\u003c\u003cendl; } else { //fork 失败 cout\u003c\u003c\"fork失败\"\u003c\u003cendl; } } 从上面的例子可以看出，fork函数会有两个返回值，一个是在子进程中返回0,一个是在父进程中返回子进程的pid。因此在编程过程中，需要判断这个值的返回值来判断当前是父进程还是子进程。 ","date":"2018-03-15","objectID":"/posts/linux/use_of_fork/:1:2","tags":["Linux","后台开发"],"title":"Linux的fork使用","uri":"/posts/linux/use_of_fork/"},{"categories":["other"],"content":"fork进程的原理 使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用 fork()函数的代价是很大的。 ","date":"2018-03-15","objectID":"/posts/linux/use_of_fork/:1:3","tags":["Linux","后台开发"],"title":"Linux的fork使用","uri":"/posts/linux/use_of_fork/"},{"categories":["other"],"content":"日常使用fork 简单来说， 一个进程调用 fork() 函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。 实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。 子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。一般来说，在 fork() 之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。 因此，在实际的使用过程中，一般都需要对fork()的返回值进行判断，看我们操作的是父进程还是子进程。 一般的操作：同时创建多个子进程 不对的例子:父进程会生成 n(n+1)/2+1个子进程，N 为循环次数，本例中共有 7 个子进程， 但实际上只有 3 个是父进程产生的，其余都为子进程 fork（）出来的。父进程fork了3个进程，第一个子进程执行完之后又fork了2个进程，第2个子进程fork了1个进程。 int main(){ pid_t p1,p2; int i; int N=100; for(int i=0;i\u003c=N;++i){ if((p1=fork())==0){ cout\u003c\u003c\"子进程1：\"\u003c\u003cgetpid()\u003c\u003cendl; //return 0; //很关键的地方，为什么需要返回呢 } wait(p1,NULL,0); //父进程等待p1子进程执行后才能继续fork其他子进程 cout\u003c\u003c\"这是父进程: \"\u003c\u003cgetpid()\u003c\u003cendl; } } 正确的使用Linux中的用fork()由一个父进程创建同时多个子进程 的格式如下： int main(){ pid_t p1,p2; int i; int N=100; for(int i=0;i\u003c=N;++i){ status=fork(); if(status==0||status==1) break;//每次循环时，如果发现是子进程就直接从创建子进程的循环中跳出来，不让你进入循环，这样就保证了每次只有父进程来做循环创建子进程的工作 if (status == -1) { //error } else if (status == 0) //每个子进程都会执行的代码 { //sub process } else { //parent process } } } ","date":"2018-03-15","objectID":"/posts/linux/use_of_fork/:1:4","tags":["Linux","后台开发"],"title":"Linux的fork使用","uri":"/posts/linux/use_of_fork/"},{"categories":["other"],"content":"无聊的问题 1.下面的程序，不算 main这个进程自身，到底创建了多少个进程啊？ int main(int argc, char* argv[]) { fork(); fork() \u0026\u0026 fork() || fork(); fork(); } 每fork一次就翻倍 fork(); //2个 fork() \u0026\u0026 fork() || fork(); //A\u0026\u0026B||C //A为假，跳过B，判断C-----------------------2 //A为真，判断B，若B为真，跳过C-----------1 //若B为假，判断C ------------2 fork(); //2 总共有： 2*(2+1+2)*2=20 不算自己的话有20-1=19个 ","date":"2018-03-15","objectID":"/posts/linux/use_of_fork/:1:5","tags":["Linux","后台开发"],"title":"Linux的fork使用","uri":"/posts/linux/use_of_fork/"},{"categories":["刷题"],"content":"LeetCode-60-Permutation-Sequence The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3): \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Given n and k, return the kth permutation sequence. 同样是排列 组合的问题，这次不需要打印所有的排列了，只需要按照排列的顺序打印出第k个，很显然，思路不会是列出所有的排列，然后找第k个打印出来是吧。 观察来看，以1,2,3,4为例，有4*3*2*1=24种排列，其中根据排列的顺序，按照第一个数字可以分为以下4种： 1 * * * 2 * * * 3 1 2 4 3 1 4 2 3 2 1 4 3 2 4 1 3 4 1 2 3 4 2 1 4 * * * #### 方法一 第一个数 可以看出，当k=14时，第一个数字为3,这个是可以通过计算的。由于是从1开始的，取k=13；index=k/(n-1)!=13/3!=2，于是可以知道第一个数是3。那么第二个数字呢? 1+permutation(2,4) 2+permutation(1,4) 4+permutation(1,2) 第二个数 可以根据:k=k-index_pre*(n-1)!=13-2*3!=1; index=k/(n-2)!=1/(4-2)!=0于是第二个数为1。 第三个数 接下来就只剩下2和4了，继续:k=k-index_pre*(n-2)!=1-0*(4-2)!=1, index=k/(n-3)!=1/(4-3)!=1在此处表示为4.之后再确定最后一个: 第四个数 k=k-index_pre*(n-4)!=1-1*(4-4)=0; index=k/(n-4)!=0/(4-4)!=0 故第四个数为2 到了这里，思路就比较清晰了。我们需要做的是从第一个一直到最后一个的循环，每次选出一个数，但是还需要将该数从原来的数组中剔除掉，因为前面选过的后面就不能排列了。 方法二： 其实原理差不多，也还是根据排列的规律。只不过算的方法不一样。 j=i+k/(n-i)!; 删除s[j]; k=k%(n-i); s[i]=s[j]; 代码如下： class Solution { public: string getPermutation(int n, int k) { if(n\u003c=0) return \" \"; int i,j,f=1; string s(n,'0'); for(i=1;i\u003c=n;i++){ f*=i; s[i-1]+=i; } for(i=0,k--;i\u003cn;++i){ f/=n-i; j=i+k/f; char c=s[j]; for(;j\u003ei;j--) s[j]=s[j-1]; k%=f; s[i]=c; } return s; } }; ","date":"2018-02-06","objectID":"/posts/algorithm/leetcode-60-permutation-sequence/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-60-Permutation-Sequence","uri":"/posts/algorithm/leetcode-60-permutation-sequence/"},{"categories":["服务器"],"content":"大型网站架构技术-架构模式 模式的关键在于模式的可重复性。 每一个模式描述了一个在我们周围不断变化重复发生的问题及该问题解决方案的核心。这样就能一次次的使用该方案而不必做重复的工作。 这是经过很多个实践，被很多网站重复使用而逐渐形成大型网站架构模式： ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:0","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"分层 将系统再横向维度上切成几个部分，每个部分负责一部分相对单一的职责。就好比平时一份工作比较多的时候，团队中大家各自负责自己擅长的那一部分。大型网站中一般分为三层： 应用层：负责具体业务和视图展示。 服务层：为应用层提供服务支持。 数据层：提供数据存储访问服务。如数据库、缓存、文件、搜索引擎等。 需要注意的是：这个分层是逻辑的，并不一定要部署在不同的服务器上，可能会根据业务调整。 ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:1","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"分割 对业务进行横向切分。比如应用层：分为购物、论坛、搜索等。 ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:2","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"分布式 一台服务器解决不了的时候，就采用分布式解决一下。 分为：分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算。 ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:3","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"集群 使用分布式已经将分层和分割后的模块独立部署，但是对于用户集中访问的模块，可能还需要将独立部署的服务器集群化（多台服务器部署相同的应用构成一个集群），再通过一个负载均衡服务器对外提供服务。 ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:4","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"缓存 缓存是改善软件性能的第一手段。 CDN：讲内容部署在离用户最近的网络服务商，用户请求的时候，可以直接访问网络服务商缓存的静态资源，所以会很快。 反向代理：用户请求到网站的数据中心时，最先访问的是反向代理服务器，这里会缓存网站的静态资源。 本地缓存：应用服务器本地缓存的热点数据，可以在本机内存中直接访问，不需要访问数据库。 分布式缓存：数据量非常庞大时，需要的内存不是单机能承受的。因此还需要分布式缓存 ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:5","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"异步 业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步进行协作。 在单一服务器内部：采用多线程共享队列的方式实现异步。在分布式系统中：多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看做内存的分布式部署。 分布式消息队列的特性：网站扩展新功能便利，提高系统可用性，加快网站响应速度，消除并发访问高峰。 ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:6","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"冗余 备份嘛，较少的机器可能坏的时间不长，但是小概率时间试验的次数过多的话就基本是必然事件了。 ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:7","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"自动化 主要集中在运维方面，包括：发布过程自动化、自动化代码管理、自动化测试、自动化安全监测、自动化部署。对于运行中：自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降级、自动化分配资源。 ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:8","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"安全 密码和手机验证码；加密；网站验证码。 ","date":"2018-02-03","objectID":"/posts/architecture/architecture-model-of-web-architecture/:1:9","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-架构模式","uri":"/posts/architecture/architecture-model-of-web-architecture/"},{"categories":["服务器"],"content":"大型网站架构技术-演化 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:0:0","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"特点 高并发、大流量 高可用 海量数据 用户分布广泛、网络情况复杂 安全环境恶劣：易受攻击 需求变化快、发布频繁：为了快速适应市场 渐进式发展：逐渐进步发展 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:1:0","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"发展历程 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:0","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"初始阶段 应用程序、数据库、文件等所有资源都在一台服务器上。一般是在一台廉价的服务器上采用LAMP这种免费资源。 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:1","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"应用服务和数据服务分离 采用三台服务器分别承担自己的角色。 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:2","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"使用缓存改善网站的性能 二八定律：80%的业务访问集中在20%的数据上，为了减少数据库的访问压力，可以将一些数据放到缓存服务器上，这样可以提高整个网站的数据访问速度。 一般分为两种： 缓存在应用服务器上的本地缓存：访问速度快，但缓存的数据有限； 缓存在专门的分布式缓存服务器上的远程缓存：可以采用分布式缓存。 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:3","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"采用应用服务器改善网站并发处理能力 当应用服务器处理不了较多的并发请求时，可以增加一台服务器分担原有的服务器的访问，在前面加一个负载均衡服务器。 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:4","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"数据库读写分离 虽然采用了缓存，但有一些读操作和一部分写操作还是会落到数据库上。一般采用主从备份的数据库，写操作可以在主数据库中进行，读操作在从数据库中读取。 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:5","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"使用反向代理和CDN加速网站响应 加速用户的访问。基本原理都是缓存，CDN是部署在网络提供商的机房，反向代理部署在网站的中心机房。对于反向代理，用户首先访问的是反向代理服务器，如果反向代理服务器中缓存着资源，就直接返回给用户。 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:6","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"使用分布式文件系统和分布式数据库系统 持续增长的业务，单一的服务器满足不了要求的时候，一头牛拉不动的时候，不要企图换一头更厉害的牛，而是考虑再加一头牛一起拉。 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:7","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"使用NoSQL和搜索引擎 网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，需要采用一些非关系数据库技术和非数据库查询技术如搜索引擎。 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:8","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"业务拆分 分而治之 ","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:9","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["服务器"],"content":"分布式服务","date":"2018-02-03","objectID":"/posts/architecture/evolution-of-webarchitecture/:2:10","tags":["后台开发","大型网站技术","架构"],"title":"大型网站架构技术-演化","uri":"/posts/architecture/evolution-of-webarchitecture/"},{"categories":["刷题"],"content":"LeetCode-56-Merge-Intervals Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18]. 如例子中所示，每个数组的前后分别表示开始和结束，工作是合并有重叠的数组。例如，由于[1,3]和[2,6]有重叠，故直接改为[1,6]后输出。 想法还是比较简单的，因为输入的并不一定是给好的按照开始，所以需要先对输入以开始的值排序。首先在结果数组中写入第一个，只有遍历进行判断，分为两种情况： 如果某一interval的开始比结果数组中的结尾要大，显然不会有重叠，直接写入到结果数组中即可； 某一interval的开始比结果数组中的结尾要大，必然有重叠，此时还需要判断结束位置的大小。 代码如下： /** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ class Solution { public: vector\u003cInterval\u003e merge(vector\u003cInterval\u003e\u0026 intervals) { vector\u003cInterval\u003e res; if(intervals.size()\u003c=0) return res; sort(intervals.begin(),intervals.end(),[](Interval a,Interval b){return a.start\u003cb.start;}); res.push_back(intervals[0]); for(int i=1;i\u003cintervals.size();++i){ if(res.back().end\u003cintervals[i].start) res.push_back(intervals[i]); else{ res.back().end=max(res.back().end,intervals[i].end); } } return res; } }; ","date":"2018-01-30","objectID":"/posts/algorithm/leetcode-56-merge-intervals/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-56and57-Merge-Intervals","uri":"/posts/algorithm/leetcode-56-merge-intervals/"},{"categories":["刷题"],"content":"57-Insert-Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 题目改为向一个已经重叠的数组中加入新加入一个。需要做的是判断所处的位置，插入进去后还要删掉，值得注意的是这个删掉值的时候，vector的迭代器会发生变化，即有些会失效，所以最好的做法是，先插入，把需要的插入都插入之后再删除。 另外还有一个值得注意的是，排序搜索的谓语，使用的是a.end\u003cb.start，而不是之前的a.start\u003cb.start ，原因是需要找到一个范围，将newINterval夹在中间的一个范围。 /** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ class Solution { public: vector\u003cInterval\u003e insert(vector\u003cInterval\u003e\u0026 intervals, Interval newInterval) { if(intervals.size()\u003c=0){ intervals.push_back(newInterval); return intervals; } auto range=equal_range(intervals.begin(),intervals.end(),newInterval,[](Interval a,Interval b){return a.end\u003cb.start;}); auto iter1=range.first,iter2=range.second; if(iter1==iter2) intervals.insert(iter1,newInterval); else{ iter2--; iter2-\u003estart=min(newInterval.start,iter1-\u003estart); iter2-\u003eend=max(newInterval.end,iter2-\u003eend); intervals.erase(iter1,iter2); } return intervals; } }; ","date":"2018-01-30","objectID":"/posts/algorithm/leetcode-56-merge-intervals/:0:2","tags":["C++","LeetCode"],"title":"LeetCode-56and57-Merge-Intervals","uri":"/posts/algorithm/leetcode-56-merge-intervals/"},{"categories":["刷题"],"content":"LeetCode-55-Jump-Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example: A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 由题可知，数组的位置表示从该位置可以像前跳的步数，看最终能否跳到结尾。乍一看，这像是一个动态规划的问题，dp数组内存储每一个位置能够走的最远的位置，但是仔细一想，又是没有必要的，因为最终的目的不是为了判断哪一个位置能走的更远，而是能否到达最后一个位置。 能到达最后一个位置的必要条件，显然一个就是能从某一位置继续往前走，而不会断。例如：[3,2,1,0,4]，我们都能走到第4个位置，但是却无法继续往前走，故到不了最后一个。所以代码可以做一个判断。 另一个需要考虑的问题是：在从前往后遍历的过程中，维护哪一个变量？显然这个变量记录的是我们能走的最远的距离，如果这个距离走的更远就更新，直到不能继续往前走，此时判断能否到终点。 贴上代码： class Solution { public: bool canJump(vector\u003cint\u003e\u0026 nums) { int i=0; for(int reach=0;i\u003cnums.size()\u0026\u0026i\u003c=reach;++i) reach=max(reach,i+nums[i]); return i==nums.size(); } }; ","date":"2018-01-30","objectID":"/posts/algorithm/leetcode-55-jump-game/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-55-Jump-Game","uri":"/posts/algorithm/leetcode-55-jump-game/"},{"categories":["刷题"],"content":"LeetCode-53-Maximum-Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 最长子序列，又是一个动态规划的问题，关于动态规划，我们最主要的是要维护DP数组，这个问题以前还有点不理解，感觉主要的还是思想，只要知道这是一个动态规划的问题，解决动态规划的一般方法掌握了，其他的就都是细节了。 最近刷算法题，不得不想到的是以前的数学，数学是逻辑性可能更强的东西，尚且需要多做练习才行，何况算法了。当然现在慢慢的感觉就是，以前看到很多题完全没有头绪，现在很多大概是能分清是想考啥了，也会想着主动去选择相应的数据结构。 class Solution { public: int maxSubArray(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e dp(nums.size(),0); dp[0]=nums[0]; int res=dp[0]; for(int i=1;i\u003cnums.size();++i){ dp[i]=nums[i]+(dp[i-1]\u003e0?dp[i-1]:0); res=max(dp[i],res); } return res; } }; ","date":"2018-01-26","objectID":"/posts/algorithm/leetcode-53-maximum-subarray/:1:0","tags":["C++","LeetCode"],"title":"LeetCode-53-Maximum-Subarray","uri":"/posts/algorithm/leetcode-53-maximum-subarray/"},{"categories":["刷题"],"content":"LeetCode-52-N-Queens-II Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. 只返回N皇后问题结果的种数。 因此不需要每一个字符串置位了，只需要判断一个位置的横竖，斜45度和斜135度方向的值即可。依然采用递归的方式，这里需要注意的是，由于是对列递归，所以需要考虑的是行，斜45度，斜135度，本来是要维护一个一维数组和两个二维数组，但是想到二维数组的特征，可以改为维护三个一维数组，这两个一维数组保存的是将二维数组展开的信息。甚至是一波操作改为共维护两个一维数组也可以。 接下来是代码： class Solution { public: int totalNQueens(int n) { vector\u003cint\u003e rows(n),d1(2*n-1),d2(2*n-1); return find(n,n,0,rows,d1,d2); } int find(int n,int left,int i,vector\u003cint\u003e\u0026 rows,vector\u003cint\u003e\u0026 d1,vector\u003cint\u003e\u0026 d2){ if(left==0) return 1; int j,sum=0; for(j=0;j\u003cn;++j){ if(rows[j]||d1[i+j]||d2[n-1+i-j]) continue; rows[j]=d1[i+j]=d2[n-1+i-j]=1; sum+=find(n,left-1,i+1,rows,d1,d2); rows[j]=d1[i+j]=d2[n-1+i-j]=0; } return sum; } }; 看了一下别人的好像确实快一点，毕竟0ms啊，也贴一下别人的代码吧： class Solution { public: int totalNQueens(int n) { bool flag[5*n] = {false}; int num = 0; dfs(num,flag,0,n); return num; } void dfs(int\u0026 num, bool* flag, int row, int n){ if(row == n){ ++num; return; } for(int i = 0; i\u003cn;i++){ if(!flag[i] \u0026\u0026 !flag[row+i+n] \u0026\u0026 !flag[4*n + row - i]){ flag[i] = 1; flag[row+i+n] = 1; flag[4*n + row - i] = 1; dfs(num,flag,row+1,n); flag[i] = 0; flag[row+i+n] = 0; flag[4*n + row - i] = 0; } } } }; reference: https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand ","date":"2018-01-26","objectID":"/posts/algorithm/leetcode-52-n-queens-ii/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-52-N-Queens-II","uri":"/posts/algorithm/leetcode-52-n-queens-ii/"},{"categories":["刷题"],"content":"LeetCode-51-N-Queens 经典的N皇后问题，重点是全排列的问题，但是这里由于N皇后的不重复行、列、斜的要求，在排列的过程中，比如从行开始排列，只能保证同行不重复，所以需要引入isValid函数。通过判断列，左斜、右斜是否重复。 需要注意的是：关于全排列递归的写法，要更加熟练掌握才行，并且能完全理解，能够在不同的情况中灵活运用。其基本思想还是：固定前面的某个数字，不短的对后面进行交换。 class Solution { public: bool isValid(vector\u003cstring\u003e\u0026 queen, int row,int col,int n){ for(int i=0;i\u003crow;++i){ if(queen[i][col]=='Q') return false; } for(int i=row-1,j=col-1;i\u003e=0\u0026\u0026j\u003e=0;--i,--j){ if(queen[i][j]=='Q') return false; } for(int i=row-1,j=col+1;i\u003e=0\u0026\u0026j\u003cn;--i,++j){ if(queen[i][j]=='Q') return false; } return true; } void recurse(vector\u003cstring\u003e\u0026 queen,vector\u003cvector\u003cstring\u003e\u003e\u0026 res,int row,int n){ if(row==n){ res.push_back(queen); return; } for(int col=0;col!=n;++col){ if(isValid(queen,row,col,n)){ queen[row][col]='Q'; recurse(queen,res,row+1,n); queen[row][col]='.'; } } } vector\u003cvector\u003cstring\u003e\u003e solveNQueens(int n) { vector\u003cvector\u003cstring\u003e\u003e res; vector\u003cstring\u003e queen(n,string(n,'.')); recurse(queen,res,0,n); return res; } }; ","date":"2018-01-26","objectID":"/posts/algorithm/leetcode-51-n-queens/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-51-N-Queens","uri":"/posts/algorithm/leetcode-51-n-queens/"},{"categories":["刷题"],"content":"LeetCode-49-Group-Anagrams Given an array of strings, group anagrams together. For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”], Return: [ [\"ate\", \"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] 输入一个字符串数组，输出的是：将相同字符的字符串放在一个数组的二维数组。相同字符的处理，基本就是要对字符串排序的。然后需要考虑的就是排序好的那一个字符串怎么存的问题。用的数据结构是map，string为键，对应的值是一个set或者是一个vector，存放满足要求的string，之后再用这个初始化结果数组。 class Solution { public: vector\u003cvector\u003cstring\u003e\u003e groupAnagrams(vector\u003cstring\u003e\u0026 strs) { unordered_map\u003cstring,multiset\u003cstring\u003e\u003e map_str; for(string s:strs){ string t=s; sort(t.begin(),t.end()); map_str[t].insert(s); } vector\u003cvector\u003cstring\u003e\u003e res; for(auto temp:map_str){ vector\u003cstring\u003e vec_str_temp(temp.second.begin(),temp.second.end()); res.push_back(vec_str_temp); } return res; } }; 后来发现用vector其实要好一些。只是别人这么写的，时间竟然要短一点，毕竟是用vector初始化vector？ ","date":"2018-01-25","objectID":"/posts/algorithm/leetcode-49-group-anagrams/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-49-Group-Anagrams","uri":"/posts/algorithm/leetcode-49-group-anagrams/"},{"categories":["刷题"],"content":"Leetcode-48-Rotate-Image ou are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example : Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 这个乍一看觉得不难，但是写的时候又不知道怎么回事，其实旋转，对于我们写程序来说，其实就是不停的调换位置，但是怎么调换是个问题。 观察发现，第一个矩阵，最角上的四个1,3,7,9。转完之后，还是这四个数字，只不过是位置变了，接下来这样的四个是：2,4,6,8.最后一个5.再看一下4x4的其实也差不多。 所以想法就是直接每次四个数字进行换，换三次，就能换回来，然后进行下一次调换。 代码如下： class Solution { public: void rotate(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { if(matrix.size()\u003c=0) return; int a=0,b=matrix.size()-1; while(a\u003cb){ for(int i=0;i\u003cb-a;++i){ swap(matrix[a][a+i],matrix[a+i][b]); swap(matrix[a][a+i],matrix[b][b-i]); swap(matrix[a][a+i],matrix[b-i][a]); } ++a; --b; } } }; ","date":"2018-01-25","objectID":"/posts/algorithm/leetcode-48-rotate-image/:0:1","tags":["C++","LeetCode"],"title":"Leetcode-48-Rotate-Image","uri":"/posts/algorithm/leetcode-48-rotate-image/"},{"categories":["服务器"],"content":"服务器-Nginx设计架构 Nginx服务器架构 Nginx服务器启动后，产生一个主进程，主进程执行一系列工作后产生一个或多个工作进程。 如下图所示：Nginx服务器的结构大致分为主进程、工作进程、后端服务器和缓存。 主进程主要进行：Nginx配置文件解析、数据结构初始化、模块配置和注册、信号处理、网络监听生成、工作进程生成和管理。 工作进程主要进行：进程初始化、模块调用和请求处理等。 缓存索引重建及管理进程：cache模块，主要由缓存索引重建和缓存索引管理两类进程完成。缓存索引重建是在Nginx服务启动一段时间后由主进程生成，在缓存元数据重建完成后自动退出。主要工作是：根据本地磁盘上的缓存文件在内存中建立索引元数据库，启动后对本地磁盘上存放缓存文件的目录结构进行扫描，检查内存中已有的缓存你数据元是否正确，并更新索引元数据库；缓存索引管理进程一般存在于主进程的整个生命周期，负责对缓存索引进行管理。主要负责对元数据是否过期做出判断。 进程交互 Master-worker交互 主进程会建立一张工作进程表，存放所有未退出的，主进程通过一个单向管道向工作进程发送指令等信息。 Worker-Worker交互 工作进程之间的交互，首先要得到彼此的信息，建立管道通信。当工作进程w1需要向w2发送指令时，首先在主进程给它的其他工作进程信息中找到w2的进程ID，然后将正确的指令写入指向w2的通道。w2捕捉到管道中的时间后，解析指令并采取相应的措施。完成worker之间的交互 Run Loops时间处理循环模型 Run Loops指的是进程内部用来不停的调配工作，对事件进行循环处理的一种模型。 ","date":"2018-01-25","objectID":"/posts/linux/nginx/server_archtectuer_of_nginx/:0:1","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx设计架构","uri":"/posts/linux/nginx/server_archtectuer_of_nginx/"},{"categories":["服务器"],"content":"服务器-Nginx的事件驱动模型 ","date":"2018-01-25","objectID":"/posts/linux/nginx/server_model_of_nginx/:1:0","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx的事件驱动模型","uri":"/posts/linux/nginx/server_model_of_nginx/"},{"categories":["服务器"],"content":"什么是事件驱动模型 事件驱动概念：在持续的事物管理过程中，由当前时间节点上出现的事件引起的调用可用资源执行相关任务，解决问题，防止事物堆积的一种策略。 一般由：事件收集器、事件发送器和事件处理器组成。 ","date":"2018-01-25","objectID":"/posts/linux/nginx/server_model_of_nginx/:1:1","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx的事件驱动模型","uri":"/posts/linux/nginx/server_model_of_nginx/"},{"categories":["服务器"],"content":"事件驱动处理库 又称为多路IO复用方法：主要包括以下几种： select库 创建所关注事件的描述符集合，每个描述符，可以关注读事件、写事件以及异常发生事件。 调用底层的select函数，等待事件发生。 轮询所有事件描述符集合中的每一个事件描述符，检查是否有相应的事件发生，如果有，就进行处理。 poll库 Linux下平台的基本事件驱动模型。基本工作方式与select库相同。 区别在于：select库需要为读事件、写事件和异常事件分别创建一个描述符集合，因此在最后轮询的时候，需要分别轮询三个集合。而poll库只需要创建一个集合。轮询的时候同时检查三种事件是否发生。 epoll库 Nginx服务器支持的高性能事件驱动库。主要的改动是：把描述符列表的管理交由内核负责，一旦有某种事件发生，内核把发生的事件的描述列表通知给进程，这样就避免了轮询整个描述符列表。 epoll库通过相关调用通知内核创建一个有N个描述符的事件列表。然后给这些描述符设置关注的事件，并添加到内核的事件列表中去。 完成设置之后，epoll库就开始等待内核通知事件发生。一旦发生，内核将发生事件的描述符上报给epoll库。 rtsig模型 Real-time signal，实时信号。使用rtsig时，工作进程会通过系统内核建立一个rtsig队列用于存放标记事件发生的信号。每个事件发生时，系统内核就会产生一个信号存放在rtsig队列中等待工作进程的处理。 ","date":"2018-01-25","objectID":"/posts/linux/nginx/server_model_of_nginx/:1:2","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx的事件驱动模型","uri":"/posts/linux/nginx/server_model_of_nginx/"},{"categories":["服务器"],"content":"服务器-Nginx的Web请求处理机制 ","date":"2018-01-25","objectID":"/posts/linux/nginx/server_web_of_nginx/:1:0","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx的Web请求处理机制","uri":"/posts/linux/nginx/server_web_of_nginx/"},{"categories":["服务器"],"content":"并行处理请求的三种方式 web服务器和客户端是一对多的关系，所以web服务器要能同时为多个客户端提供服务。一般有三种方式：多进程方式、多线程方式和异步方式。 多进程方式 服务器每接收到一个客户端时，就由服务器主进程生成一个子进程与该客户端交互 ，直到连接断开，子进程结束。 优点：设计和实现相对简单、子进程之间相互独立，处理客户端请求的过程彼此不干扰，一个有问题不会影响其他的。保证了稳定性。子进程退出时，资源会被系统回收，不会留下垃圾。 缺点：每生成一个子进程，都要进行内存复制的操作，在资源和时间上会有额外的开销。 Apache采用的“预生成进程”可以稍微解决大并发请求，但是本质是多进程，无法解决多并发的问题。 多线程方式 服务器每接收到一个客户端时，会由服务器主进程派生一个线程出来和该客户端进行交互。 优点：产生一个线程的开销要小于一个进程，比较规范，利于协作。 缺点：多个线程在一个内存空间中，彼此互相影响，对内存的管理增加了出错的风险。 异步方式 同步、异步与阻塞、非阻塞 同步和异步描述的是通信模式的概念 同步：发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求。所有的请求在服务器端得到同步，发送方和接收方对请求的处理步调是一致的。 异步：发送方发送请求后，不等待接收方响应这个请求，就继续发送下一个请求。所有来自发送方的请求形成一个队列，接收方处理完后通知发送方。 阻塞和非阻塞描述的是进程处理调用的方式，在网络通信中，主要指的是网络套接字socket的阻塞和非阻塞方式，socket实质上就是IO操作 阻塞：调用结果返回之前，当前的线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU继续执行。 非阻塞：调用结果返回之前，线程不会被挂起，而是立即返回执行下一个周期。 所以共有四种方式： 同步阻塞：发送方发送请求后，一直等待响应；接收方处理请求时不能立即等到结果的时候，就会一直等待返回结果，才响应发送方，期间不能执行任何其他工作。 同步非阻塞：发送方发送请求后，一直等待响应；接收方处理请求时不能立即等到结果的时候，就会立即返回，去做别的事情，但是由于没有得到结果，也不响应发送方，发送方一直等待。 异步阻塞：发送方发送请求后，不等待响应；接收方处理请求时不能立即等到结果的时候，就会一直等待返回结果，才响应发送方，期间不能执行任何其他工作。 异步非阻塞：发送方发送请求后，不等待响应；接收方处理请求时不能立即等到结果的时候，就会立即返回，去做别的事情，但是由于没有得到结果，也不响应发送方，发送方一直等待。 Nginx如何处理请求 Nginx采用的是异步非阻塞的方式。采用Master-work模型（其实实际也有single的单进程模式，但是性能较差，很少使用）。每个工作进程采用异步非阻塞的方式。 Nginx服务器的工作进程调用IO后，就去进行其他工作，当IO调用返回，会通知工作进程。接下来就是怎么通知给工作进程了。 ","date":"2018-01-25","objectID":"/posts/linux/nginx/server_web_of_nginx/:1:1","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx的Web请求处理机制","uri":"/posts/linux/nginx/server_web_of_nginx/"},{"categories":["服务器"],"content":"服务器-Nginx模块化结构 习惯上将Nginx分为：核心模块、标准模块、可选HTTP模块、邮件服务模块和第三方模块五大类。 核心模块 包含对两部分功能的支持： 主体功能：进程管理、权限控制、错误日志记录、配置解析等 用于响应请求必需的功能：事件驱动机制、正则表达式解析等 标准HTTP模块 对应基本的HTTP服务 可选HTTP模块 快速编译中默认不编译，需要使用的话需要自己加上–with-XXX的参数声明。 邮件服务模块 Nginx的主要服务之一，快速编译时也不会编译 第三方模块 ","date":"2018-01-25","objectID":"/posts/linux/nginx/server_structure_of_nginx/:0:1","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx模块化结构","uri":"/posts/linux/nginx/server_structure_of_nginx/"},{"categories":["服务器"],"content":"服务器-Nginx-一个简单的例子 直接贴一个几经磨难的简单的例子吧，虽然简单，但是有些不理解的地方，就出了很多错，但是因为这些错误，在对nginx理解稍微深刻了那么一点点的同时，对Linux的操作好像也有了一点进步啊。才知道为什么大家的命令都那么长，而我总是一步步慢慢的来了，一方面不熟，另一方面确实操作的不够多啊。 配置细节 user mianhk; worker_processes 3; pid /run/nginx.pid; events { use epoll; #worker_connections 768; worker_connections 768; # multi_accept on; } http { ## # Basic Settings ## sendfile on; #tcp_nopush on; #tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## #ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE #ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable \"msie6\"; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## ## 配置虚拟主机1 server { listen 8081; #监听端口 server_name myServer1; access_log var/myweb/server1/log/access_log; #配置日志存放路径 error_page 404 /404.thml; # 错误界面 location /server1/location1 { #配置/server1/location1请求的location root /var/myweb; index index.svr1-loc1.htm; } location /server1/location2 { #配置/server1/location2请求的location root /var/myweb; index index.svr1-locl2.htm; } } server { #配置虚拟主机myServer2 listen 8082; server_name 192.168.1.31; access_log var/myweb/server2/log/access_log; error_page 404 /404.thml; #对错误页面定向 location /server2/location1 { root /var/myweb; index index.svr2-loc1.htm; } location /svr2/loc2 { alias /myweb/server2/location2/; #对location的URI进行更改 index index.svr2-locl2.htm; } location = /404.html { #配置错误页面转向 root /var/myweb; index 404.html; } } #include /etc/nginx/conf.d/*.conf; #include /etc/nginx/sites-enabled/*; } 结果 在浏览器中输入：http://111.230.231.95:8081/server1/location1/ 输入http://111.230.231.95:8082/server2/location1/显示： 出现的问题分析 root目录的位置： 原来root的目录虽然写的是/var/myweb，但是实际发现位置是 在/usr/share/nginx下面，所以需要拷过去，具体这个位置是在哪里设置的，因为已经把所有其他的include都关掉了，所以可能是ubuntu下安装之后的默认目录，就像默认监听的80端口的页面其实在var/www/html下面一样。 导致出了各种莫名其妙的错误啊: root@VM-95-58-ubuntu:/etc/nginx# systemctl status nginx.service ● nginx.service - A high performance web server and a reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) Active: failed (Result: exit-code) since Wed 2018-01-24 22:05:09 CST; 1s ago Process: 32576 ExecStop=/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid (code Process: 21311 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS) Process: 3307 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=1/FAI Main PID: 21314 (code=exited, status=0/SUCCESS) Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: Starting A high performance web server and a reverse proxy server. Jan 24 22:05:09 VM-95-58-ubuntu nginx[3307]: nginx: [emerg] open() \"/usr/share/nginx/var/myweb/server1/log/acc Jan 24 22:05:09 VM-95-58-ubuntu nginx[3307]: nginx: configuration file /etc/nginx/nginx.conf test failed Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: nginx.service: Control process exited, code=exited status=1 Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: Failed to start A high performance web server and a reverse proxy Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: nginx.service: Unit entered failed state. Jan 24 22:05:09 VM-95-58-ubuntu systemd[1]: nginx.service: Failed with result 'exit-code'. 另一个就是关于config文件的格式，一定要仔细写，需要加分号，然后就是最后的/，对于nginx的配置来说，是意义重大的，后面可能会说到这个问题，但是现在还是要写上。 刚刚测试，好像发现这里还有其他的问题，比如我的location2好像打不开啊，尴尬，明天再看看出了什么问题。。 ","date":"2018-01-24","objectID":"/posts/linux/nginx/server_a_simple_sample/:0:1","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx-一个简单的例子","uri":"/posts/linux/nginx/server_a_simple_sample/"},{"categories":["服务器"],"content":"服务器-Nginx基础配置 nginx.conf文件结构 Nginx的默认配置文件为：nginx.conf，文件一共由三个部分组成，分别为：全局块、events块、http块在http块中，包含http全局块，多个server块。在每个server块中，可以包含多个server块和location块。 同一模块中嵌套的配置块。各个之间不存在次序关系，也就是是同时生效的。另外，在高一等级的配置可能会被更内层括号内的设置覆盖，这个其实跟我们的继承或者函数中差不多。 全局块：（从配置文件开始到events的一部分）主要影响Nginx服务器整体运行的配置指令 ，顾名思义，能够作用于全局。 evevts块：主要影响Nginx服务器与用户的网络连接。这部分对Nginx服务器性能影响较大。 http块：代理、缓存和日志定义等绝大部分功能和第三方模块的配置都在这部分。由于http块包括server块，这里用http全局块表示不包含server块的部分。 server块：和“虚拟主机”密切联系。利用虚拟主机技术可以避免为每一个要用运行的网站提供单独的Nginx服务器，也不需要为每个网站对应一组nginx进程。一个http块中可以包含多个server块，每个server块相当于一个虚拟主机，它内部可以有多台主机联合提供服务，一起对外提供在逻辑上的一组服务（或网站）。server全局块一般配置的是：虚拟主机的监听配置和本虚拟主机的名称和IP配置。 location块：location块其实是server块的一个指令，主要作用是：基于Nginx服务器接收到的字符串，对除虚拟主机名称外的字符串进行匹配，对特定的请求进行处理、地址定向、数据缓存和应答控制等功能。 详细配置分析 接下来是一个详细解释的配置的设置 #全局块开始 user user [group]; #可以开启nginx服务的用户名user和所对应的group（可选） #user nobody nobody; #注释或者nobody可以表示任何人都能启动 worker_processes number|auto; #开启的工作进程的数量，auto则会根据系统自动 pid /run/nginx.pid; #存储进程pid的文件，记得不止要加上路径，还要加上文件名，并且开启服务的用户需要对该文件有权限 events { #events块 worker_connections 768; #每一个工作进程能开启的最大连接个数：总的连接个数total=worker_processes*worker_connections # accept_mutex on; #设置网络连接的序列化，解决“惊群”的问题（当一个网络连接到来时，多个睡眠进程被唤醒，影响系统性能） # multi_accept on; #允许接受多个网络连接 #use method; #时间驱动模型的选择:select|poll|kqueue|epoll|rtsig|/dev/poll|eventport } http { #http块 ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; #连接超时时间 #keepalive_requests number; #单连接请求数上限 types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; #MIME-types存储了媒体资源的类型 default_type application/octet-stream; #处理前端请求的MIME类型，可在http、server、location中定义 ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; # 日志存放文件名，该指令可以在全局块、http块和server块中，作用域不同 error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable \"msie6\"; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; # include 引入配置文件，支持相对路径 include /etc/nginx/sites-enabled/*; } ","date":"2018-01-24","objectID":"/posts/linux/nginx/server_simple_of_nginx/:0:1","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx基础配置","uri":"/posts/linux/nginx/server_simple_of_nginx/"},{"categories":["服务器"],"content":"服务器-Nginx安装和基本配置 Nginx的安装 没有看书上，直接在ubuntu输了一个nginx，大概是ubuntu的支持比较好，直接提醒可以安装，于是就毫不客气的装了一下就启动了： sudo apt-get install nginx sudo /etc/init.d/nginx start 接下来直接在浏览器里面打开，就能看到hello,Nginx这样欣慰 的界面了。 之后能够在文件夹/etc中看到我们的配置的文件： 在var/www/html文件夹中能看到index.html文件，即是我们的主页文件。 **这里没有采用源码的方式安装，其实是觉得没有必要了。 ** Nginx的启停 刚刚已经直接开启了Nginx了，其实关就更简单了。 sudo /etc/init.d/nginx stop #停止nginx sudo /etc/init.d/nginx restart # 重启nginx 这里需要注意的是nginx的平滑重启：Nginx服务进程接受到信号后，首先读取新的Nginx的配置文件，如果新的配置文件语法正确，则启动新的Nginx服务，然后平缓的关闭旧的服务进程。否则，仍然使用旧的Nginx进程提供服务。 Nginx服务器的升级 平滑升级：Nginx服务接收到USR2信号后，首先将旧的nginx.pid文件（如果配置文件中更改过名字，也是相同的过程）添加后缀.oldbin，变为nginx.pid.oldbin文件；之后执行新版本Nginx服务器的二进制文件启动服务。如果新的服务启动成功，系统中将有新旧两个Nginx服务共同提供Web服务。之后，需要像旧的Nginx服务进程发送WINCH信号，使旧的Nginx服务平滑停止，并删除nginx.pid.oldbin文件。在发送WINCH信号之前，可以随时停止新的Nginx服务。 ","date":"2018-01-23","objectID":"/posts/linux/nginx/server_first_of_nginx/:0:1","tags":["后台开发","Linux","Nginx"],"title":"服务器-Nginx安装和基本配置","uri":"/posts/linux/nginx/server_first_of_nginx/"},{"categories":["服务器"],"content":"初识Nginx Nginx的历史 Netcraft公司，1994年在英国成立。 常见服务器 Apache服务器：目前最广泛使用的web服务器，由于使用了以“进程”为基础的结构，会消耗更多的系统开支。因此通常对Apache web进行扩容的时候，是增加服务器或者扩充集群节点而不是增加处理器。 Microsoft IIS：微软的，付费软件，部署成本较高。 Tomcat服务器：最初Sun公司开发，是官方推荐的Servlet和JSP容器，在中小型系统和并发访问用户不是很多的时候，可以作为轻量级应用服务器。一般应用中，通常作为Apache服务器的扩展部分，为运行JSP页面和Servlet提供服务，提供的Servlet容器是Tomcat的默认模式。Tomcat也具有处理HTML页面的功能，只是处理静态页面的能力不如Apache服务器。 Lighttpd服务器：德国开源的一个轻量级web服务器，它专门针对高性能网站，提供一种安全、快速、兼容性良好并且灵活的Web Server的环境。同时有非常低的内存开销、CPU占用率低、模块丰富。 但是最为轻量服务器，与Apache这种大型服务器相比还有差距。 Nginx Nginx的功能特性 基本的HTTP服务： 作为HTTP代理服务器和反向代理服务器 支持通过缓存加速访问 完成简单的负载均衡和容错 支持包过滤 支持SSL 高级HTTP服务： 进行自定义配置 支持虚拟主机 支持URL重定向 支持网络监控 支持流媒体传输 邮件服务： 支持IMAP/POP3代理服务 支持内部SMTP代理服务 常用功能 HTTP代理和反向代理 在反向代理服务方面，Nginx服务器转发前端请求性能稳定，并且后端转发与业务配置相互分离，配置相当灵活。 负载均衡 负载均衡：一是将单一的重负载分担到多个网络节点做并行处理，每个节点处理结束后将结果汇总返回给用户；二是讲大量的前端并发访问或数据流量分担到多个后端网络节点上分别处理，有效减少前端用户等待响应的时间。Nginx服务器的负载均衡主要是对大量的前端访问和流量进行分流，以保证前端用户的访问效率。 Nginx服务器的负载均衡策略可以划分为两类： 内置策略：轮询、加权轮询和IP hash 扩展策略：通过第三方模块实现，常见：url hash、fair Web缓存 ","date":"2018-01-23","objectID":"/posts/linux/nginx/server_learn_nginx/:0:1","tags":["后台开发","Linux","Nginx"],"title":"服务器-初识Nginx","uri":"/posts/linux/nginx/server_learn_nginx/"},{"categories":["工具"],"content":"腾讯云服务器Linux挖比特币 毕竟又是一个周五的下午，有点等着放假，就想起来现在的挖矿，虽然现在挖矿都是专门的矿机或者是显卡之类的。但是经过计算，好像自己挖的话连电费都不够，就想试试云服务器可不可以，虽然CPU做这种傻瓜的计算问题可能不如专门的器件是吧。 这是我的ubuntu服务器的。 注册一个矿池账号，推荐https://www.f2pool.com/ 通过ssh连接远程服务器 下载挖矿工具 这里别人推荐的地址可能有问题，或者我这个之后也会升级，所以可以直接去官网下载最新的推荐的版本就行。 wget http://downloads.sourceforge.net/project/cpuminer/pooler-cpuminer-2.5.0-linux-x86_64.tar.gz 解压 tar xvzf ooler-cpuminer-2.5.0-linux-x86_64.tar.gz nohup命令后台一直运行 注意：不同的端口对应不同的币，一个用户名可以在后面例如：mianhk.001，mianhk.002代表不同的矿机。userpass后面是账户名和密码 # 以下不同的地址对应的是不同的矿 nohup ./minerd -a scrypt -o stratum+tcp://stratum.f2pool.com:3333 --userpass=账号:密码 \u0026 nohup ./minerd -a scrypt -o stratum+tcp://xmr.f2pool.com:13531 --userpass=账号:密码 \u0026 nohup ./minerd -a scrypt -o stratum+tcp://zec.f2pool.com:3357 --userpass=账号:密码 \u0026 之后，就可以打开日志文件看到在挖矿了。我们还需要在网站填上自己的比特币钱包地址。但是这个挖的数目确实有点小啊 之后打开腾讯云服务器可以看到CPU已经跑满了啊。 然后之后就看到网上说云服务器跑的太满的话，会被封的，那就把CPU限制一下吧。 步骤如下： sudo apt-get install cpulimit top # 查看pid cpulimit -p pid -l n # n是限制的值 下面是centos的，因为有两台服务器，但是centos放的是vpn，平时还没装过软件呢 yum install epel-release yum install cpulimit top # 查看pid cpulimit -p pid -l n # n是限制的值 限制之后，就能明显的看到CPU占用没有满了： 哈哈，就当玩玩吧，多了解一下区块链，总得跟上节奏吧，虽然已经有点晚了的样子 ","date":"2018-01-19","objectID":"/posts/tools/tencentcloud_bitcoin/:0:1","tags":["工具"],"title":"腾讯云服务器Linux挖比特币","uri":"/posts/tools/tencentcloud_bitcoin/"},{"categories":["刷题"],"content":"LeetCode-36-Valid-Sudoku Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. 判断一个二维数组是不是数独数组。要求是：同行同列，斜对角不能有相同的数组，这里需要定义三个数组，当然参考了一下讨论区一个大神的代码。采用行列，竖列和斜列。其中比较惊艳的是k=i/3*3+j/3;这里可以直接得到斜对角的元素。 class Solution { public: bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) { int used1[9][9]={0},used2[9][9]={0},used3[9][9]={0}; for(int i=0;i\u003cboard.size();++i){ for(int j=0;j\u003cboard[i].size();++j){ if(board[i][j]!='.'){ int num=board[i][j]-'0'-1,k=i/3*3+j/3; if(used1[i][num]||used2[j][num]||used3[k][num]) return false; used1[i][num]=used2[j][num]=used3[k][num]=1; } } } return true; } }; reference: https://blog.csdn.net/u012050154/article/details/51541380 ","date":"2018-01-14","objectID":"/posts/algorithm/leetcode-36-valid-sudoku/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-36-Valid-Sudoku","uri":"/posts/algorithm/leetcode-36-valid-sudoku/"},{"categories":["刷题"],"content":"LeetCode-34-Search-for-a-Range Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. 在一个排序的数组中找到出现这个值的起点和重点。很容易想到的是二分查找了。复杂度为nlog(n)。思路如下，先二分查找，找到下界，如果下界lo的值不等于target时，直接返回{-1，-1}，否则，直接将下界添加到res中。之后重置上界，同样的方法搜索上界。注意到，由于每次循环中，我们只考虑了一个界，所以只有一个界能mid+1，否则就会出现相等的也被else处理了。写的时候就是这个问题没有考虑好，折腾了很久。 class Solution { public: vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cint\u003e res={-1,-1}; if(nums.size()\u003c=0) return res; int lo=0,hi=nums.size()-1; while(lo\u003chi){ //找下界 int mid=(lo+hi)/2; if(nums[mid]\u003ctarget) lo=mid+1; else hi=mid; } if((nums[lo]!=target)){ return res; } else res[0]=lo; hi=nums.size()-1; while(lo\u003chi){ //找上界 int mid=(lo+hi)/2+1; if(nums[mid]\u003etarget) hi=mid-1; else lo=mid; } res[1]=hi; return res; } }; 当然还看到有用stl的方法的，直接用lower_bound()和upper_bound()函数，速度要快一些。虽然觉得stl应该也是一样的原理写的吧。。 class Solution { public: vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) { if (nums.empty()) return{ -1, -1 }; auto iter1 = lower_bound(nums.begin(), nums.end(), target); auto iter2 = upper_bound(nums.begin(), nums.end(), target); if (iter1 == nums.end()) return{ -1, -1 }; if ((*iter1) != target) return{ -1, -1 }; vector\u003cint\u003e tmp(2, 0); tmp[0] = iter1 - nums.begin(); --iter2; tmp[1] = iter2 - nums.begin(); return tmp; } }; ","date":"2018-01-14","objectID":"/posts/algorithm/leetcode-34-search-for-a-range/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-34-Search-for-a-Range","uri":"/posts/algorithm/leetcode-34-search-for-a-range/"},{"categories":["刷题"],"content":"LeetCode-32-Longest-Valid-Parentheses Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. For “(()”, the longest valid parentheses substring is “()”, which has length = 2. Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4. 表示这是一道没有看懂题目的题，看到题目的难度是hard，但是自己的想法很简答，以为直接一个栈就可以了。。 too young啊 提交之后才知道，原来还要解决类似()((()))这类问题，所以这是一个动态规划的问题啊。 昨天看了一下动态规划，我们首先要构建D数组，如下所示的vector longest，负责存下当前第i个的长度。需要考虑的情况如下。 只有当s[i]为)时，才需要判断，如果它的左边是(或者)的情况。 代码如下： class Solution { public: int longestValidParentheses(string s) { if(s.length()\u003c=1) return 0; vector\u003cint \u003e longest(s.size(),0); int curMax=0; for(int i=1;i\u003cs.length();++i){ if(s[i]==')'){ if(s[i-1]=='('){ longest[i]=(i-2\u003e=0?(longest[i-2]+2):2); curMax=curMax\u003elongest[i]?curMax:longest[i]; } else { if(i-longest[i-1]-1\u003e=0\u0026\u0026s[i-longest[i-1]-1]=='('){ longest[i]=longest[i-1]+2+((i-longest[i-1]-2\u003e=0)?longest[i-longest[i-1]-2]:0); curMax=curMax\u003elongest[i]?curMax:longest[i]; } } } } return curMax; } }; ","date":"2018-01-12","objectID":"/posts/algorithm/leetcode-32-longest-valid-parentheses/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-32-Longest-Valid-Parentheses","uri":"/posts/algorithm/leetcode-32-longest-valid-parentheses/"},{"categories":["刷题"],"content":"LeetCode-31-Next-Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. 这个排序主要是有两种情况，一个是类似于3 1 2 这样的情况，直接从后往前找到第一个nums[i]\u003cnums[i-1]的，然后把i记下来，再与后面第一个小于i的k调换顺序之后，对i后面的进行反转排序就好了。 另一种情况是：已经反转成功了，类似3 2 1，需要直接置为最开始的状态，处理方式是，依旧从后往前找i,如果没有找到的话，就可以直接将序列反转即可。 代码如下： class Solution { public: void nextPermutation(vector\u003cint\u003e\u0026 nums) { int k=-1; for(int i=nums.size()-2;i\u003e=0;--i){ if(nums[i]\u003cnums[i+1]){ k=i; break; } } if(k==-1){ reverse(nums.begin(),nums.end()); return; } int l=0; for(int i=nums.size()-1;i\u003ek;--i){ if(nums[i]\u003enums[k]){ l=i; break; } } swap(nums[l],nums[k]); reverse(nums.begin()+k+1,nums.end()); } }; ","date":"2018-01-12","objectID":"/posts/algorithm/leetcode-31-next-permutation/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-31-Next-Permutation","uri":"/posts/algorithm/leetcode-31-next-permutation/"},{"categories":["刷题"],"content":" Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-\u003e2-\u003e3-\u003e4-\u003e5, and n = 2. After removing the second node from the end, the linked list becomes 1-\u003e2-\u003e3-\u003e5. 这个题目之前在剑指offer上就有，记得当时的方法是：采用两个指针，首先判断n的大小是否比链表的长度要大，大的话直接返回。否则采用一前一后两个指针，两个指针相差n，当前面的指针到链表末尾时，后面的指针所在的位置就是要删除的位置了。 当然，这是个很好的方法，不过看了一下后面的答案，以及前天看到的一个有点不是很明白的一个答案，才知道大家都用的是二级指针，二级指针的好处是，可以直接记住链表的头节点，而不至于总是去判断。这样显得对指针的理解就不一样了。可以看看下面的这篇文章。 Linus：利用二级指针删除单向链表 下面是代码： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode **t1=\u0026head,*t2=head; //这样head一直指向的是头节点 for(int i=0;i\u003cn;++i){ t2=t2-\u003enext; } while(t2!=nullptr){ t1=\u0026((*t1)-\u003enext); t2=t2-\u003enext; } *t1=(*t1)-\u003enext; //删除找到的节点 return head; } }; 无奈每次提交总是有群禽兽比我的快那么多啊，我的12ms，别人的6ms。。 不过别人的代码一看好像也还好，思路都是差不多的，就是一些细节的地方注意的比较好，看来还得好好弄啊。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { int counter = 0; if(!head || !n) { return head; } ListNode *p = head; ListNode **pp = \u0026head; while(p \u0026\u0026 n) { p = p-\u003enext; n--; } while(p) { p = p-\u003enext; pp = \u0026((*pp)-\u003enext); } ListNode *temp = *pp; *pp = temp-\u003enext; delete(temp); return head; } }; ","date":"2018-01-12","objectID":"/posts/algorithm/leetcode-19-remove-nth-node-from-end-of-list/:0:0","tags":["C++","LeetCode"],"title":"LeetCode-19-Remove-Nth-Node-From-End-of-List","uri":"/posts/algorithm/leetcode-19-remove-nth-node-from-end-of-list/"},{"categories":["刷题"],"content":"23. Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 这个题乍一看只是对链表的一个排序，因为是很多个链表，所以很简单的想法就是将整个数组里面的两个链表分别进行排序。两个两个互相排序之后就能排好。这里用的是递归。当vector中的元素大于1说明还没有排完。 直接一下就AC了，但是一看detail，果然时间有点长。运行时间内93ms，看到别人的只需要20+。。 还是先记一下自己的代码 吧。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* merge2List(ListNode* lList,ListNode* rList){ if(lList==nullptr) return rList; if(rList==nullptr) return lList; if(lList-\u003eval\u003crList-\u003eval){ lList-\u003enext=merge2List(lList-\u003enext,rList); return lList; } else{ rList-\u003enext=merge2List(lList,rList-\u003enext); return rList; } } ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { if(lists.size()==0) return nullptr; while(lists.size()\u003e1){ lists.push_back(merge2List(lists[0],lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); } return lists[0]; } }; 看了一下别人的代码，用了优先队列，进行排序，没有重新写了。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { class Cmp { public: bool operator() (ListNode *a, ListNode *b) const { return a-\u003eval \u003e b-\u003eval; } }; public: ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { priority_queue\u003cListNode *, vector\u003cListNode *\u003e, Cmp\u003e pq; ListNode *head = NULL; ListNode *cur = NULL; int k = lists.size(); if(k == 0) { return NULL; } for(ListNode *list: lists) { if(list != NULL) { pq.push(list); } } while( !pq.empty() ) { ListNode *next = pq.top(); pq.pop(); if(next-\u003enext != NULL) { pq.push(next-\u003enext); } next-\u003enext = NULL; if(head == NULL) { head = next; cur = head; } else { cur-\u003enext = next; cur = cur-\u003enext; } } return head; } }; ","date":"2018-01-11","objectID":"/posts/algorithm/leetcode-23-merge-k-sorted-lists/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-23-Merge-k-Sorted-Lists","uri":"/posts/algorithm/leetcode-23-merge-k-sorted-lists/"},{"categories":["刷题"],"content":"15. 3Sum Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 同之前的2sum差不多，计算两个的和的方式是：为了避免重复，重新用一个set容器，解决重复的问题。但是这里的情况是，重复的一个数字是可以出现的，而且是三个数字相加的和，所以我们没法用之前的处理办法。 很容易想到的办法是，先让一个指针向前走，然后对之后的数字搜索，为了减少搜索的复杂度，我们可以先将数组进行排序，先排序后搜索，可以从O(n^2)的复杂度减小到nlog(n)，所以采用先排序。 然而这里需要注意的是，需要判断数组中有相同数字的情况。虽然结果中允许有相同的数字出现，但不允许出现完全相同的两个结果，所以需要处理这种情况。 具体的代码如下： class Solution { public: vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) { vector\u003cvector\u003cint\u003e\u003e res; if(nums.size()\u003c=0) return res; sort(nums.begin(),nums.end()); for(int i=0;i\u003cnums.size()\u0026\u0026nums[i]\u003c=0;++i){ int j=i+1,k=nums.size()-1; while(j\u003ck){ if(nums[i]+nums[j]+nums[k]\u003c0) j++; else if(nums[i]+nums[j]+nums[k]\u003e0) --k; else if(nums[i]+nums[j]+nums[k]==0){ vector\u003cint\u003e temp(3,0); temp[0]=nums[i]; temp[1]=nums[j]; temp[2]=nums[k]; res.push_back(temp); while(k\u003ej\u0026\u0026nums[k]==temp[2]) //去除k的重复 k--; while(k\u003ej\u0026\u0026nums[j]==temp[1]) //去除j的重复 j++; } } while(i+1\u003cnums.size()\u0026\u0026nums[i+1]==nums[i]) //去除i的重复 i++; } return res; } }; ","date":"2018-01-10","objectID":"/posts/algorithm/leetcode-15-3sum/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-15-3Sum\u0026\u00264Sum","uri":"/posts/algorithm/leetcode-15-3sum/"},{"categories":["刷题"],"content":"18. 4Sum Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. **Note **: The solution set must not contain duplicate quadruplets. 其实跟前面的3sum解决的办法是一样的，无非这里为了减少一点复杂度，借用了一下大家使用的方法。，在每次遍历的时候进行一点判断，以减少循环的次数。代码如下： class Solution { public: vector\u003cvector\u003cint\u003e\u003e fourSum(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cvector\u003cint\u003e\u003e res; int n=nums.size(); if(n\u003c4) return res; sort(nums.begin(),nums.end()); for(int i=0;i\u003cn-3;++i){ if(i\u003e0\u0026\u0026nums[i]==nums[i-1]) continue; if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]\u003etarget) break; if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3]\u003ctarget) continue; for(int j=i+1;j\u003cnums.size()-2;++j){ if(j\u003ei+1\u0026\u0026nums[j]==nums[j-1]) continue; if(nums[i]+nums[j]+nums[j+1]+nums[j+2]\u003etarget) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]\u003ctarget) continue; int begin=j+1,end=n-1; while(begin\u003cend){ int sum=nums[i]+nums[j]+nums[begin]+nums[end]; if(sum\u003etarget) --end; else if(sum\u003ctarget) ++begin; if(sum==target){ vector\u003cint\u003e temp(4,0); temp[0]=nums[i]; temp[1]=nums[j]; temp[2]=nums[begin]; temp[3]=nums[end]; res.push_back(temp); while(begin\u003cend\u0026\u0026temp[2]==nums[begin]) ++begin; while(begin\u003cend\u0026\u0026temp[3]==nums[end]) --end; } } } } return res; } }; ","date":"2018-01-10","objectID":"/posts/algorithm/leetcode-15-3sum/:0:2","tags":["C++","LeetCode"],"title":"LeetCode-15-3Sum\u0026\u00264Sum","uri":"/posts/algorithm/leetcode-15-3sum/"},{"categories":["刷题"],"content":"8.String to Integer (atoi) Implement atoi to convert a string to an integer. 讲字符串转化为整型。当然过程很简单，但是需要考虑的乱七八糟的情况很多，空格和正负号之类的。提交了一百次，终于过了，但是看到别人的代码还是很气呀，还是得多写才行，但是起码写的慢慢有感觉了是吧。 总体思路基本都是差不多的： 1.循环字符串，从第一个开始不为空的字符开始判断，如果是正负号，则只能有一个正负号，进行标记，数字开始。 2.数字开始之后，出现空格或者字母，返回已经生成的整型。 3.当数字大于最大的整数或者小于最小的整数的时候，应该将其置为最大或者最小。所以这里应该将结果定义为long long int ，不然当加到INT_MAX的时候，会自动+1，置为INT_MIN，应该避免这样的情况。 这里贴一下自己改的乱七八糟的代码吧，实在很气呀。 class Solution { public: int myAtoi(string str) { int flag=1; long long int res=0; int begin=-1; for(int i=0;i\u003cstr.size();++i){ if(str[i]=='-'||str[i]=='+'){ if(begin!=-1) return 0; begin=i; flag=str[i]=='-'?-1:1; } else if(str[i]\u003e='0'\u0026\u0026str[i]\u003c='9'){ begin=i; res=res*10+str[i]-48; if(res*flag\u003eINT_MAX) return INT_MAX; if(res*flag\u003cINT_MIN) return INT_MIN; } else if(str[i]==' '){ if(begin!=-1) return res*flag; } else return res*flag; } return res*flag; } }; 提交一看，这个时间还有点问题，就懒得自己再改了，思路都是一样的吧，就直接贴过来学习一下了，即使我觉得写的也一般呀。。 class Solution { public: int myAtoi(string str) { int i = 0; long long res = 0; if(str.size() == 0) return res; while(i \u003c str.size() \u0026\u0026 str[i] == ' ') i++; int flag = 1; if(str[i] == '+') i++; else if(str[i] == '-') { flag = -1; i++; } while(str[i] \u003e= '0' \u0026\u0026 str[i] \u003c= '9') { res = res * 10 + str[i] - '0'; i++; if(res * flag \u003e= INT_MAX) return INT_MAX; if(res * flag \u003c= INT_MIN) return INT_MIN; } return res * flag; } }; ","date":"2018-01-09","objectID":"/posts/algorithm/leetcode-8-string-to-integer-atoi/:0:1","tags":["C++","LeetCode"],"title":"LeetCode-8-String to Integer (atoi)","uri":"/posts/algorithm/leetcode-8-string-to-integer-atoi/"},{"categories":["生活"],"content":"好像从小的时候开始，拥有各种感兴趣的事情或者不只是好好学习就像一种美德一样充斥于我们与同龄人的自己的生活中。就像小时候打的弹珠和后面看的小说乒乓球和dota一样。哦，对，应该说是合群，或者是接地气，就是所有与同龄人正常社交所需的娱乐活动吧。所以作为一个老师口中活泼开朗的学生，这些我基本都有，可能玩的不一定好，但是so what，只要不是像“那些只爱学习的同学”一样，好像都够了。 于是，也不知道什么时候就慢慢形成了广泛的娱乐活动了。直到现在，想起自己好像啥都能参与，就像篮球里能够从1打到5的那种全能型选手，不一定有机会上场，但总是差不多合格一样。 想一下现在自己的娱乐： 打球？篮球、羽毛球、乒乓球，都可以打一些。虽然现在打篮球确实少了很多了，一个是宿舍就我一个人去，这样就很多时候懒得去了。羽毛球呢，总觉得要是四个人比较好，但是又对天气有些要求。还有乒乓球，需要有个水平不是很厉害还愿意跟我 打的了。。。 打麻将？这个简直是好约啊，四个人可以动脑或者不动脑的室内活动，主动或者三缺一的要求，都是相当的容易，这种活动还一般安排在吃饭的后边，就像你有时候也没法拒绝吃饱之后某个茶楼的茶一样，因为即使回去也还是睡觉是吧，而且自己总是告诉自己不要把生命浪费在床上。 各种吃饭？是的，忘了多少个睡到十点的周末，大家在一边互相催着起床一边讨论中午吃什么，于是由简单的黄焖鸡变成了鸡公煲，自助、火锅。。然后就是一个白天很快就过去了。 打游戏？简直是不可或缺的一部分啊。好像之前一年已经很少玩了。直到暑假开始玩的一个垃圾手游，轩辕传奇，几乎每天要花一个多小时的时间吧，想了一下，占据了我基本每天吃完午饭到睡觉之前和晚上回到宿舍到上床的一段时间。这段时间本来就不是很长，但是却被我用的看起来更紧张了。还有偶尔同学们约的王者荣耀，我基本自己都没有打过。还有最近的荒野行动，也是周末晚上或者正好十点多的上午才会有的娱乐。 看书？当然，我还是愿意把这个算进去。毕竟看的一些闲书，不能说没用，但确实是一种娱乐了吧。占据了上床到睡觉之前的不玩手机的时间，这个时间可能更短了。 然后，实验室玩手机？这个就不多说了，想想每天的手机电量吧。 乱七八糟的折腾？额，年轻的特征吗。。没意思的东西还是少弄点了吧 这样看的话其实生活好像也很正常的，但是却是感觉每天，或者周末都很忙，忙了还不知道自己干了啥。有些难受。而且这好像也是自己写的第二篇这种苦恼了，上一次也是觉得这样的周末，但是两周过去了，好像还没有好多少，可能周末确实适合这么过，但是显然不是现在。 接下来需要做的，就是精简生活了，不是什么活动都需要参加的是吧，也不是什么都需要自己关注的是吧，也不用总是活在一个中心。** 先专注做好自己现在该做的事情，或者先想想？** ","date":"2017-12-10","objectID":"/posts/daily/cut-life/:0:0","tags":["杂想","记录"],"title":"精剪生活","uri":"/posts/daily/cut-life/"},{"categories":["刷题"],"content":"T31：把数组排成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 这里想到的是，要对数组里面的所有数进行一个排序：不只是排长度，还要排最高位的大小。于是可以通过c++的STL的排序，通过自己定义的一个谓语比较函数。在这个比较函数里，把整数转成string进行比较，但是想到string的长度不一样的话也没法比较字符的大小了。所以分别将两个数加在一起，前后顺序不同，这样string的长度就一样了，比较的就是顺序了。 代码如下： class Solution { public: string PrintMinNumber(vector\u003cint\u003e numbers) { string result; sort(numbers.begin(),numbers.end(),cmp); for(int i=0;i!=numbers.size();++i){ result+=to_string(numbers[i]); } return result; } static bool cmp(int a,int b){ string A=to_string(a)+to_string(b); string B=to_string(b)+to_string(a); return A\u003cB; } }; T32：丑数 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 要求出第N个丑数，显然就要求到这N个，所以就要把所有的找出来嘛。简单的办法，就是2,3，5的倍数，但是这些倍数出来的丑数的顺序，这时候需要排序。显然不能直接对所有的都排序，那复杂度就太大了。这里一种考虑就是：比如，对于一次倍数的计算，如果2的倍数比原来的都大，那么3和5的倍数显然只会更大了。所以可以通过记录下此时分别为2,3,5倍数三个值，这样就可以减少比较的次数了。 代码如下： class Solution { public: int GetUglyNumber_Solution(int index) { if(index==0) return 0; //解决边界条件 vector\u003cint\u003e result(index); result[0]=1; int x=0,y=0,z=0,i; for(i=1;i\u003cindex;i++){ result[i]=min(result[x]*2,min(result[y]*3,result[z]*5)); if(result[i]==result[x]*2) x++; if(result[i]==result[y]*3) y++; if(result[i]==result[z]*5) z++; } return result[index-1]; } }; T33：第一个只出现一次的字符 在一个字符串(1\u003c=字符串长度\u003c=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置 很容易想到的一种复杂度为O(n)的算法是采用哈希表，遍历一次，将出现的字符放在键中，出现一次即在值中加1。第二次遍历，直接查找该键对应的值，第一个为1的输出即可。当然，这里由于是字符，所以可以直接采用数组的形式。** 一定要记得对数组进行初始化** class Solution { public: int FirstNotRepeatingChar(string str) { if(str.size()==0) return -1; //处理边界条件 int res[256]={0}; //局部变量，一定要初始化啊 int i=0; for(;i!=str.size();++i){ res[(int)str[i]]++; } for(i=0;i!=str.size();++i){ if(res[(int)str[i]]==1) return i; } return str.size(); } }; ","date":"2017-12-03","objectID":"/posts/algorithm/nowcoder-sword-to-offer11/:0:0","tags":["C++","剑指offer","牛客网"],"title":"牛客网-剑指offer-11","uri":"/posts/algorithm/nowcoder-sword-to-offer11/"},{"categories":["刷题"],"content":"T28：最小的K个数 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解法一：剑指offer上给的有两种办法，一种是对数组进行排序，类似于快速排序的方式，假设基于第k个数来调整，就可以将比k小的数全放在左边，比k大的数都放在右边，于是，最后k左边的数即为最小的k个数。 优点：平均时间复杂度：O(n)，思路较快 缺点：需要修改数组 解法二：算法复杂度O(nlogk)，适合海量的数据。需要我们一个能存储k个数的容器，当容器中的数不足k个的时候，直接装进容器，当超过的时候，需要拿容器中最大的数与新的数进行比较，新数小的时候，替换已有的最大。如此，每一个新的数都需要判断，这样会增加复杂度，但是在海量数据处理的时候比较适合，因为无法一次把所有的数据都载入内存。 下面是解法二的代码：（没有采用multiset，直接用的vector排序的，原理一样，但是我的stl确实没有用好，下次再改吧） class Solution { public: vector\u003cint\u003e GetLeastNumbers_Solution(vector\u003cint\u003e input, int k) { //没有考虑复杂度的情况，都是直接写的 vector\u003cint\u003e result; //判断输入为空，或者k大于input的个数的情况 if(input.size()\u003c=0||k==0||k\u003einput.size()) return result; vector\u003cint\u003e::iterator iter=input.begin(); for(;iter!=input.end();++iter){ sort(result.begin(),result.end()); if(result.size()\u003ck) result.push_back(*iter); else if(*iter\u003c*(result.end()-1)){ result.pop_back(); result.push_back(*iter); } } return result; } }; T29：连续子数组的最大和 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 主要是想为什么会有最大的和，一个情况是，新加上的数比原来的数都要大，就要开始考虑需不需要原来的数了。所以我们需要两个数，一个保存最大的和，用来返回，一个 保存当前的和，可以在适当的时候丢掉。 另一种情况，加入的数都比原来的小，即都是负数的时候，可能最大和只是一个最小的数；另外，当都是正数的时候也比较好解决。 代码如下： class Solution { public: int FindGreatestSumOfSubArray(vector\u003cint\u003e array) { if(array.size()==0) return 0; int curSum=array[0];//注意这里不能用0，因为会出现数组值全小于0的情况 int maxSum=array[0]; for(int i=1;i!=array.size();++i){ curSum+=array[i]; if(curSum\u003carray[i]) curSum=array[i]; if(maxSum\u003ccurSum) maxSum=curSum; } return maxSum; } }; T30:整数中1出现的个数(从1到n整数中1出现的个数) 题目描述：求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数 显然，最简单的思路，从1遍历到n是吧，因为要找到每个数中1的个数。先不说这个，问题的重点是，这个1的个数怎么找。 于是想到的是关于1存在的规律。比如很简单的就个位数而言，从0–9，只会出现一个1。由此想到，我们可以把n分成很多段进行计算。具体怎么分段，《剑指offer》上有个方法，不过确实有点难看明白了，就没有看，自己觉得可以按照从按10的倍数来分，1,10,100之类的，不过又有点问题，每个段内1的个数不一样，因为这样的话1的个数就不好算了。不过牛客网厉害的还是多啊，思路清晰，代码简洁。自己真的需要学习的有点多。不过后来又回头看了一下《剑指offer》上其实也是这样的。 那就直接复述一遍具体的思路吧：根据设定的整数位置，对n进行分割。这里就直接选10了，高位是a=n/10，低位是b=n%10，循环条件直接就是n*10了，这样就可以从最后一位到最高位的遍历了。 这里需要考虑的就是，a的最后一位，就是高位对应的最低位。 当i表示百位，且百位对应的数\u003e=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1。 当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1。 当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）。 代码如下： class Solution { public: int NumberOf1Between1AndN_Solution(int n) { int count=0; //n=1的情况 if(n==1) return 1; //考虑的边界情况，n=10,100,1000之类的，同时循环中没有考虑n=0的情况 if(n\u003e1\u0026\u0026n%10==0) count++; //没有考虑n=1的情况 for(int i=1;i\u003cn;i*=10){ int a=n/i,b=n%i; //补8的效果：当百位为0，则a/10==(a+8)/10， //当百位\u003e=2，补8会产生进位位，效果等同于(a/10+1) count+=(a+8)/10*i+(a%10==1)*(b+1); } return count; } }; ","date":"2017-12-01","objectID":"/posts/algorithm/nowcoder-sword-to-offer10/:0:0","tags":["C++","剑指offer","牛客网"],"title":"牛客网-剑指offer-10","uri":"/posts/algorithm/nowcoder-sword-to-offer10/"},{"categories":["生活"],"content":"2017-11-26 记录一个可能很熟悉的周末 这周又过去了，时间依旧是这么快啊，待在实验室跟上一周的感觉差不多，还是周日的下午，晚上才想起来来一下实验室，还是本来想周末搞个学习，却还是没有一不小心就休息过去了，非常单纯的尊重了一下周末。 先记个心里活动加流水吧，很无聊，但是还是想写一下，看一下自己的周末重播是怎样的。。 本来周五晚上就没有睡很晚，所以生物钟还是个好东西，一到周末就提醒我不要起的太早，于是醒 来还是十点多了，躺在床上玩了一会游戏觉得有点罪过，就起床搞搞学习，嗯，十点多，算是个相 对还不错的时间了，如果不是上周立了flag说是周末要学习一天的话，即使以前的我好像可以不分 周末一样。 没错，起床了就学习啊，还是先看一下游戏吧，刚刚打开就看到有人说，游戏现在可以电脑端挂着 了，一想，这样就不用耽误我时间看平板了，直接电脑上从代码切过来很快的样子，毕竟这么多年 的单身。于是开始准备下。想一下，这个流量。。赶紧查一查，还有一个多G，，算一下还有几天， 今天才25，好像有点不够呀，还是不下了吧。不过仔细一想，下一个电脑端，多省事啊，毕竟我不 是一个轻易被困难打倒的人，于是看了一下手机，还有3G流量，好像也有点不够用了啊。又想起来 上个月月末的两个活动送的2G流量，看看能不能，于是赶紧一顿操作，我靠，竟然还有啊。只能不 好意思安心开始下游戏了。 哇，搞学习的时间终于开始了啊，额，这个宿舍环境，好像更适合看视频一点，打开教学视频，习 惯的1.5倍速，连上云服务器，先操作一顿，看看上周用的vim的操作忘了没有。然后切到视频，额 ，这讲的也太慢了吧，完全不把我的基础当回事啊，这也讲。。 算了，切一下看看游戏下的怎么样 了，19%，才这么点啊。切回去，切过来，25%，再切过来，咦，怎么不动了，难道热点断了，看一 下手机，额，没有啊，==看，额，怎么错误了，怎么说。切回去把视频停一下，百度看看怎么回事。 额，这垃圾游戏，百度都搜不到，额，这是啥啊，就是一个模拟器嘛，还下不下来。唉，算了，重试 一遍吧。 接下来是有点忧心忡忡的看着视频，一边心疼着流量啊，一边看。忍不了，切回去看看，2%,5%。。。 额，40%，又不动了，又出错了。垃圾游戏，删掉。重新网上找一个。看一下手机，我靠，1G流量已经 没了啊。算了，我去找个别的模拟器吧，还得搞学习呢，耽误我时间，分分钟搜到一个，赶紧下。 额 ，这次好像很顺利的样子，（百次切换后的十分钟。。）额，这个怎么有点不对的样子啊，头上怎么一 个安卓的机器人啊，难道是只有安卓的才能用吗？这波就傻逼了。还先装的引擎，再下的游戏，额，这 游戏都下了一半了，现在我是停不停啊，不会坑我吧。算了，中国有句古话说的好，来都来了是吧。。 等等下完吧。 终于下完了，我手机也提示2G的流量也没了。赶紧隆重的停一下视屏，装上看一看，额，怎么一个不是 很熟悉的模拟器一样，上面就装了一个游戏，有点虚呀，兄弟。还是试试吧，擦，果然不可以啊，这下 傻逼了。怎么说，哎，难道我老了，连这点都解决不了了。关机重启重下吧。 重启！可是我的校园网没流量了啊，管他呢，先下了再说吧，出去吃饭了。。。。。。回来，赶紧看一 下，哇，竟然下完了，看来西电的校园网还是有一点靠谱的嘛，装上试试，等等，这好像有点卡啊，这 个，半天进不去啊。怎么他们说的可以啊，赶紧微信私聊一个人问一下，靠，他也很卡，刚刚自己还说 可以的，擦。 嗯，游戏总是很坑，但生活还得继续啊，周末的好天气也不忍心待在室内，难得在这个时间没有雾霾， 已经快一点了，约的羽毛球和洗澡吃饭一条龙还没确定呢。赶紧找人啊，随便问一个，怎么不去？这也 不去，只剩下我和这个破峰了？两个人怎么玩到四点去洗澡啊。额，再想想，于是看到师兄约篮球，要 不怂恿看看？可是破峰竟然抛弃我准备先去洗澡了，但是这么好的天气，作为有点欠太阳的我是必须要 出去运动一下的，那就去打篮球吧。。 。。。 打完球四点多，打的有点累啊，回来休息一波，也没啥事干，要不休息一下带这个破峰玩一局吧，结果 洗澡就是五点多了，自己去洗个澡，买点吃的，回来还是用平板玩会游戏，吃个饭，给家里打个电话， 已经七点多了，想起游戏有活动啊，上来看看，顺便看看视频，额，完全看不进去啊，还有点累啊。算 了，随便看看视频之类的吧，反正不想学习。额，我的校园网没了，要不用免费网下个游戏吧，试试看 怎么样，就荒野行动吧，反正最近这么火是吧，这个速度有点快啊，确定是我自己的网吗？看一下，是 我的，放心不是书记的。下完了，再更新，额，怎么一兆多啊，不对啊，再看一下，果然是书记的，我 靠，这就尴尬了 。。于是结果就是半个小时陪着这个破书记去搞了吃的额 回来已经十点多了，游戏终于下好了，怂恿破峰下一个吧。我先去床上玩一把。于是玩到了12点了。该 睡觉了，好困啊，睡吧。 星期天到了，看来睡的早还是可以啊，八点多就醒了，简直是像上帝多要了两个多小时的生命啊，赶紧 玩会游戏浪费一下，玩到九点，额，怎么有点困啊，算了，睡吧，昨天打球确实有点累啊，年纪大了， 不能拉杆了啊。休息休息。。。已经11点了啊，赶紧起来看看，随便一收拾，又要吃饭了，唉，赶紧收 拾一下衣服扔下去，然后吃个饭，去个超市回来正好收衣服，我真会过日子啊，哈哈。 回来又是一点，挂好衣服，干啥了，听听歌，洗洗东西。额，快两点了啊，赶紧休息一下，三点了，想 起来周末好像完全没学习啊，关键是还是入党的东西很多没填啊，还是去一下实验室吧。。 终于差不多记完了，真的有点无聊，但是确实好像又好像拜托不了的周末啊，除了周内每天按时上班让人周末不想好好起床以外，还有一些确实需要做的事情，比如锻炼和洗刷，时间好像也就那些。或者再稍微加点娱乐，再加点别的赖床，晚上再睡晚一点，时间就更短了啊。 显然，时间当然没法安排的这么满，但是确实也不是一点留给该做事的时间都没有的。为什么别人都有了，而我只是看似想着学习却实际上啥都没干呢？ 分析一下周末的时间： 晚上的晚睡：没有理由的晚睡当然是透支了第二天的白天的时间，晚睡的一两个小时，直接一个上午几乎没了，然后下午再随便一玩，就觉得一天啥都没干。 无聊的折腾：有的时候很多的爱好并不是一件很好的事情，看看比赛的情况，刷个新闻，刷个朋友圈，看看游戏，再玩会游戏，直接学习时间就没了，直接体现就是在进度上。还会觉得很烦躁 当然还是有点懒啊： 谁都有不想做啥的时候，但是生活就是这样，这就不多说了。 直到晚上写个人自传的时候，才想起来很多没得啥写，生活就像游戏一样，你玩的多爽杀了多少人，能给你带来的快乐，除了当时的快乐，还有之后你回头看过来，自己有多少收获，有的时候不功利是一种美德，但有时候那只能证明你太年轻了，换句话说就是傻逼了，快乐的生活还是要建立在将来看起来也仍然是快乐的不是吗。 希望以后换种方式的周末吧 ","date":"2017-11-26","objectID":"/posts/random-life-1/:0:1","tags":["杂想"],"title":"一个可能很熟悉的周末","uri":"/posts/random-life-1/"},{"categories":["刷题"],"content":"T7：斐波那契数列 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 n\u003c=39 斐波那契数列是很常用的数列，也是很简单的递归能够解决的，但是当n稍微大一点的时候，复杂度都让人无法接受。 例如： long long Fi(int n){ if(n==0) return 0; if(n==1) return 1; return Fi(n-1)+Fi(n-2); } 这样出现的问题主要是在递归的过程中会出现很多重复的计算，比如我们每次计算第n个的时候，都需要重新计算前面的n-1和n-2，这样每个值其实都会被计算两遍。简单的处理是：从下往上开始算，从第0个一直算到第n个。 代码如下： class Solution { public: int Fibonacci(int n) { if(n\u003c=0) return 0; if(n==1||n==2) return 1; int newNum=1; int oneNum=1,twoNum=1; for(int i=3;i\u003c=n;++i){ newNum=oneNum+twoNum; oneNum=twoNum; twoNum=newNum; } return newNum; } }; T8：跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 该类问题其实就是斐波那契数列的应用：考虑第一次跳的情况，如果第一跳1级，那么后面就是n种情况，如果第一次跳2级，后面就是n-2种，于是：f(n)=f(n-1)+f(n-2)；同理： class Solution { public: int jumpFloor(int number) { if(number\u003c=0) return 0; int result=0; if(number==1) return 1; int first_step=1; int second_step=1; while(number\u003e=2){ --number; result=first_step+second_step; first_step=second_step; second_step=result; } return result; } }; T9：变态跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 同样的分析：1.把第n级和第n-1级看成一级，则有：f(n-1)种；2.把第n级和第n-1级分开，则到n-1级有：f(n-1)，n-1级到第n级只有一种，所以加起来是：2*f(n-1) 代码如下： class Solution { public: int jumpFloorII(int number) { if(number\u003c=0) return 0; int result=1; if(number==1) return 1; for(int i=1;i\u003c=number-1;++i){ result*=2; } return result; } }; ","date":"2017-11-17","objectID":"/posts/algorithm/nowcoder-sword-to-offer3/:0:0","tags":["C++","剑指offer","牛客网"],"title":"牛客网-剑指offer-3","uri":"/posts/algorithm/nowcoder-sword-to-offer3/"},{"categories":["C++"],"content":"专业书 《Python核心编程》 ed2 《C++　Primer 》ed5 《STL 源码剖析》 《Effective C++》 《Unix 网络编程》卷一 《Unix 网络编程》卷二 《Unix 环境高级编程》 《Linux多线程服务端编程》陈硕 《TCP/IP详解》卷一 其他 2017要看完的书，生活总得有一些flag是吧 《人类简史》尤瓦尔·赫拉利 《未来简史》尤瓦尔·赫拉利 2015-2016看的书： 经济学通识 霍乱时期的爱情 围城 雅库玛的诅咒 今天你真好看 鬼吹灯1 北京折叠 百年孤独 活着 东野圭吾专场 白夜行 嫌疑人X的现身 秘密 信 恶意 假面饭店 放学后 解忧杂货店 彷徨之刃 ","date":"2017-11-12","objectID":"/posts/read/books/:0:0","tags":["C++"],"title":"我的专业书阅读","uri":"/posts/read/books/"},{"categories":["生活"],"content":"记录我看的电影 ","date":"2017-11-12","objectID":"/posts/read/moives/:0:0","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"2018年– ","date":"2017-11-12","objectID":"/posts/read/moives/:1:0","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"目击者之追凶豆瓣8.1分 看的时候主要是看评分这么高，而且还是台湾的，觉得应该就是个剧情比较好看的电影，慢慢看着都不觉得有多好看，只不过到后面越来越觉得剧情不简单了。尺度很大，不到最后一刻不知道结果的那种，但是从每个人的角度来理解这个剧情，又觉得每个人的特点都塑造的让人感叹。 ","date":"2017-11-12","objectID":"/posts/read/moives/:1:1","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"三块广告牌 豆瓣8.7分 毕竟是拿了奥斯卡最佳女主的。。 ","date":"2017-11-12","objectID":"/posts/read/moives/:1:2","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"前任3：再见前任 豆瓣5.7分 闲着 没事就看看了== ","date":"2017-11-12","objectID":"/posts/read/moives/:1:3","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"非常嫌疑犯 豆瓣8.6分 觉得自己一开始就猜中了大坏蛋，但是中间仍然起伏，差点以为自己猜错了，不过结果还是差不多。 对于这样的悬疑片，突然觉得有了一点经验了，那种你算的很好的逻辑，很大程度是别人给你写好的逻辑圈套让你钻进去。 所以对于逻辑，还是要像马克思说的啊，从正反两面考虑。不管是狼人杀这种游戏，还是生活中的决定。 说回这个电影吧，剧情就不说了，还有整个电影的叙事方式，刚刚开始觉得有点乱，还是对美帝主义的一些情况不太了解。不过后面就觉得清晰了。而且电影里出现了很多干扰的东西，比如像医院里出现的那些人，总觉得会有所错觉，还有警局里的一些，可能是年代有点久远还是自己要求有点高了？。。 ","date":"2017-11-12","objectID":"/posts/read/moives/:1:4","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"穆赫兰道 ","date":"2017-11-12","objectID":"/posts/read/moives/:1:5","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"银翼杀手2049 可能我们无法想象30年后地球上会发生什么，会不会真的连一点真的木头都变得很珍贵？会不会真的有一群复制人帮我们做着一些我们不太愿意做的事情，但是我们仍然在歧视他们？不过有些东西是我们能想象的，就比如现在所说的科技发展的界限，就像很多所提的，那就是伦理，那就是以人为本。从一方面来说，所有的发明和创造都是为了让人的生活变的更好，而不是给人类带来麻烦，另一方面，如果我们人类的创作也跟人一样有思想，我们应不应该像人一样尊重他们。 ","date":"2017-11-12","objectID":"/posts/read/moives/:1:6","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"羞羞的铁拳 真的，感觉是个啥，为了搞笑就在搞笑。。 ","date":"2017-11-12","objectID":"/posts/read/moives/:1:7","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"2017年– ","date":"2017-11-12","objectID":"/posts/read/moives/:2:0","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"嘉年华 值得一看的电影。如鲠在喉 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:1","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"机器之血 估计可能是成龙演的吧，毕竟61岁了，还这么拼，总让人觉得有点厉害了。但是电影从剧情到演员到画面，真的没有一点合格的吧，浪费时间了啊。 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:2","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"无证之罪（1957） ","date":"2017-11-12","objectID":"/posts/read/moives/:2:3","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"缝纫机乐队（2017） 毕竟睿思一周热门啊，还是忍不住下下来看了一下。记得之前大鹏各种微博之类的请大家去看看，不过评分依然很低。所以看的时候本来也没有那么期待。看完之后觉得也没有那么烂吧，想起之前看的大鹏的煎饼侠，也不知道除了搞笑之外还记起来什么了。不过这个好像好了很多，因为我想以后可能不会记得这个有多搞笑，但应该会记得讲了个什么故事。 虽然电影对于大鹏来说可能有着特别的意义或者怎样，但是我看的时候还是觉得一如很多的国产电影，剧情不够瞎搞笑凑，然后就为了搞笑又加了很多无聊的东西，让剧情更烂了。所以这个也是这样，但是在最后强催的泪点环节，还是能够感觉到大鹏想告诉大家的东西，或者说是他对生活，对他自己的生活的一个理解？但是不重要是吗？电影可以就像一个人，但应该是我们发自肺腑的感叹，而不是要你用电影之外的话来告诉我们。就好像你做了一道菜，一定要在我们吃的时候加上旁白告诉我们现在吃的是什么，那可能不一定难吃，但一定不优秀。 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:4","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"寻梦环游记（2017） date：2017-12-2 额，要不是评分实在太高了，我也不会去看个说是动画片的电影吧，很少见出来一周的电影还9.5分的，但是确实值得高分。 不愧是迪士尼啊，效果非常棒不说了。整个剧情，跟一些非常优秀的电影一样，塑造了一个存在于人们想象中有可能很合理的新世界，在那里，有很多匪夷所思却又言之合理的事情。然后在这个世界里出现了与现实有联系的矛盾。当然最后问题的解决，又给人现实很简单纯粹的思考。比如在这里，塑造了亡灵的世界，如果死了的人真的被人遗忘，就会真的死亡。你在现实里追逐梦想最终被人记住的，在亡灵的世界也可以活的风光，就像梦想可能不被理解，但是实现了一定很值得一样。最后的大反转又让人回归，家人是最重要的，即使你有梦想，也没必要去牺牲这些。简单的道理，但是如果像我这么说就很没意思了，所以，这就是我们为什么会喜欢优秀的电影了吧。 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:5","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"天才枪手(2017) IMDI 8.2分 ** /**豆瓣 8.3分 好吧，8分多纯粹就是看了个热闹啊。简直就像告诉你，优秀的人作弊都比人优秀啊，即使感觉满屏幕的bug也依然很没文化的wokaowokao了。。 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:6","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"东方快车谋杀案(1974) IMDI 7.3分 ** /**豆瓣 8.3分 能拿奥斯卡的一般特性，就像一般艺术到最后所反映的，除了一个完整的故事，精彩的剧情，还有整个电影对人物、风情、地域以及社会环境等的刻画，传达人性或这个世界我们需要的思考。这种深度，国产电影离别人几十年前的电影都相差甚远。想起冯小刚说的，中国电影拍不好，是因为中国的观众不行，我觉得观众始终是很少的一部分，因为更多的时候、其实观众不知道他们喜欢的究竟是什么，因为更好看的永远在后面，这就是电影行业的责任了。 再说这个电影吧，剧情的丰富就不必说了，从开头的各种铺垫，让我们在看到各种人物性格，国家的特点等，产生各种怀疑的时候，案件就开始了，于是现在看起来有点搞笑的主人公就开始了表演，整个审问和查找线索的过程让人敬佩，直到慢慢开始跟着他产生新的怀疑。。 在主人公宣布结果之前，我也似乎猜到了一点，他最后给了大家选择，这是大家都希望的，看到大家开始香槟庆祝的时候，我不禁在想，这样的结果，究竟是应该的吗？如果这样的谋杀也可以，法律又怎么会进步。 说到这里，又不禁想起来最近的江歌的事件，我只是在新闻上看到了，对此也表示很遗憾。不过在网上却各种签名投票之类的沸沸扬扬，诚然，在这种时候我们需要帮助受害者的家人，也想让罪人得到应有的报应，但这样可能真的不是最好的办法。就像规则可能有时候会有缺陷，但是如果每次都因为特殊事件让它临时违背，那跟没有也没区别。 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:7","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"幸福终点站(2004) IMDI 7.3分 ** /**豆瓣 8.6分 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:8","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"加勒比海盗5：死无对证 IMDI 6.7分 ** /**豆瓣 7.2分 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:9","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"速度与激情8 IMDI 6.8分 ** /**豆瓣 7.1分 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:10","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"百万美元宝贝( Million Dollor baby) ","date":"2017-11-12","objectID":"/posts/read/moives/:2:11","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"陪安东尼度过漫长岁月 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:12","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"看不见的客人 IMDI 8.1分 ** /**豆瓣 8.7分 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:13","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"致命ID ","date":"2017-11-12","objectID":"/posts/read/moives/:2:14","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"雷神3 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:15","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"罗生门（日本） ","date":"2017-11-12","objectID":"/posts/read/moives/:2:16","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"心迷宫 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:17","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"情遇曼哈顿 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:18","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"复仇者联盟 ","date":"2017-11-12","objectID":"/posts/read/moives/:2:19","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"记录看的电视剧 电视剧看的不多，但是一看就要看完啊。等不了啊 ","date":"2017-11-12","objectID":"/posts/read/moives/:3:0","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"琅琊榜之风起长林 自认为超过了1的水平。 超级正的家国情怀和三观，虽然在这个人人都想买房买车的年代显得有点。。但是梦想总还是要有的是吧 将在其位谋其事，什么样的环境造就什么样的人演绎的很彻底。我第一次很理解所有的反派的行为。。 ","date":"2017-11-12","objectID":"/posts/read/moives/:3:1","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"猎场 就当是看胡歌了啊 ","date":"2017-11-12","objectID":"/posts/read/moives/:3:2","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"权力的游戏s7 ","date":"2017-11-12","objectID":"/posts/read/moives/:3:3","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"白夜追凶 ","date":"2017-11-12","objectID":"/posts/read/moives/:3:4","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"无证之罪 ","date":"2017-11-12","objectID":"/posts/read/moives/:3:5","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"激战玄武门（纪录片） ","date":"2017-11-12","objectID":"/posts/read/moives/:3:6","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["生活"],"content":"Justice（公开课）","date":"2017-11-12","objectID":"/posts/read/moives/:3:7","tags":["娱乐","记录"],"title":"我看的电影","uri":"/posts/read/moives/"},{"categories":["刷题"],"content":"T4：重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 二叉树是觉得很烦的东西了，比链表复杂很多，看着头都有点疼啊，但是没办法，生活就是这样，只有把不会的会了才会进步，怕的变得不怕才能越来越厉害。 常规的理解一下：二叉树的遍历序列分为三种：前序遍历、中序遍历和后序遍历。这样叫是根据根节点相对于其左右子节点而言的。所以很容易知道三种遍历序列的特点，比如对于前序遍历而言，第一个就是根节点，对于中序遍历，根节点的左边必然是左子树，右边为右子树。所以首先可以根据两个序列确定根节点，然后把两个序列都分别分为两个序列，两个左右子树的前序遍历和两个左右子树的后序遍历。于是便可以采用递归的方式分别对左右子树进行处理了。 代码如下： /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reConstructBinaryTree(vector\u003cint\u003e pre,vector\u003cint\u003e vin) { if(pre.size()==0||vin.size()==0||pre.size()!=vin.size()) return nullptr; TreeNode *root=new TreeNode(pre[0]); vector\u003cint\u003e pre1,pre2,vin1,vin2; int i=0; for(;i!=vin.size();++i){ if(root-\u003eval==vin[i]){ break; } } //if(i==0) //root-\u003eleft=nullptr; //else if(i==vin.size()-1) //root-\u003eright=nullptr; //else{ for(int j=0;j\u003ci;++j){ pre1.push_back(pre[1+j]); vin1.push_back(vin[j]); } for(int j=i+1;j\u003cvin.size();++j){ pre2.push_back(pre[j]); vin2.push_back(vin[j]); } root-\u003eleft=reConstructBinaryTree(pre1,vin1); root-\u003eright=reConstructBinaryTree(pre2,vin2); //} return root; } }; T5:用两个栈实现队列 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 对于这种简单的结构，实现起来可能还是比较简单一点，主要还是思考的过程，通过队列和栈的特点进行分析。队列是一个先进先出的结构，而栈是一个先进后出的结构。显然当我们把数据push到第一个栈，每次数据pop都把第一个栈的全部数据先放到第二个栈当中，然后再pop，肯定就达到了先入先出的目的了。 另外需要的是代码的编写。 代码如下： class Solution { public: void push(int node) { stack1.push(node); } int pop() { if(stack2.size()\u003c=0){ while(stack1.size()\u003e0){ int temp=stack1.top(); stack1.pop(); stack2.push(temp); } } int result=stack2.top(); stack2.pop(); return result; } private: stack\u003cint\u003e stack1; stack\u003cint\u003e stack2; }; T6：旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 对于数组或者双链表的问题，很多时候我们都可以采用** 双指针**的方法来解决，这通常能减小难度，就像这题，首先我们需要注意的是，旋转数组的特点，旋转之前是一个非递减排序，所以旋转之后必然是前面一个非递减排序加上后半部分的一个非递增排序。很容易想到的是，采用前后两个指针，根据两个指针中间的点的值，可以确定这个数组中最小的值在前半部分还是后半部分，然后移动某一指针到中间节点，知道两个指针之间相差1，就可以确定最小值。 然而，看题目还存在一个问题，就是题目所说的是一个非递减排序，而并非递增序列。（这就需要我们认真审题了），可以想到，如果出现了特殊的情况，例如存在几个相等值，导致左右两个指针和中间值都相同的时候，我们只能通过最原始的办法一个个进行判断了。 代码如下： class Solution { public: int minNumberInRotateArray(vector\u003cint\u003e rotateArray) { if(rotateArray.size()\u003c=0) return 0; int index1=0; int index2=rotateArray.size()-1; int indexMid=index1; while(rotateArray[index1]\u003e=rotateArray[index2]){ if(index2-index1==1){ indexMid=index2; break; } indexMid=index1+(index2-index1)/2; if(rotateArray[index1]==rotateArray[indexMid]\u0026\u0026 rotateArray[indexMid]==rotateArray[index2]) return MinInorder(rotateArray); if(rotateArray[indexMid]\u003e=rotateArray[index1]) index1=indexMid; else if(rotateArray[indexMid]\u003c=rotateArray[index2]) index2=indexMid; } return rotateArray[indexMid]; } int MinInorder(vector\u003cint\u003e rotateArray){ int result=rotateArray[0]; int index2=rotateArray[1]; while(index2!=rotateArray.size()){ if(result\u003erotateArray[index2]) result=rotateArray[index2++]; else ++index2; } return result; } }; ","date":"2017-10-27","objectID":"/posts/algorithm/nowcoder-sword-to-offer2/:0:0","tags":["C++","剑指offer","牛客网"],"title":"牛客网-剑指offer-2","uri":"/posts/algorithm/nowcoder-sword-to-offer2/"},{"categories":["工具"],"content":" 学(xian)习(de)所(dan)需(teng)，觉得一个虚拟机确实装的Ubuntu确实有点烦了，除了没有一个系统那样直接用起来爽以外，总觉得感受不到一个纯正的系统。而且虚拟机有时候懒得开了就算了。但是又舍不得直接把我换了固态之后就没有换过的系统直接换掉，毕竟我已经不是那个年轻的爱折腾的22岁的小伙子了，我23了。。于是就看着教程和xjbg装了双系统。同时的难度是，我的固态硬盘里放的系统，但是又不想把系统直接放在固态硬盘，只是希望通过固态启动一下，然后把其他的目录放在机械硬盘中 Win7准备 双系统的准备主要就是硬盘了，毕竟这么多学习资料是吧。。总还是要谨慎一点的。因为win7和linux系统的磁盘格式不一样，所以我们不能直接在win7里面分好磁盘。这里的工作是：将固态硬盘压缩300MB空间，作为Ubuntu的/boot分区，以供系统启动用。另外在机械硬盘中分出80GB空间，作为其他的/和swap分区。 通过U盘做系统盘 使用工具UtralISO，将下载好的Ubuntu系统，通过正常的模式写入到U盘中(这个随便百度一下就有了，经常装系统的这个就差不多知道了) 重启装系统 首先还是熟悉的修改bios，按一下各种类似F2之类的键，进入BIOS设置，将启动项第一位改成U盘，然后重启。。 之后就是进去装系统了，主要是选磁盘的时候，把 固态硬盘中的未分配空间格式化为/boot，然后其他的机械硬盘中的，按照需要格式化为/和/swap,之后等着装完就好了。 修改启动选项 系统装完之后就要重启进入新系统了，这是惊喜而又刺激的发现，Ubuntu真好看，但是我的Win7去哪儿了。不过装了一百遍系统的我知道肯定还是个引导的问题，在网上找到了解决办法。在Ubuntu中输入命令： sudo gedit /etc/default/grub #修改 GRUB_DEFAULT=0 为：GRUB_DEFAULT=4 #更新grub sudo update-grub 在终端中找到： found win7... 就说明win7引导被找到了，重启可以开始愉快的用了 Reference: http://m.jb51.net/article/110288.htm https://jingyan.baidu.com/article/e4d08ffdace06e0fd2f60d39.html http://www.jianshu.com/p/c6750e459a94 ","date":"2017-10-22","objectID":"/posts/tools/installation_of_two_system_on_win7/:0:0","tags":["工具"],"title":"win7下安装Ubuntu双系统","uri":"/posts/tools/installation_of_two_system_on_win7/"},{"categories":["刷题"],"content":" 说在前面：刷题真的是一件残酷的事情，就好比以前大学的时候只剩两天就考试了，刚刚看了一遍就开始先做题一样的感觉，面对无数的套路，幸运的时候还能庆幸自己能发现他们的套路。。 刷题的开始总是艰难的，希望有一天我能以上帝视角看清这些芸芸众生的时候，还能想起来当年我不止一次的一道题怼了一晚上照样白怼。 T1：二维数组的查找 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 这里一般的思路肯定是，从行或者列开始找，根据递增的顺序，找到行或者列之后再判断列或者行，知道找到为止。最好的方法是，从左下角或者右上角开始找。原因是：这样的一行和一列的顺序是不一样的，这样我们找一行的时候没有就可以直接找下一行，充分利用递增的顺序，减少循环的次数。 其他的就是循环的写法了，关于数组，一定注意的是不要越界，这真的是我的痛啊，日常越界一百遍。^^_ class Solution { public: bool Find(int target, vector\u003cvector\u003cint\u003e \u003e array) { bool found=false; if(array.size()==0 ||array[0].size()==0) return found; for(int i=array[0].size()-1;i\u003e=0;--i){ if(target\u003e=array[0][i]){ for(int j=0;j!=array.size();++j){ if(target==array[j][i]) found=true; } } else continue; } return found; } }; T2：替换空格 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 替换的过程是，先找到这个空格，正常想法是，从前往后找，然后遇到就开始替换。但是注意到对于一般题目，最直观的解法总不是最好的，都是需要多从时间复杂度和空间复杂度想一想。就这个题目而言，直接从前往后替换，因为替换后的字符比原来多2个，所以每次替换我们都需要将后面的字符串向后移2个，这无疑会增加复杂度。一个很好的办法是：先统计空格的个数，计算出替换后的字符串长度，然后从后往前开始替换，这样就减少了移动的复杂度。 class Solution { public: void replaceSpace(char *str,int length) { if(length\u003c=0) return; int move_length=0; int original_length=0; for(int i=0;str[i]!='\\0';++i){ ++original_length; if(str[i]==' ') ++move_length; } int new_length=original_length+2*move_length; if(new_length\u003elength) return; str[new_length]='\\0'; while(original_length\u003e0){ --original_length; if(str[original_length]==' '){ str[--new_length]='0'; str[--new_length]='2'; str[--new_length]='%'; } else str[--new_length]=str[original_length]; } } }; T3:从尾到头打印链表 输入一个链表，从尾到头打印链表每个节点的值。 链表我们一般都是从头到尾处理的，要从尾到头打印，这里想到一个数据结构：栈，后入先出的特点。从头到尾遍历链表，并把节点的值存入栈中，再从栈一一弹出即可。 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector\u003cint\u003e printListFromTailToHead(ListNode* head) { stack\u003cint\u003e stack; vector\u003cint\u003e result; while(head!=nullptr){ stack.push(head-\u003eval); head=head-\u003enext; } while(stack.size()!=0){ result.push_back(stack.top()); stack.pop(); } return result; } }; ","date":"2017-10-15","objectID":"/posts/algorithm/nowcoder-sword-to-offer1/:0:0","tags":["C++","剑指offer","牛客网"],"title":"牛客网刷题总结-剑指offer(1)","uri":"/posts/algorithm/nowcoder-sword-to-offer1/"},{"categories":["C++"],"content":" 前面两章的内容主要是习惯使用c++，大部分都是《C++ primer》中的需要注意的一些东西，由于刚刚看完前面一本，所以有些还是有些印象的。这里大体总结一下。 L1:C++是一个语言联邦。 包含着最初的以c语言为基础的C，面向对象的C++，C++的泛型编程，以及STL。在我们使用的过程中，可能会穿插，但是我们需要根据不同的情况使用不同的策略。 L2：代替#define #define是在编译之前，也就是预处理的阶段就会被替换，这样我们在调试程序的时候看到的就是被替换的数字，会给别人甚至是之后调试的我们自己带来理解上的困难。另外，预处理器的工作是，直接把define的内容进行替换，当我们在define中写的表达式，并且在接下来使用的时候，可能产生无法理解的结果。所以当我们使用不想改变的常量时，使用const代替#define。 我们还可以使用enum来代替#define。这样显得会更接近一些，因为enum和#define一样，同时也不会被pointer或reference指向。 使用inline函数。 L3:尽量使用const 这是一个很好理解的问题，就像你把东西给别人用，不想让别人动的地方就加一个const不让别人动一样。。。 具体的体现为：指针，不想被改变的变量，迭代器，成员函数等等。 我们可能还会为一个函数定义const和非const版本。 L4：在使用对象前先初始化 嗯，记住。 L5：了解c++会默认编写并调用哪些函数 在面向对象编程时，记住三五法则。构造函数、拷贝构造函数、拷贝赋值运算符、移动赋值运算符、析构函数。记住这几个函数的作用，其在什么时候会被使用，如果没有的时候，系统会不会为我们生成。我们需不需要系统为我们生成。 L6：不想编译器默认生成的函数，应该明确拒绝 比如我们不希望编译器为我们生成默认的函数，我们应该将其定义为删除的或者定义为private的，也可以定义类似于uncopyable类似的base class。 L7：为多态的基类声明virtual析构函数 通常我们希望派生类覆盖或重写的函数，定义为virtual函数。析构函数作为对象被销毁时调用的函数，如果不是虚函数，那么可能在销毁的时候只会销毁基类的部分，局部销毁，造成资源泄露。 L8：不要让异常逃离析构函数 析构函数绝对不要吐出异常，当遇到异常的时候应该捕捉任何异常，然后吞下或结束程序。 如果需要对某个操作函数运行期间抛出的异常做出反应，应该提供一个普通的函数执行操作，而不是在析构函数中。 L9：绝不在构造和析构过程中调用virtual函数 构造和析构过程中，调用virtual函数的对象可能还没有产生，也就是派生类的对象，此时会产生未定义的行为。 L10：另operator=返回一个reference to *this 并不强制，只是为了防止一些调皮的调用者使用：x=y=z=15这样的操作。 L11：在operator=中处理自赋值的情况 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，行为仍然正确。 L12：复制对象时不忘每一个成分 Copying函数应该确保复制对象内的所有成员变量和所有base class成分。 不要使用一个copying函数实现另一个copying函数，而是创建一个新的函数避免代码重复。 ","date":"2017-10-09","objectID":"/posts/language/cpp/effective-cpp-1/:0:0","tags":["C++"],"title":"《effective C++》from line 1 to line 12","uri":"/posts/language/cpp/effective-cpp-1/"},{"categories":["生活"],"content":"2017-9-25 记录学习 额，打开sublime，打出来第一个#号，下意识的想打include，笑了自己两秒钟，好像这几天看来，就这句写的最熟练吧。 最近开始再一次准备看数据结构和算法，再一次，是不能再跟闹着玩的一次了。看着实验室最近找工作的师兄师姐，一边心疼他们，一边更心疼明年的自己。所以我也想到了也许很好的办法，不如抓紧时间现在先好好学习，头疼起来了，心就不疼了吧。 断断续续看完了c++ primer，加上之前看过一些数据结构，但是当我打开牛客网第一题的时候还是觉得自己像个傻逼，于是按照我通常的习惯，换了第二题，觉得更傻逼了。于是还是先打开书看看了。。 看看书啊，又刷刷题啊，自己还是经常在骂自己和夸自己和强行夸自己这几种有限状态中跳来跳去。 晚上，刷到那个链表翻转的题目，又是好久没搞出来，各种数组越界。明明只是就那么几个指针而已，反复看了好几遍。当方法论出了问题的时候，有的时候会忍不住怀疑世界观。作为一个还是对这个世界充满疑惑和兴趣的青年，我好奇地又在网上搜了一遍：C++学什么，C++怎么学，C++学习路线。。于是一晚上又没了，留下一份写有听过好多遍名字的书的TXT文档，一如一个多月前的某一个晚上。。 可能距离我们找工作也有快一年吧，时间说长不长，说短不短吧。其实我觉得能担心的可能一直不是时间，而是利用时间。 先写一下接下来一段时间的任务吧，不要又乱跑了： 《Effictive C++》认真看，主线 有空看数据结构，刷题，不随便放弃题目。搞懂会写，写好了为止 ","date":"2017-09-25","objectID":"/posts/daily/how_to_sail/:0:1","tags":["杂想"],"title":"不知道怎么开的船？","uri":"/posts/daily/how_to_sail/"},{"categories":["C++"],"content":"泛型编程与面向对象编程的区别是：面向对象编程能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。 16.1 定义模板 模板程序应该尽量减少对实参类型的要求。 模板的头文件通常包括声明和定义。 模板直到实例化时才生成代码。 泛型编程的一个目标就是另算法是“通用的”-适合于不同类型。所有标准库容器都定义了==和!=，但只有少数定义了\u003c运算符。因此尽量使用!=而不是\u003c。 ** 类模板用来生成类的蓝图，一个类模板的每个实例都形成一个独立的类。默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。在类模板的作用域类，我们可以直接使用模板名而不必指定模板实参。 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给 所有友元模板实例，也可以只授权给特定实例。 当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。 ** 成员模板：一个类（不管是模板类还是普通类）可以包含本身是模板的成员函数。这些成员函数被称为成员模板。成员模板不能是虚函数。 控制实例化： extern template class Blob\u003cstring\u003e; //声明，遇到extern模板声明时，编译器不会在本文件中生成实例化代码。，对于一个给定的实例化版本，可以有多个extern声明，但只能有一个定义。 template int compare(const int\u0026,const int\u0026); //定义 16.2 模板实参推断 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。 一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。 如果函数参数类型不是模板参数，则可以进行正常的类型转换。 ** 显式模板实参**按由左至右的顺序与对应的模板参数匹配。 16.3 重载与模板 16.4 可变参数模板 16.5 模板特例化 ","date":"2017-09-19","objectID":"/posts/language/cpp/cpp_primer_ch16/:0:0","tags":["C++"],"title":"《c++primer》ch16 模板与泛型编程","uri":"/posts/language/cpp/cpp_primer_ch16/"},{"categories":["C++"],"content":" 面向对象三个基本概念：数据抽象、继承和动态绑定（java里说的多态）。这章主要内容是继承和动态绑定。 15.1 OOP：概述 15.2 定义基类和派生类 基类希望派生类进行覆盖的函数，通常将其定义为** 虚函数**，另一种是基类希望派生类继承但不要改变的函数。 protected访问运算符：派生类可以访问，但是其他用户无法访问。 定义派生类：通过访问说明符控制派生类从基类继承而来的成员是否对派生类可见。 如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为跟其他类一样，派生类会直接继承其在基类中的版本。 派生类到基类的转换。这可以让我们把派生类对象或者派生类对象的引用用在需要基类引用的地方，也可以把派生类指针用在需要基类指针的地方。但是，这里会出现一个问题，当我们使用基类的指针或者引用时，就不知道这个所绑定的对象到底是基类还是派生类了。 派生类构造函数。必须使用基类的构造函数初始化。（每个类控制自己的初始化过程。） 每个类定义各自的接口，派生类要遵循基类的接口。 如果基类中定义了静态成员，则在整个继承体系中只存在唯一的定义，不管定义了多少遍，都只存在唯一的实例。 对派生类的声明，不需要包含派生列表。 当我们不想让类被继承的时候，可以使用final关键字，跟在类名之后。 表达式的** 静态类型在编译时是已知的，是变量声明时或者表达式生成式生成的类型。 动态类型**则是变量或表达式表示的内存中的对象的类型。因此，基类的指针或引用的静态类型可能与动态类型不一致。 派生类向基类的自动类型转换只对指针和引用有效，在类型之间不存在这样的转换。当我们用一个派生类对象初始化或给一个基类对象赋值时，只有该派生类的对象中的基类部分会被拷贝、移动或赋值，派生类部分则会被忽略掉。 15.3 虚函数 我们必须为每一个虚函数提供定义，因为连编译器也无法确定到底使用的是哪一个虚函数。 如果我们在派生类中覆盖了某个虚函数时，可以再次使用virtual指出该函数的性质，但实际上并不一定要这么做。因为某个函数被声明成虚函数，则在所有的派生类中都是虚函数。 15.4 抽象基类 在函数体声明的语句的分号前使用=0可以将一个函数声明为纯虚函数。 含有纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类负责覆盖该接口。我们不能直接创建一个抽象基类的对象。GCC的编译器中可能前面还是要加上virtual ** 重构**：重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。 15.5 访问控制与继承 protected:对于类的用户来说是不可访问的，对于派生类的成员和友元来说是可访问的。但是只能通过** 派生类对象来访问， 派生类对于一个基类中受保护的成员是无法访问的。 派生类向基类的转换：只有当D公有的继承B时， 用户代码**才能使用基类向派生类的转换。无论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换。如果D继承B的方式是公有的或受保护的，则D的派生类可以使用D向B的类型转换。 友元关系不能继承。基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员。 派生类可以使用using为那些可以访问的名字提供声明，以改变这些名字在它的派生类中的可访问性。 15.6 继承中的类作用域 每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。 当名字相同时，派生类的成员将隐藏基类的成员。基类可以通过** 作用域运算符来使用隐藏的成员。一般情况下，我们应该不会这么使用，所以，平时继承类尽量不要覆盖继承而来的虚函数以外的基类的名字。 ** 名字查找先于类型检查：如果派生类的成员与基类中的某个成员同名，则派生类将在其作用域内隐藏该基类成员。一旦编译器查找到名字后，不管形参列表是否相同，都不会再继续查找，这也是我们需要在覆盖虚函数时，保证形参列表是相同的。 using声明语句指定一个名字而不是形参列表，所以我们在基类中使用一个using就可以把该函数的所有重载实例添加到派生类作用域中，派生类只需要定义特有的函数即可。 15.7 构造函数与拷贝控制 位于继承体系中的类也需要控制当其对象执行一系列操作时发生怎样的行为：包括创建、移动、拷贝、赋值和销毁。 一般讲基类中的析构函数定义为虚函数，这样，继承体系中的派生类都会是虚析构函数，否则，若基类中的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。 虚析构函数将组织合成移动操作。 和普通成员的using声明不同，构造函数的using声明不会改变该构造函数的访问级别。 using声明语句不能指定explicit或constexpr。 当一个基类构造函数含有默认实参时，这些实参并不会被继承。派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。 15.8 容器与继承 容器不能直接存放继承体系中的对象，通常采用间接存储的方式。因为当我们把基类存储到一个容器中，当存入派生类对象，实际存入的只是派生类中基类的部分，显然不符合我们的需要。所以我们希望在具有继承关系的对象时，实际上存储的是基类的指针。（最好使用智能指针） 15.9 文本查询程序再探 ","date":"2017-09-19","objectID":"/posts/language/cpp/cpp_primer_ch15/:0:0","tags":["C++"],"title":"《c++primer》ch15-面向对象程序设计","uri":"/posts/language/cpp/cpp_primer_ch15/"},{"categories":["C++"],"content":"通过定义的五种特殊的成员函数，控制类的对象在拷贝。赋值、移动或销毁时做什么。包括：拷贝构造函数、拷贝赋值运算符、拷贝赋值运算符、移动赋值运算符以及析构函数。 13.1 拷贝、赋值、销毁 13.6 对象移动 在旧标准的标准库中，容器中所保存的类必须是可以拷贝的，新标准中，可以在容器中保存不可拷贝的类型，只要他们能够被移动就可以。 13.6.1 右值引用 通过\u0026\u0026来获得右值引用，意为绑定到右值的引用。 ** 重要性质：只能绑定到一个将要销毁的对象。** ** 所引用的对象将要被销毁，该对象没有其他用户** – 左值引用：返回左值引用的函数，赋值、下标、解引用、前置递增/递减运算符。 – 右值引用：返回非引用的函数，算数、关系、位以及后置递增/递减运算符。 区分的方法：一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。右值引用比较 ** move函数(utility头文件中)** int \u0026\u0026rr3=std::move(rr1); //相当于告诉编译器，我们希望像处理右值一样处理左值rr1。 //调用move后，除了赋值和销毁rr1外不会再使用它 //使用move直接用std::move 移动构造函数和移动赋值运算符 目的：让类支持移动操作。 移动构造函数：第一个参数是一个该类类型的右值引用，任何其他额外的参数都要有默认实参。不需要分配新内存，直接接管原来的内存。不会跑异常，不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。（原因是标准库很多对于存在异常的处理方式，例如vector） 移动赋值运算符：首先要处理自赋值的情况。（为什么检查自赋值？因为右值可能是move调用返回的结果，不能在使用右侧运算符对象之前释放左侧运算对象的资源。） ** 如果类有拷贝构造函数和拷贝赋值运算符，没有定义移动操作时，编译器不会为其分配默认的移动操作，而是会采用对应的拷贝进行代替。如果没有定义任何的拷贝操作，才会为其合成移动构造函数或移动赋值运算符。** 移动操作不会被隐式的定义为删除的操作,定义为删除元素的原则： 有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或有类成员未定义自己的拷贝构造函数且编译器不能为其合成默认移动构造函数 有类成员的移动构造函数或移动赋值运算符被定义为删除的或不可访问的 类的析构函数被定义为删除的 有类成员是const的或是引用 ** 三/五法则 **： 通常，拥有一个资源的类，必须定义拷贝构造函数、拷贝赋值运算符、析构函数才能工作，而由于大量的拷贝会影响资源的额外开销，定义移动构造函数和移动赋值运算符可以避免此类问题。 13.6.1 右值引用和成员函数 区分移动和拷贝的重载函数通常有一个版本接受const T\u0026，另一个版本接受一个T\u0026\u0026。很多时候它们看起来调用的是一个函数，通常它们内部的构造也很接近，有一点差别。我们可以根据实参的类型进行判断，我们用的是左值和右值区分调用的版本。 有的时候我们想要避免对右值进行赋值（在旧的标准中是有可能发生的，并且新的标准为了向后兼容没有禁止），可以在参数列表后放置一个** 引用限定符**。还可以通过使用\u0026或者\u0026\u0026指出指向一个左值或者一个右值。eg: class Foo{ public: Foo \u0026operator=(const Foo\u0026) \u0026; //只能向可修改的左值赋值。 } 引用限定符可以区分重载版本，如同const可以用来区分一个成员函数的重载版本。一般当我们定义两个或两个以上的具有相同名字和相同参数列表的成员函数，就必须对所有函数加上引用限定符，或者都不加。 class Foo{ public: Foo sorted() \u0026\u0026; Foo sorted() const; //错误，需要加上引用限定符 ///////////////// Foo sorted(Comp*); Foo sorted(Comp*) const; //正确，两个版本都没有引用限定符 } ","date":"2017-09-14","objectID":"/posts/language/cpp/cpp_primer_ch13/:0:0","tags":["C++"],"title":"《c++primer》ch13 拷贝控制","uri":"/posts/language/cpp/cpp_primer_ch13/"},{"categories":["C++"],"content":"ch14 重载运算与类型转化 当运算符作用于类的对象的时，通过重载运算符，使不同的运算符对于不同的类有着特定的含义，一方面能够简化类的使用者的逻辑，另一方面也能是程序更易于编写和阅读，而不至于编写更多的函数。 14.1 基本概念 重载的运算符是特殊的函数：由operator关键字加上要定义的运算符号共同组成。作为函数，也包含返回类型、参数列表和函数体。参数列表个数与该运算符作用的算数对象数量一样多。 不应该被重载的运算符：逻辑与、逻辑或、逗号运算符、取地址运算符。 定义成成员还是非成员的判断： 赋值、下标、调用、成员访问箭头等运算符必须是类的成员。 复合赋值运算符一般是类的成员 递增、递减、解引用等运算符。通常是类的成员 具有对称性的运算符可能转换任意一端的运算对象。如算数、相等性、关系、位运算符，通常应该是普通的成员函数。 14.2 输入输出运算符 输出的运算符尽量减少格式化操作，只需要打印信息就可以了。 输入输出运算符必须是非成员函数。 输入时可能会发生错误，例如：当流含有错误类型的数据时读取可能失败，当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。所以在输入操作中，输入运算符应该负责读取错误发生时，从错误中恢复。 14.3 算术和关系运算符 代码的解释： Sales_data operator-(const Sales_data \u0026lhs,const Sales_data \u0026rhs){ Sales_data item=lhs; item-=rhs; //调用重载的-=运算符来定义。性能相同，只是增加代码的 复用，增加可读性 return item; } ** 相等运算符的定义：如果定义了==，那么这个类也要定义!=（因为对于用户来说，当他们使用了==时，他们应该也希望能使用!=），并且相等运算符和不相等运算符的一个应该把工作委托给另外一个，这样一个预算负责实际比较，另外一个负责调用。 ** 关系运算符:一般定义了相等运算符后，也会定义关系运算符，特别是\u003c运算符。 关系运算符的原则：如果存在唯一逻辑可靠的\u003c定义，就考虑定义\u003c运算符。如果该类同时包含==运算符，则当且仅当\u003c的定义与==产生一致的结果时才定义\u003c运算符。 14.4 赋值运算符 赋值运算符=和符合赋值运算符+=，通常都定义为类的成员，并且都应该返回左侧运算对象的引用。 14.5 下标运算符 当我们需要按元素在容器中的位置访问元素时，通常定义一个下标运算符operator[]，必须是成员函数。通常会定义两个版本，一个返回普通引用，一个返回常量引用。 14.6 递增和递减运算符 后置运算符接受一个额外的（不被使用）int类型的形参，当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参 。前置运算符返回递增或者递减后的对象的引用，后置运算符返回对象的原值（即递增或递减之前的原值），返回的是一个值而非引用。 class StrBlobPtr{ public: StrBlobPtr\u0026 operator++(); //前置递增运算符 StrBlobPtr\u0026 operator++(int); //后置递增运算符 } ... p.operator++(0); //显式的调用后置递增运算符 p.operator++(); // 显式的调用前置递增运算符 14.7 成员访问运算符 箭头运算符必须是类的成员，解引用运算符通常也是类的成员，即使并非必须这么做。 箭头运算符永远不能丢掉成员访问的这个基本含义，当我们重载箭头运算符时，可以改变的是从哪个对象中获取成员，而获取成员这一事实永远不变。 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。 14.8 函数调用运算符 如果类重载了函数调用运算符，我们就可以像调用函数一样使用该类的对象。函数调用运算符必须是成员函数，一个类可以定义多个函数运算符，之间用参数的数量和类型进行区分。 函数对象通常作为泛型算法的实参 lambda表达式：当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在这个类中，含有一个重载的函数调用运算符。捕获的对象相当于类内含有数据成员。是否含有默认/移动构造函数通常视捕获的对象而定。 标准库定义了一组表示算数运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。 标准库规定其函数对象对于指针同样适用。eg: vector\u003cstring *\u003e nameTable; sort(nameTable.begin(),nameTable.end(), [](string *a,string *b){return a\u003cb}); //错误，nameTable中的指针之间没有关系，所以\u003c将产生未定义的行为 sort(nameTable.begin(),nameTable.end(),less\u003cstring* \u003e()); //正确 C++中的** 可调用对象**：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。可调用的对象也有类型。 不同类型可能具有相同的调用形式，可以定义一个** 函数表用于存储指向这些可调用对象的“指针”。 ** 标准库function类型：是一个模板，当创建具体的function类型时，需要我们提供额外的信息。eg：function\u003cint (int,int)\u003e表示接受2个int、返回1个int的可调用对象。不能直接将重载函数的名字存入function类型的对象中，可存储函数指针而不是函数的名字。 14.9 重载、类型转换与运算符 ** 转换构造函数和类型转换运算符共同定义了类类型转换，有时也被称作用户定义的类型转换。 operator type() const; //type表示某种类型因为类型转换运算符是隐式执行的，所以无法传递实参，也不能定义形参。为了避免具有误导性的类型转换，在不存在明显映射关系的时候，应不适用。 显式的类型转换运算符。eg:explicit operator int() const;当类型转换运算符是显式的，必须通过显式的强制类型转换才可以。 如果表达式被用作条件，编译器会显式的自动转换。** 无论我们什么时候在条件中使用了流对象，都会使用为IO类型定义operator bool。 struct Integral{ operator const int(); //将对象转换成 const int operator int() const; //将对象转换成 int，用的相对较多 } 应该避免使用二义性的类型转换，总体原则：除了显式的向bool类型的转换外，应该尽量避免定义类型转换函数，并且尽可能限制某些看起来显然正确的显式构造函数。 错误eg：定义了两种将B类转换为A类的方法，一种使用B的类型转换运算符，一种使用A的以B为参数的构造函数。 不要另两个类执行相同的类型转换。 避免转换目标是内置算数类型的类型转换。 函数重载的类型匹配：当调用重载函数时，如果两个或多个用户定义的类型转换都提供了可行的匹配，那么这些类型转换被认为一样好。这意味着我们设计的不足。 ","date":"2017-09-14","objectID":"/posts/language/cpp/cpp_primer_ch14/:0:1","tags":["C++"],"title":"《c++primer》ch14 重载运算符和类型转换","uri":"/posts/language/cpp/cpp_primer_ch14/"},{"categories":["C++"],"content":" 类是面向对象编程的基础，使用类定义自己的数据类型，可以更方便的解决问题中的各种概念，使我们更容易编写、调试和修改程序。 ","date":"2017-06-27","objectID":"/posts/language/cpp/cpp_primer_ch7/:0:0","tags":["C++"],"title":"《c++primer》ch7 类","uri":"/posts/language/cpp/cpp_primer_ch7/"},{"categories":["C++"],"content":"7.1 定义抽象的数据类型 定义在类内部的函数时隐式的inline函数。 类的所有成员都必须在类的内部声明，但是成员函数体可以定义在类的内部或外部。 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。 成员函数体可以随意使用类中的其他成员而不需要在意这些成员出现的次序。 构造函数 编译器创建的构造函数又被称为合成的默认构造函数，合成的默认构造函数初始化类的数据成员规则为：存在类内初始值的时候，用它来初始化成员；否则，默认初始化该成员。 对于一个普通的类，一般要定义自己的默认构造函数： 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。 对于某些类来说，合成的默认构造函数可能执行错误的操作。 有的时候编译器不能为某些类合成默认的构造函数。 构造函数没有返回类型。 拷贝。赋值和析构 除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象的时候发生的行为。 当我们不主动定义这些操作的的时候，编译器将替我们合成他们。但是有些类不能依赖于合成的版本。当类需要分配类对象之外的资源时，合成的版本常常会失效。 ","date":"2017-06-27","objectID":"/posts/language/cpp/cpp_primer_ch7/:0:1","tags":["C++"],"title":"《c++primer》ch7 类","uri":"/posts/language/cpp/cpp_primer_ch7/"},{"categories":["C++"],"content":"7.2 访问控制与封装 在类的定义中，可以包含0个或多个访问说明符，每个访问说明符指定接下来的成员访问级别，一般来说，作为接口的一部分，构造函数和一部分成员函数应该定义在public说明符之后，而数据成员和作为实现部分的函数跟在private说明符之后。 class和struct唯一的区别是默认访问权限不同。 ","date":"2017-06-27","objectID":"/posts/language/cpp/cpp_primer_ch7/:0:2","tags":["C++"],"title":"《c++primer》ch7 类","uri":"/posts/language/cpp/cpp_primer_ch7/"},{"categories":["C++"],"content":"7.3 类的其他特性 类型成员、类的成员的类内初始值、可变数据成员、内联数据成员、从成员函数返回*this、关于如何定义类类型及友元类等。 类成员 除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制。 令成员作为内联函数 在类中，一些规模较小的函数常被定义为内联函数 两种方式：1、直接把函数定义放在类的内部 2、把函数定义放在类的外部，显式的使用inline 一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。 在实践中，设计良好的代码常常包含很多的小函数，通过调用这些小函数，可以完成其他一组函数的“实际”工作。 类类型 对于一个类来说，它的成员和其他任何类的成员都不是一回事。 类的声明：不完全类型的使用：可以定义指向这种类型的指针或引用，也可以声明（但不能完全定义）以不完全类型作为参数或者返回类型的函数。 友元 如果一个类指定了友元类，则友元类的成员函数可以访问此类中包括非公有成员在内的所有成员。 还可以另一个类的成员函数为自己的友元。 如果一个类想把一组重载函数声明称它的友元，需要对每一个分别声明。 友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。 ","date":"2017-06-27","objectID":"/posts/language/cpp/cpp_primer_ch7/:0:3","tags":["C++"],"title":"《c++primer》ch7 类","uri":"/posts/language/cpp/cpp_primer_ch7/"},{"categories":["C++"],"content":"类的作用域 一个类就是一个作用域 函数的返回类型通常出现在函数名之前，所以返回类型是在类的作用域外的。 名字查找规则：首先名字所在快寻找声明语句；查找外层作用；报错。 构造函数再探 如果成员是const或引用的话，必须进行初始化；当成员属于某种类类型且该类没有定义构造函数时，也必须初始化。 使用构造函数初始值：不仅仅是底层效率的问题。另有一些数据成员必须被初始化。 成员初始化顺序：构造函数初始化列表值说明用于初始化成员的值，而不限定初始化的具体执行顺序。（尽量按照顺序初始化，并且避免使用某些成员初始化其他成员） 委托构造函数： 默认构造函数的作用：当对象被默认初始化或值初始化时自动执行默认构造函数 默认初始化发生: 块作用域内不适用任何初始值定义一个非静态变量或数组时。 一个类本身含有类类型的成员且使用合成的默认构造函数。 类类型的成员没有在构造函数初始值列表中显式的初始化。 值初始化发生： 数组初始化时提供的初始值数量小于数组的大小 不使用初始值定义一个局部的静态变量 书写形如T()的表达式显式的请求值初始化 隐式的类类型转换：能通过一个实参调用的构造函数定义一条从构造函数的参数类型向类类型隐式转换的规则： string null_book=\"2132321\"; item.combine(null_book);//将一个string的实参传递给了combine成员。 隐式类型转换只能一步，可以使用explicit阻止隐式类型转换。 字面值常量类至少提供一个constexpr构造函数 ","date":"2017-06-27","objectID":"/posts/language/cpp/cpp_primer_ch7/:0:4","tags":["C++"],"title":"《c++primer》ch7 类","uri":"/posts/language/cpp/cpp_primer_ch7/"},{"categories":["C++"],"content":"类的静态成员 ","date":"2017-06-27","objectID":"/posts/language/cpp/cpp_primer_ch7/:0:5","tags":["C++"],"title":"《c++primer》ch7 类","uri":"/posts/language/cpp/cpp_primer_ch7/"},{"categories":["C++"],"content":" 不管学习什么语言都会有这么一章，不管是c、java、Python，这都是会经历的一章，唉，无奈当时年少无知不止梦想是什么的我每每看到这些的时候都觉得很烦。当再一次翻开c++的这一章的时候，也有这样的感觉，似曾相识燕归来，却又无可奈何花落去。 我认为这一章的很多都不是需要太多的去深究，只需要有个大概的概念，然后更多的是在今后的编程过程中，不断的实践自然就知道了，是怎样写的。而且累死一些优先级的问题，更多的时候就像书里建议的那样，一个括号来的简单粗暴实用的多，所以，这章，就记一下实在有违常规的理解的内容吧。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:0","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":"4.1 基础 运算对象转换：小整数类型（如bool、char、short等）通常会被提升为较大的整数类型，主要是int。 左值和右值：一个左值表达式的求值结果时一个对象或者一个函数，以常量对象为代表的某些左值不能作为赋值语句的左侧运算对象。** 简单归纳：当对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置） ** 左值右值使用原则：需要右值的地方可以用左值代替，但是不能把右值当成左值使用。当一个左值被当成一个右值使用的时候，实际上使用的是它的内容（值 ） 需要用到左值的地方： 1.赋值运算符。需要左值作为其左值运算对象，得到结果仍然是一个左值 2.取地址符。返回一个指向该运算对象的指针，这个指针是一个右值 3.内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值 4.内置类型和迭代器的递增递减运算符作用于左值运算对象，得到的结果是左值。 关键字decltype中左值和右值的不同 处理复合表达式的经验：使用括号；如果改变了某个运算对象的值，就不要在表达式的其它地方再使用这个运算对象 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:1","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":"4.2 算数运算符 溢出的情况，值会发生“环绕” ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:2","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":"4.3 逻辑和关系运算符 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值作为运算对象 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:3","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":"4.4 赋值运算符 赋值运算满足右结合律 参与连续赋值的变量必须是相同的类型 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:4","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":"4.5 递增和递减运算符 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:5","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":"4.6 成员访问运算符 解应用运算符的优先级低于点运算符 cond?expr1:expr2; //输出表达式中使用条件运算符 cout\u003c\u003c((grade\u003c60)?\"fail\":\"pass\"); //输出pass或者fail 条件运算符可以嵌套，一般为了代码的可读性，嵌套不要超过三层。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:6","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":"4.7 sizeof运算符 sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得值是一个size_t类型的常量表达式 sizeof(type) sizeof expr ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:7","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":"4.10 逗号运算符 首先对左侧表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:8","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":"4.11 类型转换 发生隐式类型转换 比int小的整形值首先提升为较大的整数类型 条件中，非bool值转为bool值。 初始化过程中，初始值转化为变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型 如果算数预算或关系运算对象有多种类型，需要转换成同一种类型。 函数调用时，也可能发生类型转换 显示转换 cast-name\u003ctype\u003e(expression) cast-name:static_cast,dynamic_cast,const_cast,reinterpret_cast static_cast:任何具有明确定义的类型转换，只要不包含底层const都可以使用。 const_cast:只能改变运算对象的底层const dynamic_cast：支持运行时类型识别 reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释。（使用起来非常危险） ** 尽量避免强制类型转换 ** ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch4/:0:9","tags":["C++"],"title":"《c++primer》ch4 表达式","uri":"/posts/language/cpp/cpp_primer_ch4/"},{"categories":["C++"],"content":" 涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。 6.1 函数基础 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:0:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"形参和实参： 实参是形参的初始值，函数的形参列表可以为空。 局部静态对象，定义成static类型，在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。 6.2 参数传递 如果形参是引用类型，它将绑定到对应的实参上，称为引用传递；否则，将实参的值拷贝后赋给形参，称为值传递。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:1:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"6.2.1 传值参数 将实参的值拷贝给形参。当是指针形参时，指针的行为和其他非引用类型一样，执行指针拷贝类型时，拷贝的是指针的值。拷贝之后是不同的指针，但是指向的是相同的值，我们可以在函数中修改指针所指对象的值。在C++中，建议使用引用类型的形参替代指针。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:2:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"6.2.2 传引用参数 ** 1.使用引用避免拷贝。 **因为有的类类型是不能拷贝的，或者在拷贝一些大的类类型对象或者容器对象比较低效。 如果函数不需要改变引用参数的值，最好将其声明为常量引用。 ** 2.使用引用形参返回额外信息。**由于函数不能有多个返回值，在我们需要返回多个值的时候，可以额外传一个引用参数。 ** 3.可以直接操作引用形参所引的对象。 ** ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:3:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"6.2.3 const形参和实参 和其它初始化一样，当用实参初始化形参时会忽略掉顶层const。也就是，形参的顶层const会被忽略掉。（这个可以思考一下，我们可以通过形参的const在参数中控制是否需要改变形参，以及对应的实参，这样更方便我们传参数。当然有了这个我们就不能重载有无const的两个函数了，因为会被编译器相同对待。） 尽量使用常量引用，除了在使用的时候，无法把常量引用初始化为引用（很简单的道理），另外，也会给调用者一种误导。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:4:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"6.2.4 数组形参 无法以值传递的方式使用数组参数。数组的特点：不允许拷贝、使用数组会将其转化为指针。 void print(const int*); void print(const int[]); void print(const int[10]); //这里的维度表示我们期望数组含有多少个元素，实际不一定 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:5:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"关于数组长度 由于传递数组引用的时候，只是数组的首元素指针，所以有时候我们需要在形参定义的时候，就将数组大小传递给形参。这里有几种方式。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:5:1","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"6.2.5 mian处理命令行选项 当使用argv[]中的实参时，第一个实参保存的是程序名，所以应该从第二个开始。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:6:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"6.2.6 含有可变形参的函数 有时候我们预先不知道向函数传递几个实参。1.如果所有的实参类型相同，可以传递名为initializee_list的标准库类型；2.如果实参类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。 6.3 返回类型和return语句 return语句终止当前执行的函数，并将控制权返回到调用该函数的地方。 return语句不要返回局部对象的引用或引用（因为局部对象会在函数调用完成后删除，会产生未定义的结果）。 c++11新标准中函数可以返回花括号包围的值列表，主函数main的返回值，非0的返回值由机器决定。 6.4 函数重载 拥有顶层const不影响传入函数的对象。另外，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。 不能仅仅通过函数的返回值区分两个同名的函数 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:7:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"重载与作用域 一般来说，将函数声明置于局部作用域内不是一个明智的选择。在不同的作用域中无法重载函数名。 在c++中，名字查找发生在类型检查之前。 6.5 特殊用途语言特性 大多数程序都有用的特性：默认实参、内联函数、constexpr函数。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:8:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"默认实参 一旦某个形参赋予了默认值，后面的所有形参必须有默认值。函数调用时，实参按其位置进行解析，只能省略尾部的实参。 一个函数被声明多次的时候，在给定的作用域中一个形参只能被赋予一次默认实参，也就是函数的后续声明。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:9:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"内联函数inline 将它在每个调用点上“内联的”展开，一般来说用于优化规模较小、流程直接、频繁调用的函数。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:10:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"constexpr函数 constexpr函数指能用于常量表达式的函数。函数的返回值及所有形参的类型都得是字面值类型，并且函数体中必须有且只有一条return语句。 编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式的指定 为内联函数. 内联函数和constexpr函数通常定义在头文件中. ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:11:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"调试帮助 assert预处理宏,以一个表达式作为条件. 我们可以使用一个#define 语句定义NDEBUG，关闭调试状态 6.6 函数匹配 当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换得来时。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:12:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"确定候选函数和可行函数 函数匹配第一步：选定本次调用对应的重载函数集。 候选函数的两个特征：与被调用的函数同名，其声明在调用点可见。 第二步考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:13:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"实参类型转换 确定最佳匹配的排序： 1.精确匹配：实参形参类型相同，实参从数组或函数类型转化为对应的指针类型，实参添加顶层const或者从实参中删除顶层const。 2.通过const转换实现的匹配。 3.通过类型提升实现的匹配。 4.通过算术类型转换或指针转换实现的匹配。 5.通过类类型转换实现的匹配。 6.7 函数指针 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:14:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"重载函数的指针 编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:15:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"函数指针形参 和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上是被当成指针使用。 可以直接把函数当成实参使用，会自动转换成指针。 ","date":"2017-06-05","objectID":"/posts/language/cpp/cpp_primer_ch6/:16:0","tags":["C++"],"title":"《c++primer》ch6 函数","uri":"/posts/language/cpp/cpp_primer_ch6/"},{"categories":["C++"],"content":"数据类型决定了程序中数据和操作的意义。 2.1 基本内置类型 基本数据类型：** 算数类型 空类型（void） **,其中算数类型包括：字符、正整数、布尔值、浮点数。空类型不对应具体的值，用于一些特殊的场合。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:0:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.1.1 算数类型 分为整形和浮点型。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:1:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"整形： bool:取值为true或者false。 char：基本的字符类型，一个char的大小与一个机器字节一样。 wchar_t,char16_t,char32_t ** rules: **一个int至少和一个short一样大，一个long至少跟一个int一样大，一个long long至少跟一个long一样大。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:1:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"浮点型： float：一般一个字，32bit double：2个字，64bit long double：3或4个字，96或128bit ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:1:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"带符号类型和无符号类型 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:1:3","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.1.2 类型转换 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:2:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"转换过程： 非bool到bool：初始为0则为false，其他为true bool到非bool：初始值为false则为0，初始值为true为1 浮点数到整型：仅保留浮点数中的** 小数点部分 ** 整数到浮点数：小数部分记为0，如果整数所占的空间超过浮点类型的容量，会报错。 赋给无符号类型，当超出它表示范围的时候，转换为该无符号类型表示数值总数取模后的余数。 给带符号的数输出超过范围的值是，结果时** 未定义的 ** tips:一般不在算数表达式中使用bool值 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:2:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"含有无符号类型的表达式 一般不要混用无符号和有符号的类型，当无符号超过范围时，可能会出现取模的情况，放在循环中，或者计算结果中，会产生无法预计的结果 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:2:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.1.3 字面值常量 顾名思义，字面值常量一望而知。每个字面值常量对应一种数据类型，字面量常量得形式和值决定了它的数据类型。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:3:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"整型和浮点型字面值 严格来说，十进制字面值不会是负数，通常，负号并不在字面值内，它的作用仅仅是对字面值取负值而已。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:3:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"字符和字符串字面值 char型字面值：由单引号括起来的一个字符 字符串字面值：由双引号括起来的零个或多个字符 ** Note：字符串字面值的类型实际上是由常量字符组成的数组，编译器在每个字符串的结尾处添加一个空字符（’\\0’），字符串的字面值的实际长度比它的内容多1。 ** ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:3:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"转义序列 有两类不能直接使用的字符。不可打印的和特殊含义的字符（单引号，双引号，问号，反斜线），这些情况下需要使用转义字符。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:3:3","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"指定字面值类型 添加一定的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。前缀有：u（Unicode16）、U（Unicode32）、L（宽字符）、u8（UTF-8）。后缀有：u或者U（unsigned）、l或者L（ling）、ll或者LL（long long），f或者F（float）、l或者L（long double）。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:3:4","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"布尔字面值和指针字面值 bool：true、false 指针：nullptr 2.2 变量 对于c++来说，一般“变量”和“对象”可以互换使用。对象时具有某种数据类型的内存空间。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:3:5","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.2.1 变量定义 基本形式：类型说明符+一个或多个变量名组成的列表（变量名以逗号分隔）+分号 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:4:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"初始值 当对象在创建时获得了一个特定的值，称为被初始化了。** 初始化和复制是两个完全不同的操作，注意这个概念很重要 ** 初始化：在创建变量是赋予其一个初始值。 复制：把对象的当前值擦除，以一个新的值代替。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:4:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"列表初始化 无论是初始化对象还是某些时候为对象赋新值，都可以使用一组又花括号括起来的初始值。 int units_sold=0; int units_sold={0}; int units_sold{0}; int units_sold(0); ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:4:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"默认初始化 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式的初始化，则其值由类确定。。建议初始化每一个内置类型的变量。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:4:3","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.2.2 变量声明与定义的关系 声明使得名字为程序所知，定义负责创建与名字关联的实体。 ** extern **关键字：如果想声明一个变量而不是定义它，就在变量名前添加extern，而不显示的初始化变量。如果在函数体内部试图初始化一个有extern关键字标记的变量，会引发错误。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:5:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.2.3 标识符 用户自定义的标识符中不能出现两个连续的下划线，也不能以下划线紧连大写字母开头。定义在函数体内的标识符不能以下划线开头。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:6:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"变量命名规范 标识符要能体现实际含义 变量名一般小写字母 自定义的类名一般大写字母开头 标识符由多个单词组成时，单词应有明显区分，使用下划线 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:6:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.2.4 名字的作用域 当内层出现与外层相同的名字时，使用内层定义的名字。 2.3 复合类型 复合类型指的是基于其他类型定义的类型。这里介绍两种：引用和指针。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:7:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.3.1 引用 引用为对象起了另外一个名字，引用；类型引用另外一种类型。通过将生命符写成\u0026d的形式来定义引用类型，其中d是声明的变量名。引用必须初始化。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:8:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"引用即别名 引用并不是对象，只是一个已经存在的对象起的另外一个名字。定义了一个引用之后，对其做的所有操作都是在与之绑定的对象上进行的。 因为引用本身只是一个别名，不是一个对象，所以不能定义引用的引用。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:8:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"引用的定义 除了两种例外的情况，其他所有的引用类型都要与之绑定的对象严格比配。 引用只能绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:8:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.3.2 指针 指针是“指向point to”的另外一种类型的复合引用。指针也实现了对其他对象的间接访问。 两者的不同点： 1.指针本身就是一个对象，允许对指针赋值和拷贝，而且指针的生命周期内可以指向多个不同的对象。 2.指针无需在定义时赋初值。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:9:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"获取对象的地址 指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符\u0026） 不能定义指向引用的指针（因为引用不是一个对象）。 除了两种例外的情况，所有指针的类型都要和它指向的对象严格匹配。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:9:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"指针值 指针的值（即地址）应该属于下面四种状态之一： 1.指向一个对象 2.指向紧邻对象所占空间的下一个位置 3.空指针，表示没有指向任何对象。 4.无效指针，上述之外的其他值。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:9:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"利用指针访问对象 如果指针指向了一个对象，允许使用解引用符（操作符*）来访问对象。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:9:3","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"空指针 空指针不指向任何对象，得到空指针的办法：直接用字面值nullptr初始化指针或者将指针初始化为字面值0来生成空指针。 ** 建议 **：初始化所有指针 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:9:4","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"赋值和指针 记住赋值永远改变的是等号左侧的对象。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:9:5","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"其他指针操作 只要一个指针拥有合法值，就能将它用在条件表达式中，只要不为空，条件都为true。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:9:6","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"void* 指针 void* 是一种特殊的指针类型，可用于存放任意对象的地址。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:9:7","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.3.3 理解复合类型的声明 变量的定义包括：一个基本数据类型+一组声明符。基本数据类型只有一个，但是声明符的形式可以不同。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:10:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"指向指针的指针 当有多个修饰符连写在一起的时候，按照逻辑关系解释。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:10:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"指向指针的引用 引用本身不是对象，但是指针是对象，所以可以对指针引用。 面对一条复杂的指针或引用的声明语句时，从右向左阅读有助于弄清真实含义。 2.4 const限定符 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:10:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"初始化和const const与非const对象的区别就是，const类型的对象执行不改变起内容的操作。如：const int也能像int一样参与算术运算，也能转化为bool值。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:10:3","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"默认状态下，const对象仅在文件内有效 如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:10:4","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.4.1 const的引用 可以把引用绑定到const对象上，就像绑定到其他对象上一样，称为对常量引用，对常量的引用不能修改它所绑定的对象。 ** 术语：常量引用是对const的引用 **：并不存在常量引用，是对const的引用。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:11:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"初始化和对const的引用 引用情况的例外：第一种是，在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:11:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"对const的引用可能引用一个非const的对象 此种行为是合法的，但是不能通过对const的引用改变对象的值，兑现可以通过其他的方式改变值。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:11:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.4.2 指针和const 指向常量的指针不能改变其所指对象的值，要想存放常量对象的地址，只能只用指向常量的指针。 所谓指向常量的指针和引用，只是自以为指向了一个常量，所以自觉不去改变所指对象的值。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:12:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"const指针 *const：不变的是指针的值而不是指向的那个值。采用从右向左的方式阅读，看离最近的符号。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:12:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"顶层const 顶层const表示指针本身是个常量，底层const表示指针指的对象是一个常量。 当对象执行拷贝操作时，顶层const不受影响，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转化。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:12:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.4.4 constexpr和常量表达式 常量表达式指：值不会改变且在编译过程就能得到计算结果的表达式。（字面值、用常量表达式初始化的const对象） ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:13:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"constexpr变量 声明为constexpr的变量一定是一个变量，且必须用常量表达式初始化。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:13:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"字面值类型 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:13:2","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"指针和constexpr 在constexpr如果定义了一个指针，则constexpr只对指针有效，与指针所指的对象无关。 2.5 处理类型 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:13:3","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.5.1 类型别名 类型别名是一个名字，是某种类型的同义词。使用方式： typedef double wages //wages 是double的别名 typedef wages base,*p #别名声明 using SI=Scales_item; ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:14:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"指针、常量和类型别名 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:14:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.5.2 auto类型说明符 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:15:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"复合类型、常量和auto 引用时的auto，以引用对象的类型作为auto的类型 auto一般会忽略掉顶层const，底层const会保留下来。 可以将引用的类型设为auto ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:15:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"2.5.3 decltype类型指示符 选择并返回操作数的类型，编译器分析表达式并得到类型，但并不实际计算值 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:16:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"decltype和引用 有些表达式将向decltype返回一个引用类型。如果表达式的内容是解引用操作，则decltype将得到引用类型。 解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。 decltype和auto的重要区别：decltype的结果类型与表达式形式密切相关。 ** 如果给变量加上一层或多层括号，decltype就会得到引用类型。decltype((val))的结果永远是引用，decltype(val)只有当val本身是一个引用时才是引用。另外，赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型 ** 2.6 自定义数据结构 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:16:1","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"定义自己的数据结构 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:17:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"定义自己的头文件 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:18:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"预处理器 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch2/:19:0","tags":["C++"],"title":"《c++primer》ch2 变量和基本类型","uri":"/posts/language/cpp/cpp_primer_ch2/"},{"categories":["C++"],"content":"第3章 字符串、向量和数组 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:0:0","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.1 命名空间的using声明 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:1:0","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"每个名字都需要独立的using声明 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:1:1","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"头文件中不应该包含using声明 因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:1:2","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.2 标准库类型string ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:2:0","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.2.1 定义和初始化string对象 string s1; //默认初始化 string s2=s1; //s2是s1的副本 string s2(s1); //等价于string s2=s1,s2是s1的副本 string s3=\"hiya\"; //s3是字面值的副本，但是不包含字面值最后的那个空字符 string s3(\"hiya\"); //等价于string s3=\"hiya\" string s4(n,'c'); //把s4初始化为连续n个字符c组成的字符串 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:2:1","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.2.2 string对象上的操作 读写string对象 读取未知数量的string对象 使用getline读取一整行 string的empty和size操作 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:2:2","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"string:size_type类型 size_type是一种无符号整形数，如果在表达式中混用了带符号数和无符号数会产生意想不到的后果。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:2:3","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"比较string对象 按字典顺序 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:2:4","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"字面值和string类型相加 //错误的方式 string s=\"hello\"+\",\" //错误，因为两个运算对象都不是string，不能把两个字面值直接相加 string s1=\"hello\"+s1+\",\" //正确 ** 字符串字面值与string是不同的类型 ** ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:2:5","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"ex3.3 string类的输入运算和getline函数分别如何处理字符串 string的标准输入：自动忽略字符串开头的空白，从第一个真正的字符开始读取，直到下一个空白为止 getline函数：从给定的输入流中读取，直到遇到换行符为止。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:2:6","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.3 标准库类型vector vector是一种类模板，需要后加一堆尖括号，在括号内放上信息。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:3:0","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.3.1 定义和初始化vector对象 1.使用拷贝初始化 2.如果提供一个类内的初始值，只能使用拷贝初始化或者花括号形式初始化 3.如果提供的是初始值元素值的列表，则只能使用花括号初始化，而不能使用圆括号 4.创建指定数量的元素：采用圆括号 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:3:1","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.3.2 像vector中添加元素 push_back：像一个值添加到vector的尾部。（如果开始不知道有多少元素，c++中，一般先创建一个空的vector然后像其中添加元素最好） 不能使用下标形式添加元素，只能对确知已存在的元素执行下标操作。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:3:2","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.4 迭代器介绍 迭代器这个名词可能有三种不同的含义：可能是迭代器概念本身，可能是容器定义的类型，还可能指某个迭代器对象。 某些对Vector对象的操作回事迭代器失效：一个是不能在范围for循环内向vector中添加元素，另一个是任何一种可能改变vector对象容量的操作，都有可能是vector对象的迭代器失效。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:4:0","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"迭代器的算数运算 可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。 迭代器之间的比较：参与比较的迭代器必须合法且指向同一个容器的元素（或者尾元素的下一个位置） ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:4:1","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.5 数组 数组与vector的区别：数组的大小确定不变，不能随意像数组中添加元素。性能很好，但是损失了灵活性。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:5:0","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.5.1 定义和初始化数组 数组是一种复合类型，数组的维度必须是一个常量表达式。 定义数组的时候必须指定数组的类型。同时，数组的元素应该为对象，不存在引用的数组。 字符数组的特殊性 char a1[]={'C','+','+'}; //列表初始化，没有空字符 char a2[]={'C','+','+'}; //列表初始化，含有显式的空字符 char a3[]=\"C++\"; //自动添加表示字符串结束的空字符 不允许拷贝和赋值 复杂的数组声明 ** 要想理解数组的声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读 ** int \u0026refs[10]=... // 错误！不存在数组的引用 int (*Parray)[10]=\u0026arr; //Parray指向一个含有10个整数的数组 int (\u0026arrRef)[10]=arr //arrRef引用一个含有10个整数的数组 int *ptrs[10]; //ptrs是一个含有10个整型指针的数组 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:5:1","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.5.2 访问数组元素 数组下标为** size_t类型 **，是一种机器相关的无符号类型。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:5:2","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.5.3 指针和数组 使用数组的时候编译器一般会把它转化成指针 指针也是迭代器 允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上 标准库函数begin和end ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:5:3","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.5.4 C风格字符串 C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。 C风格字符串和字符数组的关系，尤其需要考虑串尾是否含有空字符。 ** 问题：为什么没有指针相加？ ** 指着也是一个对象，与指针有关的属性有三个，分别是指针的值（是一个内存地址值）、指针所指的对象、指针本身在内存中的存储位置。显然把两个地址加在一起是没有意义的。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:5:4","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.5.5 与旧代码的接口 混用string对象和C风格字符串 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（但不能两个都是）；在string对象的赋值运算中允许以空字符串结束的字符数组作为右侧的运算对象。 使用数组初始化vector对象 允许使用数组初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址即可。但不能使用一个数组为另一个内置类型的数组赋初值，也不能使用vector对象初始化数组。 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:5:5","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["C++"],"content":"3.6 多维数组 严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。 当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小。 int ia[3][4] //大小为3的数组，每个元素是含有4个整数的数组 ","date":"2017-06-04","objectID":"/posts/language/cpp/cpp_primer_ch3/:6:0","tags":["C++"],"title":"《c++primer》ch3 字符串、向量和数组","uri":"/posts/language/cpp/cpp_primer_ch3/"},{"categories":["工具"],"content":"如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。 **摘自：https://xuanwo.org/2015/03/26/hexo-intor/ **写的很详细了，就不仔细写一遍了，就当个记录吧，以后出问题了好解决一点。 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:1:0","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"一、准备工作，准备需要准备好以下软件： Node.js环境 Git ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:2:0","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"1.Windows配置Node.js环境下载Node.js安装文件： Windows Installer 32-bit Windows Installer 64-bit 根据自己的Windows版本选择相应的安装文件。 保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口： 在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~） 在打开的命令行界面中，输入 node -v npm -v 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 (https://xuanwo.org/imgs/opinion/Nodejs-test.png) ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:2:1","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"2.配置Git环境下载Git安装文件： Git-2.6.3-64-bit.exe 然后就进入了Git的安装界面，如图： 和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择： 这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。 一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入： git --version 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:2:2","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"二、新建仓库 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:3:0","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"1.打开https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:3:1","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"2.创建代码库登陆之后，点击页面右上角的加号，选择New repository： 进入代码库创建页面： 在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示： 正确创建之后，你将会看到如下界面： 开启gh-pages功能点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图： 点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。 配置Hexo安装Hexo在自己认为合适的地方创建一个文件夹，然后在文件夹空白处按住Shift+鼠标右键，然后点击在此处打开命令行窗口。（同样要记住啦，下文中会使用在当前目录打开命令行来代指上述的操作） 在命令行中输入： npm install hexo-cli -g 然后你将会看到: 可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入 npm install hexo --save 然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入： hexo -v 如果你看到了如图文字，则说明已经安装成功了。 初始化Hexo接着上面的操作，输入： hexo init 如图： 然后输入： npm install 之后npm将会自动安装你需要的组件，只需要等待npm操作即可。 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:3:2","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"首次体验Hexo 继续操作，同样是在命令行中，输入： hexo g 如图： 然后输入： hexo s 然后会提示： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 在浏览器中打开http://localhost:4000/，你将会看到： 到目前为止，Hexo在本地的配置已经全都结束了。 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:4:0","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"使用Hexo 在配置过程中请使用yamllint来保证自己的yaml语法正确 修改全局配置文件此段落引用自Hexo官方文档 您可以在 _config.yml 中修改大部份的配置。 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:5:0","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"网站 参数 | 描述 title | 网站标题 subtitle | 网站副标题 description | 网站描述 author | 您的名字 language | 网站使用的语言 timezone | 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:5:1","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"网址 参数 描述 默认值 url 网址 root 网站根目录 permalink文章的 永久链接 格式:year/:month/:day/:title/permalink_default永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录参数描述默认值source_dir资源文件夹，这个文件夹用来存放内容。sourcepublic_dir公共文件夹，这个文件夹用于存放生成的站点文件。publictag_dir标签文件夹tagsarchive_dir归档文件夹archivescategory_dir分类文件夹categoriescode_dirInclude code 文件夹`downloads/codei18n_dir国际化（i18n）文件夹:langskip_render跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 文章参数描述默认值new_post_name新文章的文件名称:title.mddefault_layout预设布局postauto_spacing在中文和英文之间加入空格falsetitlecase把标题转换为 title casefalseexternal_link在新标签中打开链接truefilename_case把文件名称转换为 (1) 小写或 (2) 大写0render_drafts显示草稿falsepost_asset_folder启动 Asset 文件夹falserelative_link把链接改为与根目录的相对位址falsefuture显示未来的文章truehighlight代码块的设置 分类 \u0026 标签参数描述默认值default_category默认分类uncategorizedcategory_map分类别名 tag_map标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数描述默认值date_format日期格式MMM D YYYYtime_format时间格式H:mm:ss分页参数描述默认值per_page每页显示的文章量 (0 = 关闭分页功能)10pagination_dir分页目录page扩展参数描述theme当前主题名称。值为false时禁用主题deploy部署部分的设置配置Deployment首先，你需要为自己配置身份信息，打开命令行，然后输入： git config --global user.name \"yourname\" git config --global user.email \"youremail\" 同样在_config.yml文件中，找到Deployment，然后按照如下修改： deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 如果使用git方式进行部署，执行npm install hexo-deployer-git –save来安装所需的插件 然后在当前目录打开命令行，输入： hexo d 随后按照提示，分别输入自己的Github账号用户名和密码，开始上传。 然后通过http://yourname.github.io/来访问自己刚刚上传的网站。 添加新文章打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就能在执行hexo g的时候被渲染。 新建的文章头需要添加一些yml信息，如下所示： title: hello-world //在此处添加你的标题。 date: 2017-5-11 08:55:29 //在此处输入你编辑这篇文章的时间。 categories: Exercise //在此处输入这篇文章的分类。 toc: true //在此处设定是否开启目录，需要主题支持。 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:5:2","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"进阶 如果成功完成了上述的全部步骤，恭喜你，你已经搭建了一个最为简单且基础的博客。但是这个博客还非常简单， 没有个人的定制，操作也比较复杂，下面的进阶技巧将会让你获得对Hexo更为深入的了解。 更换主题可以在此处寻找自己喜欢的主题 下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改： ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:6:0","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["工具"],"content":"Extensions Plugins: http://hexo.io/plugins/ Themes: http://hexo.io/themes/ theme: landscape //themes文件夹中对应文件夹的名称 然后先执行hexo clean，然后重新hexo g，并且hexo d，很快就能看到新主题的效果了~ 更换域名首先，需要注册一个域名。在中国的话，.cn全都需要进行备案，如果不想备案的话，请注册别的顶级域名，可以使用godaddy或新网或万网中的任意一家，自己权衡价格即可。 然后，我们需要配置一下域名解析。推荐使用DNSPod的服务，比较稳定，解析速度比较快。在域名注册商出修改NS服务器地址为： f1g1ns1.dnspod.net f1g1ns2.dnspod.net 以新网为例，首先点击域名管理进入管理页面： 然后点击域名后面的管理： 进入域名管理的操作界面，点击域名管理，来到域名管理界面： 点击修改域名DNS，然后选择填写具体信息，在下面的空框中填入DNSPod的NS服务器： 然后我们进入DNSPod的界面，开始真正进入域名解析的配置= =。在DNSPod中，首先添加域名，然后分别添加如下条目： 最后，我们对Github进行一下配置。 在自己本地的hexo目录下的source文件夹中，新建一个CNAME文件（注意，没有后缀名。），内容为yourdomin.xxx。然后再执行一下hexo d -g，重新上传自己的博客。 在github中打开你自己的库，进入库的setting界面，如果看到了如下提示，说明配置成功了。 在这一系列的操作中，包括修改NS服务器，设置A解析等等，都需要一定的时间。短则10分钟，长则24小时，最长不会超过72小时。如果超过72小时，请检查自己的配置过程，或者修改自己本地的DNS服务器。 ##绑定域名： 有一个简单的办法，当然只是现在作为拥有GitHub学生包才可以用的，打开学生包，通过教育邮箱申请之后，可以在package中找到那么namecheap，注册通过GitHub进入，可以直接申请域名，会自动绑定到我们的gitpage，不过还需要一点点修改，就是把cname的www改成我们的gitpage页面，就可以了。。 ","date":"2017-05-31","objectID":"/posts/tools/hexo+gitpage/:6:1","tags":null,"title":"使用gitpage+Hexo搭建自己的博客","uri":"/posts/tools/hexo+gitpage/"},{"categories":["生活"],"content":"开博客的第一天–谈学习与博客 作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。 那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。 然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99.可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？ 今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。 所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧： When nothing seems to help,I go and look at a stonecutter hammering away at his rock perhaps a hundred times without as much as a crack showing in it.Yet at the hundred and first blow it will split in two,and I know it was not that blow that did it——but all that had gone before. ——Jacob Riis ","date":"2017-05-15","objectID":"/posts/why_blog/:0:0","tags":["日常"],"title":"我为什么写博客","uri":"/posts/why_blog/"},{"categories":["other"],"content":"面向对象编程(二) 封装（private） 匿名对象使用的方式：只调用一次 注意，封装只是私有的一种表现形式。不私有也能封装。 构造函数 构造函数和一般函数在写法上有不同 构造函数在对象一建立就运行， 而一般方法是在对象调用的时候才运行，是给对象添加对象具备的功能。 一个对象建立，构造方法运行 构造代码块 作用：给对象初始化，对象一建立就运行，而且优先于构造函数执行。 和构造函数的区别： 构造代码块是给所有的对象初始化，构造函数是给特定的对象初始化。 构造代码块 中定义的是不同对象共性的特性. this关键字 变量名起的没有意义，可读性非常差 局部变量和成员变量一样了，局部中有就在局部中使用，没有的话就在成员变量中找,将局部的值赋给成员变量，引出了this关键字 this:看上去，是用于区分局部变量和成员变量同名的情况 this到底代表的是什么 this：就代表本类的对象，到底代表哪一个呢？ this代表它所在函数所在对象的引用 简单说：哪个对象在调用this所在的函数，this就代表哪个对象 this关键字在构造函数间的调用 this语句：用于构造函数间互相调用 this语句只能放在构造函数的第一行。因为初始化动作要先执行 不允许死循环调用 面向对象（3） （继承，final，抽象类，接口） ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:0:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"1.继承（概述） 继承： 1.提高了代码的复用性 2.继承让类与类之间有了关系，有了关系才有了多态的特性。 注意：千万不要为了获取其他类的功能，简化代码而继承。 必须是类与类之间有所属关系才可以继承，所属关系 is a。 java语言中：java只支持单继承，不支持多继承。 因为多继承容易带来安全隐患：当多个父类中定义了相同的功能，当功能内容不同时，子类对象不确定要运行哪一个。 但是java保留了这种机制，并用另一种体现形式来完成表示，多实现。 java支持多层继承。 如何使用一个继承体系中的功能？ 想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系的共性功能。 通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了 那么在具体调用时，要创建最子类的对象。 因为：1.可能父类不能创建对象 2.创建子类可以使用更多的功能，包括基本的也包括特有的 简单的说，就是查阅父类，创建子类 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:1:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"2.聚集关系 聚集：has a 聚合： 组合： 子父类出现后，类成员的特点 类成员： 1.变量 2.函数 3.构造函数 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:2:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"3.1.子父类中的变量的特点 如果子类中出现非私有的同名成员变量时，子类要访问本类中的变量，用this super代表的是父类对象的引用 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:3:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"3.2.子父类中的函数的特点 当子类和父类中出现一样的函数时，当子类对象调用该函数，会运行子类函数的内容。如同父类的函数被覆盖一样。 这种情况是函数的另一个特性：重写（覆盖） 当子类继承父类，沿袭了父类的功能，但是功能的内容却和父类不一致。这时没有必要定义新功能，而是使用覆盖特殊，保留父类的功能定义，并重写功能内容。 覆盖： 1.子类覆盖父类，必须保证子类权限大于父类权限，否则编译失败 2.静态只能覆盖静态。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:4:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"3.3.子父类中构造函数的特点–子类的实例化过程 重载：只看重名函数的参数列表。 重写：子类父类方法要一模一样。 子父类中的构造函数： 在对子类对象进行初始化 时，弗父类的构造函数也会运行，那是因为子类的构造函数第一行默认有一条隐式语句super()； super()：会访问父类中空参数的构造函数。而且子类中所有的构造函数默认第一行都是super() 为什么子类一定要访问父类中的构造函数？ 因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要先查看父类如何对这些数据进行初始化的，所以子类在对象进行初始化时，要先访问一下父类中的构造函数 如果要访问父类中指定的构造函数，可以用super语句来指定。 注意：super语句一定定义在子类构造函数的第一行。 子类的实例化过程： 结论：子类所有的构造函数默认都会访问父类中空参数的构造函数，因为子类每一个构造函数的第一行都有一句隐式的super() 当父类中没有空的构造函数时，子类必须手动通过super或者this语句形式来指定要访问父类中的构造函数。 当然：子类中的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:5:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"4.final关键字 final：最终，作为一个修饰符 可以修饰类，函数，变量 被final修饰的类不可以被继承,为了避免被继承，被子类复写功能 被final修饰的方法不可以被复写 被final修饰的变量是一个常量只能赋值一次，既可以修饰局部变量，也可以修饰成员变量。 在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这值起个名字，方便于阅读，而这个值不需要改变，所以加个final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成，单词间通过_连接。 内部类定义在类中的局部位置时，只能访问该局部被final修饰的局部变量。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:6:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"5.抽象类 当多个类中出现相同功能，但是功能的主体不同，这时可以向上抽取，这时只能抽取功能定义，而不抽取功能主题 抽象：看不懂 抽象类的特点： 抽象方法一定在抽象类中。 抽象方法和抽象类都必须被abstract关键字修饰。 抽象类不可以用new创建对象，因为调用抽象方法没意义。 抽象类中的方法要被使用，必须由子类复写起所有的抽象方法之后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。 抽象类和一般类没有太大的不同。 该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。 这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。 抽象类比一般类多了个抽象函数。就是在类中可以定义抽象方法。 抽象类不可以实例化。 特殊：抽象类中可以不定义抽象方法，这样做仅仅是为了不让该类建立对象。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:7:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"6.模板方法设计模式 在定义功能时，功能的一部分是确定的，但是有一部分功能时不确定的，而确定的部分在使用不确定的部分，就将不确定的部分暴露出去， ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:8:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"7.接口 接口：初期理解，可以认为是一个特殊的抽象类 当抽象类中的方法都是抽象的，那么该类可以通过接口的形式实现 class 用于定义类 interface 用于定义接口 接口定义时，格式特点： 接口中常见定义：常量，抽象方法。 接口中的成员都有固定的修饰符。常量：public static final 方法：public abstract 记住，接口中的成员都是public的 接口是不可以创建对象的，因为有抽象方法。 需要被子类实现，子类对接口中的抽象方法全部覆盖后，子类才可以实例化。否则子类是一个抽象类 接口可以被类多实现 接口与接口之间可以多继承 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:9:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"8.接口的特点 接口是对外暴露的规则 接口是程序的程序扩展 接口可以用来多实现 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口 接口与接口之间可以有继承关系 面向对象（4）–多态 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:10:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"多态概念 多态：可以理解为事物存在的多种体现形态 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:11:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"多态的扩展性 多态的体现 父类的引用指向了自己的子类对象 父类的引用也可以接收自己的子类对象 多态的前提 必须是类与类之间有关系，要么继承，要么实现。 通常还有一个前提：存在覆盖 多态的好处 多态的出现大大的提高程序的扩展性 多态的弊端： 提高了扩展性，但是只能用父类的引用访问父类中的成员 多态的应用 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:12:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"多态–转型 向上转型，向上转型 千万不要出现这样的操作，就是将父类对象转换成子类类型。 我们能转换的是父类应用指向了自己的子类对象时，该引用可以被提升，也可以被强制转换。 多态自始至终都是子类对象在做着变化 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:13:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"多态成员的特点 在多态中成员函数的特点： 在编译时期：参阅引用型变量所属的类中是否有调用的方法，如果有，编译通过，如果没有，编译失败。 在运行时期：参阅对象所属的类中是否有调用的方法。 简单总结就是：成员函数在多态调用时，编译看左边，运行看右边。 在多态中，成员变量的特点：无论编译还是运行，都参考左边（引用型变量所属的类）。 在多态中，静态成员函数的特点：无论编译还是运行，都参考左边（引用型变量所属的类）。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:14:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"多态的实例 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:15:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Object类 内部类 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:16:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"内部类访问规则 内部类可以直接访问外部类中的成员，包括私有 之所以可以直接访问外部类中的成员，是因为内部类中持有了 一个外部类的引用，格式：外部类名.this 外部类要访问内部类，必须建立内部类对象。 直接访问内部类中的成员 访问格式： 当内部类定义在外部类的成员位置上，就可以被成员修饰符所修饰。 比如，private：将内部类在外部类中进行封装。 static：内部类就具备static的特性。 当内部类被static修饰后，只能直接访问外部类中的static成员，出现了访问局限。 在外部其他类中，如何访问内部类的非静态成员呢？ ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:17:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"内部类定义的原则 当描述事物时，事物的内部还有事物，该事物用内部类来描述。因为内部事物在使用外部事物的内容。 内部类定义在局部时， 不可以被成员修饰符修饰 可以直接访问外部类中的成员，因为还持有外部类中的引用。但是不可以访问它所在的局部中的变量，只能访问被final修饰的局部变量 、 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:18:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"匿名内部类 匿名内部类其实就是内部类的简写格式 定义匿名内部类的前提：内部类必须是继承一个类或者实现接口。 匿名内部类的格式：new 父类或者接口（）{定义子类的内容} 其实匿名内部类就是一个匿名子类对象，而且这个对象有点胖。可以理解为带内容的对象 匿名内部类中定义的方法最多不要超过三个 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:19:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"异常概述 异常：就是程序在运行时出现不正常的情况。 异常的由来：问题也是现实生活中一个具体的事物，也可以通过java的类的形式进行描述。并封装成对象。其实就是java对不正常情况进行描述后的对象体现 对于问题的划分：两种：一种是严重的问题，一种是不严重的问题 对于严重的，java通过Error类进行描述。 对于Error，一般不编写针对性的代码进行处理 对于非严重的，java通过Exception类进行描述。（可以使用针对性的处理方式进行处理 ） ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:20:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"异常try-catch 异常的处理：java提供了特有的语句进行处理 对捕获到的异常对象进行常见的方法操作。 String getMessage ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:21:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"异常声明throws ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:22:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"多异常处理 对多异常的处理。 声明异常时，建议声明更为具体的异常。这样处理的可以更具体。 对方声明几个异常，就对应有几个catch块。不要定义多余的catch块 如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面 建立在进行catch处理时，catch中一定要具体的处理方式。不要简单的定义一句e.peintStackTrace()，也不要简单的就书写一条输出语句。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:23:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"自定义异常 项目中会出现特有的问题，而这些问题并未被java所描述并封装对象。所以对于这些特有的问题可以按照java对问题封装的思想。将特有的问题。进行自定义的异常封装。 当在函数内部出现了throw抛出异常对象，那么就必须要给对应的处理动作。 要么在内部try catch处理，要么在函数上声明让调用者处理。 发现打印的结果中只有异常的名称，缺没有异常的信息。 因为自定义的异常并未定义信息。 父类中已经把异常信息的操作都完成了。所以子类只要在构造时，将异常信息传递给父类通过super语句。那么直接就可以通过getMessage方法获取自定义的异常。 自定义异常：必须是自定义类继承Exception。原因是： 异常体系有一个特点：因为异常类和异常对象都被抛出。他们都具备可抛性。这个可抛性是Throwable这个体系中的独有特点。只有这个体系中的类和对象才可以被throw和throws操作。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:24:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"throws 和throw的区别：throws使用在函数上。throw使用在函数内。 throws后面跟的异常类，可以跟多个。用逗号隔开。throw后面跟的是异常对象。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:25:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"RuntimeException运行时异常。 如果在函数内抛出该异常，函数上可以不用声明，编译一样通过。 如果在函数上声明了该异常。调用者可以不用进行处理。编译一样通过。 之所以不用在函数声明，是因为不需要让调用者处理，当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，对代码尽心修正。 自定义异常时，如果该异常的发生，无法再继续进行运算，就让自定义异常继承RuntimeException 对于异常分两种： 编译时被检测的异常。 编译时不被检测的异常（运行时异常。RuntimeException以及其子类） 异常 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:26:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"异常-finally ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:27:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"异常-处理语句其他格式 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:28:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"异常-覆盖时的异常特点 异常在子父类覆盖中的特点： 子类在覆盖父类时，如果父类的方法抛出异常，子类的覆盖方法，只能抛出父类的异常或该异常的子类。 如果父类方法抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集。 如果父类或接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常。 如果子类方法发生了异常。那么就必须要进行try处理，绝对不能抛。 ##　异常练习 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:29:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"异常–总结 是什么：是对问题的描述。将问题进行对象的封装 异常体系：Throwable |–Eroor |–Exception |–RuntimeException 异常体系的特点：在异常体系中的所有类以及建立的对象都具备可抛性。也就是说可以被throw和throws关键字所操作。只有异常体系具备这个特点。 throw和throws的用法： throw：定义在函数内，用于抛出异常对象 throws：定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开 当函数内有throw抛出异常对象，并未进行try处理。必须要在函数上声明，都在编译失败。 注意：除了RuntimeException除外，函数内如果声明的是RuntimeException异常，函数上可以不用声明。 如果函数声明了异常，调用者需要处理。处理方法可以throws可以try 异常有两种： 编译时被检测异常：该异常在编译时，如果没有处理（没有抛出也没try），编译失败。该异常被标识，代表这可以被处理。 运行时异常（编译时不检测）：在编译时不需要检测，编译器不检查。该异常的发生，建议不处理，让程序停止。需要对代码进行修正。 注意：finally中定义的通常是：关闭资源代码。因为资源必须释放。 finally只有一种情况不被执行。当执行到System.exit(0)；finally不被执行 自定义异常： 定义类继承Exception或者RuntimeException 为了让该自定义类具备可抛性 让该类具备异常操作的共性方法 自定义异常好处：按照java面向对象的思想，将程序中出现的特有问题进行封装。 将问题进行封装 将问题和代码进行分离，方便于阅读 异常处理的原则： 处理方式有两种：try或者throws 调用到抛出异常的功能时，抛出几个，就处理几个 多个catch，父类的catch放在最下面 catch内，需要定义针对性的处理方式。不要简单的定义printStackTrace输出语句，也不要不写。当捕捉到的异常，本功能处理不了时，可以继续在catch中抛出。 如果该异常处理不了，但并不属于该功能出现的异常。也可以将异常转换后再抛出和该功能相关的异常。 或者异常可以处理，当需要将异常产生的和本功能相关的问题提供出去，让调用者知道，并处理。也可以捕获异常处理后，转换新的异常。 异常的注意事项： 在子类覆盖时： 子类抛出的异常必须是父类异常的子类或者子集 如果父类或者接口没有异常抛出时，子类覆盖出现异常，只能try不能抛 多线程 进程：是一个正在执行中的程序。 每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制单元。 线程：就是进程中的一个独立的控制单元。 线程在控制着进程的执行。 一个进程中至少有一个线程。 java VM启动的时候会有一个进程jav.exe。该进程中至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main方法中。该线程称之为主线程。 扩展：其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。 创建线程 如何在自定义的代码中，自定义一个线程？ 通过对API的查找，java已经提供了对线程这类事物的描述，就Thread类。 创建线程的第一种方式：继承Thread类。 步骤：定义类继承Thread；复写Thread类中的run方法；调用线程的start方法。 发现运行结果每次都不同。因为多个线程都获取cpu的执行权，CPU执行到谁，谁就运行。（多核除外），cpu在做着快速的切换，以达到看上去是同时运行的效果 创建线程-run和start的特点 为什么要覆盖run方法？ Thread类用于描述线程。该类定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法。 也就是说Thread类中的run方法，用于存储线程要运行的代码。 线程运行状态 原来线程都有自己默认的名称。Thread-编号，该编号从0开始。 static Thread currentThread()：获取当前线程对象。 getName()：获取线程名称 设置线程名称：setName或者构造函数。 创建线程-runable接口 创建线程的第二种方式：实现Runable接口 步骤： 定义类实现Runable接口 覆盖Runable接口中的run方法。 （将线程要运行的代码存放到该run方法中） 通过Thread类建立线程对象。 将Runable接口的子类对象作为实际参数传递给Thread类的构造函数。（自定义的run方法所属的对象时Runable接口的子类对象。所以要让线程去指定对象的run方法，就必须明确该run方法所属的对象） 调用Thread类的start方法开启线程并调用Runable接口子类的run方法。 实现方式和继承方式有什么区别呢？ 实现方式：避免了单继承的局限性。在定义线程时，建议使用实现方式。 两种方式的区别： 继承Thread：线程代码存放在Thread子类的run方法中。 实现Runable：线程 代码存在接口的子类的run方法中。 多线程的安全问题 多线程运行出现安全问题的原因： 当多条语句在操作同一个线程共享数据时，一个线程对多条语句值执行了一部分，还没有执行完，另一个线程参与执行。导致共享数据的错误。 解决办法： 对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中，其他线程不可以参与执行。 java对于多线程的安全问题提供了专业的解决方式。 同步代码块。 synchronized（对象）{需要被同步的代码} 对象如同锁。持有锁的线程可以在同步中执行。没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有获取锁。 同步的前提： 必须要有两个或两个以上的线程。 必须是多个线程使用同一个锁 3必须保证同步中只能有一个线程在运行。 好处：解决了多线程的安全问题。 弊端：多个线程需要判断锁，较为消耗资源。 多线程-同步函数 同步函数的锁用的是this。 静态同步函数的锁是Class对象 多线程-死锁 #多进程（二） ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:30:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"1线程间通信 线程间通讯：其实就是多个线程在操作同一个资源，但是操作的动作不同。 ##2解决安全问题 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:31:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"3等待唤醒机制 wait notify notifyAll 都使用在同步中，因为要对持有监视器（锁）的线程操作。所以要使用在同步中，以为只有同步才具有锁。 为什么这些操作线程的方法要定义在Object类中呢？ 因为这些方法在操作同步中线程时，都必须要标识他们所操作线程只有的锁。只有同一个锁上的等待线程，可以被同一个锁上的notify唤醒。不可以对不同锁中的线程进行唤醒。 也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法定义在Object类中。 StringBuffer ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:32:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"StringBuffer 是字符串缓冲区。是一个容器， 而且长度是可变化的。 可以操作多个数据类型。 最终会通过toString方法变成字符串 C（create）U（update）R（read）D（delete） 1.存储 StringBuffer append（）：将指定的数据作为参数添加到到已有数据的结尾处 StringBuffer insert（index，数据）：可以将数据 插入到数据指定index位置 2.删除 String 3.获取 4.修改 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:33:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"StringBuilder java升级的三个因素： 1.提高效率 2.简化书写 3.安全性 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:34:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"基本数据类型对象包装类 byte Byte short short int Integer long Long boolean Boolean float Float double Double char Character 基本数据类型对象包装类的最常见作用：就是用于基本数据类型和字符串类型之间做转换。 基本数据类型转成字符串。 基本数据类型+“”或者 基本数据类型.toString(基本数据类型值) 字符串转基本类型。基本数据类型包装类 a=Xxx.parseXxx(String) 集合类 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:35:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"集合框架（体系概述） 为什么出现集合类？ 数组是固定长度的，集合是可变长度的。 为什么出现这么多的容器？ 因为每一个容器对数据的存储方式都有不同。这个存储方式称之为：数据结构。 ##集合框架（共性方法） ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:36:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"迭代器 什么是迭代器？ 其实就是集合中元素的取出方式。 把取出方式定义在集合的内部，这样取出方式就可以直接访问集合内容的元素。那么取出方式就被定义成了内部类。而每一个容器的结构数据不同，所以取出的动作细节也不一样。但是都有共性内容：判断和取出。那么可以将这些共性抽取。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:37:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"List ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:38:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"List集合共性方法 List：元素是有序的，元素可以重复，因为该集合体系有索引。 Set：元素是无序的，不能重复。 List：特有方法：凡是可以操作角标的方法都是该体系特有的方法。 增：add addAll 删： remove 改：set 查：get subList listIterator ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:38:1","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"ListIterator 在迭代器时，只能用迭代器的方法操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。 该接口只能通过List集合的ListIterator方法获取。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:38:2","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"List集合具体对象的特点 List： ArrayList：底层的数据结构使用的是数组，查找很快，但是增删稍慢 （可变长度的） Linkedlist：底层使用的是链表数据结构。特点是增删速度很快，查询稍慢 Vector：底层是数组数据结构。线程同步，被ArrayList替代了 ，现在一般不用了。枚举是Vector特有的取出方式。发现枚举和迭代器很像。其实枚举和迭代是一样的。因为枚举的名称以及方法的名称都过长。所以被迭代器取代了。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:38:3","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"LinkedList LinkedList特有方法：addFirst(),addLast(),getFirst(),getLast(),removeFirst(),removeLast() JDK1.6出现了替代方法。 offerFriest peekFirst poolFirst 堆栈：先进后出 队列： 先进先出 FIFO List集合判断元素是否相同，依据的是元素的equals方法。 ##set set：元素是无序（存入和取出的顺序不一定一致） set集合的功能和collection是一致的。 HashSet：底层数据结构是哈希表。HashSet是如何保证元素的唯一性的呢？是通过元素的两个方法。hashCode和equals来完成。如果元素的HashCode值相同，才会判断equals是否为true，如果元素的hashCode不同，不会判断equals。 注意：对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashcode和equals方法。 集合框架2 ##set set：无序，不可以重复元素。 hashset：数据结构是哈希表，线程非同步的，保证元素唯一性的原理，判断元素的hashCode值是否相同。如果相同，判断equals TreeSet：可以对set集合中的元素进行排序。 底层数据结构是二叉树。保证元素唯一性的依据：compareTo return 0 往TreeSet集合中存储自定义对象学生。想按照学生的年龄进行排序。 记住：排序时，当主要条件相同时，一定判断一下次要条件。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:38:4","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"二叉树 TreeSet排序的第一种方式：让元素自身具备比较性。元素需要事项compareable接口，覆盖compareTo方法。这种方式也称为元素的自然顺序，或者叫做默认顺序。 TreeSet排序的第二种方式：当元素自身不具备比较性时，或者具备的比较性不是锁需要的。这时就需要让集合自身具备比较性。在集合初始化时，就有了比较方式。 当元素自身不具备比较性，或者具备的比较性不是所需要的。这时需要让容器自身具备比较性，定义了比较器，将比较器对象作为参数传递给TreeSet集合的构造函数。 当两种排序都存在时，以比较器为主。定义一个类实现Comparator接口，覆盖compare方法。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:39:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"泛型 JDK1.5之后出现的新特性，用于解决安全问题，是一个安全机制。 好处： 将运行时期出现问题转移到编译时期，便于程序员解决。 避免了强制转换的麻烦。 泛型格式：通过\u003c\u003e来定义要操作的引用数据类型 在使用java提供的对象时，什么时候写泛型？ 通常在集合框架中很常见，只要见到\u003c\u003e就要定义泛型。其实\u003c\u003e就是用来接收类型的。当使用集合时，将集合中的要存储的数据类型放到\u003c\u003e中即可。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:40:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"泛型类 泛型类：带泛型的类。 当类中要操作的引用数据类型不确定的时候，早期定义Object来完成扩展，现在定义泛型完成扩展。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:41:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"泛型方法 泛型类定义的泛型，在整个类中有效，如果被方法使用，那么泛型类的对象没明确要操作的具体类型后，所有要操作的类型就已经固定了。为了让不同方法可以操作不同类型，而且类型还不确定，那么可以将泛型定义到方法上。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:42:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"静态方法泛型 特殊之处是：静态方法不可以访问类上定义的泛型，如果静态方法操作的引用数据类型不确定，可以将泛型定义在方法上。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:43:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"泛型接口 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:44:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"泛型限定 ？： 通配符，也可以理解为占位符。 泛型的限定： ？ extends E：可以接收E类型或者E的子类型。上限 ？ super E：可以接收E类型或者E的父类型。下限 集合(MAP) ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:45:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Map集合：该集合存储键值对。一对一对往里存。而且要保证键的唯一性。 添加。 删除。clear() 判断。 获取。 Map：Hashtable：底层是哈希表数据结构，不能存入null键null值，是线程同步的。 HashMap:底层是哈希表数据结构，允许使用null键null值，该集合是不同步的。 TreeMap：底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。–和Set很像，其实Set底层就是使用了Map集合。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:46:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Map子类对象的特点 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:47:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Map共性方法 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:48:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Map-keySet map集合的两种取出方式： keySet：将map中所有的键存入到set集合。因为set具备迭代器。所有可以迭代方式取出所有的键，在根据get方法。获取每一个键对应的值。 entrySet Set\u003cMap.Entry\u003cK,V» entrySet:将Map集合中的映射关系存入了set集合中，而这个关系的数据类型就是：Map.entry。其实Entry也是一个借口，它是Map接口中的一个内部接口。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:49:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Map练习 当发现有映射关系时，可以选择map集合。因为map集合中存放的就是映射关系。 什么时候使用map集合？当数据之间存在映射关系时，就要先想map集合 ##map扩展知识 map集合被使用是因为具备映射关系。 集合（工具类） ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:50:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"sort ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:51:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"max ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:52:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"binarySerch ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:53:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"替换反转 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:54:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"reserveOrder ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:55:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Synlist ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:56:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Arrays 用于操作数组的工具类，里面都是静态方法。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:57:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"集合变数组 1.指定类型的数组到底要定义多长呢？ 当指定类型的数组长度小于集合的size，那么该方法会创建一个新的数组，长度为集合的size。当指定类型的数组长度小于了集合的size，就不会创建新数组，而是使用传递进来的数组，所以创建一个刚刚好的数组最优。 2.为什么要将集合变数组？ 为了限定对元素的操作。 ##增强for循环 ##可变参数 方法的可变参数注意： 可变参数一定要定义在参数列表的最后面。 ##静态导入 当类名方法重名时，需要指定具体的包名。 当方法重名时，指定具备所属的对象或者类 #其他对象 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:58:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"System 可不可以在jvm启动时，动态加载一些属性信息。 ##Runtime对象 该类并没有提供构造函数。说明不可以new 对象，那么会直接想到该类中的方法都是静态的，发现该类中海油非静态方法。 说明该类肯定会提供了方法获取本类对象，而且该方法是静态的，并返回值类型是本类类型。 由这个特点可以看出该类使用了单例设计模式执行。 ##Date ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:59:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Math #IO流 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:60:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"BufferedWriter 缓冲区的出现是为了提高流的操作效率而出现的。所以在创建缓冲区之前，必须要先有流对象。 为了 提高字符写入流效率，加入了缓冲技术,只要将需要提高效率的流对象作为参数传递给缓冲区的构造函数即可。 记住只要用到缓冲区，就要记得刷新。 其实关闭缓冲区，其实就是在关闭缓冲区的流对象。 该缓冲区中提供了一个跨平台的newLine（） ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:61:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"BufferedReader 为了提高效率，加入缓冲技术。将字符读取流对象作为参数传进缓冲对象的构造函数。 readLine方法返回的时候只返回回车符之前的数据内容，并不返回回车符。 readLine方法的原理：无论是读取一行，还是读取多个字符，其实最终都是在硬盘上一个个读取。所以最终使用的还是read方法一次读一个的方法。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:62:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"MyBufferedReader ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:63:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"装饰设计模式 定义：当想要对已有的对象进行功能增强时，可以定义一个类，将已有对象传入，基于已有的功能，并提供加强功能。那么自定义的该类称为装饰类。 装饰类通常会通过构造方法接收被装饰的对象。并基于被装饰的对象的功能，提供更强的功能。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:64:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"装饰和继承的区别 装饰模式比继承要灵活，避免了继承体系臃肿。而且降低了类与类之间的关系。 装饰类因为增强已有对象，具备的功能和已有的是相同的，只不过提供了更强的功能。所以装饰类和被装饰类通常都属于一个体系中的。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:65:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"LineNumberReader ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:66:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"字符流和字节流 FileReader: FileWriter: 字节流： InputStream： OutputStream: ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:67:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"复制一个图片 思路： 1.用字节读取流对象和图片关联。 2.用字节写入流对象创建一个图片文件，用于存储获取到的图片数据。 3. 通过循环读写，完成数据的存储。 4. 关闭资源 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:68:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"读取转换流 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:69:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"写入转换流 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:70:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"流操作的基本规律 最痛苦的就是流对象有很多，不知道该用哪一个。 通过两个明确来完成。 1.明确源和目的。 源：输入流。InputStream Reader 目的：输出流。OutputStream Writer 2.操作的数据是否是纯文本。 是：字符流。 否：字节流。 3.当体系明确后，再明确要使用哪个具体的对象。 通过设备来进行区分： 源设备：内存，硬盘，键盘 目的设备：内存，硬盘，控制台。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:71:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"File类 用来将文件或文件夹封装成对象。 方便对文件与文件夹的属性信息进行操作。 File对象可以作为参数传递给 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:72:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"File类的常见方法 1.创建 boolean createNewFile() boolean mkdir() boolean mkdirs() 2.删除 boolean delete() 删除失败返回false void deleteOnExit() 在程序退出时删除文件 3.判断 boolean exists() 文件或目录是否存在。 记住在判断文件对象是否是文件或者目录时，必须要先判断该文件对象封装的内容是否存在，通过exists判断。 boolean isFile() boolean isDirectory() 4.获取信息。 String getName() String getParent() 该方法返回的是绝对路径中的父目录，如果获取的是相对路径，则返回null。 String getPath() File getAbsoluteFile() long lastModified() long length() ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:73:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"文件列表 static File[] listRoots() String[] list() 调用list方法的必须是封装的一个目录。该目录还必须存在。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:74:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"列出目录下所有的内容 递归 递归要注意： 1.限定条件。 2.要注意递归的次数，尽量避免内存溢出。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:75:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"删除一个带内容的目录 删除原理： 在Windows中，删除目录从里面往外删除的。既然是从里往外删除，就需要用到递归。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:76:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"创建java文件列表 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:77:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"properties properties是hashtables的子类，也就是说它具备map集合的特点。而且它里面存储的键值对都是字符串。是集合中和IO技术相结合的集合容器。 该对象的特点：可以用于键值对形式的配置文件。 ##IO包中的其他类 打印流：该流提供了打印方法，可以将各种数据类型的数据都原样打印。 字节打印流 PrintStream 构造函数可以接收的参数类型。 file对象。File 字符串路径 字节输出流 字符打印流 PrintWrite file对象。File 字符串路径 字节输出流 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:78:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"合并流和切割文件 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:79:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"对象的序列化 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:80:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"管道流 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:81:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"RandomAccessFile 该类不是算是IO体系中子类，而是继承自Object。 但是它是IO包中的成员，因为它具备读和写功能。颞部封装了一个数组，而且通过指针对数组的元素进行操作。 可以通过getFilePointer获取指针位置。同时可以通过seek改变指针位置。 其实完成读写的原理就是内部封装了字节输入流和输出流。通过构造函数可以看出，该类只能操作文件。而且操作文件还有模式。 该对象的构造函数要操作的文件不存在，会自动创建。如果存在不会覆盖。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:82:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"ByteArrayStream GUI(图形用户界面) ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:83:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"GUI ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:84:0","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":["other"],"content":"Awt与 Swing java.Awt： Abstract Window ToolKit (抽象窗口 工具包)，需要调用本地系统方法实现功能。属 重量级控件。 javax.Swing：在AWT的基础上，建立的一套图 形界面系统，其中提供了更多的组件，而且完全 由Java实现。增强了移植性，属轻量级控件。 ","date":"2017-03-09","objectID":"/posts/language/java/20days_java/:84:1","tags":["Java"],"title":"20天学习Java视频笔记","uri":"/posts/language/java/20days_java/"},{"categories":null,"content":"主从问题 ","date":"0001-01-01","objectID":"/posts/database/mysql-problems/:1:0","tags":null,"title":"","uri":"/posts/database/mysql-problems/"},{"categories":null,"content":"主从延迟 降低安全性的前提下，修改 提高主从同步速度 innodb_flush_log_at_trx_commit=0; sync_binlog=0; set global sync_binlog=0; # 原为1 set global innodb_flush_log_at_trx_commit=0; # 原为1 set global sync_binlog=1000; # 原为1 set global innodb_flush_log_at_trx_commit=2; # 原为1 ","date":"0001-01-01","objectID":"/posts/database/mysql-problems/:1:1","tags":null,"title":"","uri":"/posts/database/mysql-problems/"}]