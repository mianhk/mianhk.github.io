<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="you don&apos;t know">
<meta property="og:type" content="website">
<meta property="og:title" content="Mianhk">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mianhk">
<meta property="og:description" content="you don&apos;t know">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mianhk">
<meta name="twitter:description" content="you don&apos;t know">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Mianhk</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mianhk</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Mianhk</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/《cpp primer》ch7类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mianhk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mianhk">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/《cpp primer》ch7类/" itemprop="url">《c++primer》ch7 类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T17:55:33+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>类是面向对象编程的基础，使用类定义自己的数据类型，可以更方便的解决问题中的各种概念，使我们更容易编写、调试和修改程序。</p>
</blockquote>
<h1 id="7-1-定义抽象的数据类型"><a href="#7-1-定义抽象的数据类型" class="headerlink" title="7.1 定义抽象的数据类型"></a>7.1 定义抽象的数据类型</h1><ul>
<li>定义在类内部的函数时隐式的inline函数。</li>
<li>类的所有成员都必须在类的内部声明，但是成员函数体可以定义在类的内部或外部。</li>
<li>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。</li>
<li>成员函数体可以随意使用类中的其他成员而不需要在意这些成员出现的次序。<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2>编译器创建的构造函数又被称为合成的默认构造函数，合成的默认构造函数初始化类的数据成员规则为：存在类内初始值的时候，用它来初始化成员；否则，默认初始化该成员。<br>对于一个普通的类，一般要定义自己的默认构造函数：</li>
</ul>
<ol>
<li>编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</li>
<li>对于某些类来说，合成的默认构造函数可能执行错误的操作。</li>
<li>有的时候编译器不能为某些类合成默认的构造函数。</li>
</ol>
<ul>
<li>构造函数没有返回类型。<h2 id="拷贝。赋值和析构"><a href="#拷贝。赋值和析构" class="headerlink" title="拷贝。赋值和析构"></a>拷贝。赋值和析构</h2>除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象的时候发生的行为。<br>当我们不主动定义这些操作的的时候，编译器将替我们合成他们。但是有些类不能依赖于合成的版本。当类需要分配类对象之外的资源时，合成的版本常常会失效。<h1 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h1>在类的定义中，可以包含0个或多个访问说明符，每个访问说明符指定接下来的成员访问级别，一般来说，作为接口的一部分，构造函数和一部分成员函数应该定义在public说明符之后，而数据成员和作为实现部分的函数跟在private说明符之后。<br>class和struct唯一的区别是默认访问权限不同。<h1 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h1>类型成员、类的成员的类内初始值、可变数据成员、内联数据成员、从成员函数返回*this、关于如何定义类类型及友元类等。<h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制。<h2 id="另成员作为内联函数"><a href="#另成员作为内联函数" class="headerlink" title="另成员作为内联函数"></a>另成员作为内联函数</h2>在类中，一些规模较小的函数常被定义为内联函数<br>两种方式：1、直接把函数定义放在类的内部<pre><code>2、把函数定义放在类的外部，显式的使用inline
</code></pre></li>
<li>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</li>
<li>在实践中，设计良好的代码常常包含很多的小函数，通过调用这些小函数，可以完成其他一组函数的“实际”工作。<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2></li>
<li>对于一个类来说，它的成员和其他任何类的成员都不是一回事。</li>
<li>类的声明：不完全类型的使用：可以定义指向这种类型的指针或引用，也可以声明（但不能完全定义）以不完全类型作为参数或者返回类型的函数。<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2>如果一个类指定了友元类，则友元类的成员函数可以访问此类中包括非公有成员在内的所有成员。</li>
<li>还可以另一个类的成员函数为自己的友元。</li>
<li>如果一个类想把一组重载函数声明称它的友元，需要对每一个分别声明。</li>
<li>友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。<h1 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h1></li>
<li>一个类就是一个作用域</li>
<li>函数的返回类型通常出现在函数名之前，所以返回类型是在类的作用域外的。</li>
<li>名字查找规则：首先名字所在快寻找声明语句；查找外层作用；报错。<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2></li>
<li>如果成员是const或引用的话，必须进行初始化；当成员属于某种类类型且该类没有定义构造函数时，也必须初始化。</li>
<li>使用构造函数初始值：不仅仅是底层效率的问题。另有一些数据成员必须被初始化。</li>
<li>成员初始化顺序：构造函数初始化列表值说明用于初始化成员的值，而不限定初始化的具体执行顺序。（尽量按照顺序初始化，并且避免使用某些成员初始化其他成员）</li>
<li>委托构造函数：</li>
<li>默认构造函数的作用：当对象被默认初始化或值初始化时自动执行默认构造函数</li>
<li>默认初始化发生:</li>
</ul>
<ol>
<li>块作用域内不适用任何初始值定义一个非静态变量或数组时。</li>
<li>一个类本身含有类类型的成员且使用合成的默认构造函数。</li>
<li>类类型的成员没有在构造函数初始值列表中显式的初始化。</li>
</ol>
<ul>
<li>值初始化发生：</li>
</ul>
<ol>
<li>数组初始化时提供的初始值数量小于数组的大小</li>
<li>不使用初始值定义一个局部的静态变量</li>
<li>书写形如T()的表达式显式的请求值初始化</li>
</ol>
<ul>
<li><p>隐式的类类型转换：能通过一个实参调用的构造函数定义一条从构造函数的参数类型向类类型隐式转换的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string null_book=&quot;2132321&quot;;</div><div class="line">item.combine(null_book);//将一个string的实参传递给了combine成员。</div></pre></td></tr></table></figure>
</li>
<li><p>隐式类型转换只能一步，可以使用explicit阻止隐式类型转换。</p>
</li>
<li>字面值常量类至少提供一个constexpr构造函数<h1 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h1></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/《cpp primer》ch6函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mianhk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mianhk">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/《cpp primer》ch6函数/" itemprop="url">《c++primer》ch6 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T17:55:33+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>涉及到函数之后，我认为已经是基础的较后面的部分，因为这开始慢慢涉及到了一门语言的思想观念，设计的想法，以及对编程人员的要求。所以这些部分不知道要知道怎么用，更要知道为什么会这样。当然第一遍看的时候，也没有多少编程经验，可能无法有更多的想法，只能跟着书里慢慢理解了。</p>
</blockquote>
<h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><h2 id="形参和实参："><a href="#形参和实参：" class="headerlink" title="形参和实参："></a>形参和实参：</h2><p>实参是形参的初始值，函数的形参列表可以为空。<br>局部静态对象，定义成static类型，在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p>
<h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><p>如果形参是引用类型，它将绑定到对应的实参上，称为引用传递；否则，将实参的值拷贝后赋给形参，称为值传递。</p>
<h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2><p>将实参的值拷贝给形参。当是指针形参时，指针的行为和其他非引用类型一样，执行指针拷贝类型时，拷贝的是指针的值。拷贝之后是不同的指针，但是指向的是相同的值，我们可以在函数中修改指针所指对象的值。在C++中，建议使用引用类型的形参替代指针。</p>
<h2 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h2><p><strong> 1.使用引用避免拷贝。 </strong>因为有的类类型是不能拷贝的，或者在拷贝一些大的类类型对象或者容器对象比较低效。<br>如果函数不需要改变引用参数的值，最好将其声明为常量引用。<br><strong> 2.使用引用形参返回额外信息。</strong>由于函数不能有多个返回值，在我们需要返回多个值的时候，可以额外传一个引用参数。<br><strong> 3.可以直接操作引用形参所引的对象。 </strong></p>
<h2 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h2><p>和其它初始化一样，当用实参初始化形参时会忽略掉顶层const。也就是，形参的顶层const会被忽略掉。（这个可以思考一下，我们可以通过形参的const在参数中控制是否需要改变形参，以及对应的实参，这样更方便我们传参数。当然有了这个我们就不能重载有无const的两个函数了，因为会被编译器相同对待。）<br>尽量使用常量引用，除了在使用的时候，无法把常量引用初始化为引用（很简单的道理），另外，也会给调用者一种误导。</p>
<h2 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h2><p>无法以值传递的方式使用数组参数。数组的特点：不允许拷贝、使用数组会将其转化为指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void print(const int*);</div><div class="line">void print(const int[]);</div><div class="line">void print(const int[10]);  //这里的维度表示我们期望数组含有多少个元素，实际不一定</div></pre></td></tr></table></figure></p>
<h3 id="关于数组长度"><a href="#关于数组长度" class="headerlink" title="关于数组长度"></a>关于数组长度</h3><p>由于传递数组引用的时候，只是数组的首元素指针，所以有时候我们需要在形参定义的时候，就将数组大小传递给形参。这里有几种方式。</p>
<h2 id="6-2-5-mian处理命令行选项"><a href="#6-2-5-mian处理命令行选项" class="headerlink" title="6.2.5 mian处理命令行选项"></a>6.2.5 mian处理命令行选项</h2><p>当使用argv[]中的实参时，第一个实参保存的是程序名，所以应该从第二个开始。</p>
<h2 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h2><p>有时候我们预先不知道向函数传递几个实参。1.如果所有的实参类型相同，可以传递名为initializee_list的标准库类型；2.如果实参类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。</p>
<h1 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h1><p>return语句终止当前执行的函数，并将控制权返回到调用该函数的地方。<br>return语句不要返回局部对象的引用或引用（因为局部对象会在函数调用完成后删除，会产生未定义的结果）。<br>c++11新标准中函数可以返回花括号包围的值列表，主函数main的返回值，非0的返回值由机器决定。</p>
<h1 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h1><p>拥有顶层const不影响传入函数的对象。另外，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。<br>不能仅仅通过函数的返回值区分两个同名的函数</p>
<h2 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h2><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。在不同的作用域中无法重载函数名。<br>在c++中，名字查找发生在类型检查之前。</p>
<h1 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h1><p>大多数程序都有用的特性：默认实参、内联函数、constexpr函数。</p>
<h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>一旦某个形参赋予了默认值，后面的所有形参必须有默认值。函数调用时，实参按其位置进行解析，只能省略尾部的实参。<br>一个函数被声明多次的时候，在给定的作用域中一个形参只能被赋予一次默认实参，也就是函数的后续声明。</p>
<h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>将它在每个调用点上“内联的”展开，一般来说用于优化规模较小、流程直接、频繁调用的函数。</p>
<h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>constexpr函数指能用于常量表达式的函数。函数的返回值及所有形参的类型都得是字面值类型，并且函数体中必须有且只有一条return语句。<br>编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式的指定 为内联函数.<br>内联函数和constexpr函数通常定义在头文件中.</p>
<h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>assert预处理宏,以一个表达式作为条件.<br>我们可以使用一个#define 语句定义NDEBUG，关闭调试状态</p>
<h1 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h1><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换得来时。</p>
<h2 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h2><p>函数匹配第一步：选定本次调用对应的重载函数集。<br>候选函数的两个特征：与被调用的函数同名，其声明在调用点可见。<br>第二步考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数。</p>
<h2 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h2><p>确定最佳匹配的排序：</p>
<ul>
<li>1.精确匹配：实参形参类型相同，实参从数组或函数类型转化为对应的指针类型，实参添加顶层const或者从实参中删除顶层const。</li>
<li>2.通过const转换实现的匹配。</li>
<li>3.通过类型提升实现的匹配。</li>
<li>4.通过算术类型转换或指针转换实现的匹配。</li>
<li>5.通过类类型转换实现的匹配。<h1 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h1>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。<h2 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h2>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。<h2 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h2>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上是被当成指针使用。<br>可以直接把函数当成实参使用，会自动转换成指针。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/《cpp primer》ch4表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mianhk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mianhk">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/《cpp primer》ch4表达式/" itemprop="url">《c++primer》ch4 表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T17:55:33+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>不管学习什么语言都会有这么一章，不管是c、java、Python，这都是会经历的一章，唉，无奈当时年少无知不止梦想是什么的我每每看到这些的时候都觉得很烦。当再一次翻开c++的这一章的时候，也有这样的感觉，似曾相识燕归来，却又无可奈何花落去。<br>我认为这一章的很多都不是需要太多的去深究，只需要有个大概的概念，然后更多的是在今后的编程过程中，不断的实践自然就知道了，是怎样写的。而且累死一些优先级的问题，更多的时候就像书里建议的那样，一个括号来的简单粗暴实用的多，所以，这章，就记一下实在有违常规的理解的内容吧。</p>
<h1 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h1><ul>
<li>运算对象转换：小整数类型（如bool、char、short等）通常会被提升为较大的整数类型，主要是int。</li>
<li>左值和右值：一个左值表达式的求值结果时一个对象或者一个函数，以常量对象为代表的某些左值不能作为赋值语句的左侧运算对象。<strong> 简单归纳：当对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置） </strong></li>
<li>左值右值使用原则：需要右值的地方可以用左值代替，但是不能把右值当成左值使用。当一个左值被当成一个右值使用的时候，实际上使用的是它的内容（值  ）</li>
<li>需要用到左值的地方：<br>1.赋值运算符。需要左值作为其左值运算对象，得到结果仍然是一个左值<br>2.取地址符。返回一个指向该运算对象的指针，这个指针是一个右值<br>3.内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值<br>4.内置类型和迭代器的递增递减运算符作用于左值运算对象，得到的结果是左值。</li>
<li>关键字decltype中左值和右值的不同</li>
<li>处理复合表达式的经验：使用括号；如果改变了某个运算对象的值，就不要在表达式的其它地方再使用这个运算对象<h1 id="4-2-算数运算符"><a href="#4-2-算数运算符" class="headerlink" title="4.2 算数运算符"></a>4.2 算数运算符</h1>溢出的情况，值会发生“环绕”<h1 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h1>进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值作为运算对象<h1 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h1>赋值运算满足右结合律<br>参与连续赋值的变量必须是相同的类型<h1 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h1><h1 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h1>解应用运算符的优先级低于点运算符<br>#<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cond?expr1:expr2;</div><div class="line">//输出表达式中使用条件运算符</div><div class="line">cout&lt;&lt;((grade&lt;60)?&quot;fail&quot;:&quot;pass&quot;); //输出pass或者fail</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>条件运算符可以嵌套，一般为了代码的可读性，嵌套不要超过三层。</p>
<h1 id="4-7-sizeof运算符"><a href="#4-7-sizeof运算符" class="headerlink" title="4.7 sizeof运算符"></a>4.7 sizeof运算符</h1><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得值是一个size_t类型的常量表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sizeof(type)</div><div class="line">sizeof expr</div></pre></td></tr></table></figure></p>
<h1 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h1><p>首先对左侧表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。</p>
<h1 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h1><h2 id="发生隐式类型转换"><a href="#发生隐式类型转换" class="headerlink" title="发生隐式类型转换"></a>发生隐式类型转换</h2><ul>
<li>比int小的整形值首先提升为较大的整数类型</li>
<li>条件中，非bool值转为bool值。</li>
<li>初始化过程中，初始值转化为变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型</li>
<li>如果算数预算或关系运算对象有多种类型，需要转换成同一种类型。</li>
<li>函数调用时，也可能发生类型转换<h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cast-name&lt;type&gt;(expression)</div><div class="line">cast-name:static_cast,dynamic_cast,const_cast,reinterpret_cast</div></pre></td></tr></table></figure>
</li>
</ul>
<p>static_cast:任何具有明确定义的类型转换，只要不包含底层const都可以使用。<br>const_cast:只能改变运算对象的底层const<br>dynamic_cast：支持运行时类型识别<br>reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释。（使用起来非常危险）</p>
<p><strong> 尽量避免强制类型转换 </strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/04/《cpp primer》ch2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mianhk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mianhk">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/04/《cpp primer》ch2/" itemprop="url">《c++primer》ch2 变量和基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-04T17:55:33+08:00">
                2017-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>ch2 变量和基本类型<br>数据类型决定了程序中数据和操作的意义。</p>
<h1 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h1><p>基本数据类型：<strong> 算数类型  空类型（void） </strong>,其中算数类型包括：字符、正整数、布尔值、浮点数。空类型不对应具体的值，用于一些特殊的场合。</p>
<h2 id="2-1-1-算数类型"><a href="#2-1-1-算数类型" class="headerlink" title="2.1.1 算数类型"></a>2.1.1 算数类型</h2><p>分为整形和浮点型。</p>
<h3 id="整形："><a href="#整形：" class="headerlink" title="整形："></a>整形：</h3><ul>
<li>bool:取值为true或者false。</li>
<li>char：基本的字符类型，一个char的大小与一个机器字节一样。</li>
<li>wchar_t,char16_t,char32_t<br><strong> rules: </strong>一个int至少和一个short一样大，一个long至少跟一个int一样大，一个long long至少跟一个long一样大。<h3 id="浮点型："><a href="#浮点型：" class="headerlink" title="浮点型："></a>浮点型：</h3></li>
<li>float：一般一个字，32bit</li>
<li>double：2个字，64bit</li>
<li>long double：3或4个字，96或128bit<h3 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a>带符号类型和无符号类型</h3><h2 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h2><h3 id="转换过程："><a href="#转换过程：" class="headerlink" title="转换过程："></a>转换过程：</h3></li>
<li>非bool到bool：初始为0则为false，其他为true</li>
<li>bool到非bool：初始值为false则为0，初始值为true为1</li>
<li>浮点数到整型：仅保留浮点数中的<strong> 小数点部分 </strong></li>
<li>整数到浮点数：小数部分记为0，如果整数所占的空间超过浮点类型的容量，会报错。</li>
<li>赋给无符号类型，当超出它表示范围的时候，转换为该无符号类型表示数值总数取模后的余数。</li>
<li>给带符号的数输出超过范围的值是，结果时<strong> 未定义的 </strong></li>
</ul>
</blockquote>
<p>tips:一般不在算数表达式中使用bool值</p>
<h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p>一般不要混用无符号和有符号的类型，当无符号超过范围时，可能会出现取模的情况，放在循环中，或者计算结果中，会产生无法预计的结果</p>
<h2 id="2-1-3-字面值常量"><a href="#2-1-3-字面值常量" class="headerlink" title="2.1.3 字面值常量"></a>2.1.3 字面值常量</h2><p>顾名思义，字面值常量一望而知。每个字面值常量对应一种数据类型，字面量常量得形式和值决定了它的数据类型。</p>
<h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><p>严格来说，十进制字面值不会是负数，通常，负号并不在字面值内，它的作用仅仅是对字面值取负值而已。</p>
<h3 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h3><ul>
<li>char型字面值：由单引号括起来的一个字符</li>
<li>字符串字面值：由双引号括起来的零个或多个字符<br><strong> Note：字符串字面值的类型实际上是由常量字符组成的数组，编译器在每个字符串的结尾处添加一个空字符（’\0’），字符串的字面值的实际长度比它的内容多1。 </strong><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3>有两类不能直接使用的字符。不可打印的和特殊含义的字符（单引号，双引号，问号，反斜线），这些情况下需要使用转义字符。<h3 id="指定字面值类型"><a href="#指定字面值类型" class="headerlink" title="指定字面值类型"></a>指定字面值类型</h3>添加一定的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。前缀有：u（Unicode16）、U（Unicode32）、L（宽字符）、u8（UTF-8）。后缀有：u或者U（unsigned）、l或者L（ling）、ll或者LL（long long），f或者F（float）、l或者L（long double）。<h3 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h3>bool：true、false<br>指针：nullptr<h1 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h1>对于c++来说，一般“变量”和“对象”可以互换使用。对象时具有某种数据类型的内存空间。<h2 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h2>基本形式：类型说明符+一个或多个变量名组成的列表（变量名以逗号分隔）+分号<h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3>当对象在创建时获得了一个特定的值，称为被初始化了。<strong> 初始化和复制是两个完全不同的操作，注意这个概念很重要 </strong><br>初始化：在创建变量是赋予其一个初始值。<br>复制：把对象的当前值擦除，以一个新的值代替。<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3>无论是初始化对象还是某些时候为对象赋新值，都可以使用一组又花括号括起来的初始值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int units_sold=0;</div><div class="line">int units_sold=&#123;0&#125;;</div><div class="line">int units_sold&#123;0&#125;;</div><div class="line">int units_sold(0);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式的初始化，则其值由类确定。。建议初始化每一个内置类型的变量。</p>
<h2 id="2-2-2-变量声明与定义的关系"><a href="#2-2-2-变量声明与定义的关系" class="headerlink" title="2.2.2 变量声明与定义的关系"></a>2.2.2 变量声明与定义的关系</h2><p>声明使得名字为程序所知，定义负责创建与名字关联的实体。<br><strong> extern </strong>关键字：如果想声明一个变量而不是定义它，就在变量名前添加extern，而不显示的初始化变量。如果在函数体内部试图初始化一个有extern关键字标记的变量，会引发错误。</p>
<h2 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h2><p>用户自定义的标识符中不能出现两个连续的下划线，也不能以下划线紧连大写字母开头。定义在函数体内的标识符不能以下划线开头。</p>
<h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><ul>
<li>标识符要能体现实际含义</li>
<li>变量名一般小写字母</li>
<li>自定义的类名一般大写字母开头</li>
<li>标识符由多个单词组成时，单词应有明显区分，使用下划线<h2 id="2-2-4-名字的作用域"><a href="#2-2-4-名字的作用域" class="headerlink" title="2.2.4 名字的作用域"></a>2.2.4 名字的作用域</h2>当内层出现与外层相同的名字时，使用内层定义的名字。<h1 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h1>复合类型指的是基于其他类型定义的类型。这里介绍两种：引用和指针。<h2 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h2>引用为对象起了另外一个名字，引用；类型引用另外一种类型。通过将生命符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用必须初始化。<h3 id="引用即别名"><a href="#引用即别名" class="headerlink" title="引用即别名"></a>引用即别名</h3>引用并不是对象，只是一个已经存在的对象起的另外一个名字。定义了一个引用之后，对其做的所有操作都是在与之绑定的对象上进行的。<br>因为引用本身只是一个别名，不是一个对象，所以不能定义引用的引用。<h3 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h3>除了两种例外的情况，其他所有的引用类型都要与之绑定的对象严格比配。<br>引用只能绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。<h2 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h2>指针是“指向point to”的另外一种类型的复合引用。指针也实现了对其他对象的间接访问。<br>两者的不同点：</li>
<li>1.指针本身就是一个对象，允许对指针赋值和拷贝，而且指针的生命周期内可以指向多个不同的对象。</li>
<li>2.指针无需在定义时赋初值。<h3 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h3>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）<br>不能定义指向引用的指针（因为引用不是一个对象）。<br>除了两种例外的情况，所有指针的类型都要和它指向的对象严格匹配。<h3 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h3>指针的值（即地址）应该属于下面四种状态之一：</li>
<li>1.指向一个对象</li>
<li>2.指向紧邻对象所占空间的下一个位置</li>
<li>3.空指针，表示没有指向任何对象。</li>
<li>4.无效指针，上述之外的其他值。<h3 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h3>如果指针指向了一个对象，允许使用解引用符（操作符*）来访问对象。<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3>空指针不指向任何对象，得到空指针的办法：直接用字面值nullptr初始化指针或者将指针初始化为字面值0来生成空指针。<br><strong> 建议 </strong>：初始化所有指针<h3 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h3>记住赋值永远改变的是等号左侧的对象。<h3 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h3>只要一个指针拥有合法值，就能将它用在条件表达式中，只要不为空，条件都为true。<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h3>void* 是一种特殊的指针类型，可用于存放任意对象的地址。<h2 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h2>变量的定义包括：一个基本数据类型+一组声明符。基本数据类型只有一个，但是声明符的形式可以不同。<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3>当有多个修饰符连写在一起的时候，按照逻辑关系解释。<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3>引用本身不是对象，但是指针是对象，所以可以对指针引用。<br>面对一条复杂的指针或引用的声明语句时，从右向左阅读有助于弄清真实含义。<h1 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h1><h3 id="初始化和const"><a href="#初始化和const" class="headerlink" title="初始化和const"></a>初始化和const</h3>const与非const对象的区别就是，const类型的对象执行不改变起内容的操作。如：const int也能像int一样参与算术运算，也能转化为bool值。<h3 id="默认状态下，const对象仅在文件内有效"><a href="#默认状态下，const对象仅在文件内有效" class="headerlink" title="默认状态下，const对象仅在文件内有效"></a>默认状态下，const对象仅在文件内有效</h3>如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字。<h2 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h2>可以把引用绑定到const对象上，就像绑定到其他对象上一样，称为对常量引用，对常量的引用不能修改它所绑定的对象。<br><strong> 术语：常量引用是对const的引用 </strong>：并不存在常量引用，是对const的引用。<h3 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h3>引用情况的例外：第一种是，在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。<h3 id="对const的引用可能引用一个非const的对象"><a href="#对const的引用可能引用一个非const的对象" class="headerlink" title="对const的引用可能引用一个非const的对象"></a>对const的引用可能引用一个非const的对象</h3>此种行为是合法的，但是不能通过对const的引用改变对象的值，兑现可以通过其他的方式改变值。<h2 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h2>指向常量的指针不能改变其所指对象的值，要想存放常量对象的地址，只能只用指向常量的指针。<br>所谓指向常量的指针和引用，只是自以为指向了一个常量，所以自觉不去改变所指对象的值。<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3>*const：不变的是指针的值而不是指向的那个值。采用从右向左的方式阅读，看离最近的符号。<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3>顶层const表示指针本身是个常量，底层const表示指针指的对象是一个常量。<br>当对象执行拷贝操作时，顶层const不受影响，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转化。<h2 id="2-4-4-constexpr和常量表达式"><a href="#2-4-4-constexpr和常量表达式" class="headerlink" title="2.4.4 constexpr和常量表达式"></a>2.4.4 constexpr和常量表达式</h2>常量表达式指：值不会改变且在编译过程就能得到计算结果的表达式。（字面值、用常量表达式初始化的const对象）<h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3>声明为constexpr的变量一定是一个变量，且必须用常量表达式初始化。<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><h3 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h3>在constexpr如果定义了一个指针，则constexpr只对指针有效，与指针所指的对象无关。<h1 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h1><h2 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h2>类型别名是一个名字，是某种类型的同义词。使用方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef double wages  //wages 是double的别名</div><div class="line">typedef wages base,*p</div><div class="line"></div><div class="line">#别名声明</div><div class="line">using SI=Scales_item;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h3><h2 id="2-5-2-auto类型说明符"><a href="#2-5-2-auto类型说明符" class="headerlink" title="2.5.2 auto类型说明符"></a>2.5.2 auto类型说明符</h2><h3 id="复合类型、常量和auto"><a href="#复合类型、常量和auto" class="headerlink" title="复合类型、常量和auto"></a>复合类型、常量和auto</h3><ul>
<li>引用时的auto，以引用对象的类型作为auto的类型</li>
<li>auto一般会忽略掉顶层const，底层const会保留下来。</li>
<li>可以将引用的类型设为auto<h2 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h2>选择并返回操作数的类型，编译器分析表达式并得到类型，但并不实际计算值<h3 id="decltype和引用"><a href="#decltype和引用" class="headerlink" title="decltype和引用"></a>decltype和引用</h3>有些表达式将向decltype返回一个引用类型。如果表达式的内容是解引用操作，则decltype将得到引用类型。<br>解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。<br>decltype和auto的重要区别：decltype的结果类型与表达式形式密切相关。<br><strong> 如果给变量加上一层或多层括号，decltype就会得到引用类型。decltype((val))的结果永远是引用，decltype(val)只有当val本身是一个引用时才是引用。另外，赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型 </strong></li>
</ul>
<h1 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h1><h2 id="定义自己的数据结构"><a href="#定义自己的数据结构" class="headerlink" title="定义自己的数据结构"></a>定义自己的数据结构</h2><h2 id="定义自己的头文件"><a href="#定义自己的头文件" class="headerlink" title="定义自己的头文件"></a>定义自己的头文件</h2><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/04/《cpp primer》ch3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mianhk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mianhk">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/04/《cpp primer》ch3/" itemprop="url">《c++primer》ch3 字符串、向量和数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-04T17:55:33+08:00">
                2017-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><h3 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h3><h3 id="头文件中不应该包含using声明"><a href="#头文件中不应该包含using声明" class="headerlink" title="头文件中不应该包含using声明"></a>头文件中不应该包含using声明</h3><p>因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。</p>
<h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string s1;   //默认初始化</div><div class="line">string s2=s1;  //s2是s1的副本</div><div class="line">string s2(s1); //等价于string s2=s1,s2是s1的副本</div><div class="line">string s3=&quot;hiya&quot;;  //s3是字面值的副本，但是不包含字面值最后的那个空字符</div><div class="line">string s3(&quot;hiya&quot;);  //等价于string s3=&quot;hiya&quot;</div><div class="line">string s4(n,&apos;c&apos;);  //把s4初始化为连续n个字符c组成的字符串</div></pre></td></tr></table></figure>
<h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><ul>
<li>读写string对象</li>
<li>读取未知数量的string对象</li>
<li>使用getline读取一整行</li>
<li>string的empty和size操作<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3>size_type是一种无符号整形数，如果在表达式中混用了带符号数和无符号数会产生意想不到的后果。<h3 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h3>按字典顺序<h3 id="字面值和string类型相加"><a href="#字面值和string类型相加" class="headerlink" title="字面值和string类型相加"></a>字面值和string类型相加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//错误的方式</div><div class="line">string s=&quot;hello&quot;+&quot;,&quot; //错误，因为两个运算对象都不是string，不能把两个字面值直接相加</div><div class="line">string s1=&quot;hello&quot;+s1+&quot;,&quot; //正确</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong> 字符串字面值与string是不同的类型 </strong></p>
<h3 id="ex3-3-string类的输入运算和getline函数分别如何处理字符串"><a href="#ex3-3-string类的输入运算和getline函数分别如何处理字符串" class="headerlink" title="ex3.3 string类的输入运算和getline函数分别如何处理字符串"></a>ex3.3 string类的输入运算和getline函数分别如何处理字符串</h3><p>string的标准输入：自动忽略字符串开头的空白，从第一个真正的字符开始读取，直到下一个空白为止<br>getline函数：从给定的输入流中读取，直到遇到换行符为止。</p>
<h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><p>vector是一种类模板，需要后加一堆尖括号，在括号内放上信息。</p>
<h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><ul>
<li>1.使用拷贝初始化</li>
<li>2.如果提供一个类内的初始值，只能使用拷贝初始化或者花括号形式初始化</li>
<li>3.如果提供的是初始值元素值的列表，则只能使用花括号初始化，而不能使用圆括号</li>
<li>4.创建指定数量的元素：采用圆括号<h3 id="3-3-2-像vector中添加元素"><a href="#3-3-2-像vector中添加元素" class="headerlink" title="3.3.2 像vector中添加元素"></a>3.3.2 像vector中添加元素</h3>push_back：像一个值添加到vector的尾部。（如果开始不知道有多少元素，c++中，一般先创建一个空的vector然后像其中添加元素最好）<br>不能使用下标形式添加元素，只能对确知已存在的元素执行下标操作。</li>
</ul>
<h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p>迭代器这个名词可能有三种不同的含义：可能是迭代器概念本身，可能是容器定义的类型，还可能指某个迭代器对象。<br>某些对Vector对象的操作回事迭代器失效：一个是不能在范围for循环内向vector中添加元素，另一个是任何一种可能改变vector对象容量的操作，都有可能是vector对象的迭代器失效。</p>
<h3 id="迭代器的算数运算"><a href="#迭代器的算数运算" class="headerlink" title="迭代器的算数运算"></a>迭代器的算数运算</h3><p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。<br>迭代器之间的比较：参与比较的迭代器必须合法且指向同一个容器的元素（或者尾元素的下一个位置）</p>
<h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组与vector的区别：数组的大小确定不变，不能随意像数组中添加元素。性能很好，但是损失了灵活性。</p>
<h3 id="3-5-1-定义和初始化数组"><a href="#3-5-1-定义和初始化数组" class="headerlink" title="3.5.1 定义和初始化数组"></a>3.5.1 定义和初始化数组</h3><p>数组是一种复合类型，数组的维度必须是一个常量表达式。<br>定义数组的时候必须指定数组的类型。同时，数组的元素应该为对象，不存在引用的数组。</p>
<h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char a1[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，没有空字符</div><div class="line">char a2[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，含有显式的空字符</div><div class="line">char a3[]=&quot;C++&quot;;   //自动添加表示字符串结束的空字符</div></pre></td></tr></table></figure>
<h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p><strong> 要想理解数组的声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int &amp;refs[10]=...  //  错误！不存在数组的引用</div><div class="line">int (*Parray)[10]=&amp;arr; //Parray指向一个含有10个整数的数组</div><div class="line">int (&amp;arrRef)[10]=arr   //arrRef引用一个含有10个整数的数组</div><div class="line">int *ptrs[10];  //ptrs是一个含有10个整型指针的数组</div></pre></td></tr></table></figure></p>
<h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><ul>
<li>数组下标为<strong> size_t类型 </strong>，是一种机器相关的无符号类型。<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3>使用数组的时候编译器一般会把它转化成指针<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4>允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。<br>C风格字符串和字符数组的关系，尤其需要考虑串尾是否含有空字符。<br><strong> 问题：为什么没有指针相加？ </strong><br>指着也是一个对象，与指针有关的属性有三个，分别是指针的值（是一个内存地址值）、指针所指的对象、指针本身在内存中的存储位置。显然把两个地址加在一起是没有意义的。<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><h4 id="混用string对象和C风格字符串"><a href="#混用string对象和C风格字符串" class="headerlink" title="混用string对象和C风格字符串"></a>混用string对象和C风格字符串</h4></li>
<li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</li>
<li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（但不能两个都是）；在string对象的赋值运算中允许以空字符串结束的字符数组作为右侧的运算对象。<h4 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h4>允许使用数组初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址即可。但不能使用一个数组为另一个内置类型的数组赋初值，也不能使用vector对象初始化数组。<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。<br>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int ia[3][4] //大小为3的数组，每个元素是含有4个整数的数组</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/04/《cpp primer》ch3字符串、向量、数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mianhk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mianhk">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/04/《cpp primer》ch3字符串、向量、数组/" itemprop="url">《c++primer》ch2 变量和基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-04T17:55:33+08:00">
                2017-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><h3 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h3><h3 id="头文件中不应该包含using声明"><a href="#头文件中不应该包含using声明" class="headerlink" title="头文件中不应该包含using声明"></a>头文件中不应该包含using声明</h3><p>因为头文件的内容会拷贝到所有引用它的文件夹中去，如果头文件中有using声明，可能会产生始料未及的名字冲突。</p>
<h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string s1;   //默认初始化</div><div class="line">string s2=s1;  //s2是s1的副本</div><div class="line">string s2(s1); //等价于string s2=s1,s2是s1的副本</div><div class="line">string s3=&quot;hiya&quot;;  //s3是字面值的副本，但是不包含字面值最后的那个空字符</div><div class="line">string s3(&quot;hiya&quot;);  //等价于string s3=&quot;hiya&quot;</div><div class="line">string s4(n,&apos;c&apos;);  //把s4初始化为连续n个字符c组成的字符串</div></pre></td></tr></table></figure>
<h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><ul>
<li>读写string对象</li>
<li>读取未知数量的string对象</li>
<li>使用getline读取一整行</li>
<li>string的empty和size操作<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3>size_type是一种无符号整形数，如果在表达式中混用了带符号数和无符号数会产生意想不到的后果。<h3 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h3>按字典顺序<h3 id="字面值和string类型相加"><a href="#字面值和string类型相加" class="headerlink" title="字面值和string类型相加"></a>字面值和string类型相加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//错误的方式</div><div class="line">string s=&quot;hello&quot;+&quot;,&quot; //错误，因为两个运算对象都不是string，不能把两个字面值直接相加</div><div class="line">string s1=&quot;hello&quot;+s1+&quot;,&quot; //正确</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong> 字符串字面值与string是不同的类型 </strong></p>
<h3 id="ex3-3-string类的输入运算和getline函数分别如何处理字符串"><a href="#ex3-3-string类的输入运算和getline函数分别如何处理字符串" class="headerlink" title="ex3.3 string类的输入运算和getline函数分别如何处理字符串"></a>ex3.3 string类的输入运算和getline函数分别如何处理字符串</h3><p>string的标准输入：自动忽略字符串开头的空白，从第一个真正的字符开始读取，直到下一个空白为止<br>getline函数：从给定的输入流中读取，直到遇到换行符为止。</p>
<h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><p>vector是一种类模板，需要后加一堆尖括号，在括号内放上信息。</p>
<h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><ul>
<li>1.使用拷贝初始化</li>
<li>2.如果提供一个类内的初始值，只能使用拷贝初始化或者花括号形式初始化</li>
<li>3.如果提供的是初始值元素值的列表，则只能使用花括号初始化，而不能使用圆括号</li>
<li>4.创建指定数量的元素：采用圆括号<h3 id="3-3-2-像vector中添加元素"><a href="#3-3-2-像vector中添加元素" class="headerlink" title="3.3.2 像vector中添加元素"></a>3.3.2 像vector中添加元素</h3>push_back：像一个值添加到vector的尾部。（如果开始不知道有多少元素，c++中，一般先创建一个空的vector然后像其中添加元素最好）<br>不能使用下标形式添加元素，只能对确知已存在的元素执行下标操作。</li>
</ul>
<h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p>迭代器这个名词可能有三种不同的含义：可能是迭代器概念本身，可能是容器定义的类型，还可能指某个迭代器对象。<br>某些对Vector对象的操作回事迭代器失效：一个是不能在范围for循环内向vector中添加元素，另一个是任何一种可能改变vector对象容量的操作，都有可能是vector对象的迭代器失效。</p>
<h3 id="迭代器的算数运算"><a href="#迭代器的算数运算" class="headerlink" title="迭代器的算数运算"></a>迭代器的算数运算</h3><p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。<br>迭代器之间的比较：参与比较的迭代器必须合法且指向同一个容器的元素（或者尾元素的下一个位置）</p>
<h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组与vector的区别：数组的大小确定不变，不能随意像数组中添加元素。性能很好，但是损失了灵活性。</p>
<h3 id="3-5-1-定义和初始化数组"><a href="#3-5-1-定义和初始化数组" class="headerlink" title="3.5.1 定义和初始化数组"></a>3.5.1 定义和初始化数组</h3><p>数组是一种复合类型，数组的维度必须是一个常量表达式。<br>定义数组的时候必须指定数组的类型。同时，数组的元素应该为对象，不存在引用的数组。</p>
<h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char a1[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，没有空字符</div><div class="line">char a2[]=&#123;&apos;C&apos;,&apos;+&apos;,&apos;+&apos;&#125;;  //列表初始化，含有显式的空字符</div><div class="line">char a3[]=&quot;C++&quot;;   //自动添加表示字符串结束的空字符</div></pre></td></tr></table></figure>
<h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p><strong> 要想理解数组的声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int &amp;refs[10]=...  //  错误！不存在数组的引用</div><div class="line">int (*Parray)[10]=&amp;arr; //Parray指向一个含有10个整数的数组</div><div class="line">int (&amp;arrRef)[10]=arr   //arrRef引用一个含有10个整数的数组</div><div class="line">int *ptrs[10];  //ptrs是一个含有10个整型指针的数组</div></pre></td></tr></table></figure></p>
<h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><ul>
<li>数组下标为<strong> size_t类型 </strong>，是一种机器相关的无符号类型。<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3>使用数组的时候编译器一般会把它转化成指针<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4>允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。<br>C风格字符串和字符数组的关系，尤其需要考虑串尾是否含有空字符。<br><strong> 问题：为什么没有指针相加？ </strong><br>指着也是一个对象，与指针有关的属性有三个，分别是指针的值（是一个内存地址值）、指针所指的对象、指针本身在内存中的存储位置。显然把两个地址加在一起是没有意义的。<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><h4 id="混用string对象和C风格字符串"><a href="#混用string对象和C风格字符串" class="headerlink" title="混用string对象和C风格字符串"></a>混用string对象和C风格字符串</h4></li>
<li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</li>
<li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（但不能两个都是）；在string对象的赋值运算中允许以空字符串结束的字符数组作为右侧的运算对象。<h4 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h4>允许使用数组初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址即可。但不能使用一个数组为另一个内置类型的数组赋初值，也不能使用vector对象初始化数组。<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。<br>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int ia[3][4] //大小为3的数组，每个元素是含有4个整数的数组</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/01/简单脚本git一键提交代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mianhk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mianhk">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/01/简单脚本git一键提交代码/" itemprop="url">简单脚本git一键提交代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-01T18:55:29+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂/" itemprop="url" rel="index">
                    <span itemprop="name">杂</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<blockquote>
<p>git是我们每天都会使用的工具，但是一般的使用还是直接通过几个简单的命令，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;...&quot;</div><div class="line">git push origin master</div></pre></td></tr></table></figure></p>
</blockquote>
<p>对于这种简单的步骤，我们每天都会重复无数次，所以巨懒如我就干脆搞个小脚本，直接点一下就提交了。。</p>
<h2 id="一、Window使用bat脚本一键提交代码"><a href="#一、Window使用bat脚本一键提交代码" class="headerlink" title="一、Window使用bat脚本一键提交代码"></a>一、Window使用bat脚本一键提交代码</h2><p>直接新建文件，保存成.bat格式，编辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">title GIT提交批处理——小二三不乌</div><div class="line">color 16</div><div class="line"></div><div class="line"></div><div class="line">echo 开始提交代码到本地仓库</div><div class="line">echo 当前目录是：%cd%</div><div class="line"></div><div class="line">echo 开始添加变更</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git add -A .</div><div class="line">echo 执行结束！</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 提交变更到本地仓库</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">set /p declation=输入修改:</div><div class="line">git commit -m &quot;%declation%&quot;</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 将变更情况提交到远程git服务器</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">git push origin master</div><div class="line">echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line">echo;</div><div class="line">echo 批处理执行完毕！</div><div class="line">echo;</div><div class="line"></div><div class="line">pause</div></pre></td></tr></table></figure></p>
<h2 id="二、编写Python脚本一键提交代码"><a href="#二、编写Python脚本一键提交代码" class="headerlink" title="二、编写Python脚本一键提交代码"></a>二、编写Python脚本一键提交代码</h2><p><strong>额，用Python 好像就比较简单，但是还得cmd输一下，所以还是算了吧。。。 </strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/31/hexo+gitpage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mianhk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mianhk">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/31/hexo+gitpage/" itemprop="url">使用gitpage+Hexo搭建自己的博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T08:55:29+08:00">
                2017-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂/" itemprop="url" rel="index">
                    <span itemprop="name">杂</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。"><a href="#如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。" class="headerlink" title="如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。"></a>如今，各种博客网站都可以让我们随意的写作，但是很多的选择也让我们有时候不知道该怎么选择，而且作为喜欢折腾的程序员来说，自己搭建属于自己的博客当然是一个很好的选择了。可以将文件保存在本地，随时换自己的风格，备份，做一些diy的调整。</h2><h2 id="一、准备工作，准备需要准备好以下软件："><a href="#一、准备工作，准备需要准备好以下软件：" class="headerlink" title="一、准备工作，准备需要准备好以下软件："></a>一、准备工作，准备需要准备好以下软件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Node.js环境</div><div class="line">Git</div></pre></td></tr></table></figure>
<h3 id="1-Windows配置Node-js环境下载Node-js安装文件："><a href="#1-Windows配置Node-js环境下载Node-js安装文件：" class="headerlink" title="1.Windows配置Node.js环境下载Node.js安装文件："></a>1.Windows配置Node.js环境下载Node.js安装文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Windows Installer 32-bit</div><div class="line">Windows Installer 64-bit</div></pre></td></tr></table></figure>
<ul>
<li><p>根据自己的Windows版本选择相应的安装文件。<br><img src="https://xuanwo.org/imgs/opinion/Nodejs-install.png" alt=""></p>
</li>
<li><p>保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口：<br><img src="http://upload-images.jianshu.io/upload_images/6054281-bc2e6deb5f394f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li>在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~） 在打开的命令行界面中，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node -v</div><div class="line">npm -v</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。<br>(<a href="https://xuanwo.org/imgs/opinion/Nodejs-test.png" target="_blank" rel="external">https://xuanwo.org/imgs/opinion/Nodejs-test.png</a>)</p>
<h3 id="2-配置Git环境下载Git安装文件："><a href="#2-配置Git环境下载Git安装文件：" class="headerlink" title="2.配置Git环境下载Git安装文件："></a>2.配置Git环境下载Git安装文件：</h3><p><a href="https://github.com/git-for-windows/git/releases/download/v2.6.3.windows.1/Git-2.6.3-64-bit.exe" target="_blank" rel="external">Git-2.6.3-64-bit.exe</a></p>
<p>然后就进入了Git的安装界面，如图：<br><img src="https://xuanwo.org/imgs/opinion/Git-install.png" alt=""><br>和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择：<br><img src="https://xuanwo.org/imgs/opinion/Git-path-setting.png" alt=""></p>
<blockquote>
<p>这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。</p>
</blockquote>
<p>一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git --version</div></pre></td></tr></table></figure></p>
<p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。<br><img src="https://xuanwo.org/imgs/opinion/Git-test.png" alt=""></p>
<h2 id="二、新建仓库"><a href="#二、新建仓库" class="headerlink" title="二、新建仓库"></a>二、新建仓库</h2><h3 id="1-打开https-github-com-，在下图的框中，分别输入自己的用户名，邮箱，密码。"><a href="#1-打开https-github-com-，在下图的框中，分别输入自己的用户名，邮箱，密码。" class="headerlink" title="1.打开https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。"></a>1.打开<a href="https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。" target="_blank" rel="external">https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。</a></h3><h3 id="2-创建代码库登陆之后，点击页面右上角的加号，选择New-repository："><a href="#2-创建代码库登陆之后，点击页面右上角的加号，选择New-repository：" class="headerlink" title="2.创建代码库登陆之后，点击页面右上角的加号，选择New repository："></a>2.创建代码库登陆之后，点击页面右上角的加号，选择New repository：</h3><p>进入代码库创建页面：<br>在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示：<br><img src="https://xuanwo.org/imgs/opinion/Github-new-repo-setting.png" alt=""><br>正确创建之后，你将会看到如下界面：<br><img src="https://xuanwo.org/imgs/opinion/Github-new-repo-look-like.png" alt=""><br>开启gh-pages功能点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图：<br><img src="https://xuanwo.org/imgs/opinion/Github-pages.png" alt=""><br>点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。<br>配置Hexo安装Hexo在自己认为合适的地方创建一个文件夹，然后在文件夹空白处按住Shift+鼠标右键，然后点击在此处打开命令行窗口。（同样要记住啦，下文中会使用在当前目录打开命令行来代指上述的操作）<br>在命令行中输入：<br><code>npm install hexo-cli -g</code><br>然后你将会看到:<br><img src="https://xuanwo.org/imgs/opinion/npm-install-hexo-cli.png" alt=""><br>可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入<br><code>npm install hexo --save</code></p>
<p>然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入：<br><code>hexo -v</code></p>
<p>如果你看到了如图文字，则说明已经安装成功了。<br><img src="https://xuanwo.org/imgs/opinion/hexo-v.png" alt=""><br>初始化Hexo接着上面的操作，输入：<br><code>hexo init</code></p>
<p>如图：<br><img src="https://xuanwo.org/imgs/opinion/hexo-init.png" alt=""><br>然后输入：<br><code>npm install</code></p>
<p>之后npm将会自动安装你需要的组件，只需要等待npm操作即可。</p>
<h2 id="首次体验Hexo"><a href="#首次体验Hexo" class="headerlink" title="首次体验Hexo"></a>首次体验Hexo</h2><p>继续操作，同样是在命令行中，输入：<br><code>hexo g</code></p>
<p>如图：<br><img src="https://xuanwo.org/imgs/opinion/hexo-g.png" alt=""><br>然后输入：<br><code>hexo s</code></p>
<p>然后会提示：<br><code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>
<p>在浏览器中打开<code>http://localhost:4000/</code>，你将会看到：<br><img src="https://xuanwo.org/imgs/opinion/hexo-first-time.png" alt=""><br>到目前为止，Hexo在本地的配置已经全都结束了。</p>
<h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><blockquote>
<p>在配置过程中请使用yamllint来保证自己的yaml语法正确<br>修改全局配置文件此段落引用自<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo官方文档</a><br>您可以在 _config.yml 中修改大部份的配置。</p>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>参数 | 描述<br>title | 网站标题<br>subtitle | 网站副标题<br>description | 网站描述<br>author | 您的名字<br>language | 网站使用的语言<br>timezone | 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</p>
<h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td>网址</td>
</tr>
<tr>
<td>root</td>
<td>网站根目录</td>
<td>permalink文章的 永久链接 格式:year/:month/:day/:title/permalink_default永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 <a href="http://yoursite.com/blog，则请将您的">http://yoursite.com/blog，则请将您的</a> url 设为 <a href="http://yoursite.com/blog">http://yoursite.com/blog</a> 并把 root 设为 /blog/。</td>
</tr>
</tbody>
</table>
<p>目录参数描述默认值source_dir资源文件夹，这个文件夹用来存放内容。sourcepublic_dir公共文件夹，这个文件夹用于存放生成的站点文件。publictag_dir标签文件夹tagsarchive_dir归档文件夹archivescategory_dir分类文件夹categoriescode_dirInclude code 文件夹`downloads/codei18n_dir国际化（i18n）文件夹:langskip_render跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 文章参数描述默认值new_post_name新文章的文件名称:title.mddefault_layout预设布局postauto_spacing在中文和英文之间加入空格falsetitlecase把标题转换为 title casefalseexternal_link在新标签中打开链接truefilename_case把文件名称转换为 (1) 小写或 (2) 大写0render_drafts显示草稿falsepost_asset_folder启动 Asset 文件夹falserelative_link把链接改为与根目录的相对位址falsefuture显示未来的文章truehighlight代码块的设置 分类 &amp; 标签参数描述默认值default_category默认分类uncategorizedcategory_map分类别名 tag_map标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。<br>参数描述默认值date_format日期格式MMM D YYYYtime_format时间格式H:mm:ss分页参数描述默认值per_page每页显示的文章量 (0 = 关闭分页功能)10pagination_dir分页目录page扩展参数描述theme当前主题名称。值为false时禁用主题deploy部署部分的设置配置Deployment首先，你需要为自己配置身份信息，打开命令行，然后输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;yourname&quot;</div><div class="line">git config --global user.email &quot;youremail&quot;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>同样在_config.yml文件中，找到Deployment，然后按照如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git@github.com:yourname/yourname.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>如果使用git方式进行部署，执行npm install hexo-deployer-git –save来安装所需的插件<br>然后在当前目录打开命令行，输入：<br><code>hexo d</code></p>
<p>随后按照提示，分别输入自己的Github账号用户名和密码，开始上传。 然后通过<a href="http://yourname.github.io/来访问自己刚刚上传的网站。" target="_blank" rel="external">http://yourname.github.io/来访问自己刚刚上传的网站。</a><br>添加新文章打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就能在执行hexo g的时候被渲染。 新建的文章头需要添加一些yml信息，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: hello-world   //在此处添加你的标题。</div><div class="line">date: 2017-5-11 08:55:29   //在此处输入你编辑这篇文章的时间。</div><div class="line">categories: Exercise   //在此处输入这篇文章的分类。</div><div class="line">toc: true    //在此处设定是否开启目录，需要主题支持。</div></pre></td></tr></table></figure></p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>如果成功完成了上述的全部步骤，恭喜你，你已经搭建了一个最为简单且基础的博客。但是这个博客还非常简单， 没有个人的定制，操作也比较复杂，下面的进阶技巧将会让你获得对Hexo更为深入的了解。<br>更换主题可以在此处寻找自己喜欢的主题 下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改：</p>
<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><h4 id="Plugins-http-hexo-io-plugins"><a href="#Plugins-http-hexo-io-plugins" class="headerlink" title="Plugins: http://hexo.io/plugins/"></a>Plugins: <a href="http://hexo.io/plugins/" target="_blank" rel="external">http://hexo.io/plugins/</a></h4><h4 id="Themes-http-hexo-io-themes"><a href="#Themes-http-hexo-io-themes" class="headerlink" title="Themes: http://hexo.io/themes/"></a>Themes: <a href="http://hexo.io/themes/" target="_blank" rel="external">http://hexo.io/themes/</a></h4><p>theme: landscape //themes文件夹中对应文件夹的名称</p>
<p>然后先执行<code>hexo clean</code>，然后重新<code>hexo g</code>，并且<code>hexo d</code>，很快就能看到新主题的效果了~<br>更换域名首先，需要注册一个域名。在中国的话，.cn全都需要进行备案，如果不想备案的话，请注册别的顶级域名，可以使用godaddy或新网或万网中的任意一家，自己权衡价格即可。 然后，我们需要配置一下域名解析。推荐使用DNSPod的服务，比较稳定，解析速度比较快。在域名注册商出修改NS服务器地址为：<br>f1g1ns1.dnspod.net<br>f1g1ns2.dnspod.net</p>
<p>以新网为例，首先点击域名管理进入管理页面：</p>
<p>然后点击域名后面的管理：</p>
<p>进入域名管理的操作界面，点击域名管理，来到域名管理界面：</p>
<p>点击修改域名DNS，然后选择填写具体信息，在下面的空框中填入DNSPod的NS服务器：</p>
<p>然后我们进入DNSPod的界面，开始真正进入域名解析的配置= =。在DNSPod中，首先添加域名，然后分别添加如下条目：</p>
<p>最后，我们对Github进行一下配置。<br>在自己本地的hexo目录下的source文件夹中，新建一个CNAME文件（注意，没有后缀名。），内容为yourdomin.xxx。然后再执行一下hexo d -g，重新上传自己的博客。 在github中打开你自己的库，进入库的setting界面，如果看到了如下提示，说明配置成功了。</p>
<p>在这一系列的操作中，包括修改NS服务器，设置A解析等等，都需要一定的时间。短则10分钟，长则24小时，最长不会超过72小时。如果超过72小时，请检查自己的配置过程，或者修改自己本地的DNS服务器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/新建博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mianhk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mianhk">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/15/新建博客/" itemprop="url">我为什么写博客？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-15T19:56:31+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开博客的第一天–谈学习与博客"><a href="#开博客的第一天–谈学习与博客" class="headerlink" title="开博客的第一天–谈学习与博客"></a>开博客的第一天–谈学习与博客</h1><hr>
<h4 id="作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。"><a href="#作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。" class="headerlink" title="作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。"></a>作为一个不是总能坚持一些事情的人，在这个碎片化的时代，每个人都有着自己的事情，学习、工作、生活、吃、玩。也正是很多乱七八糟的包围着我们。作为一个通信工程的学生，我深深的理解并期待互联网给生活带来了超乎想象的便利与良好的生活体验，但是，就像你以为你发现了一个有意思的东西，其实是你被他让你发现了。你是被绑架的可怜的那个。我想说的是，不管是你认真理解的生活，还是学习，是真的能够好好思考才能有自己的东西。</h4><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h4 id="那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。"><a href="#那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。" class="headerlink" title="那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。"></a>那么，怎么才能好好思考呢，首先是要有足够的知识，才能减少信息不对称，才能在看到什么能够知道更多的什么，才能够举一反三。但是你每天还要刷微博，还要看新闻，还要看编程，还要忙老板的事情，想要在一年后想起自己曾经做过什么的小事或者学过的一点东西很难，因为它们大部分都不是在你学习的时候已经打好了标签，写着，一年后的某个中午会用到它，如果真的可以那样倒也还好，我们无非是在学习的时候加个备忘录就好了。</h4><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h4 id="然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99-可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？"><a href="#然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99-可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？" class="headerlink" title="然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99.可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？"></a>然后，事情就变成怎样将放弃看剧打游戏时间来学习的东西记下来了，至少更深刻吧。长达十几年学渣生涯告诉我，就是做笔记，可能大学的时候确实太渣了，只能在快要考试的时候再抄一下笔记，或者整理出一份重点才行，那就是多年后翻起来仍然能让你想起来那门课学了什么，在那个时间段学了什么的，更具体的学了什么。而不是模电学过，数电学过，甚至爱装逼的话还能记起来某门专业课考了99.可是这样就算拿出去装逼自己都不记得是什么课，更何况是学了什么呢？</h4><h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><h4 id="今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。"><a href="#今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。" class="headerlink" title="今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。"></a>今天，是我最喜欢的球队，圣安东尼奥马刺队西部总决赛第一场，早上五点多起来看球的时候，发现莱昂纳德受伤了，很伤心。看到网上各种互怼，有那么一瞬间就觉得，当事人都觉得打球比这个更重要，不管能不能上场，接下来的比赛都更重要，何况是我这个只是连个腾讯体育会员都没买的支持者呢。</h4><h3 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h3><h4 id="所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧："><a href="#所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧：" class="headerlink" title="所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧："></a>所谓开始，我总不觉得需要有什么原因，这个不重要，重要的是永远是以后。最后以马刺队更衣室的一段话开始吧：</h4><blockquote>
<p> When nothing seems to help,I go and look at a stonecutter hammering away at his rock perhaps a hundred times without as much as a crack showing in it.Yet at the hundred and first blow it will split in two,and I know it was not that blow that did it——but all that had gone before.<br>——Jacob Riis</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mianhk" />
          <p class="site-author-name" itemprop="name">Mianhk</p>
           
              <p class="site-description motion-element" itemprop="description">you don't know</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mianhk</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
