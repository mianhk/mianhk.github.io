+++
title = "《c++primer》ch4 表达式"
date = "2017-06-05T17:55:33+08:00"
categories = ["C++"]
tags = ["C++"]
toc = true
description = ""
+++

> 不管学习什么语言都会有这么一章，不管是c、java、Python，这都是会经历的一章，唉，无奈当时年少无知不止梦想是什么的我每每看到这些的时候都觉得很烦。当再一次翻开c++的这一章的时候，也有这样的感觉，似曾相识燕归来，却又无可奈何花落去。
> 我认为这一章的很多都不是需要太多的去深究，只需要有个大概的概念，然后更多的是在今后的编程过程中，不断的实践自然就知道了，是怎样写的。而且累死一些优先级的问题，更多的时候就像书里建议的那样，一个括号来的简单粗暴实用的多，所以，这章，就记一下实在有违常规的理解的内容吧。


<!-- more -->
### 4.1 基础
* 运算对象转换：小整数类型（如bool、char、short等）通常会被提升为较大的整数类型，主要是int。
* 左值和右值：一个左值表达式的求值结果时一个对象或者一个函数，以常量对象为代表的某些左值不能作为赋值语句的左侧运算对象。** 简单归纳：当对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置） **
* 左值右值使用原则：需要右值的地方可以用左值代替，但是不能把右值当成左值使用。当一个左值被当成一个右值使用的时候，实际上使用的是它的内容（值  ）
* 需要用到左值的地方：
1.赋值运算符。需要左值作为其左值运算对象，得到结果仍然是一个左值
2.取地址符。返回一个指向该运算对象的指针，这个指针是一个右值
3.内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值
4.内置类型和迭代器的递增递减运算符作用于左值运算对象，得到的结果是左值。
* 关键字decltype中左值和右值的不同
* 处理复合表达式的经验：使用括号；如果改变了某个运算对象的值，就不要在表达式的其它地方再使用这个运算对象

### 4.2 算数运算符
溢出的情况，值会发生“环绕”

### 4.3 逻辑和关系运算符
进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值作为运算对象

### 4.4 赋值运算符
赋值运算满足右结合律
参与连续赋值的变量必须是相同的类型

### 4.5 递增和递减运算符

### 4.6 成员访问运算符
解应用运算符的优先级低于点运算符
```
cond?expr1:expr2;
//输出表达式中使用条件运算符
cout<<((grade<60)?"fail":"pass"); //输出pass或者fail
```
条件运算符可以嵌套，一般为了代码的可读性，嵌套不要超过三层。

### 4.7 sizeof运算符
sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得值是一个size_t类型的常量表达式
```
sizeof(type)
sizeof expr
```

### 4.10 逗号运算符
首先对左侧表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。

### 4.11 类型转换
#### 发生隐式类型转换
* 比int小的整形值首先提升为较大的整数类型
* 条件中，非bool值转为bool值。
* 初始化过程中，初始值转化为变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型
* 如果算数预算或关系运算对象有多种类型，需要转换成同一种类型。
* 函数调用时，也可能发生类型转换

#### 显示转换
```
cast-name<type>(expression)
cast-name:static_cast,dynamic_cast,const_cast,reinterpret_cast
```
static_cast:任何具有明确定义的类型转换，只要不包含底层const都可以使用。
const_cast:只能改变运算对象的底层const
dynamic_cast：支持运行时类型识别
reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释。（使用起来非常危险）

** 尽量避免强制类型转换 **

