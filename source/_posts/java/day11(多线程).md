---
title: day11&12(多线程)
date: 2017-03-09 12:55:17
categories: Java
tags: java
---
# 多线程

----------
进程：是一个正在执行中的程序。
每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制单元。
线程：就是进程中的一个独立的控制单元。  线程在控制着进程的执行。
一个进程中至少有一个线程。
java VM启动的时候会有一个进程jav.exe。该进程中至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main方法中。该线程称之为主线程。
扩展：其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。

----------
# 创建线程
1. 如何在自定义的代码中，自定义一个线程？
通过对API的查找，java已经提供了对线程这类事物的描述，就Thread类。
创建线程的第一种方式：继承Thread类。
步骤：定义类继承Thread；复写Thread类中的run方法；调用线程的start方法。
发现运行结果每次都不同。因为多个线程都获取cpu的执行权，CPU执行到谁，谁就运行。（多核除外），cpu在做着快速的切换，以达到看上去是同时运行的效果

----------
# 创建线程-run和start的特点
为什么要覆盖run方法？
Thread类用于描述线程。该类定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法。
也就是说Thread类中的run方法，用于存储线程要运行的代码。
# 线程运行状态

原来线程都有自己默认的名称。Thread-编号，该编号从0开始。
static Thread currentThread()：获取当前线程对象。
getName()：获取线程名称
设置线程名称：setName或者构造函数。

----------
# 创建线程-runable接口
创建线程的第二种方式：实现Runable接口
步骤：
1. 定义类实现Runable接口
2. 覆盖Runable接口中的run方法。  （将线程要运行的代码存放到该run方法中）
3. 通过Thread类建立线程对象。
4. 将Runable接口的子类对象作为实际参数传递给Thread类的构造函数。（自定义的run方法所属的对象时Runable接口的子类对象。所以要让线程去指定对象的run方法，就必须明确该run方法所属的对象）
5. 调用Thread类的start方法开启线程并调用Runable接口子类的run方法。

----------
实现方式和继承方式有什么区别呢？
实现方式：避免了单继承的局限性。在定义线程时，建议使用实现方式。
两种方式的区别：
继承Thread：线程代码存放在Thread子类的run方法中。
实现Runable：线程 代码存在接口的子类的run方法中。

----------

# 多线程的安全问题
多线程运行出现安全问题的原因：
当多条语句在操作同一个线程共享数据时，一个线程对多条语句值执行了一部分，还没有执行完，另一个线程参与执行。导致共享数据的错误。
解决办法：
对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中，其他线程不可以参与执行。
  java对于多线程的安全问题提供了专业的解决方式。
同步代码块。
synchronized（对象）{需要被同步的代码}
对象如同锁。持有锁的线程可以在同步中执行。没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有获取锁。
同步的前提：
1. 必须要有两个或两个以上的线程。
2. 必须是多个线程使用同一个锁
3必须保证同步中只能有一个线程在运行。
好处：解决了多线程的安全问题。
弊端：多个线程需要判断锁，较为消耗资源。

----------

# 多线程-同步函数
**同步函数的锁用的是this。
静态同步函数的锁是Class对象**

----------

# 多线程-死锁

#多进程（二）

----------

## 1线程间通信
线程间通讯：其实就是多个线程在操作同一个资源，但是操作的动作不同。

##2解决安全问题
## 3等待唤醒机制
wait  notify notifyAll 都使用在同步中，因为要对持有监视器（锁）的线程操作。所以要使用在同步中，以为只有同步才具有锁。
为什么这些操作线程的方法要定义在Object类中呢？
因为这些方法在操作同步中线程时，都必须要标识他们所操作线程只有的锁。只有同一个锁上的等待线程，可以被同一个锁上的notify唤醒。不可以对不同锁中的线程进行唤醒。
也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法定义在Object类中。
