---
title: day5(面向对象2)
date: 2017-03-09 12:55:17
categories: Java
tags: java
---
# 面向对象（3）
# *（继承，final，抽象类，接口）*

----------

## 1.继承（概述）
* **继承：**

1.提高了代码的复用性

2.继承让类与类之间有了关系，有了关系才有了多态的特性。

注意：千万不要为了获取其他类的功能，简化代码而继承。
必须是类与类之间有所属关系才可以继承，所属关系 is a。

**java语言中：java只支持单继承，不支持多继承。**

  因为多继承容易带来安全隐患：当多个父类中定义了相同的功能，当功能内容不同时，子类对象不确定要运行哪一个。
  但是java保留了这种机制，并用另一种体现形式来完成表示，多实现。

* **java支持多层继承。**



* **如何使用一个继承体系中的功能？**

想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系的共性功能。

通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了
那么在具体调用时，要创建最子类的对象。
因为：1.可能父类不能创建对象 2.创建子类可以使用更多的功能，包括基本的也包括特有的
简单的说，就是查阅父类，创建子类
## 2.聚集关系
聚集：has a
聚合：
组合：


子父类出现后，类成员的特点
类成员：
1.变量
2.函数
3.构造函数

## 3.1.子父类中的变量的特点
如果子类中出现非私有的同名成员变量时，子类要访问本类中的变量，用this
super代表的是父类对象的引用
## 3.2.子父类中的函数的特点
当子类和父类中出现一样的函数时，当子类对象调用该函数，会运行子类函数的内容。如同父类的函数被覆盖一样。
这种情况是函数的另一个特性：重写（覆盖）
当子类继承父类，沿袭了父类的功能，但是功能的内容却和父类不一致。这时没有必要定义新功能，而是使用覆盖特殊，保留父类的功能定义，并重写功能内容。

覆盖：
1.子类覆盖父类，必须保证子类权限大于父类权限，否则编译失败
2.静态只能覆盖静态。

## 3.3.子父类中构造函数的特点--子类的实例化过程
重载：只看重名函数的参数列表。
重写：子类父类方法要一模一样。

子父类中的构造函数：
在对子类对象进行初始化 时，弗父类的构造函数也会运行，那是因为子类的构造函数第一行默认有一条隐式语句super()；
super()：会访问父类中空参数的构造函数。而且子类中所有的构造函数默认第一行都是super()
为什么子类一定要访问父类中的构造函数？
因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要先查看父类如何对这些数据进行初始化的，所以子类在对象进行初始化时，要先访问一下父类中的构造函数
如果要访问父类中指定的构造函数，可以用super语句来指定。

注意：super语句一定定义在子类构造函数的第一行。

* 子类的实例化过程：

结论：子类所有的构造函数默认都会访问父类中空参数的构造函数，因为子类每一个构造函数的第一行都有一句隐式的super()
当父类中没有空的构造函数时，子类必须手动通过super或者this语句形式来指定要访问父类中的构造函数。
当然：子类中的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数

## 4.final关键字
final：最终，作为一个修饰符

1. 可以修饰类，函数，变量
2. 被final修饰的类不可以被继承,为了避免被继承，被子类复写功能
3. 被final修饰的方法不可以被复写
4. 被final修饰的变量是一个常量只能赋值一次，既可以修饰局部变量，也可以修饰成员变量。
	在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这值起个名字，方便于阅读，而这个值不需要改变，所以加个final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成，单词间通过_连接。
5. 内部类定义在类中的局部位置时，只能访问该局部被final修饰的局部变量。

## 5.抽象类
当多个类中出现相同功能，但是功能的主体不同，这时可以向上抽取，这时只能抽取功能定义，而不抽取功能主题
抽象：看不懂
抽象类的特点：

1. 抽象方法一定在抽象类中。
2. 抽象方法和抽象类都必须被abstract关键字修饰。
3. 抽象类不可以用new创建对象，因为调用抽象方法没意义。
4. 抽象类中的方法要被使用，必须由子类复写起所有的抽象方法之后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。

抽象类和一般类没有太大的不同。
该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。
这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。


抽象类比一般类多了个抽象函数。就是在类中可以定义抽象方法。
抽象类不可以实例化。
特殊：抽象类中可以不定义抽象方法，这样做仅仅是为了不让该类建立对象。

## 6.模板方法设计模式
在定义功能时，功能的一部分是确定的，但是有一部分功能时不确定的，而确定的部分在使用不确定的部分，就将不确定的部分暴露出去，

## 7.接口
*  **接口**：初期理解，可以认为是一个特殊的抽象类
当抽象类中的方法都是抽象的，那么该类可以通过接口的形式实现
class 用于定义类
interface 用于定义接口
接口定义时，格式特点：
1. 接口中常见定义：常量，抽象方法。
2. 接口中的成员都有固定的修饰符。常量：public static final
   方法：public abstract
记住，接口中的成员都是public的
接口是不可以创建对象的，因为有抽象方法。
需要被子类实现，子类对接口中的抽象方法全部覆盖后，子类才可以实例化。否则子类是一个抽象类
* **接口可以被类多实现**
**接口与接口之间可以多继承**
## 8.接口的特点
1. 接口是对外暴露的规则
2. 接口是程序的程序扩展
3. 接口可以用来多实现
4. 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口
5. 接口与接口之间可以有继承关系
