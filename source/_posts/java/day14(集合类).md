---
title: day14&15(集合类)
date: 2017-03-09 12:55:17
categories: Java
tags: java
---
# 集合类

----------
## 集合框架（体系概述）
为什么出现集合类？
数组是固定长度的，集合是可变长度的。
为什么出现这么多的容器？
因为每一个容器对数据的存储方式都有不同。这个存储方式称之为：数据结构。
##集合框架（共性方法）
## 迭代器
什么是迭代器？
其实就是集合中元素的取出方式。
把取出方式定义在集合的内部，这样取出方式就可以直接访问集合内容的元素。那么取出方式就被定义成了内部类。而每一个容器的结构数据不同，所以取出的动作细节也不一样。但是都有共性内容：判断和取出。那么可以将这些共性抽取。
## List
### List集合共性方法
List：元素是有序的，元素可以重复，因为该集合体系有索引。
Set：元素是无序的，不能重复。
List：特有方法：凡是可以操作角标的方法都是该体系特有的方法。
增：add addAll
删： remove
改：set
查：get subList listIterator
### ListIterator
在迭代器时，只能用迭代器的方法操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。
该接口只能通过List集合的ListIterator方法获取。
### List集合具体对象的特点
List：
ArrayList：底层的数据结构使用的是数组，查找很快，但是增删稍慢 （可变长度的）
Linkedlist：底层使用的是链表数据结构。特点是增删速度很快，查询稍慢
Vector：底层是数组数据结构。线程同步，被ArrayList替代了 ，现在一般不用了。枚举是Vector特有的取出方式。发现枚举和迭代器很像。其实枚举和迭代是一样的。因为枚举的名称以及方法的名称都过长。所以被迭代器取代了。
### LinkedList
LinkedList特有方法：addFirst(),addLast(),getFirst(),getLast(),removeFirst(),removeLast()
JDK1.6出现了替代方法。
offerFriest  peekFirst poolFirst
堆栈：先进后出
队列： 先进先出 FIFO
List集合判断元素是否相同，依据的是元素的equals方法。
##set
set：元素是无序（存入和取出的顺序不一定一致）
set集合的功能和collection是一致的。
HashSet：底层数据结构是哈希表。HashSet是如何保证元素的唯一性的呢？是通过元素的两个方法。hashCode和equals来完成。如果元素的HashCode值相同，才会判断equals是否为true，如果元素的hashCode不同，不会判断equals。
注意：对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashcode和equals方法。

# 集合框架2

----------
##set
set：无序，不可以重复元素。
hashset：数据结构是哈希表，线程非同步的，保证元素唯一性的原理，判断元素的hashCode值是否相同。如果相同，判断equals
TreeSet：可以对set集合中的元素进行排序。
底层数据结构是二叉树。保证元素唯一性的依据：compareTo return 0
往TreeSet集合中存储自定义对象学生。想按照学生的年龄进行排序。
记住：排序时，当主要条件相同时，一定判断一下次要条件。
## 二叉树
TreeSet排序的第一种方式：让元素自身具备比较性。元素需要事项compareable接口，覆盖compareTo方法。这种方式也称为元素的自然顺序，或者叫做默认顺序。
TreeSet排序的第二种方式：当元素自身不具备比较性时，或者具备的比较性不是锁需要的。这时就需要让集合自身具备比较性。在集合初始化时，就有了比较方式。
当元素自身不具备比较性，或者具备的比较性不是所需要的。这时需要让容器自身具备比较性，定义了比较器，将比较器对象作为参数传递给TreeSet集合的构造函数。
当两种排序都存在时，以比较器为主。定义一个类实现Comparator接口，覆盖compare方法。
## 泛型
JDK1.5之后出现的新特性，用于解决安全问题，是一个安全机制。
好处：
1. 将运行时期出现问题转移到编译时期，便于程序员解决。
2. 避免了强制转换的麻烦。
泛型格式：通过<>来定义要操作的引用数据类型
在使用java提供的对象时，什么时候写泛型？
通常在集合框架中很常见，只要见到<>就要定义泛型。其实<>就是用来接收类型的。当使用集合时，将集合中的要存储的数据类型放到<>中即可。
## 泛型类
泛型类：带泛型的类。
当类中要操作的引用数据类型不确定的时候，早期定义Object来完成扩展，现在定义泛型完成扩展。
## 泛型方法
泛型类定义的泛型，在整个类中有效，如果被方法使用，那么泛型类的对象没明确要操作的具体类型后，所有要操作的类型就已经固定了。为了让不同方法可以操作不同类型，而且类型还不确定，那么可以将泛型定义到方法上。
## 静态方法泛型
特殊之处是：静态方法不可以访问类上定义的泛型，如果静态方法操作的引用数据类型不确定，可以将泛型定义在方法上。
## 泛型接口
## 泛型限定
？： 通配符，也可以理解为占位符。
泛型的限定： ？ extends E：可以接收E类型或者E的子类型。上限
			     ？ super E：可以接收E类型或者E的父类型。下限
                 
# 集合(MAP)
## Map集合：该集合存储键值对。一对一对往里存。而且要保证键的唯一性。
1. 添加。
2. 删除。clear()
3. 判断。
4. 获取。
Map：Hashtable：底层是哈希表数据结构，不能存入null键null值，是线程同步的。
  HashMap:底层是哈希表数据结构，允许使用null键null值，该集合是不同步的。
 TreeMap：底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。--和Set很像，其实Set底层就是使用了Map集合。
## Map子类对象的特点
## Map共性方法
## Map-keySet
map集合的两种取出方式：
1. keySet：将map中所有的键存入到set集合。因为set具备迭代器。所有可以迭代方式取出所有的键，在根据get方法。获取每一个键对应的值。
2. entrySet
Set<Map.Entry<K,V>> entrySet:将Map集合中的映射关系存入了set集合中，而这个关系的数据类型就是：Map.entry。其实Entry也是一个借口，它是Map接口中的一个内部接口。
## Map练习
当发现有映射关系时，可以选择map集合。因为map集合中存放的就是映射关系。
什么时候使用map集合？当数据之间存在映射关系时，就要先想map集合
##map扩展知识
map集合被使用是因为具备映射关系。
