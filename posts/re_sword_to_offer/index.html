<!doctype html><html lang=zh-cn dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>剑指offer-刷题总结 | mianhk's notes</title>
<meta name=keywords content="C++,LeetCode,剑指offer">
<meta name=description content="
重刷剑指offer总结

">
<meta name=author content="mianhk">
<link rel=canonical href=https://yuguocong.cn/posts/re_sword_to_offer/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123 -45','auto'),ga('send','pageview'))</script><meta property="og:title" content="剑指offer-刷题总结">
<meta property="og:description" content="
重刷剑指offer总结

">
<meta property="og:type" content="article">
<meta property="og:url" content="https://yuguocong.cn/posts/re_sword_to_offer/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-06-20T21:40:02+08:00">
<meta property="article:modified_time" content="2018-06-20T21:40:02+08:00"><meta property="og:site_name" content="mianhk's notes">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="剑指offer-刷题总结">
<meta name=twitter:description content="
重刷剑指offer总结

">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuguocong.cn/posts/"},{"@type":"ListItem","position":2,"name":"剑指offer-刷题总结","item":"https://yuguocong.cn/posts/re_sword_to_offer/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"剑指offer-刷题总结","name":"剑指offer-刷题总结","description":" 重刷剑指offer总结\n ","keywords":["C++","LeetCode","剑指offer"],"articleBody":" 重刷剑指offer总结\n 01.二维数组中的查找  在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n 分析：由于每一行都有递增的特性，我们可以采用类似二分搜索的方法。将数组分成行列来进行搜索。\nclass Solution { public: bool Find(int target, vector  array) { if(0==array.size()) return false; int raw=array.size(); int col=array[0].size(); for(int i=0;i=target){ for(int j=0;j02.替换空格  请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n 考虑到是在原字符串上操作，如果遇到一个空格就替换的话，需要把后面的都要后移两位，这个复杂度就大了，所以可以先遍历第一遍，找到空格的总数，之后就可以计算替换后的字符串长度。再经过第二遍遍历，从后往前开始替换，这样就不用移动了。\nclass Solution { public: void replaceSpace(char *str,int length) { if(lengthlength) return; str[new_length]='\\0'; while(origin_length0){ --origin_length; if(str[origin_length]==' '){ str[--new_length]='0'; str[--new_length]='2'; str[--new_length]='%'; } else{ str[--new_length]=str[origin_length]; } } } }; 03.从尾到头打印链表  输入一个链表，从尾到头打印链表每个节点的值。\n 分析：由于链表我们必须从头到尾遍历才能从链表尾开始，所以直接打印的话，需要先从前往后遍历一遍找到链表尾节点，再从后往前遍历打印。能够进行的改善是，通过增加O(N)的空间复杂度，第一次遍历的时候，将数据放在一个栈中，之后再从栈中把所有的数都弹出来就好。\n/** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector printListFromTailToHead(ListNode* head) { vector res; if(!head) return res; stack istack; while(head){ istack.push(head-val); head=head-next; } while(!istack.empty()){ res.push_back(istack.top()); istack.pop(); } return res; } }; 04.重建二叉树  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n 分析：首先需要知道的是前序遍历和后续遍历的特点，程序中可以维护4个子数组，当进行递归调用。\n/** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reConstructBinaryTree(vector pre,vector vin) { if(pre.empty() || pre.size()!=vin.size()) return nullptr; vector pre1,pre2,vin1,vin2; TreeNode* root=new TreeNode(pre[0]); int i=0; for(;ileft=reConstructBinaryTree(pre1,vin1); root-right=reConstructBinaryTree(pre2,vin2); return root; } }; 不过上述的方法有个问题，虽然看起来比较好理解，但是增加了空间复杂度，其实这里可以多加一个递归函数就好了，所以觉得还是需要重新写一下。\n/** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* recurse(vector\u0026 pre,int begin1,int end1,vector\u0026 vin,int begin2,int end2){ if(begin1end1 || begin2end2) //退出条件 return nullptr; TreeNode* root=new TreeNode(pre[begin1]); for(int i=begin2;ileft=recurse(pre,begin1+1,begin1+i-begin2,vin,begin2,i-1); //递归的重点，这个要考虑清楚 root-right=recurse(pre,begin1+1+i-begin2,end1,vin,1+i,end2); break; } } return root; } TreeNode* reConstructBinaryTree(vector pre,vector vin) { if(pre.empty() || pre.size()!=vin.size()) return nullptr; return recurse(pre,0,pre.size()-1,vin,0,vin.size()-1); } }; 05.用两个栈实现队列  用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n 分析：由于栈是先进后出，队列是先进先出，于是可以想到，两个栈，必然能够实现一个队列。原理就是，当push的时候就往第一个栈push，pop的时候就从第二个栈pop，当第二个栈的数为空时，从第一个栈pop再push到第二个栈。\nclass Solution { public: void push(int node) { stack1.push(node); } int pop() { if(stack2.empty()){ while(!stack1.empty()){ stack2.push(stack1.top()); stack1.pop(); } } int top=stack2.top(); stack2.pop(); return top; } private: stack stack1; stack stack2; }; 06.旋转数组的最小数字  把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n 分析：对于排序的数组，即使被旋转过，也能想到的是，采用二分查找。不过可能会存在的问题的是：当整个数组的值都是1 0 0 1 1之类的时候，就会失效了，只是非递减，但是不一定递增。\nclass Solution { public: int minNumberInRotateArray(vector rotateArray) { if(0==rotateArray.size()){ return 0; } int begin=0,end=rotateArray.size()-1; while(beginrotateArray[mid]) end=mid; else{ int res=begin; for(size_t i=1;i07.斐波那契数列  大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n分析：斐波拉契数列原理很简单，不过按照原理写的显然复杂度过高了，这里我们可以采用变量存下之前计算过的数。\nclass Solution { public: int Fibonacci(int n) { if(n==0) return 0; if(n==1||n==2) return 1; int first=1,second=1,res=0; while(--n1){ res=first+second; first=second; second=res; } return res; } }; 08.跳台阶  一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n 分析：原理同斐波拉契数列。\nclass Solution { public: int jumpFloor(int number) { if(number1){ res=first+second; first=second; second=res; } return res; } }; 09.变态跳台阶  一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n 分析：\nf(n)=f(1)+f(2)+...+f(n-1) f(n+1)=f(1)+f(2)+...+f(n-1)+f(n)=2f(n) //代码如下： class Solution { public: int jumpFloorII(int number) { if(number=2){ res*=2; } return res; } }; 10.矩形覆盖 /TODO: 11.二进制中1的个数  输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n 分析：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。\nclass Solution { public: int NumberOf1(int n) { int count=0; while(n){ count++; n=n\u0026(n-1); } return count; } }; 12.数值的整数次方  给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n 分析：求一个数的次方，一个就是幂数是负数的处理，另一个就是，对幂的处理，连乘必然带来复杂度，可以想到的是2^4可以表示为(2^2)^2，想到这里，考虑的开水奇偶exponent的奇偶性了，奇数的时候直接乘以base，偶数的时候自乘。\nclass Solution { public: double Power(double base, int exponent) { bool flag=true; if(exponent13.调整数组顺序使奇数位于偶数前面  输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n class Solution { public: void reOrderArray(vector \u0026array) { if(array.empty()) return; int begin=0,end=array.size(); int even=-1; while(begin=end) return; int temp=array[begin]; while(even14.链表中倒数第k个结点  输入一个链表，输出该链表中倒数第k个结点。\n 分析：采用两个指针一起移动是一个很好的办法，不过需要考虑是否越界。\n/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { ListNode* p1=pListHead; for(int i=0;inext; } while(p1){ p1=p1-next; pListHead=pListHead-next; } return pListHead; } }; 15.反转链表  输入一个链表，反转链表后，输出新链表的表头。\n 分析：注意断开链表重连的过程。\n/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ //最开始的一版代码，采用的是栈，看起来比较复杂。 class Solution { public: ListNode* ReverseList(ListNode* pHead) { if((!pHead)||(!pHead-next)) return pHead; stack list_stack; while(pHead-next){ list_stack.push(pHead); pHead=pHead-next; } ListNode *newHead=pHead; while(!list_stack.empty()){ pHead-next=list_stack.top(); pHead=pHead-next; list_stack.pop(); } pHead-next=nullptr; return newHead; } }; //采用在链表中的穿针引线。涉及到链表的断开与重连，维护三个指针，分别为：pre,cur,next class Solution { public: ListNode* ReverseList(ListNode* pHead) { ListNode* pre=nullptr; ListNode* cur=pHead; while(cur){ ListNode* next=cur-next; cur-next=pre; pre=cur; cur=next; } return pre; } }; //采用递归实现 class Solution { public: ListNode* ReverseList(ListNode* pHead) { if(!pHead||!pHead-next) return pHead; ListNode* rHead=ReverseList(pHead-next); // head-next此刻指向head后面的链表的尾节点 // head-next-next = head把head节点放在了尾部 pHead-next-next=pHead; pHead-next=nullptr; return rHead; } }; 16.合并两个排序的链表  输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { //当一个链表为空时，直接返回另一个链表 if(!pHead1) return pHead2; if(!pHead2) return pHead1; ListNode* vHead=new ListNode(0); //设立虚拟的头节点 ListNode* vHeadHead=vHead; while(pHead1 \u0026\u0026 pHead2){ //一旦有一个链表为空，就退出循环 if(pHead1-valval){ vHead-next=pHead1; pHead1=pHead1-next; } else{ vHead-next=pHead2; pHead2=pHead2-next; } vHead=vHead-next; } //另一个链表不为空时，加在后面 if(!pHead1) vHead-next=pHead2; else vHead-next=pHead1; return vHeadHead-next; //返回虚拟头节点的下一个节点 } }; //采用递归实现 class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { if(!pHead1) return pHead2; if(!pHead2) return pHead1; ListNode* vHead=nullptr; if(pHead1-valval){ vHead=pHead1; vHead-next=Merge(pHead1-next,pHead2); } else{ vHead=pHead2; vHead-next=Merge(pHead1,pHead2-next); } return vHead; } }; 17.树的子结构  输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）\n class Solution { public: bool dfs(TreeNode* pRoot1,TreeNode* pRoot2){ if(!pRoot2) //注意不能先判断pRoot1再判断pRoot2，因为，只要pRoot2为空的时候，都是true了，而不管这时候pRoot1是不是为空。 return true; if(!pRoot1) return false; if(pRoot1-val!=pRoot2-val) return false; return dfs(pRoot1-left,pRoot2-left)\u0026\u0026dfs(pRoot1-right,pRoot2-right); } bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { if((!pRoot2)||(!pRoot1)) return false; return (dfs(pRoot1,pRoot2)||HasSubtree(pRoot1-left,pRoot2)||HasSubtree(pRoot1-right,pRoot2)); } }; 18.二叉树的镜像  操作给定的二叉树，将其变换为源二叉树的镜像。\n 分析：简单的递归解决。\n/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void Mirror(TreeNode *pRoot) { if(pRoot==nullptr) return; Mirror(pRoot-left); Mirror(pRoot-right); swap(pRoot-left,pRoot-right); } }; 19.顺时针打印矩阵 20.包含min函数的栈  定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。\n 分析：维护两个栈，其中一个是压入数据的栈，另一个是min栈，存储当前数据的最小的值。只有压入的数小于min栈的时候，才压入新值，否则继续压入最小值。\nclass Solution { public: void push(int value) { stk.push(value); if(!stk_min.empty()){ if(valuestk; stack stk_min; }; 21.栈的压入、弹出序列  输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n 思路：判断是否是压入弹出序列，可以直接使用一个栈进行压入，然后在压入的过程中判断是否跟弹出序列的值相同，是的话则先弹出，最后判断栈是否为空即可。\nclass Solution { public: bool IsPopOrder(vector pushV,vector popV) { stack istack; int i=0,j=0; while(i22.从上往下打印二叉树  从上往下打印出二叉树的每个节点，同层节点从左至右打印。\n 分析：层序遍历，需要每遍历一个节点，就将他们的左右节点保存起来，当前层遍历完后，再顺序遍历他们的孩子节点。于是很容易想到先入先出的结构，队列。\n/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector PrintFromTopToBottom(TreeNode* root) { vector res; if(root==nullptr) return res; queue ique; ique.push(root); while(!ique.empty()){ TreeNode* temp=ique.front(); res.push_back(temp-val); ique.pop(); if(temp-left) ique.push(temp-left); if(temp-right) ique.push(temp-right); } return res; } }; 23.二叉搜索树的后序遍历序列  输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。\n class Solution { public: bool VerifySquenceOfBST(vector sequence) { return Verify(sequence,0,sequence.size()); } bool Verify(vector sequence,int start,int end){ int i=start; if(start==end) return false; for(;isequence[end-1]){ break; } } for(int j=i;j!=end;++j){ if(sequence[j]start) left=Verify(sequence,start,i); bool right=true; if(i24.二叉树中和为某一值的路径  输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n class Solution { public: vector res; vector temp; vector  FindPath(TreeNode* root,int expectNumber) { if(!root) return res; temp.push_back(root-val); if(expectNumber-root-val==0 \u0026\u0026 root-left==nullptr \u0026\u0026 root-right==nullptr) res.push_back(temp); FindPath(root-left,expectNumber-root-val); FindPath(root-right,expectNumber-root-val); if(!temp.empty()) temp.pop_back(); return res; } }; 25.复杂链表的复制 代码问题：\n while(pHead-next){ // coutlabellabel); pTemp-next=pHead-next; coutnext-labelnext=pTemp; pHead=pTemp-next; } //拆分 pNode=pHead; RandomListNode* newHead=pHead-next; RandomListNode* pTemp=pNode-next; while(pNode){ pNode-next=pTemp-next; pNode=pNode-next; pTemp-next=pNode?pNode-next:NULL; //pTemp-next=pNode-next; //coutlabelnext; //coutclass Solution { public: RandomListNode* Clone(RandomListNode* pHead) { if(!pHead) return pHead; RandomListNode* pNode=pHead; while(pNode){ RandomListNode* pClone=new RandomListNode(pNode-label); pClone-next=pNode-next; pNode-next=pClone; pNode=pClone-next; } pNode=pHead; while(pNode){ RandomListNode* pClone=pNode-next; if(pNode-random) pClone-random=pNode-random-next; pNode=pClone-next; } pNode=pHead; RandomListNode* newHead=pNode-next; while(pNode-next){ RandomListNode* pTemp=pNode-next; pNode-next=pTemp-next; pNode=pTemp; //\tpNode=pNode-next; //这种不行，搞得我折腾了很久 //\tpTemp-next=pNode-next; } return newHead; } }; 26.二叉搜索树与双向链表  输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 TODO:\n 27.字符串的排列 28.数组中出现次数超过一半的数字 解决一个问题，最终输出的判断，是1，还是0。如果大于1的话，万一最后只剩下了一个呢。所以还需要再判断最后剩下的结果是不是符合条件的，即是大于一般数目的。\nclass Solution { public: int MoreThanHalfNum_Solution(vector numbers) { if(numbers.empty()) return 0; int count=1; int num=numbers[0]; for(int i=1;inumbers.size()?num:0; } }; 29.最小的K个数 存在的问题，写程序的时候越界，没有判断好边界条件。\nclass Solution { public: vector GetLeastNumbers_Solution(vector input, int k) { vector min_stack; if(input.empty()||(kinput.size())) //边界条件的判断 return min_stack; for(int i=0;i30.连续子数组的最大和 class Solution { public: int FindGreatestSumOfSubArray(vector array) { int res=array[0]; int cur=array[0]; for(int i=1;icur?res:cur); } return res; } }; 31.整数中1出现的次数（从1到n整数中1出现的次数）  求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。\n 分析：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析。\n当i表示百位，且百位对应的数=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)100个点的百位为1\n当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10100）+(b+1)，这些点百位对应为1\n当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）\n综合以上三种情况，当百位对应0或=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1 之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位=2，补8会产生进位位，效果等同于(a/10+1)\nclass Solution { public: int NumberOf1Between1AndN_Solution(int n) { int count=0; //n=1的情况 if(n==1) return 1; //考虑的边界情况，n=10,100,1000之类的，同时循环中没有考虑n=0的情况 if(n1\u0026\u0026n%10==0) count++; //没有考虑n=1的情况 for(int i=1;i32.把数组排成最小的数  输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。\n class Solution { public: static bool equal(int a,int b){ string str1=to_string(a)+to_string(b); string str2=to_string(b)+to_string(a); return str1numbers) { string result; sort(numbers.begin(),numbers.end(),equal); for(int i=0;i33.丑数  把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\n class Solution { public: int GetUglyNumber_Solution(int index) { if(indexres(index); res[0]=1; int x=0,y=0,z=0; for(int i=1;i34.第一个只出现一次的字符位置  在一个字符串(1一般对于这种字符的处理，因为字符一般都是不超过256的，所以尤其是计数之类的，我们可以首先考虑数组。\nclass Solution { public: int FirstNotRepeatingChar(string str) { if(str.size()35.数组中的逆序对  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007\n 36.两个链表的第一个公共结点  输入两个链表，找出它们的第一个公共结点。\n 需要知道的一个常识是，对于只有一个单链表，两个链表有公共节点，意味着从公共节点开始，之后两个链表都是公共的，因此他们有共同的终点。有了这个就好办了。可以将两个链表一直遍历，当遍历到链表尾的时候，就换另一个链表，当他们有公共节点时，在他们遍历到同一个节点时停止遍历，此节点即为第一个公共节点。\n对于这种将两个不同的长度，通过两个结合在一起，使两个长度相等的方法，其实我们用到过很多次。例如本题中的找公共节点，原因是两个链表长度不同。还有之前的一个判断两个string的大小，可以把他们放在一起，这样他们的长度就相同了，可以直接用string的方法进行比较。\nclass Solution { public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) { ListNode* p1=pHead1; ListNode* p2=pHead2; while(p1!=p2){ p1=(p1==nullptr?pHead2:p1-next); p2=(p2==nullptr?pHead1:p2-next); } return p1; } }; 37.数字在排序数组中出现的次数  统计一个数字在排序数组中出现的次数。\n 显然很容易想到的是二分法,没有用函数的话，就存在一个找到没找到的问题，在这采用了一个返回值的处理。如果没找到，(end-begin-1)class Solution { public: int GetNumberOfK(vector data ,int k) { if(data.empty()) return 0; int begin=0,end=data.size()-1; int count=0; int mid; while(begink){ end=mid-1; continue; } } begin=end=mid; while(data[begin]==k) --begin; while(data[end]==k) ++end; count=(end-begin-1)0?(end-begin-1):0; return count; } }; 38.二叉树的深度  输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。\n class Solution { public: int TreeDepth(TreeNode* pRoot) { if(!pRoot) return 0; return max(1+TreeDepth(pRoot-left),1+TreeDepth(pRoot-right)); } }; 39.平衡二叉树  输入一棵二叉树，判断该二叉树是否是平衡二叉树。\n 40.数组中只出现一次的数字  一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。\n 数组中只出现一次的数字，当有一个的时候，很容易利用的特性是：全部异或，最后剩下的那个就是。原因是一个数跟自身异或，结果为0.那么出现有两个的时候呢。很容易想到的还是异或，最后的结果是两个只出现一次数字异或的结果，再进行分组解决。分组的依据是：因为有两个不同的数字只出现一次，所以整个数组异或的结果必然不为0，不为0就肯定有一位为1.按该位是否为1来进行划分即可。代码如下：\nclass Solution { public: void FindNumsAppearOnce(vector data,int* num1,int *num2) { if(data.empty()) return; //第一次遍历一遍，求两个数字最后的异或 int res=data[0]; for(int i=1;i1; index++; } *num1=*num2=0; //根据index位为不为1，将数组分为两部分。 int x; for(int i=0;iindex)\u00261) *num1^=data[i]; else { *num2^=data[i]; } } } }; 41.和为S的连续正数序列  输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序\n class Solution { public: vector  FindContinuousSequence(int sum) { vector res; vector temp; //边界条件的判断 if(sumsum){ tempSum-=temp[0]; temp.erase(temp.begin()); continue; } temp.push_back(++end); tempSum+=end; } return res; } }; 42.和为S的两个数字  输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。\n 输出乘积最小的，显然距离最大的乘积就越小，所以，可以直接前后两个指针搜索，搜到的第一个就是。\nclass Solution { public: vector FindNumbersWithSum(vector array, int sum) { vectorres; if(array.empty()) return res; int i=0,j=array.size()-1; while(isum) --j; if(temp43.左旋转字符串  汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！\n 由BA=(ATBT)T计算可得\n//第一次通过代码 class Solution { public: string LeftRotateString(string str, int n) { int len=str.size(); if(n=len) return str; int i=0,j=0; for(i=0,j=n-1;i44.翻转单词顺序列  牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？\n //以前买的 class Solution { public: void ReverseSentence(string \u0026str,int begin,int end){ while(begin45.扑克牌顺子  LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。\n class Solution { public: bool IsContinuous(vector numbers) { if (numbers.empty()) return false; sort(numbers.begin(), numbers.end()); int sum = 0, zero_num = 0; for (int i = 0; i 46.孩子们的游戏(圆圈中最后剩下的数)  每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)\n 此约瑟夫环的问题。https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365\nclass Solution { public: int LastRemaining_Solution(int n, int m) { if(n47.求1+2+3+…+n  求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n 这个题，可以有好几种解决办法，一个容易想到的就是递归，每次都跟自己相加，直到加到0为止，判断的条件可以采用\u0026\u0026的短路特性：通过\u0026\u0026判断值是否为0已经到达结尾了。\n另一种办法，可以利用类的构造函数。\nclass Solution { public: int Sum_Solution(int n) { int sum=n; sum\u0026\u0026(sum+=Sum_Solution(n-1)); return sum; } }; 48.不用加减乘除做加法  写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。\n 不能用加法做加法运算，可以想到的计算机中利用的二进制的加法。通过异或两个数，也就是模2加，得到的是不考虑进位的加法的结果。通过两个数异或，左移一位得到的是进位。无进位结果加上进位，一直循环知道进位为0的时候，结果即为加法的结果。\n计算的过程中，一定要细心。方法虽然简单，但是要写对。\nclass Solution { public: int Add(int num1, int num2) { int res = num1 ^ num2, temp = num1 \u0026 num2; while (temp != 0) { temp = temp 49.把字符串转换成整数  输入一个字符串,包括数字字母符号,可以为空.如果是合法的数值表达则返回该数字，否则返回0\n 分析：主要首先要考虑正负号，这里有一个小细节，我们把flag直接置1的话，可以直接输出flag*res得到结果，而不需要进行判断，是一种省略。另外的判断就比较简单了，按照正常的思路去判断就行。\nclass Solution { public: int StrToInt(string str) { if (str.size() == 0) return 0; int flag = 1; int size = str.size(), res = 0; int i = 0; if (str[0] == '-') { flag = -1; i++; } else if (str[0] == '+') { i++; } for (; i = '9') { return 0; } else res = res * 10 + (str[i] - '0'); } return flag * res; } }; 50.数组中重复的数字  在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。\n 分析：由于规定了数组中的数字在范围为0–n内，所以可以利用当前数组的位置进行遍历，比如每次遍历到一个位置，就将该数字对应位置的值加n，这样，当再次遍历到该值时，发现如果该值已经大于n，说明已经重复了，返回即可。不过在遍历的时候，如果发现某一位置的值大于n，应该先减去n，得到该位置上原来的值，这里应该捋清楚。\nclass Solution { public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int *duplication) { for(int i=0;i=length) index=index-length; if(numbers[index]=length){ *duplication=index; return true; } numbers[index]+=length; } return false; } }; 51.构建乘积数组  给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…*A[i-1]A[i+1]…*A[n-1]。不能使用除法。\n class Solution { public: vector multiply(const vector\u0026 A) { vector res(A.size()); if(A.empty()) return res; res[0]=1; //计算下三角 for(int i=1;i=0;--i){ temp*=A[i+1]; res[i]*=temp; } return res; } }; 52.正则表达式匹配 53.表示数值的字符串 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(pHead==nullptr) return pHead; ListNode* virtualHead=new ListNode(0); virtualHead-next=pHead; ListNode* prev=virtualHead; while(pHead-next){ if(pHead-val==pHead-next-val){ if(pHead-next-next){ pHead=pHead-next-next; prev-next=pHead; } else return virtualHead-next; } else{ pHead=pHead-next; prev=prev-next; } } return virtualHead-next; } }; 测试用例: {1,1,1,1,1,1,1}\n对应输出应该为:\n54.字符流中第一个不重复的字符  请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符\"go\"时，第一个只出现一次的字符是\"g\"。当从该字符流中读出前六个字符“google\"时，第一个只出现一次的字符是\"l\"。 如果当前字符流没有存在出现一次的字符，返回#字符。\n class Solution { public: //Insert one char from stringstream void Insert(char ch) { if(!array[ch]) ique.push(ch); array[ch]++; } //return the first appearence once char in current stringstream char FirstAppearingOnce() { while(!ique.empty() \u0026\u0026 array[ique.front()]1){ ique.pop(); } if(!ique.empty()) return ique.front(); return '#'; } private: int array[256]={0}; queue ique; }; 55.链表中环的入口结点  一个链表中包含环，请找出该链表的环的入口结点。\n 分析：http://wuchong.me/blog/2014/03/25/interview-link-questions/\nclass Solution { public: ListNode* EntryNodeOfLoop(ListNode* pHead) { if(!pHead || !pHead-next) return nullptr; ListNode* fast=pHead,*slow=pHead; while(fast-next \u0026\u0026 slow){ fast=fast-next-next; slow=slow-next; if(fast==slow) break; } if(fast!=slow) return nullptr; fast=pHead; while(fast!=slow){ fast=fast-next; slow=slow-next; } return fast; } }; 56.删除链表中重复的结点 //一个不通过的代码 class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(!pHead || !pHead-next) return pHead; ListNode* vHead=new ListNode(0); vHead-next=pHead; ListNode* pre=vHead; ListNode* cur=pHead; int temp; while(cur \u0026\u0026 cur-next){ ListNode* next=cur-next; if(cur-val==next-val){ //原因是这个相等的处理有问题，没有考虑一直是同一个值的处理 temp=cur-val; cur=next-next; pre-next=cur; } else if(next-val==temp){ cur-next=next-next; pre-next=cur; } else{ if(next-next){ pre=cur; cur=next; // next=next-next; } else return vHead-next; } } return vHead-next; } }; //一个通过了的代码 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(!pHead || !pHead-next) return pHead; ListNode* vHead=new ListNode(-1); vHead-next=pHead; ListNode* pre=vHead; ListNode* cur=pHead; while(cur \u0026\u0026 cur-next){ ListNode* next=cur-next; if(cur-val==next-val){ int val=cur-val; while(cur \u0026\u0026 cur-val==val) //一直遍历到不为当前值为止 cur=cur-next; pre-next=cur; cur=pre-next; } else{ pre=pre-next; cur=cur-next; } } return vHead-next; } }; //递归解决 class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(pHead==nullptr || pHead-next==nullptr) return pHead; ListNode* current=pHead; if(pHead-val==pHead-next-val){ current=pHead-next-next; while(current!=nullptr \u0026\u0026 current-val==pHead-val) current=current-next; return deleteDuplication(current); } else{ current=pHead-next; pHead-next=deleteDuplication(current); return pHead; } } }; 57.二叉树的下一个结点  给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。\n 分析二叉树的下一个节点，一共有以下情况： 1.二叉树为空，则返回空； 2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点； 3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。\n58.对称的二叉树 59.按之字形顺序打印二叉树 60.把二叉树打印成多行 61.序列化二叉树 62.二叉搜索树的第k个结点 63.数据流中的中位数 64.滑动窗口的最大值 65.矩阵中的路径 66.机器人的运动范围","wordCount":"10745","inLanguage":"zh-cn","datePublished":"2018-06-20T21:40:02+08:00","dateModified":"2018-06-20T21:40:02+08:00","author":{"@type":"Person","name":"mianhk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuguocong.cn/posts/re_sword_to_offer/"},"publisher":{"@type":"Organization","name":"mianhk's notes","logo":{"@type":"ImageObject","url":"https://yuguocong.cn/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://yuguocong.cn/ accesskey=h title="mianhk's notes (Alt + H)">mianhk's notes</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://yuguocong.cn/posts/ title=文章>
<span>文章</span>
</a>
</li>
<li>
<a href=https://yuguocong.cn/archives/ title=归档>
<span>归档</span>
</a>
</li>
<li>
<a href=https://yuguocong.cn/tags/ title=标签>
<span>标签</span>
</a>
</li>
<li>
<a href=https://yuguocong.cn/search/ title=搜索>
<span>搜索</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://yuguocong.cn/>Home</a>&nbsp;»&nbsp;<a href=https://yuguocong.cn/posts/>Posts</a></div>
<h1 class=post-title>
剑指offer-刷题总结
</h1>
<div class=post-meta>June 20, 2018&nbsp;·&nbsp;22 min&nbsp;·&nbsp;mianhk
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#01%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%9f%a5%e6%89%be aria-label=01.二维数组中的查找>01.二维数组中的查找</a></li>
<li>
<a href=#02%e6%9b%bf%e6%8d%a2%e7%a9%ba%e6%a0%bc aria-label=02.替换空格>02.替换空格</a></li>
<li>
<a href=#03%e4%bb%8e%e5%b0%be%e5%88%b0%e5%a4%b4%e6%89%93%e5%8d%b0%e9%93%be%e8%a1%a8 aria-label=03.从尾到头打印链表>03.从尾到头打印链表</a></li>
<li>
<a href=#04%e9%87%8d%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=04.重建二叉树>04.重建二叉树</a></li>
<li>
<a href=#05%e7%94%a8%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97 aria-label=05.用两个栈实现队列>05.用两个栈实现队列</a></li>
<li>
<a href=#06%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%b0%8f%e6%95%b0%e5%ad%97 aria-label=06.旋转数组的最小数字>06.旋转数组的最小数字</a></li>
<li>
<a href=#07%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97 aria-label=07.斐波那契数列>07.斐波那契数列</a></li>
<li>
<a href=#08%e8%b7%b3%e5%8f%b0%e9%98%b6 aria-label=08.跳台阶>08.跳台阶</a></li>
<li>
<a href=#09%e5%8f%98%e6%80%81%e8%b7%b3%e5%8f%b0%e9%98%b6 aria-label=09.变态跳台阶>09.变态跳台阶</a></li>
<li>
<a href=#10%e7%9f%a9%e5%bd%a2%e8%a6%86%e7%9b%96-todo aria-label="10.矩形覆盖 /TODO:">10.矩形覆盖 /TODO:</a></li>
<li>
<a href=#11%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%b8%ad1%e7%9a%84%e4%b8%aa%e6%95%b0 aria-label=11.二进制中1的个数>11.二进制中1的个数</a></li>
<li>
<a href=#12%e6%95%b0%e5%80%bc%e7%9a%84%e6%95%b4%e6%95%b0%e6%ac%a1%e6%96%b9 aria-label=12.数值的整数次方>12.数值的整数次方</a></li>
<li>
<a href=#13%e8%b0%83%e6%95%b4%e6%95%b0%e7%bb%84%e9%a1%ba%e5%ba%8f%e4%bd%bf%e5%a5%87%e6%95%b0%e4%bd%8d%e4%ba%8e%e5%81%b6%e6%95%b0%e5%89%8d%e9%9d%a2 aria-label=13.调整数组顺序使奇数位于偶数前面>13.调整数组顺序使奇数位于偶数前面</a></li>
<li>
<a href=#14%e9%93%be%e8%a1%a8%e4%b8%ad%e5%80%92%e6%95%b0%e7%ac%ack%e4%b8%aa%e7%bb%93%e7%82%b9 aria-label=14.链表中倒数第k个结点>14.链表中倒数第k个结点</a></li>
<li>
<a href=#15%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8 aria-label=15.反转链表>15.反转链表</a></li>
<li>
<a href=#16%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%8e%92%e5%ba%8f%e7%9a%84%e9%93%be%e8%a1%a8 aria-label=16.合并两个排序的链表>16.合并两个排序的链表</a></li>
<li>
<a href=#17%e6%a0%91%e7%9a%84%e5%ad%90%e7%bb%93%e6%9e%84 aria-label=17.树的子结构>17.树的子结构</a></li>
<li>
<a href=#18%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%95%9c%e5%83%8f aria-label=18.二叉树的镜像>18.二叉树的镜像</a></li>
<li>
<a href=#19%e9%a1%ba%e6%97%b6%e9%92%88%e6%89%93%e5%8d%b0%e7%9f%a9%e9%98%b5 aria-label=19.顺时针打印矩阵>19.顺时针打印矩阵</a></li>
<li>
<a href=#20%e5%8c%85%e5%90%abmin%e5%87%bd%e6%95%b0%e7%9a%84%e6%a0%88 aria-label=20.包含min函数的栈>20.包含min函数的栈</a></li>
<li>
<a href=#21%e6%a0%88%e7%9a%84%e5%8e%8b%e5%85%a5%e5%bc%b9%e5%87%ba%e5%ba%8f%e5%88%97 aria-label=21.栈的压入、弹出序列>21.栈的压入、弹出序列</a></li>
<li>
<a href=#22%e4%bb%8e%e4%b8%8a%e5%be%80%e4%b8%8b%e6%89%93%e5%8d%b0%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=22.从上往下打印二叉树>22.从上往下打印二叉树</a></li>
<li>
<a href=#23%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97 aria-label=23.二叉搜索树的后序遍历序列>23.二叉搜索树的后序遍历序列</a></li>
<li>
<a href=#24%e4%ba%8c%e5%8f%89%e6%a0%91%e4%b8%ad%e5%92%8c%e4%b8%ba%e6%9f%90%e4%b8%80%e5%80%bc%e7%9a%84%e8%b7%af%e5%be%84 aria-label=24.二叉树中和为某一值的路径>24.二叉树中和为某一值的路径</a></li>
<li>
<a href=#25%e5%a4%8d%e6%9d%82%e9%93%be%e8%a1%a8%e7%9a%84%e5%a4%8d%e5%88%b6 aria-label=25.复杂链表的复制>25.复杂链表的复制</a></li>
<li>
<a href=#26%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%8e%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8 aria-label=26.二叉搜索树与双向链表>26.二叉搜索树与双向链表</a></li>
<li>
<a href=#27%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%8e%92%e5%88%97 aria-label=27.字符串的排列>27.字符串的排列</a></li>
<li>
<a href=#28%e6%95%b0%e7%bb%84%e4%b8%ad%e5%87%ba%e7%8e%b0%e6%ac%a1%e6%95%b0%e8%b6%85%e8%bf%87%e4%b8%80%e5%8d%8a%e7%9a%84%e6%95%b0%e5%ad%97 aria-label=28.数组中出现次数超过一半的数字>28.数组中出现次数超过一半的数字</a></li>
<li>
<a href=#29%e6%9c%80%e5%b0%8f%e7%9a%84k%e4%b8%aa%e6%95%b0 aria-label=29.最小的K个数>29.最小的K个数</a></li>
<li>
<a href=#30%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c aria-label=30.连续子数组的最大和>30.连续子数组的最大和</a></li>
<li>
<a href=#31%e6%95%b4%e6%95%b0%e4%b8%ad1%e5%87%ba%e7%8e%b0%e7%9a%84%e6%ac%a1%e6%95%b0%e4%bb%8e1%e5%88%b0n%e6%95%b4%e6%95%b0%e4%b8%ad1%e5%87%ba%e7%8e%b0%e7%9a%84%e6%ac%a1%e6%95%b0 aria-label=31.整数中1出现的次数（从1到n整数中1出现的次数）>31.整数中1出现的次数（从1到n整数中1出现的次数）</a></li>
<li>
<a href=#32%e6%8a%8a%e6%95%b0%e7%bb%84%e6%8e%92%e6%88%90%e6%9c%80%e5%b0%8f%e7%9a%84%e6%95%b0 aria-label=32.把数组排成最小的数>32.把数组排成最小的数</a></li>
<li>
<a href=#33%e4%b8%91%e6%95%b0 aria-label=33.丑数>33.丑数</a></li>
<li>
<a href=#34%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%8f%aa%e5%87%ba%e7%8e%b0%e4%b8%80%e6%ac%a1%e7%9a%84%e5%ad%97%e7%ac%a6%e4%bd%8d%e7%bd%ae aria-label=34.第一个只出现一次的字符位置>34.第一个只出现一次的字符位置</a></li>
<li>
<a href=#35%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e9%80%86%e5%ba%8f%e5%af%b9 aria-label=35.数组中的逆序对>35.数组中的逆序对</a></li>
<li>
<a href=#36%e4%b8%a4%e4%b8%aa%e9%93%be%e8%a1%a8%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%85%ac%e5%85%b1%e7%bb%93%e7%82%b9 aria-label=36.两个链表的第一个公共结点>36.两个链表的第一个公共结点</a></li>
<li>
<a href=#37%e6%95%b0%e5%ad%97%e5%9c%a8%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e5%87%ba%e7%8e%b0%e7%9a%84%e6%ac%a1%e6%95%b0 aria-label=37.数字在排序数组中出现的次数>37.数字在排序数组中出现的次数</a></li>
<li>
<a href=#38%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%b7%b1%e5%ba%a6 aria-label=38.二叉树的深度>38.二叉树的深度</a></li>
<li>
<a href=#39%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=39.平衡二叉树>39.平衡二叉树</a></li>
<li>
<a href=#40%e6%95%b0%e7%bb%84%e4%b8%ad%e5%8f%aa%e5%87%ba%e7%8e%b0%e4%b8%80%e6%ac%a1%e7%9a%84%e6%95%b0%e5%ad%97 aria-label=40.数组中只出现一次的数字>40.数组中只出现一次的数字</a></li>
<li>
<a href=#41%e5%92%8c%e4%b8%bas%e7%9a%84%e8%bf%9e%e7%bb%ad%e6%ad%a3%e6%95%b0%e5%ba%8f%e5%88%97 aria-label=41.和为S的连续正数序列>41.和为S的连续正数序列</a></li>
<li>
<a href=#42%e5%92%8c%e4%b8%bas%e7%9a%84%e4%b8%a4%e4%b8%aa%e6%95%b0%e5%ad%97 aria-label=42.和为S的两个数字>42.和为S的两个数字</a></li>
<li>
<a href=#43%e5%b7%a6%e6%97%8b%e8%bd%ac%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=43.左旋转字符串>43.左旋转字符串</a></li>
<li>
<a href=#44%e7%bf%bb%e8%bd%ac%e5%8d%95%e8%af%8d%e9%a1%ba%e5%ba%8f%e5%88%97 aria-label=44.翻转单词顺序列>44.翻转单词顺序列</a></li>
<li>
<a href=#45%e6%89%91%e5%85%8b%e7%89%8c%e9%a1%ba%e5%ad%90 aria-label=45.扑克牌顺子>45.扑克牌顺子</a></li>
<li>
<a href=#46%e5%ad%a9%e5%ad%90%e4%bb%ac%e7%9a%84%e6%b8%b8%e6%88%8f%e5%9c%86%e5%9c%88%e4%b8%ad%e6%9c%80%e5%90%8e%e5%89%a9%e4%b8%8b%e7%9a%84%e6%95%b0 aria-label=46.孩子们的游戏(圆圈中最后剩下的数)>46.孩子们的游戏(圆圈中最后剩下的数)</a></li>
<li>
<a href=#47%e6%b1%82123n aria-label=47.求1+2+3+&amp;hellip;+n>47.求1+2+3+&mldr;+n</a></li>
<li>
<a href=#48%e4%b8%8d%e7%94%a8%e5%8a%a0%e5%87%8f%e4%b9%98%e9%99%a4%e5%81%9a%e5%8a%a0%e6%b3%95 aria-label=48.不用加减乘除做加法>48.不用加减乘除做加法</a></li>
<li>
<a href=#49%e6%8a%8a%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%bd%ac%e6%8d%a2%e6%88%90%e6%95%b4%e6%95%b0 aria-label=49.把字符串转换成整数>49.把字符串转换成整数</a></li>
<li>
<a href=#50%e6%95%b0%e7%bb%84%e4%b8%ad%e9%87%8d%e5%a4%8d%e7%9a%84%e6%95%b0%e5%ad%97 aria-label=50.数组中重复的数字>50.数组中重复的数字</a></li>
<li>
<a href=#51%e6%9e%84%e5%bb%ba%e4%b9%98%e7%a7%af%e6%95%b0%e7%bb%84 aria-label=51.构建乘积数组>51.构建乘积数组</a></li>
<li>
<a href=#52%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%8c%b9%e9%85%8d aria-label=52.正则表达式匹配>52.正则表达式匹配</a></li>
<li>
<a href=#53%e8%a1%a8%e7%a4%ba%e6%95%b0%e5%80%bc%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=53.表示数值的字符串>53.表示数值的字符串</a></li>
<li>
<a href=#54%e5%ad%97%e7%ac%a6%e6%b5%81%e4%b8%ad%e7%ac%ac%e4%b8%80%e4%b8%aa%e4%b8%8d%e9%87%8d%e5%a4%8d%e7%9a%84%e5%ad%97%e7%ac%a6 aria-label=54.字符流中第一个不重复的字符>54.字符流中第一个不重复的字符</a></li>
<li>
<a href=#55%e9%93%be%e8%a1%a8%e4%b8%ad%e7%8e%af%e7%9a%84%e5%85%a5%e5%8f%a3%e7%bb%93%e7%82%b9 aria-label=55.链表中环的入口结点>55.链表中环的入口结点</a></li>
<li>
<a href=#56%e5%88%a0%e9%99%a4%e9%93%be%e8%a1%a8%e4%b8%ad%e9%87%8d%e5%a4%8d%e7%9a%84%e7%bb%93%e7%82%b9 aria-label=56.删除链表中重复的结点>56.删除链表中重复的结点</a></li>
<li>
<a href=#57%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e7%bb%93%e7%82%b9 aria-label=57.二叉树的下一个结点>57.二叉树的下一个结点</a></li>
<li>
<a href=#58%e5%af%b9%e7%a7%b0%e7%9a%84%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=58.对称的二叉树>58.对称的二叉树</a></li>
<li>
<a href=#59%e6%8c%89%e4%b9%8b%e5%ad%97%e5%bd%a2%e9%a1%ba%e5%ba%8f%e6%89%93%e5%8d%b0%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=59.按之字形顺序打印二叉树>59.按之字形顺序打印二叉树</a></li>
<li>
<a href=#60%e6%8a%8a%e4%ba%8c%e5%8f%89%e6%a0%91%e6%89%93%e5%8d%b0%e6%88%90%e5%a4%9a%e8%a1%8c aria-label=60.把二叉树打印成多行>60.把二叉树打印成多行</a></li>
<li>
<a href=#61%e5%ba%8f%e5%88%97%e5%8c%96%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=61.序列化二叉树>61.序列化二叉树</a></li>
<li>
<a href=#62%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e7%ac%ack%e4%b8%aa%e7%bb%93%e7%82%b9 aria-label=62.二叉搜索树的第k个结点>62.二叉搜索树的第k个结点</a></li>
<li>
<a href=#63%e6%95%b0%e6%8d%ae%e6%b5%81%e4%b8%ad%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0 aria-label=63.数据流中的中位数>63.数据流中的中位数</a></li>
<li>
<a href=#64%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e7%9a%84%e6%9c%80%e5%a4%a7%e5%80%bc aria-label=64.滑动窗口的最大值>64.滑动窗口的最大值</a></li>
<li>
<a href=#65%e7%9f%a9%e9%98%b5%e4%b8%ad%e7%9a%84%e8%b7%af%e5%be%84 aria-label=65.矩阵中的路径>65.矩阵中的路径</a></li>
<li>
<a href=#66%e6%9c%ba%e5%99%a8%e4%ba%ba%e7%9a%84%e8%bf%90%e5%8a%a8%e8%8c%83%e5%9b%b4 aria-label=66.机器人的运动范围>66.机器人的运动范围</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><blockquote>
<p>重刷剑指offer总结</p>
</blockquote>
<h2 id=01二维数组中的查找>01.二维数组中的查找<a hidden class=anchor aria-hidden=true href=#01二维数组中的查找>#</a></h2>
<blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p>分析：由于每一行都有递增的特性，我们可以采用类似二分搜索的方法。将数组分成行列来进行搜索。</p>
<pre tabindex=0><code>class Solution {
public:
    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) {
        if(0==array.size())
            return false;
        int raw=array.size();
        int col=array[0].size();
        for(int i=0;i&lt;raw;++i){
            if(array[i][col-1]&gt;=target){
                for(int j=0;j&lt;col;++j){
                    if(array[i][j]==target)
                        return true;
                }
            }
        }
        return false;
    }
};
</code></pre><h2 id=02替换空格>02.替换空格<a hidden class=anchor aria-hidden=true href=#02替换空格>#</a></h2>
<blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>考虑到是在原字符串上操作，如果遇到一个空格就替换的话，需要把后面的都要后移两位，这个复杂度就大了，所以可以先遍历第一遍，找到空格的总数，之后就可以计算替换后的字符串长度。再经过第二遍遍历，从后往前开始替换，这样就不用移动了。</p>
<pre tabindex=0><code>class Solution {
public:
	void replaceSpace(char *str,int length) {
         if(length&lt;=0)
             return;
        int origin_length=0,new_length=0,space_num=0;
        for(int i=0;str[i]!='\0';++i){
            origin_length++;
            if(str[i]==' ')
                space_num++;
        }
        new_length=origin_length+2*space_num;
        if(new_length&gt;length)
            return;
        str[new_length]='\0';
        while(origin_length&gt;0){
            --origin_length;
            if(str[origin_length]==' '){
                str[--new_length]='0';
                str[--new_length]='2';
                str[--new_length]='%';
            }
            else{
                str[--new_length]=str[origin_length];
            }
        }
	}
};
</code></pre><h2 id=03从尾到头打印链表>03.从尾到头打印链表<a hidden class=anchor aria-hidden=true href=#03从尾到头打印链表>#</a></h2>
<blockquote>
<p>输入一个链表，从尾到头打印链表每个节点的值。</p>
</blockquote>
<p>分析：由于链表我们必须从头到尾遍历才能从链表尾开始，所以直接打印的话，需要先从前往后遍历一遍找到链表尾节点，再从后往前遍历打印。能够进行的改善是，通过增加O(N)的空间复杂度，第一次遍历的时候，将数据放在一个栈中，之后再从栈中把所有的数都弹出来就好。</p>
<pre tabindex=0><code>/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector&lt;int&gt; printListFromTailToHead(ListNode* head) {
        vector&lt;int&gt; res;
        if(!head)
            return res;
        stack&lt;int&gt; istack;
        while(head){
            istack.push(head-&gt;val);
            head=head-&gt;next;
        }
        while(!istack.empty()){
            res.push_back(istack.top());
            istack.pop();
        }
        return res;
    }
};
</code></pre><h2 id=04重建二叉树>04.重建二叉树<a hidden class=anchor aria-hidden=true href=#04重建二叉树>#</a></h2>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<p>分析：首先需要知道的是前序遍历和后续遍历的特点，程序中可以维护4个子数组，当进行递归调用。</p>
<pre tabindex=0><code>/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) {
        if(pre.empty() || pre.size()!=vin.size())
            return nullptr;
        vector&lt;int&gt; pre1,pre2,vin1,vin2;
        TreeNode* root=new TreeNode(pre[0]);
        int i=0;
        for(;i&lt;vin.size();++i){
            if(pre[0]==vin[i])
                break;
        }
        //不需要判断i ==0 或者i==vin.size()-1的情况
        for(int j=0;j&lt;i;++j){
            pre1.push_back(pre[1+j]);
            vin1.push_back(vin[j]);
        }
        for(int j=i+1;j&lt;pre.size();++j){
            pre2.push_back(pre[j]);
            vin2.push_back(vin[j]);
        }
        root-&gt;left=reConstructBinaryTree(pre1,vin1);
        root-&gt;right=reConstructBinaryTree(pre2,vin2);
        return root;
    }
};
</code></pre><p>不过上述的方法有个问题，虽然看起来比较好理解，但是增加了空间复杂度，其实这里可以多加一个递归函数就好了，所以觉得还是需要重新写一下。</p>
<pre tabindex=0><code>/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* recurse(vector&lt;int&gt;&amp; pre,int begin1,int end1,vector&lt;int &gt;&amp; vin,int begin2,int end2){
        if(begin1&gt;end1 || begin2&gt;end2)  //退出条件
            return nullptr;
        TreeNode* root=new TreeNode(pre[begin1]);
        for(int i=begin2;i&lt;=end2;++i){
            if(pre[begin1]==vin[i]){
                root-&gt;left=recurse(pre,begin1+1,begin1+i-begin2,vin,begin2,i-1);  //递归的重点，这个要考虑清楚
                root-&gt;right=recurse(pre,begin1+1+i-begin2,end1,vin,1+i,end2);
                break;
            }
        }
        return root;
    }
    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) {
        if(pre.empty() || pre.size()!=vin.size())
            return nullptr;
        return recurse(pre,0,pre.size()-1,vin,0,vin.size()-1);
    }
};
</code></pre><h2 id=05用两个栈实现队列>05.用两个栈实现队列<a hidden class=anchor aria-hidden=true href=#05用两个栈实现队列>#</a></h2>
<blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<p>分析：由于栈是先进后出，队列是先进先出，于是可以想到，两个栈，必然能够实现一个队列。原理就是，当push的时候就往第一个栈push，pop的时候就从第二个栈pop，当第二个栈的数为空时，从第一个栈pop再push到第二个栈。</p>
<pre tabindex=0><code>class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int top=stack2.top();
        stack2.pop();
        return top;
    }

private:
    stack&lt;int&gt; stack1;
    stack&lt;int&gt; stack2;
};
</code></pre><h2 id=06旋转数组的最小数字>06.旋转数组的最小数字<a hidden class=anchor aria-hidden=true href=#06旋转数组的最小数字>#</a></h2>
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<p>分析：对于排序的数组，即使被旋转过，也能想到的是，采用二分查找。不过可能会存在的问题的是：当整个数组的值都是<code>1 0 0 1 1</code>之类的时候，就会失效了，只是非递减，但是不一定递增。</p>
<pre tabindex=0><code>class Solution {
public:
    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) {
        if(0==rotateArray.size()){
            return 0;
        }
        int begin=0,end=rotateArray.size()-1;
        while(begin&lt;end-1){
            int mid=begin+(end-begin)/2;
            if(rotateArray[begin]&lt;rotateArray[mid])
                begin=mid;
            else if(rotateArray[begin]&gt;rotateArray[mid])
                end=mid;
            else{
                int res=begin;
                for(size_t i=1;i&lt;rotateArray.size();++i){
                    res=(res&lt;rotateArray[i]?res:rotateArray[i]);
                }
                return res;
            }
        }
        return rotateArray[end];
    }
};
</code></pre><h2 id=07斐波那契数列>07.斐波那契数列<a hidden class=anchor aria-hidden=true href=#07斐波那契数列>#</a></h2>
<blockquote>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p>
</blockquote>
<p>分析：斐波拉契数列原理很简单，不过按照原理写的显然复杂度过高了，这里我们可以采用变量存下之前计算过的数。</p>
<pre tabindex=0><code>class Solution {
public:
    int Fibonacci(int n) {
        if(n==0)
            return 0;
        if(n==1||n==2)
            return 1;
        int first=1,second=1,res=0;
        while(--n&gt;1){
            res=first+second;
            first=second;
            second=res;
        }
        return res;
    }
};
</code></pre><h2 id=08跳台阶>08.跳台阶<a hidden class=anchor aria-hidden=true href=#08跳台阶>#</a></h2>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>分析：原理同斐波拉契数列。</p>
<pre tabindex=0><code>class Solution {
public:
    int jumpFloor(int number) {
        if(number&lt;=2)
            return number;
        int first=1,second=2,res=0;
        while(--number&gt;1){
            res=first+second;
            first=second;
            second=res;
        }
        return res;
    }
};
</code></pre><h2 id=09变态跳台阶>09.变态跳台阶<a hidden class=anchor aria-hidden=true href=#09变态跳台阶>#</a></h2>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>分析：</p>
<pre tabindex=0><code>f(n)=f(1)+f(2)+...+f(n-1)
f(n+1)=f(1)+f(2)+...+f(n-1)+f(n)=2f(n)
//代码如下：
class Solution {
public:
    int jumpFloorII(int number) {
        if(number&lt;=2)
            return number;
        int res=2;
        while(--number&gt;=2){
            res*=2;
        }
        return res;
    }
};
</code></pre><h2 id=10矩形覆盖-todo>10.矩形覆盖 /TODO:<a hidden class=anchor aria-hidden=true href=#10矩形覆盖-todo>#</a></h2>
<h2 id=11二进制中1的个数>11.二进制中1的个数<a hidden class=anchor aria-hidden=true href=#11二进制中1的个数>#</a></h2>
<blockquote>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p>分析：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p>
<pre tabindex=0><code>class Solution {
public:
     int  NumberOf1(int n) {
         int count=0;
         while(n){
             count++;
             n=n&amp;(n-1);
         }
         return count;
     }
};
</code></pre><h2 id=12数值的整数次方>12.数值的整数次方<a hidden class=anchor aria-hidden=true href=#12数值的整数次方>#</a></h2>
<blockquote>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
</blockquote>
<p>分析：求一个数的次方，一个就是幂数是负数的处理，另一个就是，对幂的处理，连乘必然带来复杂度，可以想到的是2^4可以表示为(2^2)^2，想到这里，考虑的开水奇偶exponent的奇偶性了，奇数的时候直接乘以base，偶数的时候自乘。</p>
<pre tabindex=0><code>class Solution {
public:
    double Power(double base, int exponent) {
        bool flag=true;
        if(exponent&lt;0){
            flag=false;
            exponent*=-1;
        }
        double res=1;
        while(exponent){
            if(exponent&amp;1){
                res*=base;
                exponent--;
            }
            else{
                exponent=exponent/2;
                res*=res;
            }
        }
        return flag?res:(1/res);
    }
};
</code></pre><h2 id=13调整数组顺序使奇数位于偶数前面>13.调整数组顺序使奇数位于偶数前面<a hidden class=anchor aria-hidden=true href=#13调整数组顺序使奇数位于偶数前面>#</a></h2>
<blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<pre tabindex=0><code>class Solution {
public:
    void reOrderArray(vector&lt;int&gt; &amp;array) {
		if(array.empty())
			return;
		int begin=0,end=array.size();
		int even=-1;
		
		while(begin&lt;end){
			while((array[begin]&amp;1) &amp;&amp; (begin&lt;end)){
				begin++;
			}
			even=begin;
			while((!(array[begin]&amp;1))){
				begin++;
			}
			if(begin&gt;=end)
				return;
			int temp=array[begin];
			while(even&lt;begin){
				array[begin]=array[begin-1];
				begin--;
			}
			array[even]=temp;
		}
    }
};
</code></pre><h2 id=14链表中倒数第k个结点>14.链表中倒数第k个结点<a hidden class=anchor aria-hidden=true href=#14链表中倒数第k个结点>#</a></h2>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>分析：采用两个指针一起移动是一个很好的办法，不过需要考虑是否越界。</p>
<pre tabindex=0><code>/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        ListNode* p1=pListHead;
        for(int i=0;i&lt;k;++i){
            if(!p1)
               return nullptr;
            p1=p1-&gt;next;
        }
        while(p1){
            p1=p1-&gt;next;
            pListHead=pListHead-&gt;next;
        }
        return pListHead;
    }
};
</code></pre><h2 id=15反转链表>15.反转链表<a hidden class=anchor aria-hidden=true href=#15反转链表>#</a></h2>
<blockquote>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
</blockquote>
<p>分析：注意断开链表重连的过程。</p>
<pre tabindex=0><code>/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
//最开始的一版代码，采用的是栈，看起来比较复杂。
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if((!pHead)||(!pHead-&gt;next))
            return pHead;
        stack&lt;ListNode*&gt; list_stack;
        while(pHead-&gt;next){
            list_stack.push(pHead);
            pHead=pHead-&gt;next;
        }
        ListNode *newHead=pHead;
        while(!list_stack.empty()){
            pHead-&gt;next=list_stack.top();
            pHead=pHead-&gt;next;
            list_stack.pop();
        }
        pHead-&gt;next=nullptr;
        return newHead;
    }
};

//采用在链表中的穿针引线。涉及到链表的断开与重连，维护三个指针，分别为：pre,cur,next
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode* pre=nullptr;
        ListNode* cur=pHead;
        while(cur){
            ListNode* next=cur-&gt;next;
            cur-&gt;next=pre;
            pre=cur;
            cur=next;
        }
        return pre;
    }
};

//采用递归实现
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(!pHead||!pHead-&gt;next)
            return pHead;
        ListNode* rHead=ReverseList(pHead-&gt;next);
        // head-&gt;next此刻指向head后面的链表的尾节点
        // head-&gt;next-&gt;next = head把head节点放在了尾部
        pHead-&gt;next-&gt;next=pHead;
        pHead-&gt;next=nullptr;
        
        return rHead;
    }
};

</code></pre><h2 id=16合并两个排序的链表>16.合并两个排序的链表<a hidden class=anchor aria-hidden=true href=#16合并两个排序的链表>#</a></h2>
<blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<pre tabindex=0><code>/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        //当一个链表为空时，直接返回另一个链表
        if(!pHead1)
            return pHead2;
        if(!pHead2)
            return pHead1;
        ListNode* vHead=new ListNode(0);  //设立虚拟的头节点
        ListNode* vHeadHead=vHead;
        while(pHead1 &amp;&amp; pHead2){  //一旦有一个链表为空，就退出循环
            if(pHead1-&gt;val&lt;=pHead2-&gt;val){
                vHead-&gt;next=pHead1;
                pHead1=pHead1-&gt;next;
            }
            else{
                vHead-&gt;next=pHead2;
                pHead2=pHead2-&gt;next;
            }
            vHead=vHead-&gt;next;
        }
        //另一个链表不为空时，加在后面
        if(!pHead1)
            vHead-&gt;next=pHead2;
        else
            vHead-&gt;next=pHead1;
        return vHeadHead-&gt;next;  //返回虚拟头节点的下一个节点
    }
};
//采用递归实现
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        if(!pHead1)
            return pHead2;
        if(!pHead2)
            return pHead1;
        ListNode* vHead=nullptr;
        if(pHead1-&gt;val&lt;=pHead2-&gt;val){
            vHead=pHead1;
            vHead-&gt;next=Merge(pHead1-&gt;next,pHead2);
        }
        else{
            vHead=pHead2;
            vHead-&gt;next=Merge(pHead1,pHead2-&gt;next);
        }
        return vHead;
    }
};
</code></pre><h2 id=17树的子结构>17.树的子结构<a hidden class=anchor aria-hidden=true href=#17树的子结构>#</a></h2>
<blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<pre tabindex=0><code>class Solution {
public:
    bool dfs(TreeNode* pRoot1,TreeNode* pRoot2){
        if(!pRoot2)    //注意不能先判断pRoot1再判断pRoot2，因为，只要pRoot2为空的时候，都是true了，而不管这时候pRoot1是不是为空。
            return true;
        if(!pRoot1)
            return false;
        if(pRoot1-&gt;val!=pRoot2-&gt;val)
            return false;
        return dfs(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;dfs(pRoot1-&gt;right,pRoot2-&gt;right);
        
    }
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if((!pRoot2)||(!pRoot1))
            return false;
        return (dfs(pRoot1,pRoot2)||HasSubtree(pRoot1-&gt;left,pRoot2)||HasSubtree(pRoot1-&gt;right,pRoot2));
    }
};
</code></pre><h2 id=18二叉树的镜像>18.二叉树的镜像<a hidden class=anchor aria-hidden=true href=#18二叉树的镜像>#</a></h2>
<blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
</blockquote>
<p>分析：简单的递归解决。</p>
<pre tabindex=0><code>/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    void Mirror(TreeNode *pRoot) {
        if(pRoot==nullptr)
            return;
        Mirror(pRoot-&gt;left);
        Mirror(pRoot-&gt;right);
        swap(pRoot-&gt;left,pRoot-&gt;right);
    }
};
</code></pre><h2 id=19顺时针打印矩阵>19.顺时针打印矩阵<a hidden class=anchor aria-hidden=true href=#19顺时针打印矩阵>#</a></h2>
<h2 id=20包含min函数的栈>20.包含min函数的栈<a hidden class=anchor aria-hidden=true href=#20包含min函数的栈>#</a></h2>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
</blockquote>
<p>分析：维护两个栈，其中一个是压入数据的栈，另一个是min栈，存储当前数据的最小的值。只有压入的数小于min栈的时候，才压入新值，否则继续压入最小值。</p>
<pre tabindex=0><code>class Solution {
public:
    void push(int value) {
        stk.push(value);
        if(!stk_min.empty()){
            if(value&lt;stk_min.top())
                stk_min.push(value);
            else{
                int temp=stk_min.top();
                stk_min.push(temp);
            }
        }
        else
            stk_min.push(value);
    }
    void pop() {
        stk_min.pop();
        stk.pop();
    }
    int top() {
        return stk.top();
    }
    int min() {
        return stk_min.top();
    }
private:
    stack&lt;int&gt; stk;
    stack&lt;int&gt; stk_min;
};
</code></pre><h2 id=21栈的压入弹出序列>21.栈的压入、弹出序列<a hidden class=anchor aria-hidden=true href=#21栈的压入弹出序列>#</a></h2>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<p>思路：判断是否是压入弹出序列，可以直接使用一个栈进行压入，然后在压入的过程中判断是否跟弹出序列的值相同，是的话则先弹出，最后判断栈是否为空即可。</p>
<pre tabindex=0><code>class Solution {
public:
    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) {
        stack&lt;int&gt; istack;
        int i=0,j=0;
        while(i&lt;pushV.size()){
        	istack.push(pushV[i++]);
        	while(j&lt;popV.size() &amp;&amp; istack.top()==popV[j]){
        		istack.pop();
        		++j;
			}
		}
		return istack.empty();
    }
};
</code></pre><h2 id=22从上往下打印二叉树>22.从上往下打印二叉树<a hidden class=anchor aria-hidden=true href=#22从上往下打印二叉树>#</a></h2>
<blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<p>分析：层序遍历，需要每遍历一个节点，就将他们的左右节点保存起来，当前层遍历完后，再顺序遍历他们的孩子节点。于是很容易想到先入先出的结构，队列。</p>
<pre tabindex=0><code>/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) {
        vector&lt;int&gt; res;
        if(root==nullptr)
            return res;
        queue&lt;TreeNode*&gt; ique;
        ique.push(root);
        while(!ique.empty()){
            TreeNode* temp=ique.front();
            res.push_back(temp-&gt;val);
            ique.pop();
            
            if(temp-&gt;left)
                ique.push(temp-&gt;left);
            if(temp-&gt;right)
                ique.push(temp-&gt;right);
        }
        return res;
    }
};
</code></pre><h2 id=23二叉搜索树的后序遍历序列>23.二叉搜索树的后序遍历序列<a hidden class=anchor aria-hidden=true href=#23二叉搜索树的后序遍历序列>#</a></h2>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<pre tabindex=0><code>class Solution {
public:
    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) {
		return Verify(sequence,0,sequence.size());
    }
    bool Verify(vector&lt;int&gt; sequence,int start,int end){
        int i=start;
        if(start==end)
            return false;
		for(;i&lt;end-1;++i){
			if(sequence[i]&gt;sequence[end-1]){
                break;
            }
		}
        for(int j=i;j!=end;++j){
            if(sequence[j]&lt;sequence[end-1]){
                 return false;
                }
             }
        bool left=true;
        if(i&gt;start)
            left=Verify(sequence,start,i);
        
        bool right=true;
        if(i&lt;end-1)
            right=Verify(sequence,i,end-1);
        return left&amp;&amp;right;
    }
};
</code></pre><h2 id=24二叉树中和为某一值的路径>24.二叉树中和为某一值的路径<a hidden class=anchor aria-hidden=true href=#24二叉树中和为某一值的路径>#</a></h2>
<blockquote>
<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
</blockquote>
<pre tabindex=0><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; temp;
    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) {
        if(!root)
            return res;
        temp.push_back(root-&gt;val);
        if(expectNumber-root-&gt;val==0 &amp;&amp; root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)
            res.push_back(temp);
        FindPath(root-&gt;left,expectNumber-root-&gt;val);
        FindPath(root-&gt;right,expectNumber-root-&gt;val);
        if(!temp.empty())
            temp.pop_back();
        return res;
    }
};
</code></pre><h2 id=25复杂链表的复制>25.复杂链表的复制<a hidden class=anchor aria-hidden=true href=#25复杂链表的复制>#</a></h2>
<p>代码问题：</p>
<pre tabindex=0><code>        while(pHead-&gt;next){
//        	cout&lt;&lt;pHead-&gt;label&lt;&lt;endl;
//            RandomListNode* pTemp=pHead;   //傻了吧
            RandomListNode* pTemp=new RandomListNode(pHead-&gt;label);  
            pTemp-&gt;next=pHead-&gt;next;
            cout&lt;&lt;pTemp-&gt;next-&gt;label&lt;&lt;endl;
            pHead-&gt;next=pTemp;
            pHead=pTemp-&gt;next;
        }
        
                //拆分
        pNode=pHead;
		RandomListNode* newHead=pHead-&gt;next;
        RandomListNode* pTemp=pNode-&gt;next;
		while(pNode){
			pNode-&gt;next=pTemp-&gt;next;
			pNode=pNode-&gt;next;
			pTemp-&gt;next=pNode?pNode-&gt;next:NULL;
			//pTemp-&gt;next=pNode-&gt;next;
			//cout&lt;&lt;&quot;pTemp: &quot;&lt;&lt;pTemp-&gt;label&lt;&lt;endl;
			pTemp=pTemp-&gt;next;
			//cout&lt;&lt;&quot;text&quot;&lt;&lt;endl;
		}
</code></pre><pre tabindex=0><code>class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead)
    {
    	if(!pHead)
    		return pHead;
    	RandomListNode* pNode=pHead;

    	while(pNode){
    		RandomListNode* pClone=new RandomListNode(pNode-&gt;label);
    		pClone-&gt;next=pNode-&gt;next;
    		pNode-&gt;next=pClone;
    		pNode=pClone-&gt;next;
		}

		pNode=pHead;
		while(pNode){
			RandomListNode* pClone=pNode-&gt;next;
			if(pNode-&gt;random)
				pClone-&gt;random=pNode-&gt;random-&gt;next;
			pNode=pClone-&gt;next;
		}
		pNode=pHead;
		RandomListNode* newHead=pNode-&gt;next;
		

		while(pNode-&gt;next){
			RandomListNode* pTemp=pNode-&gt;next;
			pNode-&gt;next=pTemp-&gt;next;
			pNode=pTemp;
//			pNode=pNode-&gt;next;                  //这种不行，搞得我折腾了很久
//			pTemp-&gt;next=pNode-&gt;next;
		}

		return newHead;
}
};
</code></pre><h2 id=26二叉搜索树与双向链表>26.二叉搜索树与双向链表<a hidden class=anchor aria-hidden=true href=#26二叉搜索树与双向链表>#</a></h2>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
TODO:</p>
</blockquote>
<h2 id=27字符串的排列>27.字符串的排列<a hidden class=anchor aria-hidden=true href=#27字符串的排列>#</a></h2>
<h2 id=28数组中出现次数超过一半的数字>28.数组中出现次数超过一半的数字<a hidden class=anchor aria-hidden=true href=#28数组中出现次数超过一半的数字>#</a></h2>
<p>解决一个问题，最终输出的判断，是1，还是0。如果大于1的话，万一最后只剩下了一个呢。所以还需要再判断最后剩下的结果是不是符合条件的，即是大于一般数目的。</p>
<pre tabindex=0><code>class Solution {
public:
    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) {
        if(numbers.empty())
            return 0;
        int count=1;
        int num=numbers[0];
        for(int i=1;i&lt;numbers.size();++i){
            if(numbers[i]==num)
                count++;
            else{
                if((--count)&lt;=0){
                    num=numbers[i];
                    count=1;
                }
            }
        }
        //判断结果是否符合条件
        count=0;
        for(int i=0;i&lt;numbers.size();++i){
            if(num==numbers[i]){
                count++;
            }
        }
        return count*2&gt;numbers.size()?num:0;
    }
};
</code></pre><h2 id=29最小的k个数>29.最小的K个数<a hidden class=anchor aria-hidden=true href=#29最小的k个数>#</a></h2>
<p>存在的问题，写程序的时候越界，没有判断好边界条件。</p>
<pre tabindex=0><code>class Solution {
public:
    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) {
        vector&lt;int&gt; min_stack;
        if(input.empty()||(k&lt;=0)||(k&gt;input.size()))  //边界条件的判断
            return min_stack;
        for(int i=0;i&lt;input.size();++i){
            sort(min_stack.begin(),min_stack.end());
            if(min_stack.size()&lt;k){
                min_stack.push_back(input[i]);
                
            }
            else{
            	//cout&lt;&lt;&quot;min_stack[min_stack.size()-1]: &quot;&lt;&lt;min_stack[min_stack.size()-1]&lt;&lt;endl;
                if(input[i]&lt;min_stack[min_stack.size()-1]){
                    min_stack.pop_back();
                    min_stack.push_back(input[i]);
                }
            }
        }
        return min_stack;
    }
};
</code></pre><h2 id=30连续子数组的最大和>30.连续子数组的最大和<a hidden class=anchor aria-hidden=true href=#30连续子数组的最大和>#</a></h2>
<pre tabindex=0><code>class Solution {
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
    	int  res=array[0];
    	int cur=array[0];
    	for(int i=1;i&lt;array.size();++i){
    		cur+=array[i];
    		if(cur&lt;array[i])
    			cur=array[i];
    		res=(res&gt;cur?res:cur);
		}
		return res;
    }
};
</code></pre><h2 id=31整数中1出现的次数从1到n整数中1出现的次数>31.整数中1出现的次数（从1到n整数中1出现的次数）<a hidden class=anchor aria-hidden=true href=#31整数中1出现的次数从1到n整数中1出现的次数>#</a></h2>
<blockquote>
<p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
</blockquote>
<p>分析：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析。<br>
当i表示百位，且百位对应的数>=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)<em>100个点的百位为1<br>
当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10</em>100）+(b+1)，这些点百位对应为1<br>
当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）<br>
综合以上三种情况，当百位对应0或>=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1
之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位>=2，补8会产生进位位，效果等同于(a/10+1)</p>
<pre tabindex=0><code>class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
    	int count=0;
        //n=1的情况
        if(n==1)
            return 1;
        //考虑的边界情况，n=10,100,1000之类的，同时循环中没有考虑n=0的情况
        if(n&gt;1&amp;&amp;n%10==0)
            count++;
        //没有考虑n=1的情况
        for(int i=1;i&lt;n;i*=10){
            int a=n/i,b=n%i;
            count+=(a+8)/10*i+(a%10==1)*(b+1);
            
        }
        return count;
    }	
};
</code></pre><h2 id=32把数组排成最小的数>32.把数组排成最小的数<a hidden class=anchor aria-hidden=true href=#32把数组排成最小的数>#</a></h2>
<blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<pre tabindex=0><code>class Solution
{
  public:
    static bool equal(int a,int b){
        string str1=to_string(a)+to_string(b);
        string str2=to_string(b)+to_string(a);
        return str1&lt;str2;
    }
    string PrintMinNumber(vector&lt;int&gt; numbers)
    {
        string result;
        sort(numbers.begin(),numbers.end(),equal);
        for(int i=0;i&lt;numbers.size();++i){
            result+=to_string(numbers[i]);
        }
        return result;
    }
};
</code></pre><h2 id=33丑数>33.丑数<a hidden class=anchor aria-hidden=true href=#33丑数>#</a></h2>
<blockquote>
<p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<pre tabindex=0><code>class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        if(index&lt;=0)        
            return 0;
        vector&lt;int &gt; res(index);
        res[0]=1;
        int x=0,y=0,z=0;
        for(int i=1;i&lt;index;++i){
            res[i]=min(2*res[x],min(3*res[y],5*res[z]));
            if(res[i]==2*res[x])
                x++;
            if(res[i]==3*res[y])
                y++;
            if(res[i]==5*res[z])
                z++;
        }
        return res[index-1];
    }
};
</code></pre><h2 id=34第一个只出现一次的字符位置>34.第一个只出现一次的字符位置<a hidden class=anchor aria-hidden=true href=#34第一个只出现一次的字符位置>#</a></h2>
<blockquote>
<p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
</blockquote>
<p>一般对于这种字符的处理，因为字符一般都是不超过256的，所以尤其是计数之类的，我们可以首先考虑数组。</p>
<pre tabindex=0><code>class Solution
{
  public:
    int FirstNotRepeatingChar(string str)
    {
        if(str.size()&lt;=0)
            return -1;
        int array[256]={0};
        for(int i=0;i&lt;str.size();++i){
            array[int(str[i])]++;
        }
        for(int i=0;i&lt;str.size();++i){
            if(array[int(str[i])]==1)
                return i;
        }
        return str.size();
    }
};
</code></pre><h2 id=35数组中的逆序对>35.数组中的逆序对<a hidden class=anchor aria-hidden=true href=#35数组中的逆序对>#</a></h2>
<blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
</blockquote>
<h2 id=36两个链表的第一个公共结点>36.两个链表的第一个公共结点<a hidden class=anchor aria-hidden=true href=#36两个链表的第一个公共结点>#</a></h2>
<blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<p>需要知道的一个常识是，对于只有一个单链表，两个链表有公共节点，意味着从公共节点开始，之后两个链表都是公共的，因此他们有共同的终点。有了这个就好办了。可以将两个链表一直遍历，当遍历到链表尾的时候，就换另一个链表，当他们有公共节点时，在他们遍历到同一个节点时停止遍历，此节点即为第一个公共节点。</p>
<p><strong>对于这种将两个不同的长度，通过两个结合在一起，使两个长度相等的方法，其实我们用到过很多次。例如本题中的找公共节点，原因是两个链表长度不同。还有之前的一个判断两个string的大小，可以把他们放在一起，这样他们的长度就相同了，可以直接用string的方法进行比较。</strong></p>
<pre tabindex=0><code>class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode* p1=pHead1;
        ListNode* p2=pHead2;
        while(p1!=p2){
            p1=(p1==nullptr?pHead2:p1-&gt;next);
            p2=(p2==nullptr?pHead1:p2-&gt;next);
        }
        return p1;
    }
};
</code></pre><h2 id=37数字在排序数组中出现的次数>37.数字在排序数组中出现的次数<a hidden class=anchor aria-hidden=true href=#37数字在排序数组中出现的次数>#</a></h2>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<p>显然很容易想到的是二分法,没有用函数的话，就存在一个找到没找到的问题，在这采用了一个返回值的处理。如果没找到，(end-begin-1)&lt;0，则可以判断是没有找到。</p>
<pre tabindex=0><code>class Solution {
public:
    int GetNumberOfK(vector&lt;int&gt; data ,int k) {
        if(data.empty())
            return 0;
        int begin=0,end=data.size()-1;
        int count=0;
        int mid;
        while(begin&lt;=end){
        	mid=(begin+end)/2;
//        	cout&lt;&lt;&quot;dsdasads&quot;&lt;&lt;endl;
			if(data[mid]==k)
				break;
            else if(data[mid]&lt;k){
                begin=mid+1;
                continue;
            }
            else if(data[mid]&gt;k){
                end=mid-1;
                continue;
            }
        }

        begin=end=mid;
        while(data[begin]==k)
            --begin;
        while(data[end]==k)
            ++end;
        count=(end-begin-1)&gt;0?(end-begin-1):0;
        return count;
    }
};
</code></pre><h2 id=38二叉树的深度>38.二叉树的深度<a hidden class=anchor aria-hidden=true href=#38二叉树的深度>#</a></h2>
<blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<pre tabindex=0><code>class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(!pRoot)
            return 0;
        return max(1+TreeDepth(pRoot-&gt;left),1+TreeDepth(pRoot-&gt;right));
    }
};
</code></pre><h2 id=39平衡二叉树>39.平衡二叉树<a hidden class=anchor aria-hidden=true href=#39平衡二叉树>#</a></h2>
<blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<h2 id=40数组中只出现一次的数字>40.数组中只出现一次的数字<a hidden class=anchor aria-hidden=true href=#40数组中只出现一次的数字>#</a></h2>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<p>数组中只出现一次的数字，当有一个的时候，很容易利用的特性是：全部异或，最后剩下的那个就是。原因是一个数跟自身异或，结果为0.那么出现有两个的时候呢。很容易想到的还是异或，最后的结果是两个只出现一次数字异或的结果，再进行分组解决。分组的依据是：因为有两个不同的数字只出现一次，所以整个数组异或的结果必然不为0，不为0就肯定有一位为1.按该位是否为1来进行划分即可。代码如下：</p>
<pre tabindex=0><code>class Solution {
public:
    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) {
        if(data.empty())
            return;
        //第一次遍历一遍，求两个数字最后的异或
        int res=data[0];
        for(int i=1;i&lt;data.size();++i){
            res=res^data[i];
        }
        if(res==0)
            return;
        //由于存在两个只出现一次的数字，所以res的值为这两个数字的异或，因此肯定不为0，肯定不为0意味着肯定有一位是1.找出这一位是1的
        int index=0;
        while((res&amp;1)==0){
            res=res&gt;&gt;1;
            index++;
        }
        *num1=*num2=0;        
        //根据index位为不为1，将数组分为两部分。
        int x;
        for(int i=0;i&lt;data.size();++i){
            if((x=data[i]&gt;&gt;index)&amp;1)
                *num1^=data[i];
            else
            {
                *num2^=data[i];
            }
            
        }
    }
};
</code></pre><h2 id=41和为s的连续正数序列>41.和为S的连续正数序列<a hidden class=anchor aria-hidden=true href=#41和为s的连续正数序列>#</a></h2>
<blockquote>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
</blockquote>
<pre tabindex=0><code>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; temp;
        //边界条件的判断
        if(sum&lt;0)
            return res;
            
        int end=0;
        int tempSum=0;
        //遍历数组
        while(end&lt;sum){
            if(tempSum==sum){
                res.push_back(temp);
                end=temp[0];  //这一句其实很重要,因为要考虑将end从最开始重新开始计算，不然可能会有所遗漏,eg:9=2+3+4=4+5，其中4会重复
                temp.erase(temp.begin(),temp.end());
                tempSum=0;
                continue;
            }
            if(tempSum&gt;sum){
                tempSum-=temp[0];
                temp.erase(temp.begin());
                continue;
            }
            temp.push_back(++end);
            tempSum+=end;
        }
        return res;
    }
};
</code></pre><h2 id=42和为s的两个数字>42.和为S的两个数字<a hidden class=anchor aria-hidden=true href=#42和为s的两个数字>#</a></h2>
<blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
</blockquote>
<p>输出乘积最小的，显然距离最大的乘积就越小，所以，可以直接前后两个指针搜索，搜到的第一个就是。</p>
<pre tabindex=0><code>class Solution
{
  public:
    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum)
    {
        vector&lt;int &gt; res;
        if(array.empty())
            return res;
            
        int i=0,j=array.size()-1;
        while(i&lt;j){
            int temp=array[i]+array[j];
            if(temp&gt;sum)
                --j;
            if(temp&lt;sum)
                ++i;
            
            if(temp==sum) 
            {
                res.push_back(array[i]);
                res.push_back(array[j]);
                return res;
            }
        }
        return res;
    }
};
</code></pre><h2 id=43左旋转字符串>43.左旋转字符串<a hidden class=anchor aria-hidden=true href=#43左旋转字符串>#</a></h2>
<blockquote>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
</blockquote>
<p>由BA=(ATBT)T计算可得</p>
<pre tabindex=0><code>//第一次通过代码
class Solution {
public:
    string LeftRotateString(string str, int n) {
        int len=str.size();
        if(n&gt;=len)
            return str;
        int i=0,j=0;
        for(i=0,j=n-1;i&lt;j;++i,--j){swap(str[i],str[j]);}
        for(i=n,j=len-1;i&lt;j;++i,--j){swap(str[i],str[j]);}
        for(i=0,j=len-1;i&lt;j;++i,--j){swap(str[i],str[j]);}
        return str;
    }
};
</code></pre><h2 id=44翻转单词顺序列>44.翻转单词顺序列<a hidden class=anchor aria-hidden=true href=#44翻转单词顺序列>#</a></h2>
<blockquote>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
</blockquote>
<pre tabindex=0><code>//以前买的
class Solution {
public:
    void ReverseSentence(string &amp;str,int begin,int end){
        while(begin&lt;end){
            char tmp=str[begin];
            str[begin]=str[end];
            str[end]=tmp;
            begin++;
            end--;
        }
    }
    string ReverseSentence(string str) {
        if(str.size()&lt;=1)
            return str;
        int begin=0;
        int end=0;
        //这里需要注意，考虑只有一个单词的情况
        while(end!=str.size()){
            if(str[end]==' '){
                ReverseSentence(str,0,str.size()-1);
                break;
            }
            else if(end==str.size()-1)
            	return str;
            else
                ++end;
        }
        end=0;
        //开始遍历，旋转每个单词
        while(begin!=str.size()){
            if(str[begin]==' '){
                ++end;
                ++begin;
            }
            else if(str[end]==' '||end==str.size()){
                ReverseSentence(str,begin,--end);
                begin=++end;
            }
            else
                ++end;
        }
        return str;
    }
};
</code></pre><h2 id=45扑克牌顺子>45.扑克牌顺子<a hidden class=anchor aria-hidden=true href=#45扑克牌顺子>#</a></h2>
<blockquote>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)&mldr;他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子&mldr;..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p>
</blockquote>
<pre tabindex=0><code>class Solution
{
  public:
    bool IsContinuous(vector&lt;int&gt; numbers)
    {
        if (numbers.empty())
            return false;
        sort(numbers.begin(), numbers.end());
        int sum = 0, zero_num = 0;
        for (int i = 0; i &lt; numbers.size() - 1; ++i)
        {
            if (numbers[i] == 0)
            {
                zero_num++;
                continue;
            }
            //考虑数字重复的情况
            if (numbers[i + 1] == numbers[i])
                return false;
            sum += numbers[i + 1] - numbers[i] - 1;
        }
        return sum &lt;= zero_num; //注意这里要大于等于就可以，不一定等于
    }
};
</code></pre><h2 id=46孩子们的游戏圆圈中最后剩下的数>46.孩子们的游戏(圆圈中最后剩下的数)<a hidden class=anchor aria-hidden=true href=#46孩子们的游戏圆圈中最后剩下的数>#</a></h2>
<blockquote>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0&mldr;m-1报数&mldr;.这样下去&mldr;.直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
</blockquote>
<p>此约瑟夫环的问题。https://www.nowcoder.com/profile/4566768/codeBookDetail?submissionId=13393365</p>
<pre tabindex=0><code>class Solution {
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n&lt;=0)
            return -1;
        int last=0;
        for(int i=2;i&lt;=n;++i){
            last=(last+m)%i;
        }
        return last;
    }
};
</code></pre><h2 id=47求123n>47.求1+2+3+&mldr;+n<a hidden class=anchor aria-hidden=true href=#47求123n>#</a></h2>
<blockquote>
<p>求1+2+3+&mldr;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</blockquote>
<p>这个题，可以有好几种解决办法，一个容易想到的就是递归，每次都跟自己相加，直到加到0为止，判断的条件可以采用<code>&&</code>的短路特性：通过&&判断值是否为0已经到达结尾了。<br>
另一种办法，可以利用类的构造函数。</p>
<pre tabindex=0><code>class Solution {
public:
    int Sum_Solution(int n) {
        int sum=n;
        sum&amp;&amp;(sum+=Sum_Solution(n-1));
        return sum;
    }
};
</code></pre><h2 id=48不用加减乘除做加法>48.不用加减乘除做加法<a hidden class=anchor aria-hidden=true href=#48不用加减乘除做加法>#</a></h2>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<p>不能用加法做加法运算，可以想到的计算机中利用的二进制的加法。通过异或两个数，也就是模2加，得到的是不考虑进位的加法的结果。通过两个数异或，左移一位得到的是进位。无进位结果加上进位，一直循环知道进位为0的时候，结果即为加法的结果。<br>
计算的过程中，一定要细心。方法虽然简单，但是要写对。</p>
<pre tabindex=0><code>class Solution
{
  public:
    int Add(int num1, int num2)
    {
        int res = num1 ^ num2, temp = num1 &amp; num2;
        while (temp != 0)
        {
            temp = temp &lt;&lt; 1;
            int t = res;  //暂存res,以避免res的值被改变
            res ^= temp;
            temp = temp &amp; t;
        }
        return res;
    }
};
</code></pre><h2 id=49把字符串转换成整数>49.把字符串转换成整数<a hidden class=anchor aria-hidden=true href=#49把字符串转换成整数>#</a></h2>
<blockquote>
<p>输入一个字符串,包括数字字母符号,可以为空.如果是合法的数值表达则返回该数字，否则返回0</p>
</blockquote>
<p>分析：主要首先要考虑正负号，这里有一个小细节，我们把flag直接置1的话，可以直接输出flag*res得到结果，而不需要进行判断，是一种省略。另外的判断就比较简单了，按照正常的思路去判断就行。</p>
<pre tabindex=0><code>class Solution
{
  public:
    int StrToInt(string str)
    {
        if (str.size() == 0)
            return 0;
        int flag = 1;
        int size = str.size(), res = 0;
        int i = 0;
        if (str[0] == '-')
        {
            flag = -1;
            i++;
        }
        else if (str[0] == '+')
        {
            i++;
        }
        for (; i &lt; size; ++i)
        {
            if (str[i] &lt;= '0' || str[i] &gt;= '9')
            {
                return 0;
            }
            else
                res = res * 10 + (str[i] - '0');
        }
        return flag * res;
    }
};
</code></pre><h2 id=50数组中重复的数字>50.数组中重复的数字<a hidden class=anchor aria-hidden=true href=#50数组中重复的数字>#</a></h2>
<blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p>分析：由于规定了数组中的数字在范围为0&ndash;n内，所以可以利用当前数组的位置进行遍历，比如每次遍历到一个位置，就将该数字对应位置的值加n，这样，当再次遍历到该值时，发现如果该值已经大于n，说明已经重复了，返回即可。不过在遍历的时候，如果发现某一位置的值大于n，应该先减去n，得到该位置上原来的值，这里应该捋清楚。</p>
<pre tabindex=0><code>class Solution
{
  public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    bool duplicate(int numbers[], int length, int *duplication)
    {
        for(int i=0;i&lt;length;++i){
            int index=numbers[i];
            if(index&gt;=length)
                index=index-length;
            if(numbers[index]&gt;=length){
                *duplication=index;
                return true;
            }
            numbers[index]+=length;
        }
        return false;
    }
};
</code></pre><h2 id=51构建乘积数组>51.构建乘积数组<a hidden class=anchor aria-hidden=true href=#51构建乘积数组>#</a></h2>
<blockquote>
<p>给定一个数组A[0,1,&mldr;,n-1],请构建一个数组B[0,1,&mldr;,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>&mldr;*A[i-1]<em>A[i+1]</em>&mldr;*A[n-1]。不能使用除法。</p>
</blockquote>
<pre tabindex=0><code>class Solution {
public:
    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) {
        vector&lt;int&gt; res(A.size());
        if(A.empty())
            return res;
        res[0]=1;
        //计算下三角
        for(int i=1;i&lt;A.size();++i){
            res[i]=res[i-1]*A[i-1];
        }
        int temp=1;
        for(int i=A.size()-2;i&gt;=0;--i){
            temp*=A[i+1];
            res[i]*=temp;
        }
        return res;
    }
};
</code></pre><h2 id=52正则表达式匹配>52.正则表达式匹配<a hidden class=anchor aria-hidden=true href=#52正则表达式匹配>#</a></h2>
<h2 id=53表示数值的字符串>53.表示数值的字符串<a hidden class=anchor aria-hidden=true href=#53表示数值的字符串>#</a></h2>
<pre tabindex=0><code>/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(pHead==nullptr)
            return pHead;
        ListNode* virtualHead=new ListNode(0);
        virtualHead-&gt;next=pHead;
        ListNode* prev=virtualHead;
        
        while(pHead-&gt;next){
            if(pHead-&gt;val==pHead-&gt;next-&gt;val){
                if(pHead-&gt;next-&gt;next){
                    pHead=pHead-&gt;next-&gt;next;
                    prev-&gt;next=pHead;
                }
                else 
                    return virtualHead-&gt;next;
            }
            else{
                pHead=pHead-&gt;next;
                prev=prev-&gt;next;
            }
            
        }
        return virtualHead-&gt;next;
    }
};
</code></pre><p>测试用例:
{1,1,1,1,1,1,1}</p>
<p>对应输出应该为:</p>
<h2 id=54字符流中第一个不重复的字符>54.字符流中第一个不重复的字符<a hidden class=anchor aria-hidden=true href=#54字符流中第一个不重复的字符>#</a></h2>
<blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。 如果当前字符流没有存在出现一次的字符，返回#字符。</p>
</blockquote>
<pre tabindex=0><code>class Solution
{
public:
  //Insert one char from stringstream
    void Insert(char ch)
    {
        if(!array[ch])
            ique.push(ch);
        array[ch]++;
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce()
    {
        while(!ique.empty() &amp;&amp; array[ique.front()]&gt;1){
            ique.pop();
        }
        if(!ique.empty())
            return ique.front();
        return '#';
    }
private:
    int array[256]={0};
    queue&lt;char&gt; ique;
};
</code></pre><h2 id=55链表中环的入口结点>55.链表中环的入口结点<a hidden class=anchor aria-hidden=true href=#55链表中环的入口结点>#</a></h2>
<blockquote>
<p>一个链表中包含环，请找出该链表的环的入口结点。</p>
</blockquote>
<p>分析：http://wuchong.me/blog/2014/03/25/interview-link-questions/</p>
<pre tabindex=0><code>class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        if(!pHead || !pHead-&gt;next)
            return nullptr;
        ListNode* fast=pHead,*slow=pHead;
        while(fast-&gt;next &amp;&amp; slow){
            fast=fast-&gt;next-&gt;next;
            slow=slow-&gt;next;
            if(fast==slow)
                break;
        }
        if(fast!=slow)
            return nullptr;
        fast=pHead;
        while(fast!=slow){
            fast=fast-&gt;next;
            slow=slow-&gt;next;
        }
        return fast;
    }
};
</code></pre><h2 id=56删除链表中重复的结点>56.删除链表中重复的结点<a hidden class=anchor aria-hidden=true href=#56删除链表中重复的结点>#</a></h2>
<pre tabindex=0><code>//一个不通过的代码
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(!pHead || !pHead-&gt;next)
            return pHead;
        ListNode* vHead=new ListNode(0);
        vHead-&gt;next=pHead;
        ListNode* pre=vHead;
        ListNode* cur=pHead;
        int temp;
        while(cur &amp;&amp; cur-&gt;next){
             ListNode* next=cur-&gt;next;
            if(cur-&gt;val==next-&gt;val){   //原因是这个相等的处理有问题，没有考虑一直是同一个值的处理
                temp=cur-&gt;val;
                cur=next-&gt;next;
                pre-&gt;next=cur;
            }
            else if(next-&gt;val==temp){
                cur-&gt;next=next-&gt;next;
                pre-&gt;next=cur;
            }
            else{
                if(next-&gt;next){
                    pre=cur;
                    cur=next;
                  //  next=next-&gt;next;
                }
               else
                    return vHead-&gt;next;
            }
        }
        return vHead-&gt;next;
    }
};
//一个通过了的代码
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(!pHead || !pHead-&gt;next)
            return pHead;
        ListNode* vHead=new ListNode(-1);
        vHead-&gt;next=pHead;
        ListNode* pre=vHead;
        ListNode* cur=pHead;
        while(cur &amp;&amp; cur-&gt;next){
            ListNode* next=cur-&gt;next;
            if(cur-&gt;val==next-&gt;val){
                int val=cur-&gt;val;
                while(cur &amp;&amp; cur-&gt;val==val)  //一直遍历到不为当前值为止
                    cur=cur-&gt;next;
                pre-&gt;next=cur;
                cur=pre-&gt;next;
            }
            else{
                pre=pre-&gt;next;
                cur=cur-&gt;next;
            }
        }
        return vHead-&gt;next;
    }
};
//递归解决
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(pHead==nullptr || pHead-&gt;next==nullptr)
            return pHead;
        ListNode* current=pHead;
        if(pHead-&gt;val==pHead-&gt;next-&gt;val){
            current=pHead-&gt;next-&gt;next;
            while(current!=nullptr &amp;&amp; current-&gt;val==pHead-&gt;val)
                current=current-&gt;next;
            return deleteDuplication(current);
        }
        
        else{
            current=pHead-&gt;next;
            pHead-&gt;next=deleteDuplication(current);
            return pHead;
        }
    }
};
</code></pre><h2 id=57二叉树的下一个结点>57.二叉树的下一个结点<a hidden class=anchor aria-hidden=true href=#57二叉树的下一个结点>#</a></h2>
<blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>分析二叉树的下一个节点，一共有以下情况：
1.二叉树为空，则返回空；
2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；
3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p>
<h2 id=58对称的二叉树>58.对称的二叉树<a hidden class=anchor aria-hidden=true href=#58对称的二叉树>#</a></h2>
<h2 id=59按之字形顺序打印二叉树>59.按之字形顺序打印二叉树<a hidden class=anchor aria-hidden=true href=#59按之字形顺序打印二叉树>#</a></h2>
<h2 id=60把二叉树打印成多行>60.把二叉树打印成多行<a hidden class=anchor aria-hidden=true href=#60把二叉树打印成多行>#</a></h2>
<h2 id=61序列化二叉树>61.序列化二叉树<a hidden class=anchor aria-hidden=true href=#61序列化二叉树>#</a></h2>
<h2 id=62二叉搜索树的第k个结点>62.二叉搜索树的第k个结点<a hidden class=anchor aria-hidden=true href=#62二叉搜索树的第k个结点>#</a></h2>
<h2 id=63数据流中的中位数>63.数据流中的中位数<a hidden class=anchor aria-hidden=true href=#63数据流中的中位数>#</a></h2>
<h2 id=64滑动窗口的最大值>64.滑动窗口的最大值<a hidden class=anchor aria-hidden=true href=#64滑动窗口的最大值>#</a></h2>
<h2 id=65矩阵中的路径>65.矩阵中的路径<a hidden class=anchor aria-hidden=true href=#65矩阵中的路径>#</a></h2>
<h2 id=66机器人的运动范围>66.机器人的运动范围<a hidden class=anchor aria-hidden=true href=#66机器人的运动范围>#</a></h2>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://yuguocong.cn/tags/c++/>C++</a></li>
<li><a href=https://yuguocong.cn/tags/leetcode/>LeetCode</a></li>
<li><a href=https://yuguocong.cn/tags/%E5%89%91%E6%8C%87offer/>剑指offer</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://yuguocong.cn/posts/interview_cpp/>
<span class=title>« </span>
<br>
<span>面试总结-C++</span>
</a>
<a class=next href=https://yuguocong.cn/posts/redis_sum/>
<span class=title> »</span>
<br>
<span>《redis 设计与实现》--总结</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share 剑指offer-刷题总结 on twitter" href="https://twitter.com/intent/tweet/?text=%e5%89%91%e6%8c%87offer-%e5%88%b7%e9%a2%98%e6%80%bb%e7%bb%93&url=https%3a%2f%2fyuguocong.cn%2fposts%2fre_sword_to_offer%2f&hashtags=C%2b%2b%2cLeetCode%2c%e5%89%91%e6%8c%87offer"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 剑指offer-刷题总结 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fyuguocong.cn%2fposts%2fre_sword_to_offer%2f&title=%e5%89%91%e6%8c%87offer-%e5%88%b7%e9%a2%98%e6%80%bb%e7%bb%93&summary=%e5%89%91%e6%8c%87offer-%e5%88%b7%e9%a2%98%e6%80%bb%e7%bb%93&source=https%3a%2f%2fyuguocong.cn%2fposts%2fre_sword_to_offer%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 剑指offer-刷题总结 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fyuguocong.cn%2fposts%2fre_sword_to_offer%2f&title=%e5%89%91%e6%8c%87offer-%e5%88%b7%e9%a2%98%e6%80%bb%e7%bb%93"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 剑指offer-刷题总结 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fyuguocong.cn%2fposts%2fre_sword_to_offer%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 剑指offer-刷题总结 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%89%91%e6%8c%87offer-%e5%88%b7%e9%a2%98%e6%80%bb%e7%bb%93%20-%20https%3a%2f%2fyuguocong.cn%2fposts%2fre_sword_to_offer%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 剑指offer-刷题总结 on telegram" href="https://telegram.me/share/url?text=%e5%89%91%e6%8c%87offer-%e5%88%b7%e9%a2%98%e6%80%bb%e7%bb%93&url=https%3a%2f%2fyuguocong.cn%2fposts%2fre_sword_to_offer%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://yuguocong.cn/>mianhk's notes</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>