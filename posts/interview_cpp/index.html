<!doctype html><html lang=zh-cn dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>面试总结-C++ | mianhk's notes</title>
<meta name=keywords content="面试,C++,工作">
<meta name=description content="编程基础 C++ 内存管理方式 堆、栈、自由存储区、全局/静态存储区、常量存储区 自由存储区存储malloc申请的内存 (1)从静态存储区域分配 。内存在程">
<meta name=author content="mianhk">
<link rel=canonical href=https://yuguocong.cn/posts/interview_cpp/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://yuguocong.cn/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123 -45','auto'),ga('send','pageview'))</script><meta property="og:title" content="面试总结-C++">
<meta property="og:description" content="编程基础 C++ 内存管理方式 堆、栈、自由存储区、全局/静态存储区、常量存储区 自由存储区存储malloc申请的内存 (1)从静态存储区域分配 。内存在程">
<meta property="og:type" content="article">
<meta property="og:url" content="https://yuguocong.cn/posts/interview_cpp/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-06-24T22:02:20+08:00">
<meta property="article:modified_time" content="2018-06-24T22:02:20+08:00"><meta property="og:site_name" content="mianhk's notes">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="面试总结-C++">
<meta name=twitter:description content="编程基础 C++ 内存管理方式 堆、栈、自由存储区、全局/静态存储区、常量存储区 自由存储区存储malloc申请的内存 (1)从静态存储区域分配 。内存在程">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuguocong.cn/posts/"},{"@type":"ListItem","position":2,"name":"面试总结-C++","item":"https://yuguocong.cn/posts/interview_cpp/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"面试总结-C++","name":"面试总结-C\u002b\u002b","description":"编程基础 C++ 内存管理方式 堆、栈、自由存储区、全局/静态存储区、常量存储区 自由存储区存储malloc申请的内存 (1)从静态存储区域分配 。内存在程","keywords":["面试","C++","工作"],"articleBody":"编程基础 C++ 内存管理方式 堆、栈、自由存储区、全局/静态存储区、常量存储区 自由存储区存储malloc申请的内存\n(1)从静态存储区域分配 。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如 全局变量， static 变量 。 (2)在栈上创建 。在执行函数时， 函数内局部变量的存储单元都可以在栈上创建 ，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 (3)从堆上分配 ， 亦称动态内存分配 。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。\nextern “C\"和extern的作用 extern “C\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。\n(http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)\n为什么需要内存对齐 c++内存问题   缓冲区溢出（buffer overrun）。\n用 std::vector/std::string 或自己编写 Buffer class 来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。\n  空悬指针/野指针。\n用 shared_ptr/weak_ptr\n  重复释放（double delete）。\n  内存泄漏（memory leak）。\n  不配对的 new[]/delete。\n把 new[] 统统替换为 std::vector/scoped_array。\n  内存碎片（memory fragmentation）。\n  static关键字 作用：  函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值 在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问 在模块内的 static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内。起到了隐藏的作用 在类的 static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量  静态全局变量不要放在头文件里 (https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html) 第6条\nC++中的static关键字的总结\n几个复制的声明 void * ( * (*fp1)(int))[10]; //fp1是一个指针，指向一个函数，函数参数为int，函数返回参数是一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个void* 指针。 float (*(* fp2)(int,int,int))(int); //fp2是一个指针，指向一个函数，函数参数为3个int，函数的返回值是一个指针，指针指向一个函数，函数的参数是1个int，返回float。 int (* ( * fp3)())[10](); //fp3是一个指针，指向一个函数，函数没有参数，函数返回值为一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个函数指针，函数没有参数，返回int。 strlen()和sizeof() 区别与联系：\n 种类：\nsizeof是运算符，并不是函数，结果在编译时得到,因此sizeof不能用来返回动态分配的内存空间的大小。用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系；strlen是字符处理的库函数,当数组名作为参数传入时，实际上数组就退化成指针了。。 输入参数：\nsizeof参数可以是任何数据的类型或者数据（sizeof参数不退化），还可以用函数做参数；strlen的参数只能是字符指针且结尾是'\\0’的字符串。 功能：\nsizeof():获得保证能容纳实现所建立的最大对象的字节大小 strlen():返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。 返回：\n当适用于一个结构类型时或变量， sizeof 返回实际的大小， 当适用于一静态地空间数组， sizeof 归还全部数组的尺寸。 sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸  https://blog.csdn.net/21aspnet/article/details/1539951\n变量声明和定义   声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。\n  相同变量可以再多处声明（外部变量extern），但只能在一处定义。\n  结构体和union 1.在存储多个成员信息时，编译器会自动给struct第个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。\n2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。\n3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。\n未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。\neg:\nstruct sTest { int a; //sizeof(int) = 4 char b; //sizeof(char) = 1 short c； //sizeof(short) = 2 }x; #最终实际占用不止4+1+2，因为要考虑内存对齐的问题 union uTest { int a; //sizeof(int) = 4 double b; //sizeof(double) = 8 char c; //sizeof(char) = 1 }x; #分配的内存 size 就是8 byte pragma pack () 取消指定对齐，恢复缺省对齐\nstatic malloc/new和free/delete   malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。\n  malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。\n  malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。\n  free和delete对应。当delete一个对象数组时，delete只删除了一个，需要使用delete[]\n  const 宏定义和const函数的区别  宏在编译时完成替换，直接进行替换，执行起来更快，但是可能会存在一些风险；函数调用在运行时需要跳转到具体调用函数。如：  \t#define area(x) x*x int main(){ int y=area(2+2); std::cout  宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。\n  宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。\n  一般可以对const常量进行调试，但不能对宏常量进行调试。\n  宏函数不要在最后加分号。\n  总之，一般尽量用const比较好。\nconst的分辨(顶层const和底层const) 一般来说，const的分辨可以直接通过看const的最左侧，如果是指针，则指针是const，若为类型，则变量为const。当const在最左侧时，看const右侧。\n 常量指针和指针常量： 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。\n指针常量是一个常量，指针的值可以改变。如int *const p。  指针和引用 区别  指针是具体的变量，需要占存储空间。引用只是别名，不占用具体存储空间。这是最基本的一点，其他的特点也就可想而知了。 指针可以先声明，但是引用声明的时候就必须初始化，不存在空的引用很容易理解。 指针变量可以改变所指的对象。但是引用一旦声明了就不能再改变引用的对象了。  引用相关问题  引用是某个变量的别名，因此定义的时候必须初始化，也不能把该引用再改成其他变量的别名。 声明一个引用并没有定义新变量，引用本身不是一种数据类型。也不占用存储空间。 不能建立数组的引用。其实这句话的意思是：不能建立引用的数组，例如：int \u0026 ref[3] = { 2, 3, 5}; 但是可以建立数组的引用:例如：int arr[3]; int (\u0026tef)[3] = arr;\n原因是：引用时不占空间的，声明引用数组没法分配空间。见为什么不能建立引用数组 将引用作为函数的参数时，可以避免对变量或者对象的复制，因此不会调用对象的拷贝构造函数。当不希望传入的引用参数不被改变时，使用const引用。 函数中不能返回局部变量的引用，不能返回函数内部ne分配的内存的引用。（虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄露。）。 可以返回类成员的引用，但最好是const。 当类中存在const或者引用时成员变量时，必须使用初始化表。  指针相关问题 指针的相关判断  int *p[10] int (*p)[10] int *p(int) int (*p)(int)   int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。\n  int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。\n  int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。\n  int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。\n  指针与数组名   二者均可通过增减偏移量来访问数组中的元素。\n  数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。\n  当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。\n  野指针 空悬指针，不是指向null的指针，是指向垃圾内存的指针。\n 产生原因及解决办法：  指针变量未及时初始化 = 定义指针变量及时初始化，要么置空。 指针free或delete之后没有及时置空 = 释放操作后立即置空。    指针和数组的区别 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。\n 修改内容上的差别:指针可能指向一块内存，但是指向的常量却无法通过下标计算。  char a[] = “hello”; a[0] = ‘X’; char *p = “world”; // 注意p 指向常量字符串，指向的是常量区 p[0] = ‘X’; // 编译器不能发现该错误，运行时错误 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。  char a[] = \"hello world\"; char *p = a; coutvolatile   volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。\n  多线程中被几个任务共享的变量需要定义为volatile类型。\n  堆栈 区别  申请方式不同：栈由系统自动分配，堆由程序员手动分配 申请大小不同：栈顶和栈底都是设定好的，大小固定，可以通过ulimit -a查看，通过ulimit -s修改。堆向高地址扩展，是不连续的内存区域，大小可以调整。 申请效率不同：栈由系统分配，速度快，没有碎片。堆速度慢，且有碎片。  内存分配 https://blog.csdn.net/nkguohao/article/details/8771867\n面向对象 面向对象三大特性   封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。\n  继承性：让某种类型对象获得另一个类型对象的属性和方法。\n  多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。\n  构造函数和析构函数 1.构造函数、析构函数中都不要调用虚函数\n我们知道，构造函数一般不能是虚函数，而析构函数一般必须是虚函数。原理也很清晰，构造函数，由于构造顺序是从基类到派生类，所以调用虚函数，可能派生类还没有构造出来，没有意义。而对于析构函数来说，又必须是虚函数，因为只有先从子类对象进行销毁，才能保证资源不泄露。\n在构造函数和析构函数中都不要调用虚函数也是这个道理。\n成员变量和成员函数 1.静态成员变量是需要初始化\n其实这样说的是有点问题的，应该是静态成员是需要定义的。 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。 《c++primer》里面说在类外定义和初始化是保证static成员变量只被定义一次的好方法。 但static const int就可以在类里面初始化\nclass Base{ public: static int class_p; //只有声明，而没有定义，不能直接调用 }; int Base::class_p=3; //进行定义 https://blog.csdn.net/qq_16209077/article/details/52602601 拷贝构造函数 调用情况：\n 用一个类的对象去初始化该类的另一个对象时。 函数形参是类的对象时，调用函数将函数的形参和实参结合的时候。 函数返回值是类的对象，函数调用完成返回时。  重写拷贝构造函数 一般会默认生成类的拷贝构造函数，但是当涉及动态分配存储空间时，默认的拷贝构造函数就会有问题，因此需要重写拷贝构造函数，并且采用深拷贝。\n浅拷贝和深拷贝：\n多态 多态：对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：\n编译时多态：函数和运算符的重载。\n运行时多态：继承和虚函数。\n友元 特性：单向的，传递性，不能继承\n标准模板库 编译和调试 编译过程 预处理-编译-汇编-链接\n 预处理：展开宏定义；处理条件编译；处理#include指令；去掉注释；添加行号和文件名标识；保留所有#pragma编译器指令。 编译：词法分析；语法分析；语义分析；中间语言生成；目标代码生成与优化。 链接：各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。  静态库和动态库 二者的不同点在于代码被载入的时刻不同。静态库和动态库的最大区别,静态情况下,把库直接加载到程序中,而动态库链接的时候,它只是保留接口,将动态库与程序代码独立,这样就可以提高代码的可复用度，和降低程序的耦合度。\n 静态库的代码在编译过程中已经被载入可执行程序,程序运行时将不再需要该静态库，因此可执行程序体积比较大。在Linux中以.a结尾 动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小,在程序运行时还需要动态库存在。不同的应用程序如果调用相同的库,那么在内存中只需要有一份该动态库(共享库)的实例。在Linux中以.so结尾\n当静态库和动态库同名时， gcc命令将优先使用动态库.为了确保使用的是静态库, 编译时可以加上 -static 选项，因此多第三方程序为了确保在没有相应动态库时运行正常，喜欢在编译最后应用程序时加入-static\n优缺点：\n1.动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。 2.动态库更新很容易，当库发生变化时，接口没变只需要用新的动态库替换掉就可以。静态库需要重新编译。\n3.静态库静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会高一些。  安全相关 类型安全 类型安全很大程度上可以理解为内存安全。类型安全的代码不会试图去访问自己没有被授权的内存区域。\n对于C语言来说，很多操作都不是类型安全的。例如打印的时候:printf(\"%f\\n\",10) //编译通过，没有报错，结果为0.000000.\n对于C++来说，有些操作也不是类型安全的，比如不同类型指针之间可以强制转换(reinterpret cast) 注：C#、Java是类型安全的\nC++使用得当，可以远比C更有类型安全性。 （1）操作符new返回的指针类型严格与对象匹配，而不是void*；\n（2）C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；\n（3）引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；\n（4）一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；\n（5）C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。\n线程安全 如果代码在多线程运行和单线程运行具有相同的结果，那就是线程安全的。\n线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。\n异常安全 当异常抛出时，带有异常安全的函数会： （1）不泄露任何资源 一般采用RAII技术，即以对象管(智能指针)理资源来防止资源泄漏。 (2)不允许数据被破坏（例如正常指针变野指针） (3)少些try catch，因为大量的try catch会影响代码逻辑。导致代码丑陋混乱不优雅\n解决异常安全的问题： 1.多使用RAII，使用智能指针来管理内存。由于unwind机制的保证，当异常发生时，函数栈内已构造的局部对象的析构函数会被一一调用，在析构函数内释放资源，也就杜绝了内存泄漏的问题。\n2.做好程序设计。特别是异常发生时的回滚机制的正确使用，copy-and-swap是有效的方法。\n3.注意需要异常保证的函数内部的调用函数，异常安全等级是以有最低等级异常保证的函数确定的。一个系统即使只有一个函数不是异常安全的，那么系统作为一个整体就不是异常安全的。\n4.流对象，资源对象，new对象，不应该直接作为参数，一旦抛出异常，就可能会导致严重的问题，函数也许会被错误的执行，资源也许会泄漏。\n5.减少全局变量的使用。\n6.如果不知道如何处理异常，就不要捕获异常，直接终止比吞掉异常不处理要好。\n7.保证构造、析构、swap不会失败\n类型安全 与 线程安全 、异常安全、事务安全\n其他 为什么说栈比堆要快  分配和释放：堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，具体可以看看MALLOC和FREE的源代码，他们做了很多额外的工作，而栈却不需要这些。 访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。 堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。  c++协程的实现 ucontext-人人都可以实现的简单协程库\n设计模式 单例模式 工厂方法 观察者模式 怎么判断两个结构体变量是否相等？ 1，元素的话，一个个比咯：if(p1-age==p2-age)…有一个元素不等，即是两个实例不相等！没什么效率高的方法吧！\n2，指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真！\n3，重载==运算符；\n Refeence: 常见C++面试题\n","wordCount":"7609","inLanguage":"zh-cn","datePublished":"2018-06-24T22:02:20+08:00","dateModified":"2018-06-24T22:02:20+08:00","author":{"@type":"Person","name":"mianhk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuguocong.cn/posts/interview_cpp/"},"publisher":{"@type":"Organization","name":"mianhk's notes","logo":{"@type":"ImageObject","url":"https://yuguocong.cn/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://yuguocong.cn/ accesskey=h title="mianhk's notes (Alt + H)">mianhk's notes</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://yuguocong.cn/posts/ title=文章>
<span>文章</span>
</a>
</li>
<li>
<a href=https://yuguocong.cn/archives/ title=归档>
<span>归档</span>
</a>
</li>
<li>
<a href=https://yuguocong.cn/tags/ title=标签>
<span>标签</span>
</a>
</li>
<li>
<a href=https://yuguocong.cn/search/ title=搜索>
<span>搜索</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://yuguocong.cn/>Home</a>&nbsp;»&nbsp;<a href=https://yuguocong.cn/posts/>Posts</a></div>
<h1 class=post-title>
面试总结-C++
</h1>
<div class=post-meta>June 24, 2018&nbsp;·&nbsp;16 min&nbsp;·&nbsp;mianhk
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e7%bc%96%e7%a8%8b%e5%9f%ba%e7%a1%80 aria-label=编程基础>编程基础</a><ul>
<li>
<a href=#c-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label="C++ 内存管理方式">C++ 内存管理方式</a></li>
<li>
<a href=#extern-c%e5%92%8cextern%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label="extern &amp;ldquo;C&amp;quot;和extern的作用">extern &ldquo;C"和extern的作用</a></li>
<li>
<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90 aria-label=为什么需要内存对齐>为什么需要内存对齐</a></li>
<li>
<a href=#c%e5%86%85%e5%ad%98%e9%97%ae%e9%a2%98 aria-label=c++内存问题>c++内存问题</a></li>
<li>
<a href=#static%e5%85%b3%e9%94%ae%e5%ad%97 aria-label=static关键字>static关键字</a><ul>
<li>
<a href=#%e4%bd%9c%e7%94%a8 aria-label=作用：>作用：</a></li>
<li>
<a href=#%e9%9d%99%e6%80%81%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e4%b8%8d%e8%a6%81%e6%94%be%e5%9c%a8%e5%a4%b4%e6%96%87%e4%bb%b6%e9%87%8c aria-label=静态全局变量不要放在头文件里>静态全局变量不要放在头文件里</a></li></ul>
</li>
<li>
<a href=#%e5%87%a0%e4%b8%aa%e5%a4%8d%e5%88%b6%e7%9a%84%e5%a3%b0%e6%98%8e aria-label=几个复制的声明>几个复制的声明</a></li>
<li>
<a href=#strlen%e5%92%8csizeof aria-label=strlen()和sizeof()>strlen()和sizeof()</a></li>
<li>
<a href=#%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e%e5%92%8c%e5%ae%9a%e4%b9%89 aria-label=变量声明和定义>变量声明和定义</a></li>
<li>
<a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%92%8cunion aria-label=结构体和union>结构体和union</a></li>
<li>
<a href=#static aria-label=static>static</a></li>
<li>
<a href=#mallocnew%e5%92%8cfreedelete aria-label=malloc/new和free/delete>malloc/new和free/delete</a></li>
<li>
<a href=#const aria-label=const>const</a><ul>
<li>
<a href=#%e5%ae%8f%e5%ae%9a%e4%b9%89%e5%92%8cconst%e5%87%bd%e6%95%b0%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=宏定义和const函数的区别>宏定义和const函数的区别</a></li>
<li>
<a href=#const%e7%9a%84%e5%88%86%e8%be%a8%e9%a1%b6%e5%b1%82const%e5%92%8c%e5%ba%95%e5%b1%82const aria-label=const的分辨(顶层const和底层const)>const的分辨(顶层const和底层const)</a></li></ul>
</li>
<li>
<a href=#%e6%8c%87%e9%92%88%e5%92%8c%e5%bc%95%e7%94%a8 aria-label=指针和引用>指针和引用</a><ul>
<li>
<a href=#%e5%8c%ba%e5%88%ab aria-label=区别>区别</a></li>
<li>
<a href=#%e5%bc%95%e7%94%a8%e7%9b%b8%e5%85%b3%e9%97%ae%e9%a2%98 aria-label=引用相关问题>引用相关问题</a></li>
<li>
<a href=#%e6%8c%87%e9%92%88%e7%9b%b8%e5%85%b3%e9%97%ae%e9%a2%98 aria-label=指针相关问题>指针相关问题</a><ul>
<li>
<a href=#%e6%8c%87%e9%92%88%e7%9a%84%e7%9b%b8%e5%85%b3%e5%88%a4%e6%96%ad aria-label=指针的相关判断>指针的相关判断</a></li>
<li>
<a href=#%e6%8c%87%e9%92%88%e4%b8%8e%e6%95%b0%e7%bb%84%e5%90%8d aria-label=指针与数组名>指针与数组名</a></li>
<li>
<a href=#%e9%87%8e%e6%8c%87%e9%92%88 aria-label=野指针>野指针</a></li>
<li>
<a href=#%e6%8c%87%e9%92%88%e5%92%8c%e6%95%b0%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=指针和数组的区别>指针和数组的区别</a></li></ul>
</li></ul>
</li>
<li>
<a href=#volatile aria-label=volatile>volatile</a></li>
<li>
<a href=#%e5%a0%86%e6%a0%88 aria-label=堆栈>堆栈</a><ul>
<li>
<a href=#%e5%8c%ba%e5%88%ab-1 aria-label=区别>区别</a></li>
<li>
<a href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d aria-label=内存分配>内存分配</a></li></ul>
</li></ul>
</li>
<li>
<a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1 aria-label=面向对象>面向对象</a><ul>
<li>
<a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%89%e5%a4%a7%e7%89%b9%e6%80%a7 aria-label=面向对象三大特性>面向对象三大特性</a></li>
<li>
<a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0 aria-label=构造函数和析构函数>构造函数和析构函数</a></li>
<li>
<a href=#%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e5%92%8c%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0 aria-label=成员变量和成员函数>成员变量和成员函数</a></li>
<li>
<a href=#%e6%8b%b7%e8%b4%9d%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=拷贝构造函数>拷贝构造函数</a><ul>
<li>
<a href=#%e9%87%8d%e5%86%99%e6%8b%b7%e8%b4%9d%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=重写拷贝构造函数>重写拷贝构造函数</a></li></ul>
</li>
<li>
<a href=#%e5%a4%9a%e6%80%81 aria-label=多态>多态</a></li>
<li>
<a href=#%e5%8f%8b%e5%85%83 aria-label=友元>友元</a></li></ul>
</li>
<li>
<a href=#%e6%a0%87%e5%87%86%e6%a8%a1%e6%9d%bf%e5%ba%93 aria-label=标准模板库>标准模板库</a></li>
<li>
<a href=#%e7%bc%96%e8%af%91%e5%92%8c%e8%b0%83%e8%af%95 aria-label=编译和调试>编译和调试</a><ul>
<li>
<a href=#%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b aria-label=编译过程>编译过程</a></li>
<li>
<a href=#%e9%9d%99%e6%80%81%e5%ba%93%e5%92%8c%e5%8a%a8%e6%80%81%e5%ba%93 aria-label=静态库和动态库>静态库和动态库</a></li></ul>
</li>
<li>
<a href=#%e5%ae%89%e5%85%a8%e7%9b%b8%e5%85%b3 aria-label=安全相关>安全相关</a><ul>
<li>
<a href=#%e7%b1%bb%e5%9e%8b%e5%ae%89%e5%85%a8 aria-label=类型安全>类型安全</a></li>
<li>
<a href=#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8 aria-label=线程安全>线程安全</a></li>
<li>
<a href=#%e5%bc%82%e5%b8%b8%e5%ae%89%e5%85%a8 aria-label=异常安全>异常安全</a></li></ul>
</li>
<li>
<a href=#%e5%85%b6%e4%bb%96 aria-label=其他>其他</a><ul>
<li>
<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%af%b4%e6%a0%88%e6%af%94%e5%a0%86%e8%a6%81%e5%bf%ab aria-label=为什么说栈比堆要快>为什么说栈比堆要快</a></li>
<li>
<a href=#c%e5%8d%8f%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=c++协程的实现>c++协程的实现</a></li></ul>
</li>
<li>
<a href=#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=设计模式>设计模式</a><ul>
<li>
<a href=#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f aria-label=单例模式>单例模式</a></li>
<li>
<a href=#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95 aria-label=工厂方法>工厂方法</a></li>
<li>
<a href=#%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f aria-label=观察者模式>观察者模式</a></li>
<li>
<a href=#%e6%80%8e%e4%b9%88%e5%88%a4%e6%96%ad%e4%b8%a4%e4%b8%aa%e7%bb%93%e6%9e%84%e4%bd%93%e5%8f%98%e9%87%8f%e6%98%af%e5%90%a6%e7%9b%b8%e7%ad%89 aria-label=怎么判断两个结构体变量是否相等？>怎么判断两个结构体变量是否相等？</a></li>
<li>
<a href=#refeence aria-label=Refeence:>Refeence:</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=编程基础>编程基础<a hidden class=anchor aria-hidden=true href=#编程基础>#</a></h2>
<h3 id=c-内存管理方式>C++ 内存管理方式<a hidden class=anchor aria-hidden=true href=#c-内存管理方式>#</a></h3>
<p>堆、栈、自由存储区、全局/静态存储区、常量存储区
自由存储区存储malloc申请的内存<br>
(1)从静态存储区域分配 。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如 全局变量， static 变量 。
(2)在栈上创建 。在执行函数时， 函数内局部变量的存储单元都可以在栈上创建 ，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。
(3)从堆上分配 ， 亦称动态内存分配 。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</p>
<h3 id=extern-c和extern的作用>extern &ldquo;C"和extern的作用<a hidden class=anchor aria-hidden=true href=#extern-c和extern的作用>#</a></h3>
<p>extern &ldquo;C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern &ldquo;C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。<br>
(<a href=http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html>http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html</a>)</p>
<h3 id=为什么需要内存对齐>为什么需要内存对齐<a hidden class=anchor aria-hidden=true href=#为什么需要内存对齐>#</a></h3>
<h3 id=c内存问题>c++内存问题<a hidden class=anchor aria-hidden=true href=#c内存问题>#</a></h3>
<ol>
<li>
<p>缓冲区溢出（buffer overrun）。<br>
用 std::vector/std::string 或自己编写 Buffer class 来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。</p>
</li>
<li>
<p>空悬指针/野指针。<br>
用 shared_ptr/weak_ptr</p>
</li>
<li>
<p>重复释放（double delete）。</p>
</li>
<li>
<p>内存泄漏（memory leak）。</p>
</li>
<li>
<p>不配对的 new[]/delete。<br>
把 new[] 统统替换为 std::vector/scoped_array。</p>
</li>
<li>
<p>内存碎片（memory fragmentation）。</p>
</li>
</ol>
<h3 id=static关键字>static关键字<a hidden class=anchor aria-hidden=true href=#static关键字>#</a></h3>
<h4 id=作用>作用：<a hidden class=anchor aria-hidden=true href=#作用>#</a></h4>
<ul>
<li>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值</li>
<li>在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问</li>
<li>在模块内的 static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内。起到了隐藏的作用</li>
<li>在类的 static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝</li>
<li>在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量</li>
</ul>
<h4 id=静态全局变量不要放在头文件里>静态全局变量不要放在头文件里<a hidden class=anchor aria-hidden=true href=#静态全局变量不要放在头文件里>#</a></h4>
<p>(<a href=https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html>https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html</a>) 第6条</p>
<p><a href=https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html>C++中的static关键字的总结</a></p>
<h3 id=几个复制的声明>几个复制的声明<a hidden class=anchor aria-hidden=true href=#几个复制的声明>#</a></h3>
<pre tabindex=0><code>void * ( * (*fp1)(int))[10];  //fp1是一个指针，指向一个函数，函数参数为int，函数返回参数是一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个void* 指针。
float (*(* fp2)(int,int,int))(int);  //fp2是一个指针，指向一个函数，函数参数为3个int，函数的返回值是一个指针，指针指向一个函数，函数的参数是1个int，返回float。 
int (* ( * fp3)())[10]();  //fp3是一个指针，指向一个函数，函数没有参数，函数返回值为一个指针，指针指向一个数组，数组中有10个元素，每个元素是一个函数指针，函数没有参数，返回int。
</code></pre><h3 id=strlen和sizeof>strlen()和sizeof()<a hidden class=anchor aria-hidden=true href=#strlen和sizeof>#</a></h3>
<p>区别与联系：</p>
<ol>
<li>种类：<br>
sizeof是运算符，并不是函数，结果在编译时得到,因此sizeof不能用来返回动态分配的内存空间的大小。用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系；strlen是字符处理的库<strong>函数</strong>,当数组名作为参数传入时，实际上数组就退化成指针了。。</li>
<li>输入参数：<br>
sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化），还可以用函数做参数；strlen的参数只能是字符指针且结尾是'\0&rsquo;的字符串。</li>
<li>功能：<br>
sizeof():获得保证能容纳实现所建立的最大对象的字节大小 <br>
strlen():返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。</li>
<li>返回：<br>
当适用于一个结构类型时或变量， sizeof 返回实际的大小，
当适用于一静态地空间数组， sizeof 归还全部数组的尺寸。
sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸</li>
</ol>
<p><a href=https://blog.csdn.net/21aspnet/article/details/1539951>https://blog.csdn.net/21aspnet/article/details/1539951</a></p>
<h3 id=变量声明和定义>变量声明和定义<a hidden class=anchor aria-hidden=true href=#变量声明和定义>#</a></h3>
<ul>
<li>
<p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p>
</li>
<li>
<p>相同变量可以再多处声明（外部变量extern），但只能在一处定义。</p>
</li>
</ul>
<h3 id=结构体和union>结构体和union<a hidden class=anchor aria-hidden=true href=#结构体和union>#</a></h3>
<p>1.在存储多个成员信息时，编译器会自动给struct第个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。</p>
<p>2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。</p>
<p>3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。</p>
<p><strong>未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。</strong><br>
eg:</p>
<pre tabindex=0><code>struct sTest
{
int a;  //sizeof(int) = 4
char b;  //sizeof(char) = 1
short c； //sizeof(short) = 2       
}x;  #最终实际占用不止4+1+2，因为要考虑内存对齐的问题

union uTest
{
int a;   //sizeof(int) = 4
double b;  //sizeof(double) = 8
char c;  //sizeof(char) = 1
}x;   #分配的内存 size 就是8 byte
</code></pre><p><strong>pragma pack () 取消指定对齐，恢复缺省对齐</strong></p>
<h3 id=static>static<a hidden class=anchor aria-hidden=true href=#static>#</a></h3>
<h3 id=mallocnew和freedelete>malloc/new和free/delete<a hidden class=anchor aria-hidden=true href=#mallocnew和freedelete>#</a></h3>
<ul>
<li>
<p>malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。</p>
</li>
<li>
<p>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</p>
</li>
<li>
<p>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</p>
</li>
<li>
<p>free和delete对应。当delete一个对象数组时，delete只删除了一个，需要使用delete[]</p>
</li>
</ul>
<h3 id=const>const<a hidden class=anchor aria-hidden=true href=#const>#</a></h3>
<h4 id=宏定义和const函数的区别>宏定义和const函数的区别<a hidden class=anchor aria-hidden=true href=#宏定义和const函数的区别>#</a></h4>
<ul>
<li>宏在编译时完成替换，直接进行替换，执行起来更快，但是可能会存在一些风险；函数调用在运行时需要跳转到具体调用函数。如：</li>
</ul>
<pre tabindex=0><code>	#define area(x) x*x
	
	int main(){
		int y=area(2+2);
		std::cout&lt;&lt;y&lt;&lt;std::endl;   # 输出为8=2+2*2+2，而不是以为的16
	}
</code></pre><ul>
<li>
<p>宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。</p>
</li>
<li>
<p>宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</p>
</li>
<li>
<p>一般可以对const常量进行调试，但不能对宏常量进行调试。</p>
</li>
<li>
<p>宏函数不要在最后加分号。</p>
</li>
</ul>
<p>总之，一般尽量用const比较好。</p>
<h4 id=const的分辨顶层const和底层const>const的分辨(顶层const和底层const)<a hidden class=anchor aria-hidden=true href=#const的分辨顶层const和底层const>#</a></h4>
<p>一般来说，const的分辨可以直接通过看const的最左侧，如果是指针，则指针是const，若为类型，则变量为const。当const在最左侧时，看const右侧。</p>
<ul>
<li>常量指针和指针常量： 常量指针是一个指针，读成常量的指针，指向一个只读变量。如<code>int const *p</code>或<code>const int *p</code>。<br>
指针常量是一个常量，指针的值可以改变。如<code>int *const p</code>。</li>
</ul>
<h3 id=指针和引用>指针和引用<a hidden class=anchor aria-hidden=true href=#指针和引用>#</a></h3>
<h4 id=区别>区别<a hidden class=anchor aria-hidden=true href=#区别>#</a></h4>
<ol>
<li>指针是具体的变量，需要占存储空间。引用只是别名，不占用具体存储空间。这是最基本的一点，其他的特点也就可想而知了。</li>
<li>指针可以先声明，但是引用声明的时候就必须初始化，不存在空的引用很容易理解。</li>
<li>指针变量可以改变所指的对象。但是引用一旦声明了就不能再改变引用的对象了。</li>
</ol>
<h4 id=引用相关问题>引用相关问题<a hidden class=anchor aria-hidden=true href=#引用相关问题>#</a></h4>
<ol>
<li>引用是某个变量的别名，因此定义的时候必须初始化，也不能把该引用再改成其他变量的别名。</li>
<li>声明一个引用并没有定义新变量，引用本身不是一种数据类型。也不占用存储空间。</li>
<li><del>不能建立数组的引用</del>。其实这句话的意思是：不能建立引用的数组，例如：int & ref[3] = { 2, 3, 5}; 但是可以建立数组的引用:例如：int arr[3]; int (&tef)[3] = arr;<br>
原因是：引用时不占空间的，声明引用数组没法分配空间。见<a href=https://blog.csdn.net/tkp2014/article/details/48858377>为什么不能建立引用数组</a></li>
<li>将引用作为函数的参数时，可以避免对变量或者对象的复制，因此不会调用对象的拷贝构造函数。当不希望传入的引用参数不被改变时，使用const引用。</li>
<li>函数中不能返回局部变量的引用，不能返回函数内部ne分配的内存的引用。（虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄露。）。 可以返回类成员的引用，但最好是const。</li>
<li>当类中存在const或者引用时成员变量时，必须使用初始化表。</li>
</ol>
<h4 id=指针相关问题>指针相关问题<a hidden class=anchor aria-hidden=true href=#指针相关问题>#</a></h4>
<h5 id=指针的相关判断>指针的相关判断<a hidden class=anchor aria-hidden=true href=#指针的相关判断>#</a></h5>
<pre tabindex=0><code>    int *p[10]
    int (*p)[10]
    int *p(int)
    int (*p)(int)
</code></pre><ul>
<li>
<p>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p>
</li>
<li>
<p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</p>
</li>
<li>
<p>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</p>
</li>
<li>
<p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p>
</li>
</ul>
<h5 id=指针与数组名>指针与数组名<a hidden class=anchor aria-hidden=true href=#指针与数组名>#</a></h5>
<ul>
<li>
<p>二者均可通过增减偏移量来访问数组中的元素。</p>
</li>
<li>
<p>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</p>
</li>
<li>
<p>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</p>
</li>
</ul>
<h5 id=野指针>野指针<a hidden class=anchor aria-hidden=true href=#野指针>#</a></h5>
<p>空悬指针，不是指向null的指针，是指向垃圾内存的指针。</p>
<ul>
<li>产生原因及解决办法：
<ul>
<li>指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。</li>
<li>指针free或delete之后没有及时置空 => 释放操作后立即置空。</li>
</ul>
</li>
</ul>
<h5 id=指针和数组的区别>指针和数组的区别<a hidden class=anchor aria-hidden=true href=#指针和数组的区别>#</a></h5>
<p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</p>
<ol>
<li>修改内容上的差别:指针可能指向一块内存，但是指向的常量却无法通过下标计算。</li>
</ol>
<pre tabindex=0><code>char a[] = “hello”;
a[0] = ‘X’;
char *p = “world”; // 注意p 指向常量字符串，指向的是常量区
p[0] = ‘X’; // 编译器不能发现该错误，运行时错误
</code></pre><ol start=2>
<li>用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</li>
</ol>
<pre tabindex=0><code>char a[] = &quot;hello world&quot;;
char *p = a;
cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节
cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节
//计算数组和指针的内存容量
void Func(char a[100])
{
	cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节
}
</code></pre><h3 id=volatile>volatile<a hidden class=anchor aria-hidden=true href=#volatile>#</a></h3>
<ul>
<li>
<p>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。</p>
</li>
<li>
<p>多线程中被几个任务共享的变量需要定义为volatile类型。</p>
</li>
</ul>
<h3 id=堆栈>堆栈<a hidden class=anchor aria-hidden=true href=#堆栈>#</a></h3>
<h4 id=区别-1>区别<a hidden class=anchor aria-hidden=true href=#区别-1>#</a></h4>
<ol>
<li>申请方式不同：栈由系统自动分配，堆由程序员手动分配</li>
<li>申请大小不同：栈顶和栈底都是设定好的，大小固定，可以通过<code>ulimit -a</code>查看，通过<code>ulimit -s</code>修改。堆向高地址扩展，是不连续的内存区域，大小可以调整。</li>
<li>申请效率不同：栈由系统分配，速度快，没有碎片。堆速度慢，且有碎片。</li>
</ol>
<h4 id=内存分配>内存分配<a hidden class=anchor aria-hidden=true href=#内存分配>#</a></h4>
<p><a href=https://blog.csdn.net/nkguohao/article/details/8771867>https://blog.csdn.net/nkguohao/article/details/8771867</a></p>
<h2 id=面向对象>面向对象<a hidden class=anchor aria-hidden=true href=#面向对象>#</a></h2>
<h3 id=面向对象三大特性>面向对象三大特性<a hidden class=anchor aria-hidden=true href=#面向对象三大特性>#</a></h3>
<ul>
<li>
<p>封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。</p>
</li>
<li>
<p>继承性：让某种类型对象获得另一个类型对象的属性和方法。</p>
</li>
<li>
<p>多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。</p>
</li>
</ul>
<h3 id=构造函数和析构函数>构造函数和析构函数<a hidden class=anchor aria-hidden=true href=#构造函数和析构函数>#</a></h3>
<p>1.构造函数、析构函数中都不要调用虚函数</p>
<p>我们知道，构造函数一般不能是虚函数，而析构函数一般必须是虚函数。原理也很清晰，构造函数，由于构造顺序是从基类到派生类，所以调用虚函数，可能派生类还没有构造出来，没有意义。而对于析构函数来说，又必须是虚函数，因为只有先从子类对象进行销毁，才能保证资源不泄露。</p>
<p>在构造函数和析构函数中都不要调用虚函数也是这个道理。</p>
<h3 id=成员变量和成员函数>成员变量和成员函数<a hidden class=anchor aria-hidden=true href=#成员变量和成员函数>#</a></h3>
<p>1.静态成员变量是需要初始化<br>
其实这样说的是有点问题的，应该是静态成员是需要定义的。
因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。 <br>
《c++primer》里面说在类外定义和初始化是保证static成员变量只被定义一次的好方法。 但static const int就可以在类里面初始化</p>
<pre tabindex=0><code>class Base{
    public:
    	static int class_p;   //只有声明，而没有定义，不能直接调用
};
int Base::class_p=3;   //进行定义  https://blog.csdn.net/qq_16209077/article/details/52602601
</code></pre><h3 id=拷贝构造函数>拷贝构造函数<a hidden class=anchor aria-hidden=true href=#拷贝构造函数>#</a></h3>
<p>调用情况：</p>
<ol>
<li>用一个类的对象去初始化该类的另一个对象时。</li>
<li>函数形参是类的对象时，调用函数将函数的形参和实参结合的时候。</li>
<li>函数返回值是类的对象，函数调用完成返回时。</li>
</ol>
<h4 id=重写拷贝构造函数>重写拷贝构造函数<a hidden class=anchor aria-hidden=true href=#重写拷贝构造函数>#</a></h4>
<p>一般会默认生成类的拷贝构造函数，但是当涉及动态分配存储空间时，默认的拷贝构造函数就会有问题，因此需要重写拷贝构造函数，并且采用深拷贝。<br>
浅拷贝和深拷贝：</p>
<h3 id=多态>多态<a hidden class=anchor aria-hidden=true href=#多态>#</a></h3>
<p>多态：对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：<br>
编译时多态：函数和运算符的重载。<br>
运行时多态：继承和虚函数。</p>
<h3 id=友元>友元<a hidden class=anchor aria-hidden=true href=#友元>#</a></h3>
<p>特性：单向的，传递性，不能继承</p>
<h2 id=标准模板库>标准模板库<a hidden class=anchor aria-hidden=true href=#标准模板库>#</a></h2>
<h2 id=编译和调试>编译和调试<a hidden class=anchor aria-hidden=true href=#编译和调试>#</a></h2>
<h3 id=编译过程>编译过程<a hidden class=anchor aria-hidden=true href=#编译过程>#</a></h3>
<p>预处理->编译->汇编->链接</p>
<ul>
<li>预处理：展开宏定义；处理条件编译；处理#include指令；去掉注释；添加行号和文件名标识；保留所有#pragma编译器指令。</li>
<li>编译：词法分析；语法分析；语义分析；中间语言生成；目标代码生成与优化。</li>
<li>链接：各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。</li>
</ul>
<h3 id=静态库和动态库>静态库和动态库<a hidden class=anchor aria-hidden=true href=#静态库和动态库>#</a></h3>
<p>二者的不同点在于代码被载入的时刻不同。静态库和动态库的最大区别,静态情况下,把库直接加载到程序中,而动态库链接的时候,它只是保留接口,将动态库与程序代码独立,这样就可以提高代码的可复用度，和降低程序的耦合度。</p>
<ul>
<li>静态库的代码在编译过程中已经被载入可执行程序,程序运行时将不再需要该静态库，因此可执行程序体积比较大。在Linux中以<code>.a</code>结尾</li>
<li>动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小,在程序运行时还需要动态库存在。不同的应用程序如果调用相同的库,那么在内存中只需要有一份该动态库(共享库)的实例。在Linux中以<code>.so</code>结尾<br>
当静态库和动态库同名时， gcc命令将优先使用动态库.为了确保使用的是静态库, 编译时可以加上 -static 选项，因此多第三方程序为了确保在没有相应动态库时运行正常，喜欢在编译最后应用程序时加入-static<br>
<strong>优缺点</strong>：<br>
1.动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。 <br>
2.动态库更新很容易，当库发生变化时，接口没变只需要用新的动态库替换掉就可以。静态库需要重新编译。<br>
3.静态库静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会高一些。</li>
</ul>
<h2 id=安全相关>安全相关<a hidden class=anchor aria-hidden=true href=#安全相关>#</a></h2>
<h3 id=类型安全>类型安全<a hidden class=anchor aria-hidden=true href=#类型安全>#</a></h3>
<p>类型安全很大程度上可以理解为内存安全。类型安全的代码不会试图去访问自己没有被授权的内存区域。<br>
对于C语言来说，很多操作都不是类型安全的。例如打印的时候:<code>printf("%f\n",10) //编译通过，没有报错，结果为0.000000</code>.<br>
对于C++来说，有些操作也不是类型安全的，比如不同类型指针之间可以强制转换(reinterpret cast) 注：C#、Java是类型安全的<br>
C++使用得当，可以远比C更有类型安全性。
（1）操作符new返回的指针类型严格与对象匹配，而不是void*；<br>
（2）C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；<br>
（3）引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；<br>
（4）一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；<br>
（5）C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</p>
<h3 id=线程安全>线程安全<a hidden class=anchor aria-hidden=true href=#线程安全>#</a></h3>
<p>如果代码在多线程运行和单线程运行具有相同的结果，那就是线程安全的。<br>
线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<h3 id=异常安全>异常安全<a hidden class=anchor aria-hidden=true href=#异常安全>#</a></h3>
<p>当异常抛出时，带有异常安全的函数会：
（1）不泄露任何资源
一般采用RAII技术，即以对象管(智能指针)理资源来防止资源泄漏。
(2)不允许数据被破坏（例如正常指针变野指针）
(3)少些try catch，因为大量的try catch会影响代码逻辑。导致代码丑陋混乱不优雅<br>
解决异常安全的问题：
1.多使用RAII，使用智能指针来管理内存。由于unwind机制的保证，当异常发生时，函数栈内已构造的局部对象的析构函数会被一一调用，在析构函数内释放资源，也就杜绝了内存泄漏的问题。<br>
2.做好程序设计。特别是异常发生时的回滚机制的正确使用，copy-and-swap是有效的方法。<br>
3.注意需要异常保证的函数内部的调用函数，异常安全等级是以有最低等级异常保证的函数确定的。一个系统即使只有一个函数不是异常安全的，那么系统作为一个整体就不是异常安全的。<br>
4.流对象，资源对象，new对象，不应该直接作为参数，一旦抛出异常，就可能会导致严重的问题，函数也许会被错误的执行，资源也许会泄漏。<br>
5.减少全局变量的使用。<br>
6.如果不知道如何处理异常，就不要捕获异常，直接终止比吞掉异常不处理要好。<br>
7.保证构造、析构、swap不会失败</p>
<p><a href=https://blog.csdn.net/lingling_1/article/details/46924991>类型安全 与 线程安全 、异常安全、事务安全</a></p>
<h2 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h2>
<h3 id=为什么说栈比堆要快>为什么说栈比堆要快<a hidden class=anchor aria-hidden=true href=#为什么说栈比堆要快>#</a></h3>
<ol>
<li>分配和释放：堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，具体可以看看MALLOC和FREE的源代码，他们做了很多额外的工作，而栈却不需要这些。</li>
<li>访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。</li>
<li>堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。</li>
</ol>
<h3 id=c协程的实现>c++协程的实现<a hidden class=anchor aria-hidden=true href=#c协程的实现>#</a></h3>
<p><a href=https://blog.csdn.net/qq910894904/article/details/41911175>ucontext-人人都可以实现的简单协程库</a></p>
<h2 id=设计模式>设计模式<a hidden class=anchor aria-hidden=true href=#设计模式>#</a></h2>
<h3 id=单例模式>单例模式<a hidden class=anchor aria-hidden=true href=#单例模式>#</a></h3>
<h3 id=工厂方法>工厂方法<a hidden class=anchor aria-hidden=true href=#工厂方法>#</a></h3>
<h3 id=观察者模式>观察者模式<a hidden class=anchor aria-hidden=true href=#观察者模式>#</a></h3>
<h3 id=怎么判断两个结构体变量是否相等>怎么判断两个结构体变量是否相等？<a hidden class=anchor aria-hidden=true href=#怎么判断两个结构体变量是否相等>#</a></h3>
<p>1，元素的话，一个个比咯：if(p1->age==p2->age)&mldr;有一个元素不等，即是两个实例不相等！没什么效率高的方法吧！</p>
<p>2，指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真！</p>
<p>3，重载==运算符；</p>
<h3 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h3>
<h3 id=refeence>Refeence:<a hidden class=anchor aria-hidden=true href=#refeence>#</a></h3>
<p><a href=http://bestmind.space/posts/%E5%B8%B8%E8%A7%81C-%E9%9D%A2%E8%AF%95%E9%A2%98/>常见C++面试题</a></p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://yuguocong.cn/tags/%E9%9D%A2%E8%AF%95/>面试</a></li>
<li><a href=https://yuguocong.cn/tags/c++/>C++</a></li>
<li><a href=https://yuguocong.cn/tags/%E5%B7%A5%E4%BD%9C/>工作</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://yuguocong.cn/posts/interview_operation/>
<span class=title>« </span>
<br>
<span>面试总结-操作系统</span>
</a>
<a class=next href=https://yuguocong.cn/posts/re_sword_to_offer/>
<span class=title> »</span>
<br>
<span>剑指offer-刷题总结</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share 面试总结-C++ on twitter" href="https://twitter.com/intent/tweet/?text=%e9%9d%a2%e8%af%95%e6%80%bb%e7%bb%93-C%2b%2b&url=https%3a%2f%2fyuguocong.cn%2fposts%2finterview_cpp%2f&hashtags=%e9%9d%a2%e8%af%95%2cC%2b%2b%2c%e5%b7%a5%e4%bd%9c"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 面试总结-C++ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fyuguocong.cn%2fposts%2finterview_cpp%2f&title=%e9%9d%a2%e8%af%95%e6%80%bb%e7%bb%93-C%2b%2b&summary=%e9%9d%a2%e8%af%95%e6%80%bb%e7%bb%93-C%2b%2b&source=https%3a%2f%2fyuguocong.cn%2fposts%2finterview_cpp%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 面试总结-C++ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fyuguocong.cn%2fposts%2finterview_cpp%2f&title=%e9%9d%a2%e8%af%95%e6%80%bb%e7%bb%93-C%2b%2b"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 面试总结-C++ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fyuguocong.cn%2fposts%2finterview_cpp%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 面试总结-C++ on whatsapp" href="https://api.whatsapp.com/send?text=%e9%9d%a2%e8%af%95%e6%80%bb%e7%bb%93-C%2b%2b%20-%20https%3a%2f%2fyuguocong.cn%2fposts%2finterview_cpp%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 面试总结-C++ on telegram" href="https://telegram.me/share/url?text=%e9%9d%a2%e8%af%95%e6%80%bb%e7%bb%93-C%2b%2b&url=https%3a%2f%2fyuguocong.cn%2fposts%2finterview_cpp%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://yuguocong.cn/>mianhk's notes</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>